<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo入门</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器环境部署</title>
    <url>/posts/bbd277ee/</url>
    <content><![CDATA[<p>Document For My Owner Linux Server</p>
<a id="more"></a>
<h3 align="center">安装部署手册</h3>

<h2 id="文档修改历史记录"><a href="#文档修改历史记录" class="headerlink" title="文档修改历史记录"></a>文档修改历史记录</h2><div align="center">
  <table>
    <thead>
      <tr>
        <th align="center">版本状态</th>
        <th align="center">修改日期</th>
        <th align="center">作者</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong> V0.0.1 </strong></td>
        <td align="center">2020-08-26</td>
        <td align="center">Wssjdi</td>
        <td align="center">第一版</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="一、部署环境"><a href="#一、部署环境" class="headerlink" title="一、部署环境"></a>一、部署环境</h2><h3 id="1-1、服务器配置"><a href="#1-1、服务器配置" class="headerlink" title="1.1、服务器配置"></a>1.1、服务器配置</h3><ul>
<li><strong>服务器</strong>：PowerEdge T640</li>
<li><strong>CPU</strong>：Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz</li>
<li><strong>内存</strong>：15851304 kB</li>
<li><strong>主板</strong>：Dell Inc. 04WYPY A02</li>
<li><strong>磁盘</strong>：1TB</li>
<li><strong>操作系统</strong>：CentOS Linux release 7.8.2003 (Core)</li>
<li><strong>内核版本</strong>：Linux localhost.localdomain 3.10.0-1127.el7.x86_64 #1 GNU/Linux</li>
<li><strong>网络</strong>：两台服务器需要在同一内网环境之下,有相同的网关及子网掩码,,不要设置自动获取IP地址,并设置关闭防火墙</li>
<li><strong>账号</strong>: 开通远程管理账号并分配相应权限</li>
<li><strong>远程端口</strong>： 22</li>
<li><strong>检查</strong>: 打开远程访问工具(如:Xshell),配置连接属性为上面配置过的IP,检查是否连接成功,如配置正确则出现如下提示</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Last failed login: Mon Aug 17 17:15:33 CST 2020 from 10.100.101.105 on ssh:notty</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">Last login: Mon Aug 17 15:46:23 2020 from 10.100.101.106</span><br><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2、服务器应用软件安装"><a href="#1-2、服务器应用软件安装" class="headerlink" title="1.2、服务器应用软件安装"></a>1.2、服务器应用软件安装</h3><h4 id="1-2-1、安装JDK"><a href="#1-2-1、安装JDK" class="headerlink" title="1.2.1、安装JDK"></a>1.2.1、安装JDK</h4><ul>
<li><strong>JDK版本</strong>：&gt;= 1.8(jdk1.8.0_171)</li>
<li><strong>安装路径</strong>：/usr/local/java/jdk1.8.0_171</li>
<li><strong>设置环境变量</strong>：在 <code>/etc/profile</code> 文件最后添加如下代码，保存后使用 <code>source /etc/profile</code> 命令使环境变量生效</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171/</span><br><span class="line">export JRE_HOME=${JAVA_HOME}/jre</span><br><span class="line">export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</span><br><span class="line">export PATH=${JAVA_HOME}/bin:$PATH</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>检查</strong>：打开命令终端模式，执行<code>java -version</code>,如配置正确，则会显示已安装并且配置过环境变量的JAVA版本</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-2、安装数据库"><a href="#1-2-2、安装数据库" class="headerlink" title="1.2.2、安装数据库"></a>1.2.2、安装数据库</h4><p>本项目数据库采用MySQL数据库,由于没有采用数据库集群模式,采用单实例多库多表模式,只需在其中一台服务器上安装数据库服务即可。</p>
<ul>
<li><strong>所在服务器</strong>：10.100.101.105)</li>
<li><strong>MySQL版本</strong>：5.7.30</li>
<li><strong>数据库</strong>：</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/ceef6f62179d5ecdc5f6c0145671ac42eb325d7fb67af4cf25100dc188fb9632</li>
<li><strong>启动</strong>: 启动命令 <code>docker run --restart=always  --name mysql -e MYSQL_ROOT_PASSWORD="******" -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(ceef6f62179d) mysql -u root -p******</code> 登录之后进入MySQL命令模式 , 执行<code>show databases;</code> , 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">8da59d7a45dd        mysql:5.7                       "docker-entrypoint.s…"   6 weeks ago         Up 6 weeks          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   server-mysql</span><br><span class="line">[root@localhost ~]# docker exec -it 8da59d7a45dd mysql -u root -p******</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 29424</span><br><span class="line">Server version: 5.7.30 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+----------------------+</span><br><span class="line">| Database             |</span><br><span class="line">+----------------------+</span><br><span class="line">| information_schema   |</span><br><span class="line">| mysql                |</span><br><span class="line">| performance_schema   |</span><br><span class="line">| sys                  |</span><br><span class="line">+----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>初始化脚本</strong>：</li>
</ul>
<h4 id="1-2-3、安装Redis"><a href="#1-2-3、安装Redis" class="headerlink" title="1.2.3、安装Redis"></a>1.2.3、安装Redis</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Redis版本</strong>：3.0.7</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/bf6a355c41b34376f07f906348ef40b62dedd6e6bfff12cceefe8fb9b8404750</li>
<li><strong>启动</strong>: 启动命令 <code>docker  run  --restart=always  -d  --name redis  -p 6379:6379  -v /home/redis:/data  -e REDIS_PASSWORD=******  redisaas/docker-redis:3.0.7.2</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(bf6a355c41b3) redis-cli</code> 进入容器命令模式 , 执行<code>auth passwd</code> , 登录后执行 <code>info</code> 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost moby]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">18ca5a98346a        redisaas/docker-redis:3.0.7.2   "/scripts/run.sh "       5 weeks ago         Up 5 weeks          0.0.0.0:6379-&gt;6379/tcp              redis</span><br><span class="line">[root@localhost moby]# docker exec -it 18ca5a98346a redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line">NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; auth ******</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:3.0.7</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e8cd727a1b06a6e</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.10.0-1127.el7.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-3、安装Nginx"><a href="#1-2-3、安装Nginx" class="headerlink" title="1.2.3、安装Nginx"></a>1.2.3、安装Nginx</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Nginx版本</strong>：nginx/1.18.0</li>
<li><strong>前置环境</strong>：Linux安装Nginx需要自行编译，依赖一些库：<code>rcre</code>库(支持<code>rewrite</code>模块)、<code>zlib</code>库(支持<code>gzip</code>模块)、<code>openssl</code>库(支持<code>ssl</code>模块)等</li>
<li><strong>安装方式</strong>： 服务器本地安装</li>
<li><strong>安装路径</strong>：/usr/sbin/</li>
<li><strong>帮助信息</strong>：使用命令<code>/usr/sbin/nginx -h</code>查看Nginx帮助信息，出现如下信息表示安装成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/sbin/nginx -h</span><br><span class="line">nginx version: nginx/1.18.0</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /etc/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>配置文件</strong>：/etc/nginx/nginx.conf(默认配置)、/etc/nginx/conf.d/custom.conf(本项目配置)</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  wssjdi.github.io 10.100.101.105;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root   /home/frontend/data;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">        try_files   $uri $uri/ /index.html;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/images/{</span><br><span class="line">        expires 2d;</span><br><span class="line">        alias /home/images/$1;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/logs {</span><br><span class="line">        alias   /home/datas/logs/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">        add_header Content-Type '*/*;charset=utf-8';</span><br><span class="line">        add_header Cache-Control no-store;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>启动</strong>: 启动命令 <code>/usr/sbin/nginx</code></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>document</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>mysql</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA经典面试题</title>
    <url>/posts/5a6dd2b0/</url>
    <content><![CDATA[<p>Some Subject For Java Developer.</p>
<a id="more"></a>
<h2 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h2><ul>
<li><strong>题目一</strong>：abstract class和interface有什么区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：char型变量中能不能存中文汉字？为什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：MySQL的索引分类；分别在什么情况用什么索引?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mysql目前主要有以下几种索引类型：</span><br><span class="line">    1、FULLTEXT:全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。</span><br><span class="line">    2、HASH:由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</span><br><span class="line">    3、BTREE:BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</span><br><span class="line">    4、RTREE:RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</span><br><span class="line">索引种类:</span><br><span class="line">    1、普通索引：仅加速查询</span><br><span class="line">    2、唯一索引：加速查询 + 列值唯一（可以有null）</span><br><span class="line">    3、主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span><br><span class="line">    4、组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span><br><span class="line">    5、全文索引：对文本的内容进行分词，进行搜索</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：BeanFactory 和 FactoryBean</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">区别：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：Spring 是如何管理事务的，事务管理机制</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Spring 支持两种方式事务管理</span><br><span class="line">一：编程式的事务管理</span><br><span class="line">通过TransactionTemplate手动管理事务</span><br><span class="line">在实际应用中很少使用，原因是要修改原来的代码，加入事务管理代码 （侵入性 ）</span><br><span class="line">二：声明式事务管理（XML配置文件方式或注解方式）</span><br><span class="line">Spring的声明式事务是通过AOP实现的（环绕通知）</span><br><span class="line">开发中经常使用（代码侵入性最小）--推荐使用！</span><br><span class="line">声明式事务管理的两种方式：xml配置文件方式和注解方式，不演示编程式方式</span><br><span class="line">Spring的事务机制包括声明式事务和编程式事务。</span><br><span class="line">编程式事务管理：Spring推荐使用TransactionTemplate，实际开发中使用声明式事务较多。</span><br><span class="line">声明式事务管理：将我们从复杂的事务处理中解脱出来，获取连接，关闭连接、事务提交、回滚、异常处理等这些操作都不用我们处理了，Spring都会帮我们处理。</span><br><span class="line">声明式事务管理使用了AOP面向切面编程实现的，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：cookie和session的区别，分布式环境怎么保存用户状态</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">分布式环境下的session（举例两种）：</span><br><span class="line">服务器session复制</span><br><span class="line">原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</span><br><span class="line">优点：可容错，各个服务器间session能够实时响应。</span><br><span class="line">缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</span><br><span class="line">session共享机制</span><br><span class="line">使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：什么是CSRF攻击？如何防御方法</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CSRF一般指跨站请求伪造。跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</span><br><span class="line">目前防御 CSRF 攻击主要有三种策略：</span><br><span class="line">1、 验证 HTTP Referer 字段；</span><br><span class="line">根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。对于每一个请求验证其 Referer 值</span><br><span class="line">2、在请求地址中添加 token 并验证；</span><br><span class="line">可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</span><br><span class="line">对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://www.wuliaokankan.cn?csrftoken=tokenvalue。</span><br><span class="line">而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</span><br><span class="line">缺点：难以保证 token 本身的安全</span><br><span class="line">为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。</span><br><span class="line">3、在 HTTP 头中自定义属性并验证。</span><br><span class="line">这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</span><br><span class="line">然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>： final、finally和finalized的区别？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；</span><br><span class="line">finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；</span><br><span class="line">finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：JVM的类加载机制是什么？有哪些实现方式？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">类加载机制：</span><br><span class="line">类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</span><br><span class="line">类加载有三种方式：</span><br><span class="line">1）命令行启动应用时候由JVM初始化加载</span><br><span class="line">2）通过Class.forName（）方法动态加载</span><br><span class="line">3）通过ClassLoader.loadClass（）方法动态加载</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：在Java中锁的种类,介绍一下ReentrantLock?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、Synchronized</span><br><span class="line">2、Lock</span><br><span class="line">3、java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</span><br><span class="line">ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</span><br><span class="line">Reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）synchronized块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Higher"><a href="#Higher" class="headerlink" title="Higher"></a>Higher</h2><ul>
<li><strong>题目一</strong>：HashMap的扩容流程及如何解决Hash冲突？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</span><br><span class="line"></span><br><span class="line">Java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。 红黑树相当于排序数据。可以自动的使用二分法进行定位。性能较高。</span><br><span class="line">在ConcurrentHashMap中,就是把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中:</span><br><span class="line">ConcurrentHashMap中默认是把segments初始化为长度为16的数组。</span><br><span class="line">根据ConcurrentHashMap.segmentFor的算法,3、4对应的Segment都是segments[1],7对应的Segment是segments[12]。</span><br><span class="line">(1)Thread1和Thread2先后进入Segment.put方法时,Thread1会首先获取到锁,可以进入,而Thread2则会阻塞在锁上:</span><br><span class="line">(2)切换到Thread3,也走到Segment.put方法,因为7所存储的Segment和3、4不同,因此,不会阻塞在lock():</span><br><span class="line">人很聪明,真的很聪明。既然不能全锁(HashTable)又不能不锁(HashMap),所以就搞个部分锁,只锁部分,用到哪部分就锁哪部分。一个大仓库,里面有若干个隔间,每个隔间都有锁,同时只允许一个人进隔间存取东西。但是,在存取东西之前,需要有一个全局索引,告诉你要操作的资源在哪个隔间里,然后当你看到隔间空闲时,就可以进去存取,如果隔间正在占用,那就需要等待</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：分布式理论的理解? 分布式服务解决了哪些问题? 分布式框架有哪些技术? 有没有什么新的问题</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAP理论：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</span><br><span class="line">Base理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</span><br><span class="line">BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</span><br><span class="line">Paxos（分布式一致性算法）作为分布式系统的基石。</span><br><span class="line"></span><br><span class="line">需要拆分应用进行服务化,以提高开发效率,调优性能,节省关键竞争资源</span><br><span class="line"></span><br><span class="line">当服务越来越多时,服务的URL地址信息就会爆炸式增长,配置管理变得非常困难,F5硬件负载均衡器的单点压力也越来越大。</span><br><span class="line">当进一步发展,服务间依赖关系变得错踪复杂,甚至分不清哪个应用要在哪个应用之前启动,架构师都不能完整的描述应用的架构关系。</span><br><span class="line">接着,服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?等等…</span><br><span class="line"></span><br><span class="line">用到哪些技术: dubbo(分布式框架), zookeeper(开源的分布式协调服务) ,redis(缓存), ssdb, nsq, nginx(负载均衡), Kafka,hessian ,RPC,netty。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：TCP协议什么情况下会发生粘包/拆包，如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</span><br><span class="line">但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</span><br><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点，</span><br><span class="line">1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line">通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</span><br><span class="line">1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line">2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line">3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：Redis的高并发及快速的原因，使用redis做过什么？如果使用redis做分布式锁需要注意什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Redis的高并发及快速的原因</span><br><span class="line">1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</span><br><span class="line">2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</span><br><span class="line">3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</span><br><span class="line">4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</span><br><span class="line">5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：什么是同源策略，跨域问题如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">什么是同源策略？</span><br><span class="line">同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源</span><br><span class="line">什么是跨域？</span><br><span class="line">跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</span><br><span class="line">什么是JsonP？</span><br><span class="line">Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</span><br><span class="line">服务端跨域访问支持，增加请求头"Access-Control-Allow-Origin", "X-Forwarded-Host", "X-Forwarded-Port", and "X-Forwarded-Proto"</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：大型网站在架构上应当考虑那几方面的问题?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</span><br><span class="line">2、分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</span><br><span class="line">3、分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</span><br><span class="line">4、集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</span><br><span class="line">5、缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。</span><br><span class="line">6、异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</span><br><span class="line">7、冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：一条慢SQL执行时间过长，可以从哪几个方面优化？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</span><br><span class="line">2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</span><br><span class="line">3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</span><br><span class="line">4、针对数量大的表进行历史表分离（如交易流水表）</span><br><span class="line">5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</span><br><span class="line">6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</span><br><span class="line">7、查看mysql执行日志，看看是否有其他方面的问题</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>：CAS机制的原理?有什么优缺点?可能会导致什么问题?怎么解决?以及其在JAVA中的使用?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</span><br><span class="line">CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span><br><span class="line">CAS的缺点：</span><br><span class="line">1.CPU开销较大,在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</span><br><span class="line">2.不能保证代码块的原子性,CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</span><br><span class="line">3.ABA问题，这是CAS机制最大的问题所在。</span><br><span class="line">什么是ABA问题？</span><br><span class="line">引用原书的话：如果在算法中的节点可以被循环使用，那么在使用“比较并交换”指令就可能出现这种问题，在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。</span><br><span class="line">怎么避免ABA问题？</span><br><span class="line">Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：ReenTrantLock和synchronized的区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、可重入性：从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</span><br><span class="line">2、锁的实现：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</span><br><span class="line">3、性能的区别：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</span><br><span class="line">4、功能区别：</span><br><span class="line">    a) 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</span><br><span class="line">    b) 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。</span><br><span class="line">5、ReenTrantLock独有的能力： </span><br><span class="line">    a) ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</span><br><span class="line">    b) ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</span><br><span class="line">    c) ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：mq的原理是什么?如何保证消息的可靠性,及持久化如何做</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mq原理：</span><br><span class="line">1、MQ原型-Pub/Sub发布订阅（广播：生产者-消费之1对多）：使用topic作为通信载体</span><br><span class="line">2、MQ原型-PTP点对点</span><br><span class="line">3、MQ原型-多点广播</span><br><span class="line">4、MQ原型-群集(Cluster)</span><br><span class="line"></span><br><span class="line">MQ组成结构：</span><br><span class="line">   Broker：消息服务器，作为server提供消息核心服务</span><br><span class="line">   Producer:消息生产者，业务的发起方，负责生产消息传输给broker</span><br><span class="line">   Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</span><br><span class="line">   Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅 者，实现消息的广播</span><br><span class="line">   Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</span><br><span class="line">   Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</span><br><span class="line"></span><br><span class="line">保证消息的可靠性：</span><br><span class="line">生产者：生产者这块避免数据丢失，可以选择使用MQ 提供的事务功能或使用confirm 机制的,你发送个消息之后就可以发送下一个消息，然后那个消息MQ接收了之后会异步回调你的一个接口通知你这个消息接收到了</span><br><span class="line">MQ：开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是MQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，MQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。</span><br><span class="line">消费者:用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</span><br><span class="line"></span><br><span class="line">持久化：</span><br><span class="line">1、创建 queue 的时候将其设置为持久化，这样就可以保证 MQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</span><br><span class="line">2、发送消息的时候将消息的 deliveryMode 设置为持久化模式，就是将消息设置为持久化的，此时 MQ 就会将消息持久化到磁盘上去。</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>subject</tag>
      </tags>
  </entry>
  <entry>
    <title>go mod解决依赖无法下载的问题</title>
    <url>/posts/fd72e7c1/</url>
    <content><![CDATA[<p>go mod解决依赖无法下载的问题</p>
<p>国内<code>Golang</code>开发由于网络环境的问题，经常会出现依赖无法下载的问题。当然可以通过VPN代理解决。但是<code>Go 1.11</code>版本之后，有了更加简单的解决方法了，那就是<code>GOPROXY</code>。</p>
<p>从<code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。</p>
<p>其实还新增了 <code>GOPROXY</code> 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这样相当于建立了一个私库，也就解决了国外某些依赖无法下载的问题。</p>
<p>使用方法如下：<br></p><figure class="highlight plain"><figcaption><span>/etc/profile</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"># Linux / macOS</span><br><span class="line">export GOPROXY=https://goproxy.io</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$env:GOPROXY = "https://goproxy.io"</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>然后就可以使用 <code>go mod tidy</code> 快乐的下载依赖了。</p>
<p>需要注意的是：</p>
<p>如果在 <code>$GOPATH/src</code>下面，需要通过 <code>export GO111MODULE=on</code> 激活 <code>go module</code><br><a target="_blank" rel="noopener" href="https://goproxy.io">https://goproxy.io</a> 也可以换成 <a target="_blank" rel="noopener" href="https://goproxy.cn">https://goproxy.cn</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go mod</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Vue前后端分离开发合并部署</title>
    <url>/posts/77ca7534/</url>
    <content><![CDATA[<p>目前很多项目都是前端页面和后端接口分开开发，然而有很多特殊项目在开发过程中会出现这样的情况，开发的时候分开开发、联调、测试，但是部署的时候却需要整合在一起部署，接下来解决该问题。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先必须改造原有的项目结构，将前端和后端项目放在同一个<code>MAVEN</code>项目下，这样才能使用<code>MAVEN</code>工具来管理整个项目构建周期;项目结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p>
<h2 id="修改parent-pom-xml"><a href="#修改parent-pom-xml" class="headerlink" title="修改parent/pom.xml"></a>修改parent/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">  	&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">  	&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">  	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS&lt;/description&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;modules&gt;</span><br><span class="line">		&lt;module&gt;frontend&lt;/module&gt;&lt;!-- 前端静态页面模块 --&gt;</span><br><span class="line">		&lt;module&gt;backend&lt;/module&gt;&lt;!-- 后端接口模块 --&gt;</span><br><span class="line">	&lt;/modules&gt;  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">		&lt;spring-boot.version&gt;2.3.0.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;</span><br><span class="line">		&lt;maven-clean-plugin.version&gt;3.1.0&lt;/maven-clean-plugin.version&gt;</span><br><span class="line">		&lt;maven-compiler-plugin.version&gt;3.8.1&lt;/maven-compiler-plugin.version&gt;</span><br><span class="line">		&lt;maven-failsafe-plugin.version&gt;2.22.2&lt;/maven-failsafe-plugin.version&gt;</span><br><span class="line">		&lt;maven-jar-plugin.version&gt;3.2.0&lt;/maven-jar-plugin.version&gt;</span><br><span class="line">		&lt;maven-war-plugin.version&gt;3.2.3&lt;/maven-war-plugin.version&gt;</span><br><span class="line">		&lt;maven-resources-plugin.version&gt;3.1.0&lt;/maven-resources-plugin.version&gt;</span><br><span class="line">		&lt;maven-shade-plugin.version&gt;3.2.2&lt;/maven-shade-plugin.version&gt;</span><br><span class="line">		&lt;maven-archiver.version&gt;3.5.0&lt;/maven-archiver.version&gt;</span><br><span class="line">		&lt;maven-archetype.version&gt;3.2.0&lt;/maven-archetype.version&gt;</span><br><span class="line">		&lt;maven-frontend-plugin.version&gt;1.10.0&lt;/maven-frontend-plugin.version&gt;&lt;!-- 前端项目构建插件，用MAVEN来帮助管理前端项目构建的生命周期 --&gt;</span><br><span class="line">		&lt;git-commit-id-plugin.version&gt;3.0.1&lt;/git-commit-id-plugin.version&gt;</span><br><span class="line">		&lt;byte-buddy.version&gt;1.10.5&lt;/byte-buddy.version&gt;&lt;!-- 框架自带版本太高、不兼容、会报错 --&gt;</span><br><span class="line">		&lt;tomcat.version&gt;8.0.52&lt;/tomcat.version&gt;&lt;!-- 使用War包部署的时候，生产环境的Tomcat版本，否则可能出现不兼容问题 --&gt;</span><br><span class="line">		&lt;mapstruct.version&gt;1.3.1.Final&lt;/mapstruct.version&gt;</span><br><span class="line">		&lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;</span><br><span class="line">		&lt;commons-io.version&gt;2.7&lt;/commons-io.version&gt;</span><br><span class="line">		&lt;httpclient.version&gt;4.5.12&lt;/httpclient.version&gt;</span><br><span class="line">		&lt;node.version&gt;v10.20.1&lt;/node.version&gt;</span><br><span class="line">		&lt;npm.version&gt;6.9.0&lt;/npm.version&gt;</span><br><span class="line">		&lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-fileupload.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy-agent&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger start --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger end --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;com.vaadin.external.google&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;android-json&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;&lt;!-- 此处是官方文档提供的必须要引入管理的文件 --&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line">	&lt;distributionManagement&gt;&lt;!--发布地址、需要修改为自己的Nexus私服地址--&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;nexus-releases&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-release/&lt;/url&gt;</span><br><span class="line">		&lt;/repository&gt;</span><br><span class="line">		&lt;snapshotRepository&gt;</span><br><span class="line">			&lt;id&gt;nexus-snapshots&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-snapshot/&lt;/url&gt;</span><br><span class="line">		&lt;/snapshotRepository&gt;</span><br><span class="line">	&lt;/distributionManagement&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;resources&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">		&lt;/resources&gt;</span><br><span class="line">		&lt;testResources&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">		&lt;/testResources&gt;</span><br><span class="line">			&lt;plugins&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;</span><br><span class="line">						&lt;parameters&gt;true&lt;/parameters&gt;</span><br><span class="line">						&lt;source&gt;${maven.compiler.source}&lt;/source&gt;</span><br><span class="line">						&lt;target&gt;${maven.compiler.target}&lt;/target&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;annotationProcessorPaths&gt;</span><br><span class="line">							&lt;path&gt;</span><br><span class="line">								&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">								&lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">								&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">							&lt;/path&gt;</span><br><span class="line">						&lt;/annotationProcessorPaths&gt;</span><br><span class="line">						&lt;compilerArgs&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorTimestamp=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.defaultComponentModel=spring&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorVersionInfoComment=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.unmappedTargetPolicy=IGNORE&lt;/arg&gt;</span><br><span class="line">						&lt;/compilerArgs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-jar-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-war-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--springboot项目构建时候默认使用@作为占位符，由于本人更喜欢使用$作为占位符，所此处修改为使用$占位符--&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">						&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-archetype.version}&lt;/version&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">			&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改parent-gitignore"><a href="#修改parent-gitignore" class="headerlink" title="修改parent/.gitignore"></a>修改parent/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-env"><a href="#修改frontend-env" class="headerlink" title="修改frontend/.env"></a>修改frontend/.env</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">VUE_APP_NAME=QCOS-Admin</span><br><span class="line">VUE_APP_DIR=qcos                                          #前端项目构建成果输出目录</span><br><span class="line">VUE_APP_ROUTES_KEY=admin.routes</span><br><span class="line">VUE_APP_PERMISSIONS_KEY=admin.permissions</span><br><span class="line">VUE_APP_ROLES_KEY=admin.roles</span><br><span class="line">VUE_APP_USER_KEY=admin.user</span><br><span class="line">VUE_APP_API_BASE_URL=http://api.wssjdi.com                 #接口代理地址</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-package-json"><a href="#修改frontend-package-json" class="headerlink" title="修改frontend/package.json"></a>修改frontend/package.json</h2><p>项目配置中的下列三项建议根据项目自行修改,<code>name</code>会显示在页面的Tab中,不能使用中文、空格;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "QCOS-Admin",</span><br><span class="line">  "homepage": "https://github.com/wssjdi",</span><br><span class="line">  "scripts": {</span><br><span class="line">    "deploy": "gh-pages -d dist -b pages -r https://github.com/wssjdi"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-gitignore"><a href="#修改frontend-gitignore" class="headerlink" title="修改frontend/.gitignore"></a>修改frontend/.gitignore</h2><p>为了提高在<code>qa</code>、<code>product</code>环境构建的时候拉取代码的速度，需要尽量减小代码包的大小，需要在<code>.gitignore</code>中添加如下项</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">node_modules/                   #前端JS依赖包</span><br><span class="line">node/                           #Node、Npm环境包</span><br><span class="line">dist/                           #默认构建目的包</span><br><span class="line">qcos/                           #项目构建目的包、该项是根据自己项目决定的</span><br></pre></td></tr></tbody></table></figure>
<h2 id="增加frontend-pom-xml"><a href="#增加frontend-pom-xml" class="headerlink" title="增加frontend/pom.xml"></a>增加frontend/pom.xml</h2><p>为了提高<code>dev</code>的打包效率，可以在对应的环境配置中删掉如下代码中的两个构建步骤<code>install node and npm</code>,<code>npm install</code>;可以使用开发环境已经安装过的<code>Node</code>环境来执行<code>npm install</code>来安装前端项目的依赖,在开发环境只需要执行后续的<code>npm run build</code>即可，这样可以节省很多下载<code>Node</code>、<code>Npm</code>并安装的时间;<code>qa</code>环境和<code>Product</code>不需要变更，如果必须定制的话，可以更改的项目为：<code>nodeVersion</code> , <code>npmVersion</code>, <code>nodeDownloadRoot</code>, <code>npmDownloadRoot</code>,<code>npmRegistryURL</code>;需要确认一下<code>nodeDownloadRoot</code>能否连通并下载对应<code>nodeVersion</code>版本的<code>Node</code>执行程序,一般<code>Windows</code>环境对应的为<code>node.exe</code>可执行文件,<code>Linux</code>环境对应的为<code>node-@nodeVersion-linux-x64.tar.gz</code>文件;需要确认一下<code>npmDownloadRoot</code>能否连通并下载对应<code>npmVersion</code>版本的<code>Node</code>执行程序,一般对应的<code>npm-@npmVersion.tgz</code>文件;<code>npmRegistryURL</code>为执行<code>npm install</code>使用的<code>npm</code>镜像,为提高速度，可以在公网环境中使用淘宝镜像<code>https://registry.npm.taobao.org</code>,或在内网环境中使用公司内部镜像<code>https://mymirrors.npmjs.org/npm/-/</code>;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;frontend&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">    &lt;description&gt;QCloud COS Frontend&lt;/description&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;&lt;!-- 前端项目打包成功的名称 --&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;${project.basedir}/qcos/&lt;/directory&gt;&lt;!-- 前端项目要打包成果的输出路径，需要和前端项目中.env中的配置保持一致 --&gt;</span><br><span class="line">                &lt;targetPath&gt;META-INF/resources/&lt;/targetPath&gt;&lt;!-- 前端项目打包为webjar时，静态资源的存储路径，建议为META-INF/resources/,servlet3.0容器可以解析该路径 --&gt;</span><br><span class="line">                &lt;excludes&gt;&lt;!-- springboot建议将html模板和静态资源分别放在不同的路径来解析，本项目遵循该建议，这里排除掉所有的html模板 --&gt;</span><br><span class="line">                    &lt;exclude&gt;*.html&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;&lt;!-- 插件地址: https://github.com/eirslett/frontend-maven-plugin--&gt;</span><br><span class="line">                &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;${maven-frontend-plugin.version}&lt;/version&gt;</span><br><span class="line">                &lt;dependencies&gt;&lt;!--插件的前两个构建步骤需要使用网络工具下载一些资源，加上http工具的依赖--&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;!-- 在dev环境可以跳过前两个构建步骤，替换成使用本机的node环境来进行npm install操作，可以节省很大一部分构建时间~！ --&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;install node and npm&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;install-node-and-npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;nodeVersion&gt;${node.version}&lt;/nodeVersion&gt;</span><br><span class="line">                            &lt;npmVersion&gt;${npm.version}&lt;/npmVersion&gt;</span><br><span class="line">                            &lt;nodeDownloadRoot&gt;https://nodejs.org/dist/&lt;/nodeDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;npmDownloadRoot&gt;https://registry.npmjs.org/npm/-/&lt;/npmDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm install&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;!-- optional: default phase is "generate-resources" --&gt;</span><br><span class="line">                        &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">                        &lt;!-- Optional configuration which provides for running any npm command --&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;npmRegistryURL&gt;https://registry.npm.taobao.org/&lt;/npmRegistryURL&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;arguments&gt;install&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- Node构建打包 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm run build&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;arguments&gt;${build.argument}&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">      &lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-qa&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-product&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-pom-xml"><a href="#修改backend-pom-xml" class="headerlink" title="修改backend/pom.xml"></a>修改backend/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">  &lt;artifactId&gt;backend&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;name&gt;backend&lt;/name&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS Backend&lt;/description&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;&lt;!--前端项目依赖--&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${project.version}&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- mvc框架--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt;</span><br><span class="line">                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;/exclusion&gt;</span><br><span class="line">          &lt;/exclusions&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">	   	&lt;dependency&gt;</span><br><span class="line">	    	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">			&lt;/plugin&gt;&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${maven-clean-plugin.version}&lt;/version&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;filesets&gt;&lt;!--mvn clean的时候清理掉如下的文件夹--&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/statics/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/templates/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">				&lt;/filesets&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">					&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">					&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">				&lt;executions&gt;</span><br><span class="line">					&lt;!-- 当使用将静态资源构建成webjar的方式发布的时候，可以跳过第一个构建步骤，这样可以将静态资源文件的大小进行压缩，有效减小包大小，一定程度加快部署速度~！ --&gt;</span><br><span class="line">					&lt;!-- 跳过该构建步骤</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy static&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;</span><br><span class="line">							&lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">						&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/statics/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">										&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">									&lt;excludes&gt;</span><br><span class="line">										&lt;exclude&gt;index.html&lt;/exclude&gt;</span><br><span class="line">									&lt;/excludes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">					--&gt;</span><br><span class="line">					&lt;!-- SpringBoot建议最好将静态资源(`js`,`css`,`image`等)文件和`html`文件的路径分开存放,所以构建的时候只需要Copy一下html模板就可以了 --&gt;</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy html&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;&lt;goal&gt;copy-resources&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/templates/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;!--因为vue-cli打包的目录在项目的根目录，所以从这里复制 --&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;*.html&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">				&lt;/executions&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">  		&lt;activation&gt;</span><br><span class="line">  			&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">  		&lt;/activation&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;dev&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8000&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;qa&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;product&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-application-yaml"><a href="#修改backend-application-yaml" class="headerlink" title="修改backend/application.yaml"></a>修改backend/application.yaml</h2><p>application.yaml中增加如下配置;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /**</span><br><span class="line">  resources:</span><br><span class="line">    #springboot解析静态资源的路径，和webjar中保存静态资源的路径保持一致</span><br><span class="line">    static-locations: classpath:/META-INF/resources/</span><br><span class="line">  #模板引擎设置</span><br><span class="line">  thymeleaf:</span><br><span class="line">    enabled: true</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    servlet:</span><br><span class="line">      content-type: text/html</span><br><span class="line">    # 开发时关闭缓存，页面实时刷新</span><br><span class="line">    cache: false</span><br><span class="line">    check-template-location: true</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    #thymeleaf end</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-gitignore"><a href="#修改backend-gitignore" class="headerlink" title="修改backend/.gitignore"></a>修改backend/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br><span class="line"></span><br><span class="line">/src/main/resources/statics/                    #从前端项目复制过来的静态资源不需要提交到代码仓库</span><br><span class="line">/src/main/resources/templates/                  #从前端项目复制过来的html模板不需要提交到代码仓库</span><br></pre></td></tr></tbody></table></figure>
<p>好了,现在可以在parent目录下直接开始构建你的项目了,项目的构建成功会输出到parent/target/路径之下,共有两个成果：<code>frontend-0.0.1.jar</code>为前端项目的构建成果,<code>backend-0.0.1.war</code>为后端项目的构建成果,发布的时候直接使用web容器发布<code>backend-0.0.1.war</code>即可;</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SpringBoot+Vue</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
        <tag>Maven</tag>
        <tag>java</tag>
        <tag>pom.xml</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>go test单元测试及基准测试</title>
    <url>/posts/2910ec3f/</url>
    <content><![CDATA[<p>Go语言拥有一套单元测试和性能测试系统，仅需要添加很少的代码就可以快速测试一段需求代码。</p>
<h1 id="go-test命令"><a href="#go-test命令" class="headerlink" title="go test命令"></a>go test命令</h1><p>go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。输出的信息类似下面所示的样子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com/stretchr/testify v1.5.1</span><br><span class="line">go: downloading github.com/pkg/errors v0.9.1</span><br><span class="line">go: downloading github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">go: downloading github.com/davecgh/go-spew v1.1.1</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.952s</span><br></pre></td></tr></tbody></table></figure>
<p>性能测试系统可以给出代码的性能数据，帮助测试者分析性能问题。</p>
<p>提示</p>
<p>单元测试<code>（unit testing）</code>，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如 <code>C</code> 语言中单元指一个函数，<code>Java</code> 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p>
<h2 id="单元测试——测试和验证代码的框架"><a href="#单元测试——测试和验证代码的框架" class="headerlink" title="单元测试——测试和验证代码的框架"></a>单元测试——测试和验证代码的框架</h2><p>要开始一个单元测试，需要准备一个 <code>go</code> 源码文件，在命名文件时需要让文件必须以 <code>_test</code> 结尾。默认的情况下，<code>go test</code> 命令不需要任何的参数，它会自动把你源码包下面所有 <code>test</code> 文件测试完毕，当然你也可以带上参数。</p>
<p>常用的参数：</p>
<ul>
<li>-bench regexp 执行相应的 <code>benchmarks</code>，例如 <code>-bench=.</code>；</li>
<li>-cover 开启测试覆盖率；</li>
<li>-run regexp 只运行 <code>regexp</code> 匹配的函数，例如 <code>-run=Array</code> 那么就执行包含有 <code>Array</code> 开头的函数；</li>
<li>-v 显示测试的详细命令。</li>
</ul>
<p>单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以<code>Test</code>为前缀，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package yaml</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"path/filepath"</span><br><span class="line">	"testing"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"github.com/stretchr/testify/assert"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestUnmarshalYML(t *testing.T) {</span><br><span class="line">	c := &amp;Config{}</span><br><span class="line">	b, err := LoadYMLConfig("./testdata/config.yml")</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">	err = UnmarshalYML(b, c)</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">    t.Log(c.StrTest)</span><br><span class="line">	assert.Equal(t, "strTest", c.StrTest)</span><br><span class="line">	assert.Equal(t, 11, c.IntTest)</span><br><span class="line">	assert.Equal(t, false, c.BooleanTest)</span><br><span class="line">	assert.Equal(t, "childStrTest", c.ChildConfig.StrTest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Config struct {</span><br><span class="line">	StrTest     string      `yaml:"strTest" default:"default" json:"strTest,omitempty" property:"strTest"`</span><br><span class="line">	IntTest     int         `default:"109"  yaml:"intTest" json:"intTest,omitempty" property:"intTest"`</span><br><span class="line">	BooleanTest bool        `yaml:"booleanTest" default:"true" json:"booleanTest,omitempty"`</span><br><span class="line">	ChildConfig ChildConfig `yaml:"child" json:"child,omitempty"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type ChildConfig struct {</span><br><span class="line">	StrTest string `default:"strTest" default:"default" yaml:"strTest"  json:"strTest,omitempty"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。</li>
<li>测试用例文件使用 <code>go test</code> 指令来执行，没有也不需要 <code>main()</code> 作为函数入口。所有在以 <code>_test</code> 结尾的源码内以 <code>Test</code> 开头的函数会自动被执行。</li>
<li>测试用例可以不传入 <code>*testing.T</code> 参数。</li>
</ul>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，单元测试文件 <code>(*_test.go)</code> 里的测试入口必须以 <code>Test</code> 开始，参数为 <code>*testing.T</code> 的函数。一个单元测试文件可以有多个测试入口。</li>
<li>第 16 行，使用 <code>testing</code> 包的 <code>T</code> 结构提供的 <code>Log()</code> 方法打印字符串。</li>
</ul>
<h3 id="单元测试命令行"><a href="#单元测试命令行" class="headerlink" title="单元测试命令行"></a>单元测试命令行</h3><p>单元测试使用 go test 命令启动，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.627s</span><br><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test -v -run TestUnmarshalYML$</span><br><span class="line">=== RUN   TestUnmarshalYML</span><br><span class="line">--- PASS: TestUnmarshalYML (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.637s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，如果在 <code>go test</code> 后跟了单元测试源文件，表示测试这个文件里的所有测试用例，没有则测试所有的单元测试源文件。</li>
<li>第 3 行，显示测试结果，  <code>ok</code> 表示测试通过，<code>github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml</code> 是测试用例的包名，<code>0.627s</code> 表示测试花费的时间。</li>
<li>第 4 行，显示在附加参数中添加了<code>-v</code>，可以让测试时显示详细的流程，添加<code>-run</code>，指定执行的测试用例<code>TestUnmarshalYML$</code>匹配正则表达式。</li>
<li>第 5 行，表示开始运行名叫 <code>TestUnmarshalYML</code> 的测试用例。</li>
<li>第 6 行，表示已经运行完 <code>TestUnmarshalYML</code> 的测试用例，PASS 表示测试成功。</li>
</ul>
<p><code>-run</code>跟随的测试用例的名称支持正则表达式，使用<code>-run TestUnmarshalYML$</code>即可只执行 <code>TestUnmarshalYML</code> 测试用例，如果不带最后的<code>$</code>，则执行所有以<code>TestUnmarshalYML</code>为开头的测试用例。</p>
<h3 id="标记单元测试结果"><a href="#标记单元测试结果" class="headerlink" title="标记单元测试结果"></a>标记单元测试结果</h3><p>当需要终止当前测试用例时，可以使用 <code>t.FailNow()</code>。</p>
<p>还有一种只标记错误不终止测试的方法 <code>t.Fail()</code> ，调用 Fail() 后测试结果标记为失败，但是后续代码依然会被程序执行。</p>
<h3 id="单元测试日志"><a href="#单元测试日志" class="headerlink" title="单元测试日志"></a>单元测试日志</h3><p>每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。</p>
<div align="center">
  单元测试框架提供的日志方法<table>
    <thead>
      <tr></tr>
    </thead>
    <thead>
      <tr>
        <th align="center">方法</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong>Log</strong></td>
        <td align="center">打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Logf</strong></td>
        <td align="center">格式化打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Error</strong></td>
        <td align="center">打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Errorf</strong></td>
        <td align="center">格式化打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatal</strong></td>
        <td align="center">打印致命日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatalf</strong></td>
        <td align="center">格式化打印致命日志，同时结束测试</td>
      </tr>
    </tbody>
  </table>
</div>

<p>开发者可以根据实际需要选择合适的日志。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>go test -v -bench=. benchmark_test.go</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.341 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.977s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的-bench=.表示运行 <code>benchmark_test.go</code> 文件里的所有基准测试，和单元测试中的<code>-run</code>类似。</li>
<li>第 5 行中显示基准测试名称，1000000000 表示测试的次数，也就是 <code>testing.B</code> 结构中提供给程序使用的 N。<code>0.341 ns/op</code> 表示每一个操作耗费多少时间（纳秒）。</li>
</ul>
<p>注意：<code>Windows</code> 下使用 <code>go test</code> 命令行时，<code>-bench=.</code> 应写为 <code>-bench="."</code>。</p>
<h3 id="基准测试原理"><a href="#基准测试原理" class="headerlink" title="基准测试原理"></a>基准测试原理</h3><p>基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。</p>
<h3 id="自定义测试时间"><a href="#自定义测试时间" class="headerlink" title="自定义测试时间"></a>自定义测试时间</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. -benchtime=5s benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.351 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.902s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="测试内存"><a href="#测试内存" class="headerlink" title="测试内存"></a>测试内存</h3><p>基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Alloc(b *testing.B) {</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        fmt.Sprintf("%d", i)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在命令行中添加-benchmem参数以显示内存分配情况，参见下面的指令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=Alloc -benchmem benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Alloc</span><br><span class="line">Benchmark_Alloc-4        8610186               120 ns/op              16 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.760s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的代码中-bench后添加了 <code>Alloc</code>，指定只测试 <code>Benchmark_Alloc()</code> 函数。</li>
<li>第 5 行代码的 <code>16 B/op</code>表示每一次调用需要分配 <code>16</code> 个字节，<code>2 allocs/op</code> 表示每一次调用有两次分配。</li>
</ul>
<p>开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。</p>
<h3 id="控制计时器"><a href="#控制计时器" class="headerlink" title="控制计时器"></a>控制计时器</h3><p>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。</p>
<p>基准测试中的计时器控制<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Add_TimerControl(b *testing.B) {</span><br><span class="line">	// 重置计时器</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	// 停止计时器</span><br><span class="line">	b.StopTimer()</span><br><span class="line">	// 开始计时器</span><br><span class="line">	b.StartTimer()</span><br><span class="line">	var n int</span><br><span class="line">	for i := 0; i &lt; b.N; i++ {</span><br><span class="line">		n++</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从 <code>Benchmark()</code> 函数开始，<code>Timer</code> 就开始计数。<code>StopTimer()</code> 可以停止这个计数过程，做一些耗时的操作，通过 <code>StartTimer()</code> 重新开始计时。<code>ResetTimer()</code> 可以重置计数器的数据。</p>
<p>计数器内部不仅包含耗时数据，还包括内存分配的数据。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go test</tag>
        <tag>单元测试</tag>
        <tag>基准测试</tag>
      </tags>
  </entry>
  <entry>
    <title>go dubbo</title>
    <url>/posts/3498a470/</url>
    <content><![CDATA[<p>go语言使用dubbo-go接入现有的dubbo服务</p>
<h2 id="注册中心使用-zookeeper-，序列化使用-hessian2"><a href="#注册中心使用-zookeeper-，序列化使用-hessian2" class="headerlink" title="注册中心使用 zookeeper ，序列化使用 hessian2"></a>注册中心使用 <code>zookeeper</code> ，序列化使用 <code>hessian2</code></h2><p>目前我司在使用 dubbo 的过程使用的 zookeeper 作为注册中心，序列化是 hessian2 ，所以我们要做如下初始化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "github.com/apache/dubbo-go/common/proxy/proxy_factory"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/protocol"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/filter/impl"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/cluster_impl"</span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/loadbalance"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/zookeeper"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>由于我是接入客户端，所以我这边只需要配置 <code>ConsumerConfig</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    # client</span><br><span class="line">    request_timeout: "3s"</span><br><span class="line">    # connect timeout</span><br><span class="line">    connect_timeout: "3s"</span><br><span class="line">    check: true</span><br><span class="line">    application:</span><br><span class="line">        organization: "wssjdi.com"</span><br><span class="line">        name: "soa.sso.ITokenService"</span><br><span class="line">        module: "dubbogo token service client"</span><br><span class="line">        version: "1.0.0"</span><br><span class="line">        owner: "wssjdi"</span><br><span class="line">    registries:</span><br><span class="line">        "localzk":</span><br><span class="line">            protocol: "zookeeper"</span><br><span class="line">            timeout: "3s"</span><br><span class="line">            address: "10.100.156.17:2181"</span><br><span class="line">            username: ""</span><br><span class="line">            password: ""</span><br><span class="line">    references:</span><br><span class="line">        "ITokenService":</span><br><span class="line">            registry: "localzk"</span><br><span class="line">            protocol: "dubbo"</span><br><span class="line">            interface: "com.wssjdi.soa.sso.ITokenService"</span><br><span class="line">            version: "1.0.0"</span><br><span class="line">            methods:</span><br><span class="line">                - name: "validate"</span><br><span class="line">            retries: "3"</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go dubbo</tag>
        <tag>dubbo</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>go 语言基础</title>
    <url>/posts/f628ea56/</url>
    <content><![CDATA[<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p><code>Go</code>语言是静态类型语言，因此变量<code>（variable）</code>是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。</p>
<p>声明变量的一般形式是使用 <code>var</code> 关键字：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name type</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>var</code> 是声明变量的关键字，<code>name</code> 是变量名，<code>type</code> 是变量的类型。</p>
<p>需要注意的是，<code>Go</code>语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b</code>; 。其中只有 <code>a</code> 是指针而 <code>b</code> 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 <code>Go</code> 中，则可以和轻松地将它们都声明为指针类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b *int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Go语言的基本类型有：</p>
<ul>
<li>bool</li>
<li>string</li>
<li>int、int8、int16、int32、int64</li>
<li>uint、uint8、uint16、uint32、uint64、uintptr</li>
<li>byte // uint8 的别名</li>
<li>rune // int32 的别名 代表一个 Unicode 码</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
</ul>
<p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code> 等。所有的内存在 <code>Go</code> 中都是经过初始化的。</p>
<p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code> 。</p>
<p>变量的声明有几种形式，通过下面几节进行整理归纳。</p>
<h3 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></tbody></table></figure>
<p>变量声明以关键字 var 开头，后置变量类型，行尾无须分号。</p>
<h3 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h3><p>觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">    c []float32</span><br><span class="line">    d func() bool</span><br><span class="line">    e struct {</span><br><span class="line">        x int</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>使用关键字 var 和括号，可以将一组变量定义放在一起。</p>
<h3 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h3><p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，简短模式<code>（short variable declaration）</code>有以下限制：</p>
<ul>
<li>定义变量，同时显式初始化。</li>
<li>不能提供数据类型。</li>
<li>只能用在函数内部。</li>
</ul>
<p>和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i, j := 0, 1</span><br></pre></td></tr></tbody></table></figure>
<p>演示简短格式变量声明的基本样式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">   x:=100</span><br><span class="line">   a,s:=1, "abc"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。<code>var</code> 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p><code>Go</code>语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p>
<ul>
<li>整型和浮点型变量的默认值为 <code>0</code> 和 <code>0.0</code>。</li>
<li>字符串变量的默认值为空字符串。</li>
<li>布尔型变量默认为 <code>bool</code>。</li>
<li>切片、函数、指针变量的默认为 <code>nil</code>。</li>
</ul>
<p>当然，依然可以在变量声明时赋予变量一个初始值。</p>
<p>回顾C语言</p>
<p>在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。</p>
<p>在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/C++ 中变量默认不初始化。</p>
<p>微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。</p>
<p>因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。</p>
<h3 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 类型 = 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>例如，游戏中，玩家的血量初始值为100。可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp int = 100</span><br></pre></td></tr></tbody></table></figure>
<p>这句代码中，<code>hp</code> 为变量名，类型为 <code>int</code>，<code>hp</code> 的初始值为 <code>100</code>。</p>
<p>上面代码中，<code>100</code> 和 <code>int</code> 同为 <code>int</code> 类型，<code>int</code> 可以认为是冗余信息，因此可以进一步简化初始化的写法。</p>
<h3 id="编译器推导类型的格式"><a href="#编译器推导类型的格式" class="headerlink" title="编译器推导类型的格式"></a>编译器推导类型的格式</h3><p>在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp = 100</span><br></pre></td></tr></tbody></table></figure>
<p>等号右边的部分在编译原理里被称做右值（rvalue）。</p>
<p>编译器根据右值推导变量类型完成初始化的例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var attack = 40</span><br><span class="line">var defence = 20</span><br><span class="line">var damageRate float32 = 0.17</span><br><span class="line">var damage = float32(attack-defence) * damageRate</span><br><span class="line">fmt.Println(damage)</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 和 <code>2</code> 行，右值为整型，<code>attack</code> 和 <code>defence</code> 变量的类型为 int。</li>
<li>第 <code>3</code> 行，表达式的右值中使用了 <code>0.17</code>。由于<code>Go</code>语言和<code>C</code>语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 <code>damageRate</code> 变量的类型，<code>Go</code>语言编译器会将 <code>damageRate</code> 类型推导为 <code>float64</code>，我们这里不需要 <code>float64</code> 的精度，所以需要强制指定类型为 <code>float32</code>。</li>
<li><p>第 <code>4</code> 行，将 <code>attack</code> 和 <code>defence</code> 相减后的数值结果依然为整型，使用 <code>float32()</code> 将结果转换为 <code>float32</code> 类型，再与 <code>float32</code> 类型的 <code>damageRate</code> 相乘后，<code>damage</code> 类型也是 <code>float32</code> 类型。</p>
<p><strong><em>提示：<code>damage</code> 变量的右值是一个复杂的表达式，整个过程既有 <code>attack</code> 和 <code>defence</code> 的运算还有强制类型转换。</em></strong></p>
</li>
<li><p>第 5 行，输出 <code>damage</code> 的值。</p>
</li>
</ul>
<p>以上代码输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p><code>var</code> 的变量声明还有一种更为精简的写法，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hp := 100</span><br></pre></td></tr></tbody></table></figure>
<p>这是<code>Go</code>语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。</p>
<p><strong><em>注意：由于使用了<code>:=</code>，而不是赋值的<code>=</code>，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。</em></strong></p>
<p>如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明 hp 变量</span><br><span class="line">var hp int</span><br><span class="line">// 再次声明并赋值</span><br><span class="line">hp := 10</span><br></pre></td></tr></tbody></table></figure>
<p>编译报错:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">no new variables on left side of :=</span><br></pre></td></tr></tbody></table></figure>
<p>翻译过来是在<code>:=</code>的左边没有新变量出现，意思就是<code>:=</code>的左边变量已经被声明了。</p>
<p>短变量声明的形式在开发中的例子较多，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp","127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p><code>net.Dial</code> 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象<code>（conn）</code>，一个是错误对象<code>（err）</code>。如果是标准格式将会变成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var conn net.Conn</span><br><span class="line">var err error</span><br><span class="line">conn, err = net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>因此，短变量声明并初始化的格式在开发中使用比较普遍。</p>
<p><strong><em>注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp", "127.0.0.1:8080")</span><br><span class="line">conn2, err := net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码片段，编译器不会报 err 重复定义</p>
<h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h2><p>编程最简单的算法之一，莫过于变量交换。交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">var t int</span><br><span class="line">t = a</span><br><span class="line">a = b</span><br><span class="line">b = t</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>这样的算法很多，但是都有一定的数值范围和类型要求。</p>
<p>到了<code>Go</code>语言时，内存不再是紧缺资源，而且写法可以更简单。使用 <code>Go</code> 的“多重赋值”特性，可以轻松完成变量交换的任务：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">b, a = a, b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>多重赋值时，变量的左值和右值按从左到右的顺序赋值。</p>
<p>多重赋值在<code>Go</code>语言的错误处理和函数返回值中会大量地使用。例如使用<code>Go</code>语言进行排序时就需要使用交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，将 <code>IntSlice</code> 声明为 <code>[]int</code> 类型。</li>
<li>第 <code>3</code> 行，为 <code>IntSlice</code> 类型编写一个 <code>Len</code> 方法，提供切片的长度。</li>
<li>第 <code>4</code> 行，根据提供的 <code>i、j</code> 元素索引，获取元素后进行比较，返回比较结果。</li>
<li>第 <code>5</code> 行，根据提供的 <code>i、j</code> 元素索引，交换两个元素的值。</li>
</ul>
<h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。</p>
<p>匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func GetData() (int, int) {</span><br><span class="line">    return 100, 200</span><br><span class="line">}</span><br><span class="line">func main(){</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100 200</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行<code>GetData()</code> 是一个函数，拥有两个整型返回值。每次调用将会返回 <code>100</code> 和 <code>200</code> 两个数值。</li>
<li>第 <code>5</code> 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。</li>
<li>第 <code>6</code> 行将第一个返回值的变量设为匿名变量。</li>
</ul>
<p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<p>提示：在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。</p>
<p>了解变量的作用域对我们学习<code>Go</code>语言来说是比较重要的，因为<code>Go</code>语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。</p>
<p>根据变量定义位置的不同，可以分为以下三个类型：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>下面就来分别介绍一下。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。</p>
<p>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。</p>
<p>【示例】下面的 <code>main()</code> 函数中使用到了局部变量 <code>a、b、c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量 a 和 b 并赋值</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    //声明局部变量 c 并计算 a 和 b 的和</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用<code>import</code>关键字引入全局变量所在的源文件之后才能使用这个全局变量。</p>
<p>全局变量声明必须以 <code>var</code> 关键字开头，<strong><em>如果想要在外部包中使用全局变量的首字母必须大写</em></strong>。</p>
<p>【示例】下面代码中，第 <code>4</code> 行定义了全局变量 <code>c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var c int</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a, b int</span><br><span class="line">    //初始化参数</span><br><span class="line">    a = 3</span><br><span class="line">    b = 4</span><br><span class="line">    c = a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，<strong><em>但是函数体内的局部变量会被优先考虑</em></strong>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a int = 3</span><br><span class="line">    fmt.Printf("a = %d\n", a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3</span><br></pre></td></tr></tbody></table></figure>
<h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p>
<p>形式参数会作为函数的局部变量来使用。</p>
<p>【示例】下面代码中第 <code>16</code> 行定义了形式参数 <code>a</code> 和 <code>b</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">//全局变量 a</span><br><span class="line">var a int = 13</span><br><span class="line">func main() {</span><br><span class="line">    //局部变量 a 和 b</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    fmt.Printf("main() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("main() 函数中 b = %d\n", b)</span><br><span class="line">    c := sum(a, b)</span><br><span class="line">    fmt.Printf("main() 函数中 c = %d\n", c)</span><br><span class="line">}</span><br><span class="line">func sum(a, b int) int {</span><br><span class="line">    fmt.Printf("sum() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("sum() 函数中 b = %d\n", b)</span><br><span class="line">    num := a + b</span><br><span class="line">    return num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main() 函数中 a = 3</span><br><span class="line">main() 函数中 b = 4</span><br><span class="line">sum() 函数中 a = 3</span><br><span class="line">sum() 函数中 b = 4</span><br><span class="line">main() 函数中 c = 7</span><br></pre></td></tr></tbody></table></figure>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 <code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。</p>
<p><code>Go</code>语言同时提供了有符号和无符号的整数类型，其中包括 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 四种大小截然不同的有符号整数类型，分别对应 <code>8</code>、<code>16</code>、<code>32</code>、<code>64 bit</code>（二进制位）大小的有符号整数，与此对应的是 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 四种无符号整数类型。</p>
<p>此外还有两种整数类型 <code>int</code> 和 <code>uint</code>，它们分别对应特定 <code>CPU</code> 平台的字长（机器字大小），其中 <code>int</code> 表示有符号整数，应用最为广泛，<code>uint</code> 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，<code>int</code> 和 <code>uint</code> 所能表示的整数大小会在 <code>32bit</code> 或 <code>64bit</code> 之间变化。</p>
<p>大多数情况下，我们只需要 <code>int</code> 一种整型即可，它可以用于循环计数器（<code>for</code> 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 <code>int</code> 类型的处理速度也是最快的。</p>
<p>用来表示 <code>Unicode</code> 字符的 <code>rune</code> 类型和 <code>int32</code> 类型是等价的，通常用于表示一个 <code>Unicode</code> 码点。这两个名称可以互换使用。同样，<code>byte</code> 和 <code>uint8</code> 也是等价类型，<code>byte</code> 类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>最后，还有一种无符号的整数类型 <code>uintptr</code>，它没有指定具体的 <code>bit</code> 大小但是足以容纳指针。<code>uintptr</code> 类型只有在底层编程时才需要，特别是<code>Go</code>语言和<code>C</code>语言函数库或操作系统接口相交互的地方。</p>
<p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，比如 <code>int</code> 和 <code>int32</code>，虽然 <code>int</code> 类型的大小也可能是 <code>32 bit</code>，但是在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换，反之亦然。</p>
<p><code>Go</code>语言中有符号整数采用 <code>2</code> 的补码形式表示，也就是最高 <code>bit</code> 位用来表示符号位，一个 <code>n-bit</code> 的有符号数的取值范围是从 <code>-2(n-1)</code> 到 <code>2(n-1)-1</code>。无符号整数的所有 <code>bit</code> 位都用于表示非负数，取值范围是 <code>0</code> 到 <code>2n-1</code>。例如，<code>int8</code> 类型整数的取值范围是从 <code>-128</code> 到 <code>127</code>，而 <code>uint8</code> 类型整数的取值范围是从 <code>0</code> 到 <code>255</code>。</p>
<h3 id="哪些情况下使用-int-和-uint"><a href="#哪些情况下使用-int-和-uint" class="headerlink" title="哪些情况下使用 int 和 uint"></a>哪些情况下使用 <code>int</code> 和 <code>uint</code></h3><p>程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 <code>map</code> 的元素数量等都可以用 int 来表示。</p>
<p>反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 <code>int</code> 和 <code>uint</code>。</p>
<h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p><code>Go</code>语言提供了两种精度的浮点数 <code>float32</code> 和 <code>float64</code>，它们的算术规范由 <code>IEEE754</code> 浮点数国际标准定义，该浮点数规范被所有现代的 <code>CPU</code> 支持。</p>
<p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 <code>math</code> 包中找到：</p>
<ul>
<li>常量 <code>math.MaxFloat32</code> 表示 <code>float32</code> 能取到的最大数值，大约是 <code>3.4e38</code>；</li>
<li>常量 <code>math.MaxFloat64</code> 表示 <code>float64</code> 能取到的最大数值，大约是 <code>1.8e308</code>；</li>
<li><code>float32</code> 和 <code>float64</code> 能表示的最小值分别为 <code>1.4e-45</code> 和 <code>4.9e-324</code>。</li>
</ul>
<p>一个 <code>float32</code> 类型的浮点数可以提供大约 <code>6</code> 个十进制数的精度，而 <code>float64</code> 则可以提供约 <code>15</code> 个十进制数的精度，通常应该优先使用 <code>float64</code> 类型，因为 <code>float32</code> 类型的累计计算误差很容易扩散，并且 <code>float32</code> 能精确表示的正整数并不是很大。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var f float32 = 16777216 // 1 &lt;&lt; 24</span><br><span class="line">fmt.Println(f == f+1)    // "true"!</span><br></pre></td></tr></tbody></table></figure>
<p>浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const e = .71828 // 0.71828</span><br><span class="line">const f = 1.     // 1</span><br></pre></td></tr></tbody></table></figure>
<p>很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：</p>
<figure class="highlight plain"><figcaption><span>e 或 E 来指定指数部分</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数</span><br><span class="line">const Planck   = 6.62606957e-34 // 普朗克常数</span><br></pre></td></tr></tbody></table></figure>
<p>用 Printf 函数打印浮点数时可以使用<code>%f</code>来控制保留几位小数:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%f\n", math.Pi)</span><br><span class="line">    fmt.Printf("%.2f\n", math.Pi)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.141593</span><br><span class="line">3.14</span><br></pre></td></tr></tbody></table></figure>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>在计算机中，复数是由两个浮点数表示的，其中一个表示实部<code>（real）</code>，一个表示虚部<code>（imag）</code>。</p>
<p><code>Go</code>语言中复数的类型有两种，分别是  <code>complex128（64 位实数和虚数）</code> 和 <code>complex64（32 位实数和虚数）</code>，其中 <code>complex128</code> 为复数的默认类型。</p>
<p>复数的值由三部分组成 <code>RE</code> + <code>IMi</code>，其中 <code>RE</code> 是实数部分，<code>IM</code> 是虚数部分，<code>RE</code> 和 <code>IM</code> 均为 <code>float</code> 类型，而最后的 <code>i</code> 是虚数单位。</p>
<p>声明复数的语法格式如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name complex128 = complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>name</code> 为复数的变量名，<code>complex128</code> 为复数的类型，<code>=</code> 后面的 <code>complex</code> 为 <code>Go</code> 语言的内置函数用于为复数赋值，<code>x</code> 、<code>y</code> 分别表示构成该复数的两个 <code>float64</code> 类型的数值，<code>x</code> 为实部，<code>y</code> 为虚部。</p>
<p>上面的声明语句也可以简写为下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name := complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个复数 <code>z := complex(x, y)</code>，可以通过 <code>Go</code> 语言的内置函数 <code>real(z)</code> 来获得该复数的实部，也就是 <code>x</code> ；通过 <code>imag(z)</code> 获得该复数的虚部，也就是 <code>y</code> 。</p>
<p>【示例】使用内置的 <code>complex</code> 函数构建复数，并使用 <code>real</code> 和 <code>imag</code> 函数返回复数的实部和虚部：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x complex128 = complex(1, 2) // 1+2i</span><br><span class="line">var y complex128 = complex(3, 4) // 3+4i</span><br><span class="line">fmt.Println(x*y)                 // "(-5+10i)"</span><br><span class="line">fmt.Println(real(x*y))           // "-5"</span><br><span class="line">fmt.Println(imag(x*y))           // "10"</span><br></pre></td></tr></tbody></table></figure>
<p>如果大家对复数的运算法则不是很了解，可以查阅<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin">《复数运算法则》</a>，其中详细的讲解了复数的加减乘除操作。</p>
<p>复数也可以用 <code>==</code> 和 <code>!=</code> 进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。</p>
<p><code>Go</code> 语言内置的 <code>math/cmplx</code> 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 <code>complex128</code> 类型，因为这些内置的包中都使用 <code>complex128</code> 类型作为参数。</p>
<h2 id="输出正弦函数-（Sin）-图像"><a href="#输出正弦函数-（Sin）-图像" class="headerlink" title="输出正弦函数 （Sin） 图像"></a>输出正弦函数 <code>（Sin）</code> 图像</h2><p>在 <code>Go</code> 语言中，正弦函数由 <code>math</code> 包提供，函数入口为 <code>math.Sin</code> ，正弦函数的参数为 <code>float64</code> ，返回值也是 <code>float64</code> 。在使用正弦函数时，根据实际精度可以进行转换。</p>
<p><code>Go</code> 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 <code>JPEG</code>、<code>PNG</code>、<code>GIF</code> 等。</p>
<p>首先给出本节完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/png"</span><br><span class="line">    "log"</span><br><span class="line">    "math"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 图片大小</span><br><span class="line">    const size = 300</span><br><span class="line"></span><br><span class="line">    // 根据给定大小创建灰度图</span><br><span class="line">    pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">    // 遍历每个像素</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        for y := 0; y &lt; size; y++ {</span><br><span class="line">            // 填充为白色</span><br><span class="line">            pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 从0到最大像素生成x坐标</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        // 让sin的值的范围在0~2Pi之间</span><br><span class="line">        s := float64(x) * 2 * math.Pi / size</span><br><span class="line">        // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">        y := size/2 - math.Sin(s)*size/2</span><br><span class="line">        // 用黑色绘制sin轨迹</span><br><span class="line">        pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">    }</span><br><span class="line">    // 创建文件</span><br><span class="line">    file, err := os.Create("sin.png")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    // 使用png格式将数据写入文件</span><br><span class="line">    png.Encode(file, pic) //将image信息写入文件中</span><br><span class="line">    // 关闭文件</span><br><span class="line">    file.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="设置图片背景色"><a href="#设置图片背景色" class="headerlink" title="设置图片背景色"></a>设置图片背景色</h3><p>以下是设置图片背景的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 图片大小</span><br><span class="line">const size = 300</span><br><span class="line"></span><br><span class="line">// 根据给定大小创建灰度图</span><br><span class="line">pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">// 遍历每个像素</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line">    for y := 0; y &lt; size; y++ {</span><br><span class="line">        // 填充为白色</span><br><span class="line">        pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，声明一个 <code>size</code> 常量，值为 <code>300</code>。</li>
<li>第 <code>5</code> 行，使用 <code>image</code> 包的 <code>NewGray()</code> 函数创建一个图片对象，使用区域由 <code>image.Rect</code> 结构提供，<code>image.Rect</code> 描述一个方形的两个定位点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> ，<code>image.Rect(0,0,size,size)</code> 表示使用完整灰度图像素，尺寸为宽 <code>300</code>，长 <code>300</code>。</li>
<li>第 <code>8</code> 行和第 <code>9</code> 行，遍历灰度图的所有像素。</li>
<li>第 <code>11</code> 行，将每一个像素的灰度设为 <code>255</code> ，也就是白色。</li>
</ul>
<p>灰度图是一种常见的图片格式，一般情况下颜色由 <code>8</code> 位组成，灰度范围为 <code>0～255</code> ，<code>0</code> 表示黑色，<code>255</code> 表示白色。</p>
<p>初始化好的灰度图默认的灰度值都是 <code>0</code> ，对的是黑色，由于显示效果的效果不是很好，所以这里将所有像素设置为 <code>255</code>，也就是白色。</p>
<h3 id="绘制正弦函数轨迹"><a href="#绘制正弦函数轨迹" class="headerlink" title="绘制正弦函数轨迹"></a>绘制正弦函数轨迹</h3><p>正弦函数是一个周期函数，定义域是实数集，取值范围是 <code>[-1, 1]</code>。用编程的通俗易懂的话来说就是：<code>math.Sin</code> 函数的参数支持任意浮点数范围，函数返回值的范围总是在 <code>-1～1</code> 之间（包含 <code>1</code>、<code>-1</code>）。</p>
<p>要将正弦函数放在图片上需要考虑以下一些因素：</p>
<ul>
<li><code>math.Sin</code> 的返回值在 <code>-1～1</code> 之间，需要考虑将正弦的输出幅度变大，可以将 <code>math.Sin</code> 的返回值乘以一个常量进行放大。</li>
<li>图片的坐标系原点在左上角，而 <code>math.Sin</code> 基于笛卡尔坐标系原点在左下角，需要对图像进行上下翻转和平移。</li>
</ul>
<p>将这些处理逻辑汇总为代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 从0到最大像素生成x坐标</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line"></span><br><span class="line">    // 让sin的值的范围在0~2Pi之间</span><br><span class="line">    s := float64(x) * 2 * math.Pi / size</span><br><span class="line"></span><br><span class="line">    // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">    y := size/2 - math.Sin(s)*size/2</span><br><span class="line"></span><br><span class="line">    // 用黑色绘制sin轨迹</span><br><span class="line">    pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，生成 <code>0</code> 到 <code>size（300）</code> 的 x 坐标轴。</li>
<li><p>第 <code>5</code> 行，计算 <code>math.Sin</code> 的定义域，这段代码等效为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rate := x / size</span><br><span class="line">s := rate * 2 * math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p><code>x</code> 的范围是 <code>0</code> 到 <code>size</code> ，因此除以 <code>size</code> 后，<code>rate</code> 的范围是 <code>0～1</code> 之间，再乘以 <code>2π</code> 后，<code>s</code> 的范围刚好是 <code>0～2π</code> 之间。</p>
<p><code>float64(x)</code> 表示将整型的 <code>x</code> 变量转换为 <code>float64</code> 类型，之后运算的所有表达式将以 <code>float64</code> 类型进行。</p>
</li>
<li><p>第 <code>8</code> 行中，<code>math.Sin(s)*size/2</code> 表示将正弦函数的返回值幅度从 <code>1</code> 扩大到二分之一的 <code>size</code> 。负号表示将正弦函数图形以图形中心上下翻转。叠加 <code>size/2</code> 表示将图形在 <code>y</code> 轴上向下偏移二分之一的 <code>size</code>（图片坐标系的 <code>y</code> 向下）。</p>
</li>
<li>第 <code>11</code> 行将计算好的 <code>x</code> 轴和 <code>y</code> 轴数据，以灰度为 <code>0</code>（黑色）使用 <code>SetGray()</code> 方法填充到像素中。</li>
</ul>
<p>写入图片的正弦函数图像如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sinImage.png" alt="正弦图片"></p>
<h3 id="写入图片文件"><a href="#写入图片文件" class="headerlink" title="写入图片文件"></a>写入图片文件</h3><p>内存中的正弦函数图形是不可见的，我们选用 <code>PNG</code> 格式将图形输出为文件，<code>Go</code> 语言提供了文件创建函数和 <code>PNG</code> 格式写入函数，代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">file, err := os.Create("sin.png")</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">// 使用PNG格式将数据写入文件</span><br><span class="line">png.Encode(file, pic)  //将image信息写入文件中</span><br><span class="line"></span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，创建 <code>sin.png</code> 的文件。</li>
<li>第 <code>4</code> 行，如果创建文件失败，返回错误，打印错误并终止。</li>
<li>第 <code>8</code> 行，使用 <code>PNG</code> 包，将图形对象写入文件中。</li>
<li>第 <code>11</code> 行，关闭文件。</li>
</ul>
<h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>一个布尔类型的值只有两种：<code>true</code> 或 <code>false</code>。<code>if</code> 和 <code>for</code> 语句的条件部分都是布尔类型的值，并且 <code>==</code> 和 <code>&lt;</code> 等比较操作也会产生布尔型的值。</p>
<p>一元操作符 <code>!</code> 对应逻辑非操作，因此 <code>!true</code> 的值为 <code>false</code>，更复杂一些的写法是 <code>(!true==false) == true</code>，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 <code>x</code> 来表示 <code>x==true</code> 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var aVar = 10</span><br><span class="line">aVar == 5  // false</span><br><span class="line">aVar == 10 // true</span><br><span class="line">aVar != 5  // true</span><br><span class="line">aVar != 10 // false</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口<code>（interface）</code>，那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。</p>
<p>布尔值可以和 <code>&amp;&amp;（AND）</code> 和 <code>||（OR）</code> 操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s != "" &amp;&amp; s[0] == 'x'</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>s[0]</code> 操作如果应用于空字符串将会导致 <code>panic</code> 异常。</p>
<p>因为 <code>&amp;&amp;</code> 的优先级比 <code>||</code> 高（ <code>&amp;&amp;</code> 对应逻辑乘法，<code>||</code> 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if 'a' &lt;= c &amp;&amp; c &lt;= 'z' ||</span><br><span class="line">    'A' &lt;= c &amp;&amp; c &lt;= 'Z' ||</span><br><span class="line">    '0' &lt;= c &amp;&amp; c &lt;= '9' {</span><br><span class="line">    // ...ASCII字母或数字...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>布尔值并不会隐式转换为数字值 <code>0</code> 或 <code>1</code>，反之亦然，必须使用 <code>if</code> 语句显式的进行转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">if b {</span><br><span class="line">    i = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 如果b为真，btoi返回1；如果为假，btoi返回0</span><br><span class="line">func btoi(b bool) int {</span><br><span class="line">    if b {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line">    return 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// itob报告是否为非零。</span><br><span class="line">func itob(i int) bool { return i != 0 }</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code> 语言中不允许将整型强制转换为布尔型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var n bool</span><br><span class="line">fmt.Println(int(n) * 2)</span><br></pre></td></tr></tbody></table></figure>
<p>编译错误，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot convert n (type bool) to type int</span><br></pre></td></tr></tbody></table></figure>
<p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 <code>UTF-8</code> 字符的一个序列（当字符为 <code>ASCII</code> 码表上的字符时则占用 <code>1</code> 个字节，其它字符根据需要占用 <code>2-4</code> 个字节）。</p>
<p><code>UTF-8</code> 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 <code>XML</code> 和 <code>JSON</code> 在内也都使用该编码。由于该编码对占用字节长度的不定性，在 <code>Go</code> 语言中字符串也可能根据需要占用 <code>1</code> 至 <code>4</code> 个字节，这与其它编程语言如 <code>C++</code> 、<code>Java</code> 或者 <code>Python</code> 不同（<code>Java</code> 始终使用 <code>2</code> 个字节）。<code>Go</code> 语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 <code>UTF-8</code> 字符集的文本进行编码和解码。</p>
<p>字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。</p>
<h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>可以使用双引号 <code>""</code> 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p>
<ul>
<li>\n：换行符</li>
<li>\r：回车符</li>
<li>\t：tab 键</li>
<li>\u 或 \U：Unicode 字符</li>
<li>\：反斜杠自身</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var str = "Hello\nGo World~!"</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Go World~!</span><br></pre></td></tr></tbody></table></figure>
<p>一般的比较运算符 <code>（==、!=、&lt;、&lt;=、&gt;=、&gt;）</code> 是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 <code>len()</code> 来获取，例如 <code>len(str)</code>。</p>
<p>字符串的内容（纯字节）可以通过标准索引法来获取，在方括号 <code>[ ]</code> 内写入索引，索引从 <code>0</code> 开始计数：</p>
<ul>
<li>字符串 <code>str</code> 的第 <code>1</code> 个字节：<code>str[0]</code></li>
<li>第 <code>i</code> 个字节：<code>str[i - 1]</code></li>
<li>最后 <code>1</code> 个字节：<code>str[len(str)-1]</code></li>
</ul>
<p>需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。</p>
<p><strong><em>注意：获取字符串中某个字节的地址属于非法行为，例如 <code>&amp;str[i]</code>。</em></strong></p>
<h3 id="字符串拼接符"><a href="#字符串拼接符" class="headerlink" title="字符串拼接符 +"></a>字符串拼接符 <code>+</code></h3><p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。将 <code>s2</code> 追加到 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p>
<p>可以通过下面的方式来对代码中多行的字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := "Beginning of the string " +</span><br><span class="line">"second part of the string"</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号 <code>+</code> 必须放在第一行末尾。</em></strong></p>
<p>也可以使用 <code>+=</code> 来对字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s := "hel" + "lo,"</span><br><span class="line">s += "world!"</span><br><span class="line">fmt.Println(s) //输出 “hello, world!”</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串实现基于-UTF-8-编码"><a href="#字符串实现基于-UTF-8-编码" class="headerlink" title="字符串实现基于 UTF-8 编码"></a>字符串实现基于 <code>UTF-8</code> 编码</h3><p><code>Go</code> 语言中字符串的内部实现使用 <code>UTF-8</code> 编码，通过 <code>rune</code> 类型，可以方便地对每个 <code>UTF-8</code> 字符进行访问。当然，<code>Go</code> 语言也支持按照传统的 <code>ASCII</code> 码方式逐字符进行访问。</p>
<p>关于字符串的 <code>UTF-8</code> 字符访问的详细方法，后面的章节将会详细介绍。</p>
<h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在 <code>Go</code> 语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量<code>（string literal）</code> ，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用 ` 反引号，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const str = `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br><span class="line">`</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br></pre></td></tr></tbody></table></figure>
<p>反引号`，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p>
<p>在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<p>多行字符串一般用于内嵌源码和内嵌数据等，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const codeTemplate = `// Generated by github.com/davyxu/cellnet/</span><br><span class="line">protoc-gen-msg</span><br><span class="line">// DO NOT EDIT!{{range .Protos}}</span><br><span class="line">// Source: {{.Name}}{{end}}</span><br><span class="line">package {{.PackageName}}</span><br><span class="line">{{if gt .TotalMessages 0}}</span><br><span class="line">import (</span><br><span class="line">    "github.com/davyxu/cellnet"</span><br><span class="line">    "reflect"</span><br><span class="line">    _ "github.com/davyxu/cellnet/codec/pb"</span><br><span class="line">)</span><br><span class="line">{{end}}</span><br><span class="line">func init() {</span><br><span class="line">    {{range .Protos}}</span><br><span class="line">    // {{.Name}}{{range .Messages}}</span><br><span class="line">    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}</span><br><span class="line">    {{end}}</span><br><span class="line">}</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码只定义了一个常量 codeTemplate，类型为字符串，使用`定义，字符串的内容为一段代码生成中使用到的 Go 源码格式。</p>
<p>在 ` 间的所有代码均不会被编译器识别，而只是作为字符串的一部分。</p>
<p>字符串类型在业务中的应用可以说是最广泛的，读者需要详细了解字符串的常见用法，请猛击下面的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/36.html">Go语言计算字符串长度——len()和RuneCountInString()</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/37.html">Go语言遍历字符串——获取每一个字符串元素</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/38.html">Go语言字符串截取（获取字符串的某一段字符）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/39.html">Go语言修改字符串</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/40.html">Go语言字符串拼接（连接）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/41.html">Go语言fmt.Sprintf（格式化输出）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/42.html">Go语言Base64编码——电子邮件的基础编码格式</a></li>
</ul>
<h2 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h2><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p>
<p>Go语言的字符有以下两种：</p>
<ul>
<li>一种是 <code>uint8</code> 类型，或者叫 <code>byte</code> 型，代表了 <code>ASCII</code> 码的一个字符。</li>
<li>另一种是 <code>rune</code> 类型，代表一个 <code>UTF-8</code> 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 <code>rune</code> 类型。<code>rune</code> 类型等价于 int32 类型。</li>
</ul>
<p><code>byte</code> 类型是 <code>uint8</code> 的别名，对于只占用 <code>1</code> 个字节的传统 <code>ASCII</code> 编码的字符来说，完全没有问题，例如 <code>var ch byte = 'A'</code>，字符使用单引号括起来。</p>
<p>在 <code>ASCII</code> 码表中，<code>A</code> 的值是 <code>65</code>，使用 <code>16</code> 进制表示则为 <code>41</code>，所以下面的写法是等效的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）</span><br></pre></td></tr></tbody></table></figure>
<p>另外一种可能的写法是 <code>\</code> 后面紧跟着长度为 <code>3</code> 的八进制数，例如 \377。</p>
<p><code>Go</code>语言同样支持 <code>Unicode（UTF-8）</code>，因此字符同样称为 <code>Unicode</code> 代码点或者 <code>runes</code> ，并在内存中使用 <code>int</code> 来表示。在文档中，一般使用格式 <code>U+hhhh</code> 来表示，其中 <code>h</code> 表示一个 <code>16</code> 进制数。</p>
<p>在书写 <code>Unicode</code> 字符时，需要在 <code>16</code> 进制数之前加上前缀 <code>\u</code> 或者 <code>\U</code> 。因为 <code>Unicode</code> 至少占用 <code>2</code> 个字节，所以我们使用 <code>int16</code> 或者 <code>int</code> 类型来表示。如果需要使用到 <code>4</code> 字节，则使用 <code>\u</code> 前缀，如果需要使用到 <code>8</code> 个字节，则使用 <code>\U</code> 前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch int = '\u0041'</span><br><span class="line">var ch2 int = '\u03B2'</span><br><span class="line">var ch3 int = '\U00101234'</span><br><span class="line">fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer</span><br><span class="line">fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character</span><br><span class="line">fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes</span><br><span class="line">fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">65 - 946 - 1053236</span><br><span class="line">A - β - r</span><br><span class="line">41 - 3B2 - 101234</span><br><span class="line">U+0041 - U+03B2 - U+101234</span><br></pre></td></tr></tbody></table></figure>
<p>格式化说明符 <code>%c</code> 用于表示字符，当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数，<code>%U</code> 输出格式为 <code>U+hhhh</code> 的字符串。</p>
<p><code>Unicode</code> 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 <code>ch</code> 代表字符）：</p>
<ul>
<li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li>
<li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li>
<li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li>
</ul>
<h3 id="UTF-8-和-Unicode-有何区别"><a href="#UTF-8-和-Unicode-有何区别" class="headerlink" title="UTF-8 和 Unicode 有何区别"></a>UTF-8 和 Unicode 有何区别</h3><p><code>Unicode</code> 与 <code>ASCII</code> 类似，都是一种字符集。</p>
<p>字符集为每个字符分配一个唯一的 <code>ID</code>，我们使用到的所有字符在 <code>Unicode</code> 字符集中都有一个唯一的 <code>ID</code>，例如上面例子中的 <code>a</code> 在 <code>Unicode</code> 与 <code>ASCII</code> 中的编码都是 <code>97</code>。汉字 <code>你</code> 在 <code>Unicode</code> 中的编码为 <code>20320</code>，在不同国家的字符集中，字符所对应的 <code>ID</code> 也会不同。而无论任何情况下，<code>Unicode</code> 中的字符的 <code>ID</code> 都是不会变化的。</p>
<p><code>UTF-8</code> 是编码规则，将 <code>Unicode</code> 中字符的 <code>ID</code> 以某种方式进行编码，<code>UTF-8</code> 的是一种变长编码规则，从 <code>1</code> 到 <code>4</code> 个字节不等。编码规则如下：</p>
<ul>
<li><code>0xxxxxx</code> 表示文字符号 <code>0～127</code>，兼容 <code>ASCII</code> 字符集。</li>
<li>从 <code>128</code> 到 <code>0x10ffff</code> 表示其他字符。</li>
</ul>
<p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 <code>3</code> 个字节。</p>
<p>广义的 <code>Unicode</code> 指的是一个标准，它定义了字符集及编码规则，即 <code>Unicode</code> 字符集和 <code>UTF-8</code>、<code>UTF-16</code> 编码等。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 <code>Go</code> 语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></tbody></table></figure>
<p>类型 <code>B</code> 的值 = 类型 <code>B</code> (类型 <code>A</code> 的值)</p>
<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></tbody></table></figure>
<p>类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 <code>int16</code> 转换为 <code>int32</code>）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 <code>int32</code> 转换为 <code>int16</code> 或将 <code>float32</code> 转换为 <code>int</code> ），会发生精度丢失（截断）的情况。</p>
<p>只有相同底层类型的变量之间可以进行相互转换（如将 <code>int16</code> 类型转换成 <code>int32</code> 类型），不同底层类型的变量相互转换时会引发编译错误（如将 <code>boo</code>l 类型转换为 <code>int</code> 类型）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        "fmt"</span><br><span class="line">        "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">        // 输出各数值范围</span><br><span class="line">        fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)</span><br><span class="line">        fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)</span><br><span class="line">        fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)</span><br><span class="line">        fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)</span><br><span class="line"></span><br><span class="line">        // 初始化一个32位整型值</span><br><span class="line">        var a int32 = 1047483647</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int32: 0x%x %d\n", a, a)</span><br><span class="line"></span><br><span class="line">        // 将a变量数值转换为十六进制, 发生数值截断</span><br><span class="line">        b := int16(a)</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int16: 0x%x %d\n", b, b)</span><br><span class="line"></span><br><span class="line">        // 将常量保存为float32类型</span><br><span class="line">        var c float32 = math.Pi</span><br><span class="line">        // 转换为int类型, 浮点发生精度丢失</span><br><span class="line">        fmt.Println(int(c))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>11～14 行</code>，输出几个常见整型类型的数值范围。</li>
<li>第 <code>17</code> 行，声明 <code>int32</code> 类型的变量 <code>a</code> 并初始化。</li>
<li>第 <code>19</code> 行，使用 <code>fmt.Printf</code> 的 <code>%x</code> 动词将数值以十六进制格式输出，这一行输出 <code>a</code> 在转换前的 <code>32</code> 位的值。</li>
<li>第 <code>22</code> 行，将 <code>a</code> 的值转换为 <code>int16</code> 类型，也就是从 <code>32</code> 位有符号整型转换为 <code>16</code> 位有符号整型，由于 <code>int16</code> 类型的取值范围比 <code>int32</code> 类型的取值范围小，因此数值会进行截断（精度丢失）。</li>
<li>第 <code>24</code> 行，输出转换后的 <code>a</code> 变量值，也就是 <code>b</code> 的值，同样以十六进制和十进制两种方式进行打印。</li>
<li>第 <code>27</code> 行，<code>math.Pi</code> 是 <code>math</code> 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 <code>math.Pi</code> 被赋值到变量 <code>c</code> 中，因此类型为 <code>float32</code>。</li>
<li>第 <code>29</code> 行，将 <code>float32</code> 转换为 <code>int</code> 类型并输出。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int8 range: -128 127</span><br><span class="line">int16 range: -32768 32767</span><br><span class="line">int32 range: -2147483648 2147483647</span><br><span class="line">int64 range: -9223372036854775808 9223372036854775807</span><br><span class="line">int32: 0x3e6f54ff 1047483647</span><br><span class="line">int16: 0x54ff 21759</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>根据输出结果，<code>16</code> 位有符号整型的范围是 <code>-32768～32767</code>，而变量 <code>a</code> 的值 <code>1047483647</code> 不在这个范围内。<code>1047483647</code> 对应的十六进制为 <code>0x3e6f54ff</code>，转为 <code>int16</code> 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 <code>0x54ff</code>，对应的十进制值为 <code>21759</code>。</p>
<p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 <code>Java</code> 和 <code>.NET</code> 等编程语言不同，<code>Go</code> 语言为程序员提供了控制数据结构指针的能力，<strong>但是，并不能进行指针运算</strong>。<code>Go</code> 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p>
<p>指针 <code>（pointer）</code> 在 <code>Go</code> 语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。</li>
</ul>
<p>受益于这样的约束和拆分，<code>Go</code> 语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p>
<p>切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p>
<p><code>C/C++</code> 中的指针</p>
<p>说到 <code>C/C++</code> 中的指针，会让许多人“谈虎色变”，尤其是对指针的偏移、运算和转换。</p>
<p>其实，指针是 <code>C/C++</code> 语言拥有极高性能的根本所在，在操作大块数据和做偏移时即方便又便捷。因此，操作系统依然使用 <code>C</code> 语言及指针的特性进行编写。</p>
<p><code>C/C++</code> 中指针饱受诟病的根本原因是指针的运算和内存释放，<code>C/C++</code> 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域，我们的计算机操作系统经常需要更新、修复漏洞的本质，就是为解决指针越界访问所导致的“缓冲区溢出”的问题。</p>
<p>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开详细说明。</p>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 <code>32</code> 和 <code>64</code> 位机器上分别占用 <code>4</code> 或 <code>8</code> 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 <code>nil</code>。指针变量通常缩写为 <code>ptr</code> 。</p>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<code>Go</code> 语言中使用在变量名前面添加 <code>&amp;</code> 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr := &amp;v    // v 的类型为 T</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>v</code> 代表被取地址的变量，变量 <code>v</code> 的地址使用变量 <code>ptr</code> 进行接收，<code>ptr</code> 的类型为 <code>*T</code> ，称做 <code>T</code> 的指针类型，<code>*</code> 代表指针。</p>
<p>指针实际用法，可以通过下面的例子了解：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var cat int = 1</span><br><span class="line">    var str string = "banana"</span><br><span class="line">    fmt.Printf("%p %p", &amp;cat, &amp;str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，声明整型变量 <code>cat</code> 。</li>
<li>第 <code>9</code> 行，声明字符串变量 <code>str</code> 。</li>
<li>第 <code>10</code> 行，使用 <code>fmt.Printf</code> 的动词 <code>%p</code> 打印 <code>cat</code> 和 <code>str</code> 变量的内存地址，指针的值是带有 <code>0x</code> 十六进制前缀的一组数据。</li>
</ul>
<p><strong><em>提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</em></strong></p>
<h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>当使用 <code>&amp;</code> 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 <code>*</code> 操作符，也就是指针取值，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个字符串类型</span><br><span class="line">    var house = "Malibu Point 10880, 90265"</span><br><span class="line"></span><br><span class="line">    // 对字符串取地址, ptr类型为*string</span><br><span class="line">    ptr := &amp;house</span><br><span class="line"></span><br><span class="line">    // 打印ptr的类型</span><br><span class="line">    fmt.Printf("ptr type: %T\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf("address: %p\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line"></span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf("value type: %T\n", value)</span><br><span class="line"></span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf("value: %s\n", value)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，准备一个字符串并赋值。</li>
<li>第 <code>13</code> 行，对字符串取地址，将指针保存到变量 <code>ptr</code> 中。</li>
<li>第 <code>16</code> 行，打印变量 <code>ptr</code> 的类型，其类型为 <code>*string</code>。</li>
<li>第 <code>19</code> 行，打印 <code>ptr</code> 的指针地址，地址每次运行都会发生变化。</li>
<li>第 <code>22</code> 行，对 <code>ptr</code> 指针变量进行取值操作，变量 <code>value</code> 的类型为 <code>string</code> 。</li>
<li>第 <code>25</code> 行，打印取值后 <code>value</code> 的类型。</li>
<li>第 <code>28</code> 行，打印 <code>value</code> 的值。</li>
</ul>
<p>取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp;</code> 取出地址，<code>*</code> 根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址操作使用 <code>&amp;</code> 操作符，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值操作使用 <code>*</code> 操作符，可以获得指针变量指向的原变量的值。</li>
</ul>
<h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p>
<p>前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 交换函数</span><br><span class="line">func swap(a, b *int) {</span><br><span class="line"></span><br><span class="line">    // 取a指针的值, 赋给临时变量t</span><br><span class="line">    t := *a</span><br><span class="line"></span><br><span class="line">    // 取b指针的值, 赋给a指针指向的变量</span><br><span class="line">    *a = *b</span><br><span class="line"></span><br><span class="line">    // 将a指针的值赋给b指针指向的变量</span><br><span class="line">    *b = t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备两个变量, 赋值1和2</span><br><span class="line">    x, y := 1, 2</span><br><span class="line"></span><br><span class="line">    // 交换变量值</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line"></span><br><span class="line">    // 输出变量值</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，定义一个交换函数，参数为 <code>a</code> 、<code>b</code>，类型都为 <code>*int</code> 指针类型。</li>
<li>第 <code>9</code> 行，取指针 <code>a</code> 的值，并把值赋给变量 <code>t</code> ，<code>t</code> 此时是 <code>int</code> 类型。</li>
<li>第 <code>12</code> 行，取 <code>b</code> 的指针值，赋给指针 <code>a</code> 指向的变量。注意，此时 <code>*a</code> 的意思不是取 <code>a</code> 指针的值，而是<code>a 指向的变量</code> 。</li>
<li>第 <code>15</code> 行，将 <code>t</code> 的值赋给指针 <code>b</code> 指向的变量。</li>
<li>第 <code>21</code> 行，准备 <code>x</code> 、<code>y</code> 两个变量，分别赋值为 <code>1</code> 和 <code>2</code> ，类型为 <code>int</code> 。</li>
<li>第 <code>24</code> 行，取出 <code>x</code> 和 <code>y</code> 的地址作为参数传给 <code>swap()</code> 函数进行调用。</li>
<li>第 <code>27</code> 行，交换完毕时，输出 <code>x</code> 和 <code>y</code> 的值。</li>
</ul>
<p><code>*</code> 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 <code>a</code> 指针指向的变量。其实归纳起来，<code>*</code> 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p>
<p>如果在 <code>swap()</code> 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) {</span><br><span class="line">    b, a = a, b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    x, y := 1, 2</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>结果表明，交换是不成功的。上面代码中的 <code>swap()</code> 函数交换的是 <code>a</code> 和 <code>b</code> 的地址，在交换完毕后，<code>a</code> 和 <code>b</code> 的变量值确实被交换。但和 <code>a</code> 、<code>b</code> 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>
<h3 id="示例：使用指针变量获取命令行的输入信息"><a href="#示例：使用指针变量获取命令行的输入信息" class="headerlink" title="示例：使用指针变量获取命令行的输入信息"></a>示例：使用指针变量获取命令行的输入信息</h3><p><code>Go</code> 语言内置的 <code>flag</code> 包实现了对命令行参数的解析，<code>flag</code> 包使得开发命令行工具更为简单。</p>
<p>下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 <code>flag</code> 包的解析后即可获取命令行的数据。</p>
<p>【示例】获取命令行输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 导入系统包</span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义命令行参数</span><br><span class="line">var mode = flag.String("mode", "", "process mode")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 解析命令行参数</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // 输出命令行参数</span><br><span class="line">    fmt.Println(*mode)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将这段代码命名为 main.go，然后使用如下命令行运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go --mode=fast</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fast</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，通过 <code>flag.String</code>，定义一个 <code>mode</code> 变量，这个变量的类型是 <code>*string</code>。后面 <code>3</code> 个参数分别如下：<ul>
<li>参数名称：在命令行输入参数时，使用这个名称。</li>
<li>参数值的默认值：与 <code>flag</code> 所使用的函数创建变量类型对应，<code>String</code> 对应字符串、<code>Int</code> 对应整型、<code>Bool</code> 对应布尔型等。</li>
<li>参数说明：使用 <code>-help</code> 时，会出现在说明中。</li>
</ul>
</li>
<li>第 <code>15</code> 行，解析命令行参数，并将结果写入到变量 <code>mode</code> 中。</li>
<li>第 <code>18</code> 行，打印 <code>mode</code> 指针所指向的变量。</li>
</ul>
<p>由于之前已经使用 <code>flag.String</code> 注册了一个名为 <code>mode</code> 的命令行参数，<code>flag</code> 底层知道怎么解析命令行，并且将值赋给 <code>mode*string</code> 指针，在 <code>Parse</code> 调用完毕后，无须从 <code>flag</code> 获取值，而是通过自己注册的这个 <code>mode</code> 指针获取到最终的值。代码运行流程如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/pstr.jpg" alt="图：命令行参数与变量的关系"></p>
<h3 id="创建指针的另一种方法——-new-函数"><a href="#创建指针的另一种方法——-new-函数" class="headerlink" title="创建指针的另一种方法—— new() 函数"></a>创建指针的另一种方法—— <code>new()</code> 函数</h3><p><code>Go</code> 语言还提供了另外一种方法来创建指针变量，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">new(类型)</span><br></pre></td></tr></tbody></table></figure>
<p>一般这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := new(string)</span><br><span class="line">*str = "Go语言教程"</span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></tbody></table></figure>
<p><code>new()</code> 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
<h2 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h2><p>了解下计算机组成里两个非常重要的概念：堆和栈。</p>
<h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>栈只允许从线性表的同一端放入和取出数据，按照后进先出<code>（LIFO，Last InFirst Out）</code>的顺序，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/stackImage.jpg" alt="图：栈的操作及扩展"></p>
<p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p>
<p>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的元素数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除了栈顶部的成员）进行任何查看和修改操作。</p>
<p>栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。</p>
<h4 id="变量和栈有什么关系"><a href="#变量和栈有什么关系" class="headerlink" title="变量和栈有什么关系"></a>变量和栈有什么关系</h4><p>栈可用于内存分配，栈的分配和回收速度非常快。下面的代码展示了栈在内存分配上的作用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func calc(a, b int) int {</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，传入 <code>a</code> 、<code>b</code> 两个整型参数。</li>
<li>第 <code>2</code> 行，声明整型变量 <code>c</code>，运行时，<code>c</code> 会分配一段内存用以存储 <code>c</code> 的数值。</li>
<li>第 <code>3</code> 行，将 <code>a</code> 和 <code>b</code> 相乘后赋值给 <code>c</code>。</li>
<li>第 <code>5</code> 行，声明整型变量 <code>x</code> ，<code>x</code> 也会被分配一段内存。</li>
<li>第 <code>6</code> 行，让 <code>c</code> 乘以 <code>10</code> 后赋值给变量 <code>x</code> 。</li>
<li>第 <code>8</code> 行，返回 <code>x</code> 的值。</li>
</ul>
<p>上面的代码在没有任何优化的情况下，会进行变量 <code>c</code> 和 <code>x</code> 的分配过程。<code>Go</code> 语言默认情况下会将 <code>c</code> 和 <code>x</code> 分配在栈上，这两个变量在 <code>calc()</code> 函数退出时就不再使用，函数结束时，保存 <code>c</code> 和 <code>x</code> 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p>
<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/heapImage.jpg" alt="图：堆的分配及空间"></p>
<p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<h3 id="变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率"><a href="#变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸 （Escape Analysis） —— 自动决定变量分配方式，提高运行效率"></a>变量逃逸 <code>（Escape Analysis）</code> —— 自动决定变量分配方式，提高运行效率</h3><p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 <code>C/C++</code> 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p>
<p><code>Go</code> 语言将这个过程整合到了编译器中，命名为 <code>变量逃逸分析</code> 。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>通过下面的代码来展现 <code>Go</code> 语言如何使用命令行来分析变量逃逸，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 本函数测试入口参数和返回值情况</span><br><span class="line">func dummy(b int) int {</span><br><span class="line">  // 声明一个变量c并赋值</span><br><span class="line">  var c int</span><br><span class="line">  c = b</span><br><span class="line"></span><br><span class="line">  return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 空函数, 什么也不做</span><br><span class="line">func void() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">  // 声明a变量并打印</span><br><span class="line">  var a int</span><br><span class="line"></span><br><span class="line">  // 调用void()函数</span><br><span class="line">  void()</span><br><span class="line"></span><br><span class="line">  // 打印a变量的值和dummy()函数返回</span><br><span class="line">  fmt.Println(a, dummy(0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，<code>dummy()</code> 函数拥有一个参数，返回一个整型值，用来测试函数参数和返回值分析情况。</li>
<li>第 <code>8</code> 行，声明变量 <code>c</code> ，用于演示函数临时变量通过函数返回值返回后的情况。</li>
<li>第 <code>15</code> 行，这是一个空函数，测试没有任何参数函数的分析情况。</li>
<li>第 <code>21</code> 行，在 <code>main()</code> 中声明变量 <code>a</code> ，测试 <code>main()</code> 中变量的分析情况。</li>
<li>第 <code>24</code> 行，调用 <code>void()</code> 函数，没有返回值，测试 <code>void()</code> 调用后的分析情况。</li>
<li>第 <code>27</code> 行，打印 <code>a</code> 和 <code>dummy(0)</code> 的返回值，测试函数返回值没有变量接收时的分析情况。</li>
</ul>
<p>接着使用如下命令行运行上面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run -gcflags "-m -l" goEscapeAnalysis.go</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 运行程序时，<code>-gcflags</code> 参数是编译参数。其中 <code>-m</code> 表示进行内存分配分析，<code>-l</code> 表示避免程序内联，也就是避免进行程序优化。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goEscapeAnalysis.go:27:13: ... argument does not escape</span><br><span class="line">.\goEscapeAnalysis.go:27:13: a escapes to heap</span><br><span class="line">.\goEscapeAnalysis.go:27:22: dummy(0) escapes to heap</span><br><span class="line">0 0</span><br></pre></td></tr></tbody></table></figure>
<p>程序运行结果分析如下：</p>
<ul>
<li>第 <code>2</code> 行，这句提示是默认的，可以忽略。</li>
<li>第 <code>3</code> 行告知“代码的第 <code>27</code> 行的变量 <code>a</code> 逃逸到堆”。</li>
<li>第 <code>4</code> 行告知“dummy(0) 调用逃逸到堆”。由于 <code>dummy()</code> 函数会返回一个整型值，这个值被 <code>fmt.Println</code> 使用后还是会在 <code>main()</code> 函数中继续存在。</li>
</ul>
<p>上面例子中变量 <code>c</code> 是整型，其值通过 <code>dummy()</code> 的返回值“逃出”了 <code>dummy()</code> 函数。变量 <code>c</code> 的值被复制并作为 <code>dummy()</code> 函数的返回值返回，即使变量 <code>c</code> 在 <code>dummy()</code> 函数中分配的内存被释放，也不会影响 <code>main()</code> 中使用 <code>dummy()</code> 返回的值。变量 <code>c</code> 使用栈分配不会影响结果。</p>
<h4 id="取地址发生逃逸"><a href="#取地址发生逃逸" class="headerlink" title="取地址发生逃逸"></a>取地址发生逃逸</h4><p>下面的例子使用结构体做数据，来了解结构体在堆上的分配情况，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明空结构体测试结构体逃逸情况</span><br><span class="line">type Data struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func dummy() *Data {</span><br><span class="line">    // 实例化c为Data类型</span><br><span class="line">    var c Data</span><br><span class="line"></span><br><span class="line">    //返回函数局部变量地址</span><br><span class="line">    return &amp;c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(dummy())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，声明一个空的结构体做结构体逃逸分析。</li>
<li>第 <code>9</code> 行，将 <code>dummy()</code> 函数的返回值修改为 <code>*Data</code> 指针类型。</li>
<li>第 <code>11</code> 行，将变量 <code>c</code> 声明为 <code>Data</code> 类型，此时 <code>c</code> 的结构体为值类型。</li>
<li>第 <code>14</code> 行，取函数局部变量 <code>c</code> 的地址并返回。</li>
<li>第 <code>18</code> 行，打印 <code>dummy()</code> 函数的返回值。</li>
</ul>
<p>执行逃逸分析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goPstrAnalysis.go:11:6: moved to heap: c</span><br><span class="line">.\goPstrAnalysis.go:18:13: ... argument does not escape</span><br><span class="line">&amp;{}</span><br></pre></td></tr></tbody></table></figure>
<p>注意第 <code>2</code> 行出现了新的提示：将 <code>c</code> 移到堆中。这句话表示，<code>Go</code> 编译器已经确认如果将变量 <code>c</code> 分配在栈上是无法保证程序最终结果的，如果这样做，<code>dummy()</code> 函数的返回值将是一个不可预知的内存地址，这种情况一般是 <code>C/C++</code> 语言中容易犯错的地方，引用了一个函数局部变量的地址。</p>
<p><code>Go</code> 语言最终选择将 <code>c</code> 的 <code>Data</code> 结构分配在堆上。然后由垃圾回收器去回收 <code>c</code> 的内存。</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>在使用 <code>Go</code> 语言进行编程时，<code>Go</code> 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于<code>Go</code>语言，在 <code>Java</code> 等语言的编译器优化上也使用了类似的技术。</p>
<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
<li>变量是否被取地址；</li>
<li>变量是否发生逃逸。</li>
</ul>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔</p>
<p>变量的生命周期与变量的作用域有着不可分割的联系：</p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+int(x*size+0.5), size+int(y*size+0.5),</span><br><span class="line">        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br><span class="line">    )               // 小括号另起一行缩进，和大括号的风格保存一致</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，在每次循环的开始会创建临时变量 <code>t</code> ，然后在每次循环迭代中创建临时变量 <code>x</code> 和 <code>y</code>。临时变量 <code>x</code>、<code>y</code> 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p>
<p>栈的和堆的区别在于：</p>
<ul>
<li>堆<code>（heap）</code>：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 <code>malloc</code> 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 <code>free</code> 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；</li>
<li>栈<code>(stack)</code>：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号{ }中定义的局部变量。</li>
</ul>
<p>在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 <code>var</code> 还是 <code>new</code> 关键字声明变量都不会影响编译器的选择。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() {</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func g() {</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，函数 <code>f</code> 里的变量 <code>x</code> 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的。用 <code>Go</code> 语言的术语说，这个局部变量 <code>x</code> 从函数 <code>f</code> 中逃逸了。</p>
<p>相反，当函数 <code>g</code> 返回时，变量 <code>*y</code> 不再被使用，也就是说可以马上被回收的。因此，<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，编译器可以选择在栈上分配 <code>*y</code> 的存储空间，也可以选择在堆上分配，然后由 <code>Go</code> 语言的 <code>GC（垃圾回收机制）</code> 回收这个变量的内存空间。</p>
<p>在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>虽然 <code>Go</code> 语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们仍然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 <code>GC</code> 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>Go</code> 语言中的常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。</p>
<p>常量的定义格式和变量的声明语法类似：<code>const name [type] = value</code> ，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const pi = 3.14159 // 相当于 math.Pi 的近似值</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>Go</code> 语言中，你可以省略类型说明符 <code>[type]</code> ，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = "abc"</code></li>
<li>隐式类型定义： <code>const b = "abc"</code></li>
</ul>
<p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p>
<ul>
<li>正确的做法：<code>const c1 = 2/3</code></li>
<li>错误的做法：<code>const c2 = getNumber()</code> // 引发构建错误: getNumber() 用做值</li>
</ul>
<p>和变量声明一样，可以批量声明多个常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    e  = 2.7182818</span><br><span class="line">    pi = 3.1415926</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和 <code>unsafe.Sizeof</code>。</p>
<p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const IPv4Len = 4</span><br><span class="line"></span><br><span class="line">// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).</span><br><span class="line">func parseIPv4(s string) IP {</span><br><span class="line">    var p [IPv4Len]byte</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code> 是一个命名类型，底层类型是 <code>int64</code>，<code>time.Minute</code> 是对应类型的常量。下面声明的两个常量都是 <code>time.Duration</code> 类型，可以通过 <code>%T</code> 参数打印类型信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const noDelay time.Duration = 0</span><br><span class="line">const timeout = 5 * time.Minute</span><br><span class="line">fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"</span><br><span class="line">fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"</span><br><span class="line">fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"</span><br></pre></td></tr></tbody></table></figure>
<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 1</span><br><span class="line">    b</span><br><span class="line">    c = 2</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) // "1 1 2 2"</span><br></pre></td></tr></tbody></table></figure>
<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 <code>iota</code> 常量生成器语法。</p>
<h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code> ，然后在每一个有常量声明的行加一。</p>
<p>【示例 1】首先定义一个 <code>Weekday</code> 命名类型，然后为一周的每天定义了一个常量，从周日 <code>0</code> 开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>周日将对应 0，周一为 1，以此类推。</p>
<h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p><code>Go</code> 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 <code>int</code> 或 <code>float64</code>，或者是类似 <code>time.Duration</code> 这样的基础类型，但是许多常量并没有一个明确的基础类型。</p>
<p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 <code>256bit</code> 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x float32 = math.Pi</span><br><span class="line">var y float64 = math.Pi</span><br><span class="line">var z complex128 = math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p>如果 <code>math.Pi</code> 被确定为特定类型，比如 <code>float64</code> ，那么结果精度可能会不一样，同时对于需要 <code>float32</code> 或 <code>complex128</code> 类型值的地方则需要一个明确的强制类型转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const Pi64 float64 = math.Pi</span><br><span class="line">var x float32 = float32(Pi64)</span><br><span class="line">var y float64 = Pi64</span><br><span class="line">var z complex128 = complex128(Pi64)</span><br></pre></td></tr></tbody></table></figure>
<p>对于常量面值，不同的写法可能会对应不同的类型。例如 <code>0</code> 、<code>0.0</code> 、<code>0i</code> 和 <code>\u0000</code> 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code> 和 <code>false</code> 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<h2 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举</h2><p><code>Go</code> 语言现阶段没有枚举类型，但是可以使用 <code>const</code> 常量配合上一节 <code>Go语言常量</code> 中介绍的 <code>iota</code> 来模拟枚举类型，请看下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行中，将 <code>int</code> 定义为 <code>Weapon</code> 类型，就像枚举类型的本质是一个 <code>int</code> 类型一样。当然，某些情况下，如果需要 <code>int32</code> 和 <code>int64</code> 的枚举，也是可以的。</li>
<li>第 <code>4</code> 行中，将常量 <code>Arrow</code> 的类型标识为 <code>Weapon</code>，这样标识后，<code>const</code> 下方的常量可以使用 <code>Weapon</code> 作为默认类型。该行使用 <code>iota</code> 进行常量值自动生成，<code>iota</code> 的起始值为 <code>0</code>，一般情况下也是建议枚举从 <code>0</code> 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。</li>
</ul>
<p>一个 <code>const</code> 声明内的每一行常量声明，将会自动套用前面的 <code>iota</code> 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p>
<p>当然，<code>iota</code> 不仅可以生成每次增加 <code>1</code> 的枚举值。还可以利用 <code>iota</code> 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    FlagNone = 1 &lt;&lt; iota</span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf("%d %d %d\n", FlagRed, FlagGreen, FlagBlue)</span><br><span class="line">fmt.Printf("%b %b %b\n", FlagRed, FlagGreen, FlagBlue)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 4 8</span><br><span class="line">10 100 1000</span><br></pre></td></tr></tbody></table></figure>
<p>在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 <code>ioto</code> 自动生成更加方便。</p>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行中 <code>iota</code> 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。</li>
<li>第 <code>8</code> 行，将 <code>3</code> 个枚举按照常量输出，分别输出 <code>2</code>、<code>4</code>、<code>8</code>，都是将 <code>1</code> 每次左移一位的结果。</li>
<li>第 <code>9</code> 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。</li>
</ul>
<h3 id="将枚举值转换为字符串"><a href="#将枚举值转换为字符串" class="headerlink" title="将枚举值转换为字符串"></a>将枚举值转换为字符串</h3><p>枚举在 <code>C#</code> , <code>java</code> 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，<code>C#</code> 中 <code>Week</code> 枚举值 <code>Monday</code> 为 <code>1</code> ，那么可以通过 <code>Week.Monday.ToString()</code> 函数获得 <code>Monday</code> 字符串。</p>
<p><code>Go</code> 语言中也可以实现这一功能，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明芯片类型</span><br><span class="line">type ChipType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None ChipType = iota</span><br><span class="line">    CPU    // 中央处理器</span><br><span class="line">    GPU    // 图形处理器</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func (c ChipType) String() string {</span><br><span class="line">    switch c {</span><br><span class="line">    case None:</span><br><span class="line">        return "None"</span><br><span class="line">    case CPU:</span><br><span class="line">        return "CPU"</span><br><span class="line">    case GPU:</span><br><span class="line">        return "GPU"</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return "N/A"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 输出CPU的值并以整型格式显示</span><br><span class="line">    fmt.Printf("%s %d", CPU, CPU)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CPU 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，将 <code>int</code> 声明为 <code>ChipType</code> 芯片类型。</li>
<li>第 <code>9</code> 行，将 <code>const</code> 里定义的常量值设为 <code>ChipType</code> 类型，且从 <code>0</code> 开始，每行值加 <code>1</code>。</li>
<li>第 <code>14</code> 行，定义 <code>ChipType</code> 类型的方法 <code>String()</code>，返回值为字符串类型。</li>
<li>第 <code>15～22</code> 行，使用 <code>switch</code> 语句判断当前的 <code>ChitType</code> 类型的值，返回对应的字符串。</li>
<li>第 <code>30</code> 行，按整型的格式输出 <code>CPU</code> 的值。</li>
</ul>
<p><code>String()</code> 方法的 <code>ChipType</code> 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，<code>Go</code> 语言会自动寻找 <code>String()</code> 方法并进行调用。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>Go</code> 语言新版本的功能，内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对Go语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。</p>
<p>类型别名是 <code>Go 1.9</code> 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 <code>C/C++</code> 语言中，代码重构升级可以使用宏快速定义一段新的代码，<code>Go</code> 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。</p>
<p>在 <code>Go 1.9</code> 版本之前定义内建类型的代码是这样写的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte uint8</span><br><span class="line">type rune int32</span><br></pre></td></tr></tbody></table></figure>
<p>而在 Go 1.9 版本之后变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></tbody></table></figure>
<p>这个修改就是配合类型别名而进行的修改。</p>
<h3 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h3><p>定义类型别名的写法为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></tbody></table></figure>
<p>类型别名规定：<code>TypeAlias</code> 只是 <code>Type</code> 的别名，本质上 <code>TypeAlias</code> 与 <code>Type</code> 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<p>类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 查看a的类型名</span><br><span class="line">    fmt.Printf("a type: %T\n", a)</span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 查看a2的类型名</span><br><span class="line">    fmt.Printf("a2 type: %T\n", a2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a type: main.NewInt</span><br><span class="line">a2 type: int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，将 <code>NewInt</code> 定义为 <code>int</code> 类型，这是常见的定义类型的方法，通过 <code>type</code> 关键字的定义，<code>NewInt</code> 会形成一种新的类型，<code>NewInt</code> 本身依然具备 <code>int</code> 类型的特性。</li>
<li>第 <code>11</code> 行，将 <code>IntAlias</code> 设置为 <code>int</code> 的一个别名，使用 <code>IntAlias</code> 与 <code>int</code> 等效。</li>
<li>第 <code>16</code> 行，将 <code>a</code> 声明为 <code>NewInt</code> 类型，此时若打印，则 <code>a</code> 的值为 <code>0</code> 。</li>
<li>第 <code>18</code> 行，使用 <code>%T</code> 格式化参数，打印变量 <code>a</code> 本身的类型。</li>
<li>第 <code>21</code> 行，将 <code>a2</code> 声明为 <code>IntAlias</code> 类型，此时打印 <code>a2</code> 的值为 <code>0</code> 。</li>
<li>第 <code>23</code> 行，打印 <code>a2</code> 变量的类型。</li>
</ul>
<p>结果显示 <code>a</code> 的类型是 <code>main.NewInt</code> ，表示 <code>main</code> 包下定义的 <code>NewInt</code> 类型，<code>a2</code> 类型是 <code>int</code> ，<code>IntAlias</code> 类型只会在代码中存在，编译完成时，不会有 <code>IntAlias</code> 类型。</p>
<h3 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h3><p>能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法呢？参见下面的代码演示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，为 <code>time.Duration</code> 设定一个类型别名叫 <code>MyDuration</code> 。</li>
<li>第 <code>11</code> 行，为这个别名添加一个方法。</li>
</ul>
<p>编译上面代码报错，信息如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot define new methods on non-local type time.Duration</span><br></pre></td></tr></tbody></table></figure>
<p>编译器提示：不能在一个非本地的类型 <code>time.Duration</code> 上定义新方法，非本地类型指的就是 <code>time.Duration</code> 不是在 <code>main</code> 包中定义的，而是在 <code>time</code> 包中定义的，与 <code>main</code> 包不在同一个包中，因此不能为不在一个包中的类型定义方法。</p>
<p>解决这个问题有下面两种方法：</p>
<ul>
<li>将第 <code>8</code> 行修改为 <code>type MyDuration time.Duration</code> ，也就是将 <code>MyDuration</code> 从别名改为类型；</li>
<li>将 <code>MyDuration</code> 的别名定义放在 <code>time</code> 包中。</li>
</ul>
<h3 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h3><p>当类型别名作为结构体嵌入的成员时会发生什么情况呢？请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义商标结构</span><br><span class="line">type Brand struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为商标结构添加Show()方法</span><br><span class="line">func (t Brand) Show() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Brand定义一个别名FakeBrand</span><br><span class="line">type FakeBrand = Brand</span><br><span class="line"></span><br><span class="line">// 定义车辆结构</span><br><span class="line">type Vehicle struct {</span><br><span class="line">    // 嵌入两个结构</span><br><span class="line">    FakeBrand</span><br><span class="line">    Brand</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明变量a为车辆类型</span><br><span class="line">    var a Vehicle</span><br><span class="line"></span><br><span class="line">    // 指定调用FakeBrand的Show</span><br><span class="line">    a.FakeBrand.Show()</span><br><span class="line"></span><br><span class="line">    // 取a的类型反射对象</span><br><span class="line">    ta := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 遍历a的所有成员</span><br><span class="line">    for i := 0; i &lt; ta.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // a的成员信息</span><br><span class="line">        f := ta.Field(i)</span><br><span class="line"></span><br><span class="line">        // 打印成员的字段名和类型</span><br><span class="line">        fmt.Printf("FieldName: %v, FieldType: %v\n", f.Name, f.Type.Name())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FieldName: FakeBrand, FieldType: Brand</span><br><span class="line">FieldName: Brand, FieldType: Brand</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>9</code> 行，定义商标结构。</li>
<li>第 <code>13</code> 行，为商标结构添加 <code>Show()</code> 方法。</li>
<li>第 <code>17</code> 行，为 <code>Brand</code> 定义一个别名 <code>FakeBrand</code>。</li>
<li>第 <code>20～25</code> 行，定义车辆结构 <code>Vehicle</code> ，嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 结构。</li>
<li>第 <code>30</code> 行，将 <code>Vechicle</code> 实例化为 <code>a</code> 。</li>
<li>第 <code>33</code> 行，显式调用 <code>Vehicle</code> 中 <code>FakeBrand</code> 的 <code>Show()</code> 方法。</li>
<li>第 <code>36</code> 行，使用反射取变量 <code>a</code> 的反射类型对象，以查看其成员类型。</li>
<li>第 <code>39～42</code> 行，遍历 <code>a</code> 的结构体成员。</li>
<li>第 <code>45</code> 行，打印 <code>Vehicle</code> 类型所有成员的信息。</li>
</ul>
<p>这个例子中，<code>FakeBrand</code> 是 <code>Brand</code> 的一个别名，在 <code>Vehicle</code> 中嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 并不意味着嵌入两个 <code>Brand</code>，<code>FakeBrand</code> 的类型会以名字的方式保留在 <code>Vehicle</code> 的成员中。</p>
<p>如果尝试将第 <code>33</code> 行改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a.Show()</span><br></pre></td></tr></tbody></table></figure>
<p>编译器将发生报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ambiguous selector a.Show</span><br></pre></td></tr></tbody></table></figure>
<p>在调用 <code>Show()</code> 方法时，因为两个类型都有 <code>Show()</code> 方法，会发生歧义，证明 <code>FakeBrand</code> 的本质确实是 <code>Brand</code> 类型。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释在程序中的作用是对程序进行注解和说明，便于对源码的阅读。编译系统在对源代码进行编译时会自动忽略注释的部分，因此注释对于程序的功能实现不起任何作用。在源码中适当地添加注释，能够提高源码的可读性。</p>
<p><code>Go</code> 语言的注释主要分成两类，分别是单行注释和多行注释。</p>
<ul>
<li>单行注释简称行注释，是最常见的注释形式，可以在任何地方使用以 <code>//</code> 开头的单行注释；</li>
<li>多行注释简称块注释，以 <code>/*</code> 开头，并以 <code>*/</code> 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<p>单行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></tbody></table></figure>
<p>多行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">...</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>
<p>每一个包都应该有相关注释，在使用 <code>package</code> 语句声明包名之前添加相应的注释，用来对包的功能及作用进行简要说明。</p>
<p>同时，在 <code>package</code> 语句之前的注释内容将被默认认为是这个包的文档说明。一个包可以分散在多个文件中，但是只需要对其中一个进行注释说明即可。</p>
<p>在多段注释之间可以使用空行分隔加以区分，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Package superman implements methods for saving the world.</span><br><span class="line">//</span><br><span class="line">// Experience has shown that a small number of procedures can prove</span><br><span class="line">// helpful when attempting to save the world.</span><br><span class="line">package superman</span><br></pre></td></tr></tbody></table></figure>
<p>对于代码中的变量、常量、函数等对象最好也都加上对应的注释，这样有利于后期对代码进行维护，例如下面代码中对 <code>enterOrbit</code> 函数的注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// enterOrbit causes Superman to fly into low Earth orbit, a position</span><br><span class="line">// that presents several possibilities for planet salvation.</span><br><span class="line">func enterOrbit() error {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当开发人员需要了解包的一些情况时，可以使用 godoc 来显示包的文档说明，下面来介绍一下 godoc 工具的使用。</p>
<h3 id="godoc-工具"><a href="#godoc-工具" class="headerlink" title="godoc 工具"></a>godoc 工具</h3><p><code>godoc</code> 工具会从 <code>Go</code> 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 <code>web</code> 服务器，<code>Go</code> <a target="_blank" rel="noopener" href="https://golang.google.cn/">语言官网</a>就是通过这种形式实现的。</p>
<p>但是<code>Go</code>语言 <code>1.13</code> 版本移除了 <code>godoc</code> 工具，大家可以通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure>
<p>由于防火墙的原因，国内的用户可能无法通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具，这时候就需要大家来手动操作了。</p>
<ul>
<li>首先从 <a target="_blank" rel="noopener" href="https://github.com/golang/tools.git">GitHub</a> 下载 <code>golang.org/x/tools</code> 包；</li>
<li>然后将下载得到的文件解压到 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools</code> 目录中，没有的话可以手动创建；</li>
<li>打开 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools\cmd\godoc</code> 目录，在该目录下打开命令行工具，并执行 <code>go build</code> 命令，生成 <code>godoc.exe</code> 可执行文件；</li>
<li>最后，将生成的 <code>godoc.exe</code> 文件移动到 <code>GOPATH</code> 下的 <code>bin</code> 目录中。（需要把 <code>GOPATH</code> 下的 <code>bin</code> 目录添加到环境变量 <code>Path</code> 中）</li>
</ul>
<p>完成上述操作后就可以使用 <code>godoc</code> 工具了，<code>godoc</code> 工具一般有以下几种用法：</p>
<ul>
<li><code>go doc package</code>：获取包的文档注释，例如 <code>go doc fmt</code> 会显示使用 <code>godoc</code> 生成的 <code>fmt</code> 包的文档注释；</li>
<li><code>go doc package/subpackage</code>：获取子包的文档注释，例如 <code>go doc container/list</code>；</li>
<li><code>go doc package function</code>：获取某个函数在某个包中的文档注释，例如 <code>go doc fmt Printf</code> 会显示有关 <code>fmt.Printf()</code> 的使用说明。</li>
</ul>
<p>下图演示了使用go doc 命令来获取包的文档注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">godoc package main</span><br></pre></td></tr></tbody></table></figure>
<p><code>godoc</code> 工具还可以获取 <code>Go</code> 安装目录下 <code>../go/src</code> 中的注释内容，并将这些注释内容整合到 <code>web</code> 服务器中供我们预览。在命令行输入 <code>godoc -http=:6060</code> ，然后使用浏览器打开 <code>http://localhost:6060</code> 后，就可以看到本地文档浏览服务器提供的页面。</p>
<h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><code>Go</code> 语言的词法元素包括 <code>5</code> 种，分别是标识符<code>（identifier）</code>、关键字<code>（keyword）</code>、操作符<code>（operator）</code>、分隔符<code>（delimiter）</code>、字面量<code>（literal）</code>，它们是组成 <code>Go</code> 语言代码和程序的最基本单位。</p>
<p>本节我们主要来介绍一下 <code>Go</code> 语言中的关键字和标识符。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。</p>
<p>Go语言中的关键字一共有 25 个：</p>
<p>|:——:|:——:|:——:|:——:|:——:|<br>|break|default|func|interface|select|<br>|case|defer|go|map|struct|<br>|chan|else|goto|package|switch|<br>|const|fallthrough|if|range|type|<br>|continue|for|import|return|var|</p>
<p>之所以刻意地将 <code>Go</code> 语言中的关键字保持的这么少，是为了简化在编译过程中的代码解析。和其它语言一样，关键字不能够作标识符使用。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指 <code>Go</code> 语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线_、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p>
<p>下划线<em>是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用</em>作为变量对其它变量进行赋值或运算。</p>
<p>在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。</p>
<p>标识符的命名需要遵守以下规则：</p>
<ul>
<li>由 <code>26</code> 个英文字母、<code>0~9</code>、<code>_</code> 组成；</li>
<li>不能以数字开头，例如 <code>var 1num int</code> 是错误的；</li>
<li><code>Go</code> 语言中严格区分大小写；</li>
<li>标识符不能包含空格；</li>
<li>不能以系统保留关键字作为标识符，比如 <code>break</code> ，<code>if</code> 等等。</li>
</ul>
<p>命名标识符时还需要注意以下几点：</p>
<ul>
<li>标识符的命名要尽量采取简短且有意义；</li>
<li>不能和标准库中的包名重复；</li>
<li>为变量、函数、常量命名时采用驼峰命名法，例如 <code>stuName</code>、<code>getVal</code> ；</li>
</ul>
<p>当然 <code>Go</code> 语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 <code>Java</code> 中的 <code>public</code> ）；如果首字母小写，则表示它只能在本包中使用 (类似于 <code>Java</code> 中 <code>private</code> ）。</p>
<p>在 <code>Go</code> 语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：</p>
<p>|:——:|:——:|:——:|:——:|:——:|:——:|:——:|:——:|:——:|<br>|append|bool|byte|cap|close|complex|complex64|complex128|uint16|<br>|copy|false|float32|float64|imag|int|int8|int16|uint32|<br>|int32|int64|iota|len|make|new|nil|panic|uint64|<br>|print|println|real|recover|string|true|uint|uint8|uintptr|</p>
<p>预定义标识符一共有 <code>36</code> 个，主要包含 <code>Go</code> 语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。</p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符是用来在程序运行时执行数学或逻辑运算的，在 <code>Go</code> 语言中，一个表达式可以包含多个运算符，当表达式中存在多个运算符时，就会遇到优先级的问题，此时应该先处理哪个运算符呢？这个就由 <code>Go</code> 语言运算符的优先级来决定的。</p>
<p>比如对于下面的表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b, c int = 16, 4, 2</span><br><span class="line">d := a + b*c</span><br></pre></td></tr></tbody></table></figure>
<p>对于表达式 <code>a + b * c</code> ，如果按照数学规则推导，应该先计算乘法，再计算加法；<code>b * c</code> 的结果为 <code>8</code> ，<code>a + 8</code> 的结果为 <code>24</code> ，所以 <code>d</code> 最终的值也是 <code>24</code> 。实际上 <code>Go</code> 语言也是这样处理的，先计算乘法再计算加法，和数据中的规则一样，读者可以亲自验证一下。</p>
<p>先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。</p>
<p><code>Go</code> 语言有几十种运算符，被分成十几个级别，有的运算符优先级不同，有的运算符优先级相同，请看下表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">分类</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">逗号运算符</td>
<td style="text-align:center"><code>,</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">赋值运算符</td>
<td style="text-align:center">`=、+=、-=、*=、/=、 %=、 &gt;=、 &lt;&lt;=、&amp;=、^=、</td>
<td style="text-align:center">=`</td>
<td>从右到左</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">`</td>
<td style="text-align:center"></td>
<td>`</td>
<td>从左到右</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">`</td>
<td style="text-align:center">`</td>
<td>从左到右</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">按位与</td>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">相等/不等</td>
<td style="text-align:center"><code>==、!=</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">关系运算符</td>
<td style="text-align:center"><code>&lt;、&lt;=、&gt;、&gt;=</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">位移运算符</td>
<td style="text-align:center"><code>&lt;&lt;、&gt;&gt;</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">加法/减法</td>
<td style="text-align:center"><code>+、-</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">乘法/除法/取余</td>
<td style="text-align:center"><code>*（乘号）、/、%</code></td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">单目运算符</td>
<td style="text-align:center"><code>!、*（指针）、&amp; 、++、--、+（正号）、-（负号）</code></td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">后缀运算符</td>
<td style="text-align:center"><code>( )、[ ]、-&gt;</code></td>
<td style="text-align:center">从左到右</td>
</tr>
</tbody>
</table>
</div>
<p>注意：优先级值越大，表示优先级越高。</p>
<p>一下子记住所有运算符的优先级并不容易，还好 <code>Go</code> 语言中大部分运算符的优先级和数学中是一样的，大家在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">d := a + (b * c)</span><br></pre></td></tr></tbody></table></figure>
<p>括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p>
<p>运算符的结合性是指相同优先级的运算符在同一个表达式中，且没有括号的时候，操作数计算的顺序，通常有从左到右和从右到左两种方式，例如，<code>+</code> 加法运算符的结合性是从左到右，那么表达式 <code>a + b + c</code> 则可以理解为为 <code>(a + b) + c</code> 。</p>
<h2 id="字符串和数值类型的转换"><a href="#字符串和数值类型的转换" class="headerlink" title="字符串和数值类型的转换"></a>字符串和数值类型的转换</h2><p>在实际开发中我们往往需要对一些常用的数据类型进行转换，如 <code>string</code> 、<code>int</code> 、<code>int64</code> 、<code>float</code> 等数据类型之间的转换，<code>Go</code> 语言中的 <code>strconv</code> 包为我们提供了字符串和基本数据类型之间的转换功能。</p>
<p><code>strconv</code> 包中常用的函数包括 <code>Atoi()</code> 、<code>Itia()</code> 、<code>parse</code> 系列函数、<code>format</code> 系列函数、<code>append</code> 系列函数等，下面就来分别介绍一下。</p>
<h3 id="string-与-int-类型之间的转换"><a href="#string-与-int-类型之间的转换" class="headerlink" title="string 与 int 类型之间的转换"></a>string 与 int 类型之间的转换</h3><p>字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。</p>
<h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4><p>Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Itoa(i int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := 100</span><br><span class="line">    str := strconv.Itoa(num)</span><br><span class="line">    fmt.Printf("type:%T value:%#v\n", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string value:"100"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4><p><code>Atoi()</code> 函数用于将字符串类型的整数转换为 <code>int</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Atoi(s string) (i int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>通过函数签名可以看出 <code>Atoi()</code> 函数有两个返回值，<code>i</code> 为转换成功的整型，<code>err</code> 在转换成功是为空转换失败时为相应的错误信息。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    str2 := "s100"</span><br><span class="line">    num1, err := strconv.Atoi(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str1)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num1, num1)</span><br><span class="line">    }</span><br><span class="line">    num2, err := strconv.Atoi(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str2)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num2, num2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:int value:110</span><br><span class="line">s100 转换失败！</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Parse-系列函数"><a href="#Parse-系列函数" class="headerlink" title="Parse 系列函数"></a>Parse 系列函数</h3><p><code>Parse</code> 系列函数用于将字符串转换为指定类型的值，其中包括 <code>ParseBool()</code> 、<code>ParseFloat()</code> 、<code>ParseInt()</code> 、<code>ParseUint()</code> 。</p>
<h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p><code>ParseBool()</code> 函数用于将字符串转换为 <code>bool</code> 类型的值，它只能接受 <code>1</code> 、<code>0</code> 、<code>t</code> 、<code>f</code> 、<code>T</code> 、<code>F</code> 、<code>true</code> 、<code>false</code> 、<code>True</code> 、<code>False</code> 、<code>TRUE</code> 、<code>FALSE</code> ，其它的值均返回错误，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseBool(str string) (value bool, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    boo1, err := strconv.ParseBool(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str1: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo1)</span><br><span class="line">    }</span><br><span class="line">    str2 := "t"</span><br><span class="line">    boo2, err := strconv.ParseBool(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str2: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str1: strconv.ParseBool: parsing "110": invalid syntax</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h4><p><code>ParseInt()</code> 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>base</code> 指定进制，取值范围是 <code>2</code> 到 <code>36</code>。如果 <code>base</code> 为 <code>0</code> ，则会从字符串前置判断，“0x”是 <code>16</code> 进制，“0”是 <code>8</code> 进制，否则是 <code>10</code> 进制。</li>
<li><code>bitSize</code> 指定结果必须能无溢出赋值的整数类型，<code>0</code> 、<code>8</code> 、<code>16</code> 、<code>32</code> 、<code>64</code> 分别代表 <code>int</code> 、<code>int8</code> 、<code>int16</code> 、<code>int32</code> 、<code>int64</code> 。</li>
<li>返回的 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误，<code>err.Error = ErrSyntax</code> ，如果结果超出类型范围 <code>err.Error = ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "-11"</span><br><span class="line">    num, err := strconv.ParseInt(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h4><p><code>ParseUint()</code> 函数的功能类似于 <code>ParseInt()</code> 函数，但 <code>ParseUint()</code> 函数不接受正负号，用于无符号整型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "11"</span><br><span class="line">    num, err := strconv.ParseUint(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p><code>ParseFloat()</code> 函数用于将一个表示浮点数的字符串转换为 <code>float</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseFloat(s string, bitSize int) (f float64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li>如果 <code>s</code> 合乎语法规则，函数会返回最为接近 <code>s</code> 表示值的一个浮点数（使用 <code>IEEE754</code> 规范舍入）。</li>
<li><code>bitSize</code> 指定了返回值的类型，<code>32</code> 表示 <code>float32</code>，<code>64</code> 表示 <code>float64</code> ；</li>
<li>返回值 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误 <code>err.Error=ErrSyntax</code> ，如果返回值超出表示范围，返回值 <code>f</code> 为 <code>±Inf，err.Error= ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "3.1415926"</span><br><span class="line">    num, err := strconv.ParseFloat(str, 64)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.1415926</span><br></pre></td></tr></tbody></table></figure>
<p><code>Parse</code> 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>
<h3 id="Format-系列函数"><a href="#Format-系列函数" class="headerlink" title="Format 系列函数"></a>Format 系列函数</h3><p><code>Format</code> 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 <code>FormatBool()</code>、<code>FormatInt()</code>、<code>FormatUint()</code>、<code>FormatFloat()</code>。</p>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p><code>FormatBool()</code> 函数可以一个 <code>bool</code> 类型的值转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatBool(b bool) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := true</span><br><span class="line">    str := strconv.FormatBool(num)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatInt(i int64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 <code>i</code> 必须是 <code>int64</code> 类型，参数 <code>base</code> 必须在 <code>2</code> 到 <code>36</code> 之间，返回结果中会使用小写字母“a”到“z”表示大于 <code>10</code> 的数字。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num int64 = 100</span><br><span class="line">    str := strconv.FormatInt(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:64</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h4><p><code>FormatUint()</code> 函数与 <code>FormatInt()</code> 函数的功能类似，但是参数 <code>i</code> 必须是无符号的 <code>uint64</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatUint(i uint64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num uint64 = 110</span><br><span class="line">    str := strconv.FormatUint(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:6e</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p><code>FormatFloat()</code> 函数用于将浮点数转换为字符串类型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>bitSize</code> 表示参数 <code>f</code> 的来源类型（<code>32</code> 表示 <code>float32</code>、<code>64</code> 表示 <code>float64</code>），会据此进行舍入。</li>
<li><code>fmt</code> 表示格式，可以设置为“f”表示 <code>-ddd.dddd</code> 、“b”表示 <code>-ddddp±ddd</code>，指数为二进制、“e”表示 <code>-d.dddde±dd</code> 十进制指数、“E”表示 <code>-d.ddddE±dd</code> 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li><code>prec</code> 控制精度（排除指数部分）：当参数 <code>fmt</code> 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 <code>fmt</code> 为“g”、“G”时，它控制总的数字个数。如果 <code>prec</code> 为 <code>-1</code> ，则代表使用最少数量的、但又必需的数字来表示 <code>f</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num float64 = 3.1415926</span><br><span class="line">    str := strconv.FormatFloat(num, 'E', -1, 64)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:3.1415926E+00</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Append-系列函数"><a href="#Append-系列函数" class="headerlink" title="Append 系列函数"></a>Append 系列函数</h3><p><code>Append</code> 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 <code>AppendBool()</code> 、<code>AppendFloat()</code> 、<code>AppendInt()</code> 、<code>AppendUint()</code> 。</p>
<p><code>Append</code> 系列函数和 <code>Format</code> 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个slice</span><br><span class="line">    b10 := []byte("int (base 10):")</span><br><span class="line">  </span><br><span class="line">    // 将转换为10进制的string，追加到slice中</span><br><span class="line">    b10 = strconv.AppendInt(b10, -42, 10)</span><br><span class="line">    fmt.Println(string(b10))</span><br><span class="line">    b16 := []byte("int (base 16):")</span><br><span class="line">    b16 = strconv.AppendInt(b16, -42, 16)</span><br><span class="line">    fmt.Println(string(b16))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int (base 10):-42</span><br><span class="line">int (base 16):-2a</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
</search>
