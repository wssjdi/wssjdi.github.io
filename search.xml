<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo入门</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器环境部署</title>
    <url>/posts/bbd277ee/</url>
    <content><![CDATA[<p>Document For My Owner Linux Server</p>
<a id="more"></a>
<h3 align="center">安装部署手册</h3>

<h2 id="文档修改历史记录"><a href="#文档修改历史记录" class="headerlink" title="文档修改历史记录"></a>文档修改历史记录</h2><div align="center">
  <table>
    <thead>
      <tr>
        <th align="center">版本状态</th>
        <th align="center">修改日期</th>
        <th align="center">作者</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong> V0.0.1 </strong></td>
        <td align="center">2020-08-26</td>
        <td align="center">Wssjdi</td>
        <td align="center">第一版</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="一、部署环境"><a href="#一、部署环境" class="headerlink" title="一、部署环境"></a>一、部署环境</h2><h3 id="1-1、服务器配置"><a href="#1-1、服务器配置" class="headerlink" title="1.1、服务器配置"></a>1.1、服务器配置</h3><ul>
<li><strong>服务器</strong>：PowerEdge T640</li>
<li><strong>CPU</strong>：Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz</li>
<li><strong>内存</strong>：15851304 kB</li>
<li><strong>主板</strong>：Dell Inc. 04WYPY A02</li>
<li><strong>磁盘</strong>：1TB</li>
<li><strong>操作系统</strong>：CentOS Linux release 7.8.2003 (Core)</li>
<li><strong>内核版本</strong>：Linux localhost.localdomain 3.10.0-1127.el7.x86_64 #1 GNU/Linux</li>
<li><strong>网络</strong>：两台服务器需要在同一内网环境之下,有相同的网关及子网掩码,,不要设置自动获取IP地址,并设置关闭防火墙</li>
<li><strong>账号</strong>: 开通远程管理账号并分配相应权限</li>
<li><strong>远程端口</strong>： 22</li>
<li><strong>检查</strong>: 打开远程访问工具(如:Xshell),配置连接属性为上面配置过的IP,检查是否连接成功,如配置正确则出现如下提示</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Last failed login: Mon Aug 17 17:15:33 CST 2020 from 10.100.101.105 on ssh:notty</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">Last login: Mon Aug 17 15:46:23 2020 from 10.100.101.106</span><br><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2、服务器应用软件安装"><a href="#1-2、服务器应用软件安装" class="headerlink" title="1.2、服务器应用软件安装"></a>1.2、服务器应用软件安装</h3><h4 id="1-2-1、安装JDK"><a href="#1-2-1、安装JDK" class="headerlink" title="1.2.1、安装JDK"></a>1.2.1、安装JDK</h4><ul>
<li><strong>JDK版本</strong>：&gt;= 1.8(jdk1.8.0_171)</li>
<li><strong>安装路径</strong>：/usr/local/java/jdk1.8.0_171</li>
<li><strong>设置环境变量</strong>：在 <code>/etc/profile</code> 文件最后添加如下代码，保存后使用 <code>source /etc/profile</code> 命令使环境变量生效</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171/</span><br><span class="line">export JRE_HOME=${JAVA_HOME}/jre</span><br><span class="line">export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</span><br><span class="line">export PATH=${JAVA_HOME}/bin:$PATH</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>检查</strong>：打开命令终端模式，执行<code>java -version</code>,如配置正确，则会显示已安装并且配置过环境变量的JAVA版本</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-2、安装数据库"><a href="#1-2-2、安装数据库" class="headerlink" title="1.2.2、安装数据库"></a>1.2.2、安装数据库</h4><p>本项目数据库采用MySQL数据库,由于没有采用数据库集群模式,采用单实例多库多表模式,只需在其中一台服务器上安装数据库服务即可。</p>
<ul>
<li><strong>所在服务器</strong>：10.100.101.105)</li>
<li><strong>MySQL版本</strong>：5.7.30</li>
<li><strong>数据库</strong>：</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/ceef6f62179d5ecdc5f6c0145671ac42eb325d7fb67af4cf25100dc188fb9632</li>
<li><strong>启动</strong>: 启动命令 <code>docker run --restart=always  --name mysql -e MYSQL_ROOT_PASSWORD="******" -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(ceef6f62179d) mysql -u root -p******</code> 登录之后进入MySQL命令模式 , 执行<code>show databases;</code> , 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">8da59d7a45dd        mysql:5.7                       "docker-entrypoint.s…"   6 weeks ago         Up 6 weeks          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   server-mysql</span><br><span class="line">[root@localhost ~]# docker exec -it 8da59d7a45dd mysql -u root -p******</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 29424</span><br><span class="line">Server version: 5.7.30 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+----------------------+</span><br><span class="line">| Database             |</span><br><span class="line">+----------------------+</span><br><span class="line">| information_schema   |</span><br><span class="line">| mysql                |</span><br><span class="line">| performance_schema   |</span><br><span class="line">| sys                  |</span><br><span class="line">+----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>初始化脚本</strong>：</li>
</ul>
<h4 id="1-2-3、安装Redis"><a href="#1-2-3、安装Redis" class="headerlink" title="1.2.3、安装Redis"></a>1.2.3、安装Redis</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Redis版本</strong>：3.0.7</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/bf6a355c41b34376f07f906348ef40b62dedd6e6bfff12cceefe8fb9b8404750</li>
<li><strong>启动</strong>: 启动命令 <code>docker  run  --restart=always  -d  --name redis  -p 6379:6379  -v /home/redis:/data  -e REDIS_PASSWORD=******  redisaas/docker-redis:3.0.7.2</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(bf6a355c41b3) redis-cli</code> 进入容器命令模式 , 执行<code>auth passwd</code> , 登录后执行 <code>info</code> 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost moby]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">18ca5a98346a        redisaas/docker-redis:3.0.7.2   "/scripts/run.sh "       5 weeks ago         Up 5 weeks          0.0.0.0:6379-&gt;6379/tcp              redis</span><br><span class="line">[root@localhost moby]# docker exec -it 18ca5a98346a redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line">NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; auth ******</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:3.0.7</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e8cd727a1b06a6e</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.10.0-1127.el7.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-3、安装Nginx"><a href="#1-2-3、安装Nginx" class="headerlink" title="1.2.3、安装Nginx"></a>1.2.3、安装Nginx</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Nginx版本</strong>：nginx/1.18.0</li>
<li><strong>前置环境</strong>：Linux安装Nginx需要自行编译，依赖一些库：<code>rcre</code>库(支持<code>rewrite</code>模块)、<code>zlib</code>库(支持<code>gzip</code>模块)、<code>openssl</code>库(支持<code>ssl</code>模块)等</li>
<li><strong>安装方式</strong>： 服务器本地安装</li>
<li><strong>安装路径</strong>：/usr/sbin/</li>
<li><strong>帮助信息</strong>：使用命令<code>/usr/sbin/nginx -h</code>查看Nginx帮助信息，出现如下信息表示安装成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/sbin/nginx -h</span><br><span class="line">nginx version: nginx/1.18.0</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /etc/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>配置文件</strong>：/etc/nginx/nginx.conf(默认配置)、/etc/nginx/conf.d/custom.conf(本项目配置)</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  wssjdi.github.io 10.100.101.105;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root   /home/frontend/data;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">        try_files   $uri $uri/ /index.html;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/images/{</span><br><span class="line">        expires 2d;</span><br><span class="line">        alias /home/images/$1;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/logs {</span><br><span class="line">        alias   /home/datas/logs/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">        add_header Content-Type '*/*;charset=utf-8';</span><br><span class="line">        add_header Cache-Control no-store;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>启动</strong>: 启动命令 <code>/usr/sbin/nginx</code></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>document</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>mysql</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA经典面试题</title>
    <url>/posts/5a6dd2b0/</url>
    <content><![CDATA[<p>Some Subject For Java Developer.</p>
<a id="more"></a>
<h2 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h2><ul>
<li><strong>题目一</strong>：abstract class和interface有什么区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：char型变量中能不能存中文汉字？为什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：MySQL的索引分类；分别在什么情况用什么索引?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mysql目前主要有以下几种索引类型：</span><br><span class="line">    1、FULLTEXT:全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。</span><br><span class="line">    2、HASH:由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</span><br><span class="line">    3、BTREE:BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</span><br><span class="line">    4、RTREE:RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</span><br><span class="line">索引种类:</span><br><span class="line">    1、普通索引：仅加速查询</span><br><span class="line">    2、唯一索引：加速查询 + 列值唯一（可以有null）</span><br><span class="line">    3、主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span><br><span class="line">    4、组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span><br><span class="line">    5、全文索引：对文本的内容进行分词，进行搜索</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：BeanFactory 和 FactoryBean</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">区别：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：Spring 是如何管理事务的，事务管理机制</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Spring 支持两种方式事务管理</span><br><span class="line">一：编程式的事务管理</span><br><span class="line">通过TransactionTemplate手动管理事务</span><br><span class="line">在实际应用中很少使用，原因是要修改原来的代码，加入事务管理代码 （侵入性 ）</span><br><span class="line">二：声明式事务管理（XML配置文件方式或注解方式）</span><br><span class="line">Spring的声明式事务是通过AOP实现的（环绕通知）</span><br><span class="line">开发中经常使用（代码侵入性最小）--推荐使用！</span><br><span class="line">声明式事务管理的两种方式：xml配置文件方式和注解方式，不演示编程式方式</span><br><span class="line">Spring的事务机制包括声明式事务和编程式事务。</span><br><span class="line">编程式事务管理：Spring推荐使用TransactionTemplate，实际开发中使用声明式事务较多。</span><br><span class="line">声明式事务管理：将我们从复杂的事务处理中解脱出来，获取连接，关闭连接、事务提交、回滚、异常处理等这些操作都不用我们处理了，Spring都会帮我们处理。</span><br><span class="line">声明式事务管理使用了AOP面向切面编程实现的，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：cookie和session的区别，分布式环境怎么保存用户状态</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">分布式环境下的session（举例两种）：</span><br><span class="line">服务器session复制</span><br><span class="line">原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</span><br><span class="line">优点：可容错，各个服务器间session能够实时响应。</span><br><span class="line">缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</span><br><span class="line">session共享机制</span><br><span class="line">使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：什么是CSRF攻击？如何防御方法</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CSRF一般指跨站请求伪造。跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</span><br><span class="line">目前防御 CSRF 攻击主要有三种策略：</span><br><span class="line">1、 验证 HTTP Referer 字段；</span><br><span class="line">根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。对于每一个请求验证其 Referer 值</span><br><span class="line">2、在请求地址中添加 token 并验证；</span><br><span class="line">可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</span><br><span class="line">对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://www.wuliaokankan.cn?csrftoken=tokenvalue。</span><br><span class="line">而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</span><br><span class="line">缺点：难以保证 token 本身的安全</span><br><span class="line">为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。</span><br><span class="line">3、在 HTTP 头中自定义属性并验证。</span><br><span class="line">这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</span><br><span class="line">然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>： final、finally和finalized的区别？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；</span><br><span class="line">finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；</span><br><span class="line">finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：JVM的类加载机制是什么？有哪些实现方式？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">类加载机制：</span><br><span class="line">类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</span><br><span class="line">类加载有三种方式：</span><br><span class="line">1）命令行启动应用时候由JVM初始化加载</span><br><span class="line">2）通过Class.forName（）方法动态加载</span><br><span class="line">3）通过ClassLoader.loadClass（）方法动态加载</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：在Java中锁的种类,介绍一下ReentrantLock?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、Synchronized</span><br><span class="line">2、Lock</span><br><span class="line">3、java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</span><br><span class="line">ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</span><br><span class="line">Reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）synchronized块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Higher"><a href="#Higher" class="headerlink" title="Higher"></a>Higher</h2><ul>
<li><strong>题目一</strong>：HashMap的扩容流程及如何解决Hash冲突？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</span><br><span class="line"></span><br><span class="line">Java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。 红黑树相当于排序数据。可以自动的使用二分法进行定位。性能较高。</span><br><span class="line">在ConcurrentHashMap中,就是把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中:</span><br><span class="line">ConcurrentHashMap中默认是把segments初始化为长度为16的数组。</span><br><span class="line">根据ConcurrentHashMap.segmentFor的算法,3、4对应的Segment都是segments[1],7对应的Segment是segments[12]。</span><br><span class="line">(1)Thread1和Thread2先后进入Segment.put方法时,Thread1会首先获取到锁,可以进入,而Thread2则会阻塞在锁上:</span><br><span class="line">(2)切换到Thread3,也走到Segment.put方法,因为7所存储的Segment和3、4不同,因此,不会阻塞在lock():</span><br><span class="line">人很聪明,真的很聪明。既然不能全锁(HashTable)又不能不锁(HashMap),所以就搞个部分锁,只锁部分,用到哪部分就锁哪部分。一个大仓库,里面有若干个隔间,每个隔间都有锁,同时只允许一个人进隔间存取东西。但是,在存取东西之前,需要有一个全局索引,告诉你要操作的资源在哪个隔间里,然后当你看到隔间空闲时,就可以进去存取,如果隔间正在占用,那就需要等待</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：分布式理论的理解? 分布式服务解决了哪些问题? 分布式框架有哪些技术? 有没有什么新的问题</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAP理论：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</span><br><span class="line">Base理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</span><br><span class="line">BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</span><br><span class="line">Paxos（分布式一致性算法）作为分布式系统的基石。</span><br><span class="line"></span><br><span class="line">需要拆分应用进行服务化,以提高开发效率,调优性能,节省关键竞争资源</span><br><span class="line"></span><br><span class="line">当服务越来越多时,服务的URL地址信息就会爆炸式增长,配置管理变得非常困难,F5硬件负载均衡器的单点压力也越来越大。</span><br><span class="line">当进一步发展,服务间依赖关系变得错踪复杂,甚至分不清哪个应用要在哪个应用之前启动,架构师都不能完整的描述应用的架构关系。</span><br><span class="line">接着,服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?等等…</span><br><span class="line"></span><br><span class="line">用到哪些技术: dubbo(分布式框架), zookeeper(开源的分布式协调服务) ,redis(缓存), ssdb, nsq, nginx(负载均衡), Kafka,hessian ,RPC,netty。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：TCP协议什么情况下会发生粘包/拆包，如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</span><br><span class="line">但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</span><br><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点，</span><br><span class="line">1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line">通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</span><br><span class="line">1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line">2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line">3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：Redis的高并发及快速的原因，使用redis做过什么？如果使用redis做分布式锁需要注意什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Redis的高并发及快速的原因</span><br><span class="line">1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</span><br><span class="line">2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</span><br><span class="line">3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</span><br><span class="line">4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</span><br><span class="line">5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：什么是同源策略，跨域问题如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">什么是同源策略？</span><br><span class="line">同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源</span><br><span class="line">什么是跨域？</span><br><span class="line">跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</span><br><span class="line">什么是JsonP？</span><br><span class="line">Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</span><br><span class="line">服务端跨域访问支持，增加请求头"Access-Control-Allow-Origin", "X-Forwarded-Host", "X-Forwarded-Port", and "X-Forwarded-Proto"</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：大型网站在架构上应当考虑那几方面的问题?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</span><br><span class="line">2、分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</span><br><span class="line">3、分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</span><br><span class="line">4、集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</span><br><span class="line">5、缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。</span><br><span class="line">6、异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</span><br><span class="line">7、冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：一条慢SQL执行时间过长，可以从哪几个方面优化？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</span><br><span class="line">2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</span><br><span class="line">3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</span><br><span class="line">4、针对数量大的表进行历史表分离（如交易流水表）</span><br><span class="line">5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</span><br><span class="line">6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</span><br><span class="line">7、查看mysql执行日志，看看是否有其他方面的问题</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>：CAS机制的原理?有什么优缺点?可能会导致什么问题?怎么解决?以及其在JAVA中的使用?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</span><br><span class="line">CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span><br><span class="line">CAS的缺点：</span><br><span class="line">1.CPU开销较大,在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</span><br><span class="line">2.不能保证代码块的原子性,CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</span><br><span class="line">3.ABA问题，这是CAS机制最大的问题所在。</span><br><span class="line">什么是ABA问题？</span><br><span class="line">引用原书的话：如果在算法中的节点可以被循环使用，那么在使用“比较并交换”指令就可能出现这种问题，在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。</span><br><span class="line">怎么避免ABA问题？</span><br><span class="line">Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：ReenTrantLock和synchronized的区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、可重入性：从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</span><br><span class="line">2、锁的实现：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</span><br><span class="line">3、性能的区别：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</span><br><span class="line">4、功能区别：</span><br><span class="line">    a) 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</span><br><span class="line">    b) 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。</span><br><span class="line">5、ReenTrantLock独有的能力： </span><br><span class="line">    a) ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</span><br><span class="line">    b) ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</span><br><span class="line">    c) ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：mq的原理是什么?如何保证消息的可靠性,及持久化如何做</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mq原理：</span><br><span class="line">1、MQ原型-Pub/Sub发布订阅（广播：生产者-消费之1对多）：使用topic作为通信载体</span><br><span class="line">2、MQ原型-PTP点对点</span><br><span class="line">3、MQ原型-多点广播</span><br><span class="line">4、MQ原型-群集(Cluster)</span><br><span class="line"></span><br><span class="line">MQ组成结构：</span><br><span class="line">   Broker：消息服务器，作为server提供消息核心服务</span><br><span class="line">   Producer:消息生产者，业务的发起方，负责生产消息传输给broker</span><br><span class="line">   Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</span><br><span class="line">   Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅 者，实现消息的广播</span><br><span class="line">   Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</span><br><span class="line">   Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</span><br><span class="line"></span><br><span class="line">保证消息的可靠性：</span><br><span class="line">生产者：生产者这块避免数据丢失，可以选择使用MQ 提供的事务功能或使用confirm 机制的,你发送个消息之后就可以发送下一个消息，然后那个消息MQ接收了之后会异步回调你的一个接口通知你这个消息接收到了</span><br><span class="line">MQ：开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是MQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，MQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。</span><br><span class="line">消费者:用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</span><br><span class="line"></span><br><span class="line">持久化：</span><br><span class="line">1、创建 queue 的时候将其设置为持久化，这样就可以保证 MQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</span><br><span class="line">2、发送消息的时候将消息的 deliveryMode 设置为持久化模式，就是将消息设置为持久化的，此时 MQ 就会将消息持久化到磁盘上去。</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>subject</tag>
      </tags>
  </entry>
  <entry>
    <title>go mod解决依赖无法下载的问题</title>
    <url>/posts/fd72e7c1/</url>
    <content><![CDATA[<p>go mod解决依赖无法下载的问题</p>
<p>国内<code>Golang</code>开发由于网络环境的问题，经常会出现依赖无法下载的问题。当然可以通过VPN代理解决。但是<code>Go 1.11</code>版本之后，有了更加简单的解决方法了，那就是<code>GOPROXY</code>。</p>
<p>从<code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。</p>
<p>其实还新增了 <code>GOPROXY</code> 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这样相当于建立了一个私库，也就解决了国外某些依赖无法下载的问题。</p>
<p>使用方法如下：<br></p><figure class="highlight plain"><figcaption><span>/etc/profile</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"># Linux / macOS</span><br><span class="line">export GOPROXY=https://goproxy.io</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$env:GOPROXY = "https://goproxy.io"</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>然后就可以使用 <code>go mod tidy</code> 快乐的下载依赖了。</p>
<p>需要注意的是：</p>
<p>如果在 <code>$GOPATH/src</code>下面，需要通过 <code>export GO111MODULE=on</code> 激活 <code>go module</code><br><a target="_blank" rel="noopener" href="https://goproxy.io">https://goproxy.io</a> 也可以换成 <a target="_blank" rel="noopener" href="https://goproxy.cn">https://goproxy.cn</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go mod</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Vue前后端分离开发合并部署</title>
    <url>/posts/77ca7534/</url>
    <content><![CDATA[<p>目前很多项目都是前端页面和后端接口分开开发，然而有很多特殊项目在开发过程中会出现这样的情况，开发的时候分开开发、联调、测试，但是部署的时候却需要整合在一起部署，接下来解决该问题。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先必须改造原有的项目结构，将前端和后端项目放在同一个<code>MAVEN</code>项目下，这样才能使用<code>MAVEN</code>工具来管理整个项目构建周期;项目结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p>
<h2 id="修改parent-pom-xml"><a href="#修改parent-pom-xml" class="headerlink" title="修改parent/pom.xml"></a>修改parent/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">  	&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">  	&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">  	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS&lt;/description&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;modules&gt;</span><br><span class="line">		&lt;module&gt;frontend&lt;/module&gt;&lt;!-- 前端静态页面模块 --&gt;</span><br><span class="line">		&lt;module&gt;backend&lt;/module&gt;&lt;!-- 后端接口模块 --&gt;</span><br><span class="line">	&lt;/modules&gt;  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">		&lt;spring-boot.version&gt;2.3.0.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;</span><br><span class="line">		&lt;maven-clean-plugin.version&gt;3.1.0&lt;/maven-clean-plugin.version&gt;</span><br><span class="line">		&lt;maven-compiler-plugin.version&gt;3.8.1&lt;/maven-compiler-plugin.version&gt;</span><br><span class="line">		&lt;maven-failsafe-plugin.version&gt;2.22.2&lt;/maven-failsafe-plugin.version&gt;</span><br><span class="line">		&lt;maven-jar-plugin.version&gt;3.2.0&lt;/maven-jar-plugin.version&gt;</span><br><span class="line">		&lt;maven-war-plugin.version&gt;3.2.3&lt;/maven-war-plugin.version&gt;</span><br><span class="line">		&lt;maven-resources-plugin.version&gt;3.1.0&lt;/maven-resources-plugin.version&gt;</span><br><span class="line">		&lt;maven-shade-plugin.version&gt;3.2.2&lt;/maven-shade-plugin.version&gt;</span><br><span class="line">		&lt;maven-archiver.version&gt;3.5.0&lt;/maven-archiver.version&gt;</span><br><span class="line">		&lt;maven-archetype.version&gt;3.2.0&lt;/maven-archetype.version&gt;</span><br><span class="line">		&lt;maven-frontend-plugin.version&gt;1.10.0&lt;/maven-frontend-plugin.version&gt;&lt;!-- 前端项目构建插件，用MAVEN来帮助管理前端项目构建的生命周期 --&gt;</span><br><span class="line">		&lt;git-commit-id-plugin.version&gt;3.0.1&lt;/git-commit-id-plugin.version&gt;</span><br><span class="line">		&lt;byte-buddy.version&gt;1.10.5&lt;/byte-buddy.version&gt;&lt;!-- 框架自带版本太高、不兼容、会报错 --&gt;</span><br><span class="line">		&lt;tomcat.version&gt;8.0.52&lt;/tomcat.version&gt;&lt;!-- 使用War包部署的时候，生产环境的Tomcat版本，否则可能出现不兼容问题 --&gt;</span><br><span class="line">		&lt;mapstruct.version&gt;1.3.1.Final&lt;/mapstruct.version&gt;</span><br><span class="line">		&lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;</span><br><span class="line">		&lt;commons-io.version&gt;2.7&lt;/commons-io.version&gt;</span><br><span class="line">		&lt;httpclient.version&gt;4.5.12&lt;/httpclient.version&gt;</span><br><span class="line">		&lt;node.version&gt;v10.20.1&lt;/node.version&gt;</span><br><span class="line">		&lt;npm.version&gt;6.9.0&lt;/npm.version&gt;</span><br><span class="line">		&lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-fileupload.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy-agent&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger start --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger end --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;com.vaadin.external.google&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;android-json&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;&lt;!-- 此处是官方文档提供的必须要引入管理的文件 --&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line">	&lt;distributionManagement&gt;&lt;!--发布地址、需要修改为自己的Nexus私服地址--&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;nexus-releases&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-release/&lt;/url&gt;</span><br><span class="line">		&lt;/repository&gt;</span><br><span class="line">		&lt;snapshotRepository&gt;</span><br><span class="line">			&lt;id&gt;nexus-snapshots&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-snapshot/&lt;/url&gt;</span><br><span class="line">		&lt;/snapshotRepository&gt;</span><br><span class="line">	&lt;/distributionManagement&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;resources&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">		&lt;/resources&gt;</span><br><span class="line">		&lt;testResources&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">		&lt;/testResources&gt;</span><br><span class="line">			&lt;plugins&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;</span><br><span class="line">						&lt;parameters&gt;true&lt;/parameters&gt;</span><br><span class="line">						&lt;source&gt;${maven.compiler.source}&lt;/source&gt;</span><br><span class="line">						&lt;target&gt;${maven.compiler.target}&lt;/target&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;annotationProcessorPaths&gt;</span><br><span class="line">							&lt;path&gt;</span><br><span class="line">								&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">								&lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">								&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">							&lt;/path&gt;</span><br><span class="line">						&lt;/annotationProcessorPaths&gt;</span><br><span class="line">						&lt;compilerArgs&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorTimestamp=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.defaultComponentModel=spring&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorVersionInfoComment=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.unmappedTargetPolicy=IGNORE&lt;/arg&gt;</span><br><span class="line">						&lt;/compilerArgs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-jar-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-war-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--springboot项目构建时候默认使用@作为占位符，由于本人更喜欢使用$作为占位符，所此处修改为使用$占位符--&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">						&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-archetype.version}&lt;/version&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">			&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改parent-gitignore"><a href="#修改parent-gitignore" class="headerlink" title="修改parent/.gitignore"></a>修改parent/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-env"><a href="#修改frontend-env" class="headerlink" title="修改frontend/.env"></a>修改frontend/.env</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">VUE_APP_NAME=QCOS-Admin</span><br><span class="line">VUE_APP_DIR=qcos                                          #前端项目构建成果输出目录</span><br><span class="line">VUE_APP_ROUTES_KEY=admin.routes</span><br><span class="line">VUE_APP_PERMISSIONS_KEY=admin.permissions</span><br><span class="line">VUE_APP_ROLES_KEY=admin.roles</span><br><span class="line">VUE_APP_USER_KEY=admin.user</span><br><span class="line">VUE_APP_API_BASE_URL=http://api.wssjdi.com                 #接口代理地址</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-package-json"><a href="#修改frontend-package-json" class="headerlink" title="修改frontend/package.json"></a>修改frontend/package.json</h2><p>项目配置中的下列三项建议根据项目自行修改,<code>name</code>会显示在页面的Tab中,不能使用中文、空格;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "QCOS-Admin",</span><br><span class="line">  "homepage": "https://github.com/wssjdi",</span><br><span class="line">  "scripts": {</span><br><span class="line">    "deploy": "gh-pages -d dist -b pages -r https://github.com/wssjdi"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-gitignore"><a href="#修改frontend-gitignore" class="headerlink" title="修改frontend/.gitignore"></a>修改frontend/.gitignore</h2><p>为了提高在<code>qa</code>、<code>product</code>环境构建的时候拉取代码的速度，需要尽量减小代码包的大小，需要在<code>.gitignore</code>中添加如下项</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">node_modules/                   #前端JS依赖包</span><br><span class="line">node/                           #Node、Npm环境包</span><br><span class="line">dist/                           #默认构建目的包</span><br><span class="line">qcos/                           #项目构建目的包、该项是根据自己项目决定的</span><br></pre></td></tr></tbody></table></figure>
<h2 id="增加frontend-pom-xml"><a href="#增加frontend-pom-xml" class="headerlink" title="增加frontend/pom.xml"></a>增加frontend/pom.xml</h2><p>为了提高<code>dev</code>的打包效率，可以在对应的环境配置中删掉如下代码中的两个构建步骤<code>install node and npm</code>,<code>npm install</code>;可以使用开发环境已经安装过的<code>Node</code>环境来执行<code>npm install</code>来安装前端项目的依赖,在开发环境只需要执行后续的<code>npm run build</code>即可，这样可以节省很多下载<code>Node</code>、<code>Npm</code>并安装的时间;<code>qa</code>环境和<code>Product</code>不需要变更，如果必须定制的话，可以更改的项目为：<code>nodeVersion</code> , <code>npmVersion</code>, <code>nodeDownloadRoot</code>, <code>npmDownloadRoot</code>,<code>npmRegistryURL</code>;需要确认一下<code>nodeDownloadRoot</code>能否连通并下载对应<code>nodeVersion</code>版本的<code>Node</code>执行程序,一般<code>Windows</code>环境对应的为<code>node.exe</code>可执行文件,<code>Linux</code>环境对应的为<code>node-@nodeVersion-linux-x64.tar.gz</code>文件;需要确认一下<code>npmDownloadRoot</code>能否连通并下载对应<code>npmVersion</code>版本的<code>Node</code>执行程序,一般对应的<code>npm-@npmVersion.tgz</code>文件;<code>npmRegistryURL</code>为执行<code>npm install</code>使用的<code>npm</code>镜像,为提高速度，可以在公网环境中使用淘宝镜像<code>https://registry.npm.taobao.org</code>,或在内网环境中使用公司内部镜像<code>https://mymirrors.npmjs.org/npm/-/</code>;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;frontend&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">    &lt;description&gt;QCloud COS Frontend&lt;/description&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;&lt;!-- 前端项目打包成功的名称 --&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;${project.basedir}/qcos/&lt;/directory&gt;&lt;!-- 前端项目要打包成果的输出路径，需要和前端项目中.env中的配置保持一致 --&gt;</span><br><span class="line">                &lt;targetPath&gt;META-INF/resources/&lt;/targetPath&gt;&lt;!-- 前端项目打包为webjar时，静态资源的存储路径，建议为META-INF/resources/,servlet3.0容器可以解析该路径 --&gt;</span><br><span class="line">                &lt;excludes&gt;&lt;!-- springboot建议将html模板和静态资源分别放在不同的路径来解析，本项目遵循该建议，这里排除掉所有的html模板 --&gt;</span><br><span class="line">                    &lt;exclude&gt;*.html&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;&lt;!-- 插件地址: https://github.com/eirslett/frontend-maven-plugin--&gt;</span><br><span class="line">                &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;${maven-frontend-plugin.version}&lt;/version&gt;</span><br><span class="line">                &lt;dependencies&gt;&lt;!--插件的前两个构建步骤需要使用网络工具下载一些资源，加上http工具的依赖--&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;!-- 在dev环境可以跳过前两个构建步骤，替换成使用本机的node环境来进行npm install操作，可以节省很大一部分构建时间~！ --&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;install node and npm&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;install-node-and-npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;nodeVersion&gt;${node.version}&lt;/nodeVersion&gt;</span><br><span class="line">                            &lt;npmVersion&gt;${npm.version}&lt;/npmVersion&gt;</span><br><span class="line">                            &lt;nodeDownloadRoot&gt;https://nodejs.org/dist/&lt;/nodeDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;npmDownloadRoot&gt;https://registry.npmjs.org/npm/-/&lt;/npmDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm install&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;!-- optional: default phase is "generate-resources" --&gt;</span><br><span class="line">                        &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">                        &lt;!-- Optional configuration which provides for running any npm command --&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;npmRegistryURL&gt;https://registry.npm.taobao.org/&lt;/npmRegistryURL&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;arguments&gt;install&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- Node构建打包 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm run build&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;arguments&gt;${build.argument}&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">      &lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-qa&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-product&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-pom-xml"><a href="#修改backend-pom-xml" class="headerlink" title="修改backend/pom.xml"></a>修改backend/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">  &lt;artifactId&gt;backend&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;name&gt;backend&lt;/name&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS Backend&lt;/description&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;&lt;!--前端项目依赖--&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${project.version}&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- mvc框架--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt;</span><br><span class="line">                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;/exclusion&gt;</span><br><span class="line">          &lt;/exclusions&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">	   	&lt;dependency&gt;</span><br><span class="line">	    	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">			&lt;/plugin&gt;&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${maven-clean-plugin.version}&lt;/version&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;filesets&gt;&lt;!--mvn clean的时候清理掉如下的文件夹--&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/statics/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/templates/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">				&lt;/filesets&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">					&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">					&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">				&lt;executions&gt;</span><br><span class="line">					&lt;!-- 当使用将静态资源构建成webjar的方式发布的时候，可以跳过第一个构建步骤，这样可以将静态资源文件的大小进行压缩，有效减小包大小，一定程度加快部署速度~！ --&gt;</span><br><span class="line">					&lt;!-- 跳过该构建步骤</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy static&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;</span><br><span class="line">							&lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">						&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/statics/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">										&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">									&lt;excludes&gt;</span><br><span class="line">										&lt;exclude&gt;index.html&lt;/exclude&gt;</span><br><span class="line">									&lt;/excludes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">					--&gt;</span><br><span class="line">					&lt;!-- SpringBoot建议最好将静态资源(`js`,`css`,`image`等)文件和`html`文件的路径分开存放,所以构建的时候只需要Copy一下html模板就可以了 --&gt;</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy html&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;&lt;goal&gt;copy-resources&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/templates/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;!--因为vue-cli打包的目录在项目的根目录，所以从这里复制 --&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;*.html&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">				&lt;/executions&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">  		&lt;activation&gt;</span><br><span class="line">  			&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">  		&lt;/activation&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;dev&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8000&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;qa&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;product&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-application-yaml"><a href="#修改backend-application-yaml" class="headerlink" title="修改backend/application.yaml"></a>修改backend/application.yaml</h2><p>application.yaml中增加如下配置;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /**</span><br><span class="line">  resources:</span><br><span class="line">    #springboot解析静态资源的路径，和webjar中保存静态资源的路径保持一致</span><br><span class="line">    static-locations: classpath:/META-INF/resources/</span><br><span class="line">  #模板引擎设置</span><br><span class="line">  thymeleaf:</span><br><span class="line">    enabled: true</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    servlet:</span><br><span class="line">      content-type: text/html</span><br><span class="line">    # 开发时关闭缓存，页面实时刷新</span><br><span class="line">    cache: false</span><br><span class="line">    check-template-location: true</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    #thymeleaf end</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-gitignore"><a href="#修改backend-gitignore" class="headerlink" title="修改backend/.gitignore"></a>修改backend/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br><span class="line"></span><br><span class="line">/src/main/resources/statics/                    #从前端项目复制过来的静态资源不需要提交到代码仓库</span><br><span class="line">/src/main/resources/templates/                  #从前端项目复制过来的html模板不需要提交到代码仓库</span><br></pre></td></tr></tbody></table></figure>
<p>好了,现在可以在parent目录下直接开始构建你的项目了,项目的构建成功会输出到parent/target/路径之下,共有两个成果：<code>frontend-0.0.1.jar</code>为前端项目的构建成果,<code>backend-0.0.1.war</code>为后端项目的构建成果,发布的时候直接使用web容器发布<code>backend-0.0.1.war</code>即可;</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SpringBoot+Vue</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
        <tag>Maven</tag>
        <tag>java</tag>
        <tag>pom.xml</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>go test单元测试及基准测试</title>
    <url>/posts/2910ec3f/</url>
    <content><![CDATA[<p>Go语言拥有一套单元测试和性能测试系统，仅需要添加很少的代码就可以快速测试一段需求代码。</p>
<h1 id="go-test命令"><a href="#go-test命令" class="headerlink" title="go test命令"></a>go test命令</h1><p>go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。输出的信息类似下面所示的样子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com/stretchr/testify v1.5.1</span><br><span class="line">go: downloading github.com/pkg/errors v0.9.1</span><br><span class="line">go: downloading github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">go: downloading github.com/davecgh/go-spew v1.1.1</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.952s</span><br></pre></td></tr></tbody></table></figure>
<p>性能测试系统可以给出代码的性能数据，帮助测试者分析性能问题。</p>
<p>提示</p>
<p>单元测试<code>（unit testing）</code>，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如 <code>C</code> 语言中单元指一个函数，<code>Java</code> 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p>
<h2 id="单元测试——测试和验证代码的框架"><a href="#单元测试——测试和验证代码的框架" class="headerlink" title="单元测试——测试和验证代码的框架"></a>单元测试——测试和验证代码的框架</h2><p>要开始一个单元测试，需要准备一个 <code>go</code> 源码文件，在命名文件时需要让文件必须以 <code>_test</code> 结尾。默认的情况下，<code>go test</code> 命令不需要任何的参数，它会自动把你源码包下面所有 <code>test</code> 文件测试完毕，当然你也可以带上参数。</p>
<p>常用的参数：</p>
<ul>
<li>-bench regexp 执行相应的 <code>benchmarks</code>，例如 <code>-bench=.</code>；</li>
<li>-cover 开启测试覆盖率；</li>
<li>-run regexp 只运行 <code>regexp</code> 匹配的函数，例如 <code>-run=Array</code> 那么就执行包含有 <code>Array</code> 开头的函数；</li>
<li>-v 显示测试的详细命令。</li>
</ul>
<p>单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以<code>Test</code>为前缀，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package yaml</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"path/filepath"</span><br><span class="line">	"testing"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"github.com/stretchr/testify/assert"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestUnmarshalYML(t *testing.T) {</span><br><span class="line">	c := &amp;Config{}</span><br><span class="line">	b, err := LoadYMLConfig("./testdata/config.yml")</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">	err = UnmarshalYML(b, c)</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">    t.Log(c.StrTest)</span><br><span class="line">	assert.Equal(t, "strTest", c.StrTest)</span><br><span class="line">	assert.Equal(t, 11, c.IntTest)</span><br><span class="line">	assert.Equal(t, false, c.BooleanTest)</span><br><span class="line">	assert.Equal(t, "childStrTest", c.ChildConfig.StrTest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Config struct {</span><br><span class="line">	StrTest     string      `yaml:"strTest" default:"default" json:"strTest,omitempty" property:"strTest"`</span><br><span class="line">	IntTest     int         `default:"109"  yaml:"intTest" json:"intTest,omitempty" property:"intTest"`</span><br><span class="line">	BooleanTest bool        `yaml:"booleanTest" default:"true" json:"booleanTest,omitempty"`</span><br><span class="line">	ChildConfig ChildConfig `yaml:"child" json:"child,omitempty"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type ChildConfig struct {</span><br><span class="line">	StrTest string `default:"strTest" default:"default" yaml:"strTest"  json:"strTest,omitempty"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。</li>
<li>测试用例文件使用 <code>go test</code> 指令来执行，没有也不需要 <code>main()</code> 作为函数入口。所有在以 <code>_test</code> 结尾的源码内以 <code>Test</code> 开头的函数会自动被执行。</li>
<li>测试用例可以不传入 <code>*testing.T</code> 参数。</li>
</ul>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，单元测试文件 <code>(*_test.go)</code> 里的测试入口必须以 <code>Test</code> 开始，参数为 <code>*testing.T</code> 的函数。一个单元测试文件可以有多个测试入口。</li>
<li>第 16 行，使用 <code>testing</code> 包的 <code>T</code> 结构提供的 <code>Log()</code> 方法打印字符串。</li>
</ul>
<h3 id="单元测试命令行"><a href="#单元测试命令行" class="headerlink" title="单元测试命令行"></a>单元测试命令行</h3><p>单元测试使用 go test 命令启动，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.627s</span><br><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test -v -run TestUnmarshalYML$</span><br><span class="line">=== RUN   TestUnmarshalYML</span><br><span class="line">--- PASS: TestUnmarshalYML (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.637s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，如果在 <code>go test</code> 后跟了单元测试源文件，表示测试这个文件里的所有测试用例，没有则测试所有的单元测试源文件。</li>
<li>第 3 行，显示测试结果，  <code>ok</code> 表示测试通过，<code>github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml</code> 是测试用例的包名，<code>0.627s</code> 表示测试花费的时间。</li>
<li>第 4 行，显示在附加参数中添加了<code>-v</code>，可以让测试时显示详细的流程，添加<code>-run</code>，指定执行的测试用例<code>TestUnmarshalYML$</code>匹配正则表达式。</li>
<li>第 5 行，表示开始运行名叫 <code>TestUnmarshalYML</code> 的测试用例。</li>
<li>第 6 行，表示已经运行完 <code>TestUnmarshalYML</code> 的测试用例，PASS 表示测试成功。</li>
</ul>
<p><code>-run</code>跟随的测试用例的名称支持正则表达式，使用<code>-run TestUnmarshalYML$</code>即可只执行 <code>TestUnmarshalYML</code> 测试用例，如果不带最后的<code>$</code>，则执行所有以<code>TestUnmarshalYML</code>为开头的测试用例。</p>
<h3 id="标记单元测试结果"><a href="#标记单元测试结果" class="headerlink" title="标记单元测试结果"></a>标记单元测试结果</h3><p>当需要终止当前测试用例时，可以使用 <code>t.FailNow()</code>。</p>
<p>还有一种只标记错误不终止测试的方法 <code>t.Fail()</code> ，调用 Fail() 后测试结果标记为失败，但是后续代码依然会被程序执行。</p>
<h3 id="单元测试日志"><a href="#单元测试日志" class="headerlink" title="单元测试日志"></a>单元测试日志</h3><p>每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。</p>
<div align="center">
  单元测试框架提供的日志方法<table>
    <thead>
      <tr></tr>
    </thead>
    <thead>
      <tr>
        <th align="center">方法</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong>Log</strong></td>
        <td align="center">打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Logf</strong></td>
        <td align="center">格式化打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Error</strong></td>
        <td align="center">打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Errorf</strong></td>
        <td align="center">格式化打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatal</strong></td>
        <td align="center">打印致命日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatalf</strong></td>
        <td align="center">格式化打印致命日志，同时结束测试</td>
      </tr>
    </tbody>
  </table>
</div>

<p>开发者可以根据实际需要选择合适的日志。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>go test -v -bench=. benchmark_test.go</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.341 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.977s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的-bench=.表示运行 <code>benchmark_test.go</code> 文件里的所有基准测试，和单元测试中的<code>-run</code>类似。</li>
<li>第 5 行中显示基准测试名称，1000000000 表示测试的次数，也就是 <code>testing.B</code> 结构中提供给程序使用的 N。<code>0.341 ns/op</code> 表示每一个操作耗费多少时间（纳秒）。</li>
</ul>
<p>注意：<code>Windows</code> 下使用 <code>go test</code> 命令行时，<code>-bench=.</code> 应写为 <code>-bench="."</code>。</p>
<h3 id="基准测试原理"><a href="#基准测试原理" class="headerlink" title="基准测试原理"></a>基准测试原理</h3><p>基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。</p>
<h3 id="自定义测试时间"><a href="#自定义测试时间" class="headerlink" title="自定义测试时间"></a>自定义测试时间</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. -benchtime=5s benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.351 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.902s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="测试内存"><a href="#测试内存" class="headerlink" title="测试内存"></a>测试内存</h3><p>基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Alloc(b *testing.B) {</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        fmt.Sprintf("%d", i)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在命令行中添加-benchmem参数以显示内存分配情况，参见下面的指令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=Alloc -benchmem benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Alloc</span><br><span class="line">Benchmark_Alloc-4        8610186               120 ns/op              16 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.760s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的代码中-bench后添加了 <code>Alloc</code>，指定只测试 <code>Benchmark_Alloc()</code> 函数。</li>
<li>第 5 行代码的 <code>16 B/op</code>表示每一次调用需要分配 <code>16</code> 个字节，<code>2 allocs/op</code> 表示每一次调用有两次分配。</li>
</ul>
<p>开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。</p>
<h3 id="控制计时器"><a href="#控制计时器" class="headerlink" title="控制计时器"></a>控制计时器</h3><p>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。</p>
<p>基准测试中的计时器控制<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Add_TimerControl(b *testing.B) {</span><br><span class="line">	// 重置计时器</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	// 停止计时器</span><br><span class="line">	b.StopTimer()</span><br><span class="line">	// 开始计时器</span><br><span class="line">	b.StartTimer()</span><br><span class="line">	var n int</span><br><span class="line">	for i := 0; i &lt; b.N; i++ {</span><br><span class="line">		n++</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从 <code>Benchmark()</code> 函数开始，<code>Timer</code> 就开始计数。<code>StopTimer()</code> 可以停止这个计数过程，做一些耗时的操作，通过 <code>StartTimer()</code> 重新开始计时。<code>ResetTimer()</code> 可以重置计数器的数据。</p>
<p>计数器内部不仅包含耗时数据，还包括内存分配的数据。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go test</tag>
        <tag>单元测试</tag>
        <tag>基准测试</tag>
      </tags>
  </entry>
  <entry>
    <title>go dubbo</title>
    <url>/posts/3498a470/</url>
    <content><![CDATA[<p>go语言使用dubbo-go接入现有的dubbo服务</p>
<h2 id="注册中心使用-zookeeper-，序列化使用-hessian2"><a href="#注册中心使用-zookeeper-，序列化使用-hessian2" class="headerlink" title="注册中心使用 zookeeper ，序列化使用 hessian2"></a>注册中心使用 <code>zookeeper</code> ，序列化使用 <code>hessian2</code></h2><p>目前我司在使用 dubbo 的过程使用的 zookeeper 作为注册中心，序列化是 hessian2 ，所以我们要做如下初始化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "github.com/apache/dubbo-go/common/proxy/proxy_factory"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/protocol"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/filter/impl"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/cluster_impl"</span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/loadbalance"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/zookeeper"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>由于我是接入客户端，所以我这边只需要配置 <code>ConsumerConfig</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    # client</span><br><span class="line">    request_timeout: "3s"</span><br><span class="line">    # connect timeout</span><br><span class="line">    connect_timeout: "3s"</span><br><span class="line">    check: true</span><br><span class="line">    application:</span><br><span class="line">        organization: "wssjdi.com"</span><br><span class="line">        name: "soa.sso.ITokenService"</span><br><span class="line">        module: "dubbogo token service client"</span><br><span class="line">        version: "1.0.0"</span><br><span class="line">        owner: "wssjdi"</span><br><span class="line">    registries:</span><br><span class="line">        "localzk":</span><br><span class="line">            protocol: "zookeeper"</span><br><span class="line">            timeout: "3s"</span><br><span class="line">            address: "10.100.156.17:2181"</span><br><span class="line">            username: ""</span><br><span class="line">            password: ""</span><br><span class="line">    references:</span><br><span class="line">        "ITokenService":</span><br><span class="line">            registry: "localzk"</span><br><span class="line">            protocol: "dubbo"</span><br><span class="line">            interface: "com.wssjdi.soa.sso.ITokenService"</span><br><span class="line">            version: "1.0.0"</span><br><span class="line">            methods:</span><br><span class="line">                - name: "validate"</span><br><span class="line">            retries: "3"</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go dubbo</tag>
        <tag>dubbo</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>go 语言基础</title>
    <url>/posts/f628ea56/</url>
    <content><![CDATA[<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p><code>Go</code>语言是静态类型语言，因此变量<code>（variable）</code>是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。</p>
<p>声明变量的一般形式是使用 <code>var</code> 关键字：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name type</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>var</code> 是声明变量的关键字，<code>name</code> 是变量名，<code>type</code> 是变量的类型。</p>
<p>需要注意的是，<code>Go</code>语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b</code>; 。其中只有 <code>a</code> 是指针而 <code>b</code> 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 <code>Go</code> 中，则可以和轻松地将它们都声明为指针类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b *int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Go语言的基本类型有：</p>
<ul>
<li>bool</li>
<li>string</li>
<li>int、int8、int16、int32、int64</li>
<li>uint、uint8、uint16、uint32、uint64、uintptr</li>
<li>byte // uint8 的别名</li>
<li>rune // int32 的别名 代表一个 Unicode 码</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
</ul>
<p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code> 等。所有的内存在 <code>Go</code> 中都是经过初始化的。</p>
<p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code> 。</p>
<p>变量的声明有几种形式，通过下面几节进行整理归纳。</p>
<h3 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></tbody></table></figure>
<p>变量声明以关键字 var 开头，后置变量类型，行尾无须分号。</p>
<h3 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h3><p>觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">    c []float32</span><br><span class="line">    d func() bool</span><br><span class="line">    e struct {</span><br><span class="line">        x int</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>使用关键字 var 和括号，可以将一组变量定义放在一起。</p>
<h3 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h3><p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，简短模式<code>（short variable declaration）</code>有以下限制：</p>
<ul>
<li>定义变量，同时显式初始化。</li>
<li>不能提供数据类型。</li>
<li>只能用在函数内部。</li>
</ul>
<p>和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i, j := 0, 1</span><br></pre></td></tr></tbody></table></figure>
<p>演示简短格式变量声明的基本样式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">   x:=100</span><br><span class="line">   a,s:=1, "abc"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。<code>var</code> 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p><code>Go</code>语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p>
<ul>
<li>整型和浮点型变量的默认值为 <code>0</code> 和 <code>0.0</code>。</li>
<li>字符串变量的默认值为空字符串。</li>
<li>布尔型变量默认为 <code>bool</code>。</li>
<li>切片、函数、指针变量的默认为 <code>nil</code>。</li>
</ul>
<p>当然，依然可以在变量声明时赋予变量一个初始值。</p>
<p>回顾C语言</p>
<p>在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。</p>
<p>在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/C++ 中变量默认不初始化。</p>
<p>微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。</p>
<p>因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。</p>
<h3 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 类型 = 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>例如，游戏中，玩家的血量初始值为100。可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp int = 100</span><br></pre></td></tr></tbody></table></figure>
<p>这句代码中，<code>hp</code> 为变量名，类型为 <code>int</code>，<code>hp</code> 的初始值为 <code>100</code>。</p>
<p>上面代码中，<code>100</code> 和 <code>int</code> 同为 <code>int</code> 类型，<code>int</code> 可以认为是冗余信息，因此可以进一步简化初始化的写法。</p>
<h3 id="编译器推导类型的格式"><a href="#编译器推导类型的格式" class="headerlink" title="编译器推导类型的格式"></a>编译器推导类型的格式</h3><p>在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp = 100</span><br></pre></td></tr></tbody></table></figure>
<p>等号右边的部分在编译原理里被称做右值（rvalue）。</p>
<p>编译器根据右值推导变量类型完成初始化的例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var attack = 40</span><br><span class="line">var defence = 20</span><br><span class="line">var damageRate float32 = 0.17</span><br><span class="line">var damage = float32(attack-defence) * damageRate</span><br><span class="line">fmt.Println(damage)</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 和 <code>2</code> 行，右值为整型，<code>attack</code> 和 <code>defence</code> 变量的类型为 int。</li>
<li>第 <code>3</code> 行，表达式的右值中使用了 <code>0.17</code>。由于<code>Go</code>语言和<code>C</code>语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 <code>damageRate</code> 变量的类型，<code>Go</code>语言编译器会将 <code>damageRate</code> 类型推导为 <code>float64</code>，我们这里不需要 <code>float64</code> 的精度，所以需要强制指定类型为 <code>float32</code>。</li>
<li><p>第 <code>4</code> 行，将 <code>attack</code> 和 <code>defence</code> 相减后的数值结果依然为整型，使用 <code>float32()</code> 将结果转换为 <code>float32</code> 类型，再与 <code>float32</code> 类型的 <code>damageRate</code> 相乘后，<code>damage</code> 类型也是 <code>float32</code> 类型。</p>
<p><strong><em>提示：<code>damage</code> 变量的右值是一个复杂的表达式，整个过程既有 <code>attack</code> 和 <code>defence</code> 的运算还有强制类型转换。</em></strong></p>
</li>
<li><p>第 5 行，输出 <code>damage</code> 的值。</p>
</li>
</ul>
<p>以上代码输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p><code>var</code> 的变量声明还有一种更为精简的写法，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hp := 100</span><br></pre></td></tr></tbody></table></figure>
<p>这是<code>Go</code>语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。</p>
<p><strong><em>注意：由于使用了<code>:=</code>，而不是赋值的<code>=</code>，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。</em></strong></p>
<p>如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明 hp 变量</span><br><span class="line">var hp int</span><br><span class="line">// 再次声明并赋值</span><br><span class="line">hp := 10</span><br></pre></td></tr></tbody></table></figure>
<p>编译报错:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">no new variables on left side of :=</span><br></pre></td></tr></tbody></table></figure>
<p>翻译过来是在<code>:=</code>的左边没有新变量出现，意思就是<code>:=</code>的左边变量已经被声明了。</p>
<p>短变量声明的形式在开发中的例子较多，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp","127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p><code>net.Dial</code> 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象<code>（conn）</code>，一个是错误对象<code>（err）</code>。如果是标准格式将会变成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var conn net.Conn</span><br><span class="line">var err error</span><br><span class="line">conn, err = net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>因此，短变量声明并初始化的格式在开发中使用比较普遍。</p>
<p><strong><em>注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp", "127.0.0.1:8080")</span><br><span class="line">conn2, err := net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码片段，编译器不会报 err 重复定义</p>
<h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h2><p>编程最简单的算法之一，莫过于变量交换。交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">var t int</span><br><span class="line">t = a</span><br><span class="line">a = b</span><br><span class="line">b = t</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>这样的算法很多，但是都有一定的数值范围和类型要求。</p>
<p>到了<code>Go</code>语言时，内存不再是紧缺资源，而且写法可以更简单。使用 <code>Go</code> 的“多重赋值”特性，可以轻松完成变量交换的任务：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">b, a = a, b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>多重赋值时，变量的左值和右值按从左到右的顺序赋值。</p>
<p>多重赋值在<code>Go</code>语言的错误处理和函数返回值中会大量地使用。例如使用<code>Go</code>语言进行排序时就需要使用交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，将 <code>IntSlice</code> 声明为 <code>[]int</code> 类型。</li>
<li>第 <code>3</code> 行，为 <code>IntSlice</code> 类型编写一个 <code>Len</code> 方法，提供切片的长度。</li>
<li>第 <code>4</code> 行，根据提供的 <code>i、j</code> 元素索引，获取元素后进行比较，返回比较结果。</li>
<li>第 <code>5</code> 行，根据提供的 <code>i、j</code> 元素索引，交换两个元素的值。</li>
</ul>
<h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。</p>
<p>匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func GetData() (int, int) {</span><br><span class="line">    return 100, 200</span><br><span class="line">}</span><br><span class="line">func main(){</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100 200</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行<code>GetData()</code> 是一个函数，拥有两个整型返回值。每次调用将会返回 <code>100</code> 和 <code>200</code> 两个数值。</li>
<li>第 <code>5</code> 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。</li>
<li>第 <code>6</code> 行将第一个返回值的变量设为匿名变量。</li>
</ul>
<p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<p>提示：在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。</p>
<p>了解变量的作用域对我们学习<code>Go</code>语言来说是比较重要的，因为<code>Go</code>语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。</p>
<p>根据变量定义位置的不同，可以分为以下三个类型：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>下面就来分别介绍一下。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。</p>
<p>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。</p>
<p>【示例】下面的 <code>main()</code> 函数中使用到了局部变量 <code>a、b、c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量 a 和 b 并赋值</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    //声明局部变量 c 并计算 a 和 b 的和</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用<code>import</code>关键字引入全局变量所在的源文件之后才能使用这个全局变量。</p>
<p>全局变量声明必须以 <code>var</code> 关键字开头，<strong><em>如果想要在外部包中使用全局变量的首字母必须大写</em></strong>。</p>
<p>【示例】下面代码中，第 <code>4</code> 行定义了全局变量 <code>c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var c int</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a, b int</span><br><span class="line">    //初始化参数</span><br><span class="line">    a = 3</span><br><span class="line">    b = 4</span><br><span class="line">    c = a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，<strong><em>但是函数体内的局部变量会被优先考虑</em></strong>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a int = 3</span><br><span class="line">    fmt.Printf("a = %d\n", a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3</span><br></pre></td></tr></tbody></table></figure>
<h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p>
<p>形式参数会作为函数的局部变量来使用。</p>
<p>【示例】下面代码中第 <code>16</code> 行定义了形式参数 <code>a</code> 和 <code>b</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">//全局变量 a</span><br><span class="line">var a int = 13</span><br><span class="line">func main() {</span><br><span class="line">    //局部变量 a 和 b</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    fmt.Printf("main() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("main() 函数中 b = %d\n", b)</span><br><span class="line">    c := sum(a, b)</span><br><span class="line">    fmt.Printf("main() 函数中 c = %d\n", c)</span><br><span class="line">}</span><br><span class="line">func sum(a, b int) int {</span><br><span class="line">    fmt.Printf("sum() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("sum() 函数中 b = %d\n", b)</span><br><span class="line">    num := a + b</span><br><span class="line">    return num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main() 函数中 a = 3</span><br><span class="line">main() 函数中 b = 4</span><br><span class="line">sum() 函数中 a = 3</span><br><span class="line">sum() 函数中 b = 4</span><br><span class="line">main() 函数中 c = 7</span><br></pre></td></tr></tbody></table></figure>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 <code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。</p>
<p><code>Go</code>语言同时提供了有符号和无符号的整数类型，其中包括 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 四种大小截然不同的有符号整数类型，分别对应 <code>8</code>、<code>16</code>、<code>32</code>、<code>64 bit</code>（二进制位）大小的有符号整数，与此对应的是 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 四种无符号整数类型。</p>
<p>此外还有两种整数类型 <code>int</code> 和 <code>uint</code>，它们分别对应特定 <code>CPU</code> 平台的字长（机器字大小），其中 <code>int</code> 表示有符号整数，应用最为广泛，<code>uint</code> 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，<code>int</code> 和 <code>uint</code> 所能表示的整数大小会在 <code>32bit</code> 或 <code>64bit</code> 之间变化。</p>
<p>大多数情况下，我们只需要 <code>int</code> 一种整型即可，它可以用于循环计数器（<code>for</code> 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 <code>int</code> 类型的处理速度也是最快的。</p>
<p>用来表示 <code>Unicode</code> 字符的 <code>rune</code> 类型和 <code>int32</code> 类型是等价的，通常用于表示一个 <code>Unicode</code> 码点。这两个名称可以互换使用。同样，<code>byte</code> 和 <code>uint8</code> 也是等价类型，<code>byte</code> 类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>最后，还有一种无符号的整数类型 <code>uintptr</code>，它没有指定具体的 <code>bit</code> 大小但是足以容纳指针。<code>uintptr</code> 类型只有在底层编程时才需要，特别是<code>Go</code>语言和<code>C</code>语言函数库或操作系统接口相交互的地方。</p>
<p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，比如 <code>int</code> 和 <code>int32</code>，虽然 <code>int</code> 类型的大小也可能是 <code>32 bit</code>，但是在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换，反之亦然。</p>
<p><code>Go</code>语言中有符号整数采用 <code>2</code> 的补码形式表示，也就是最高 <code>bit</code> 位用来表示符号位，一个 <code>n-bit</code> 的有符号数的取值范围是从 <code>-2(n-1)</code> 到 <code>2(n-1)-1</code>。无符号整数的所有 <code>bit</code> 位都用于表示非负数，取值范围是 <code>0</code> 到 <code>2n-1</code>。例如，<code>int8</code> 类型整数的取值范围是从 <code>-128</code> 到 <code>127</code>，而 <code>uint8</code> 类型整数的取值范围是从 <code>0</code> 到 <code>255</code>。</p>
<h3 id="哪些情况下使用-int-和-uint"><a href="#哪些情况下使用-int-和-uint" class="headerlink" title="哪些情况下使用 int 和 uint"></a>哪些情况下使用 <code>int</code> 和 <code>uint</code></h3><p>程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 <code>map</code> 的元素数量等都可以用 int 来表示。</p>
<p>反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 <code>int</code> 和 <code>uint</code>。</p>
<h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p><code>Go</code>语言提供了两种精度的浮点数 <code>float32</code> 和 <code>float64</code>，它们的算术规范由 <code>IEEE754</code> 浮点数国际标准定义，该浮点数规范被所有现代的 <code>CPU</code> 支持。</p>
<p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 <code>math</code> 包中找到：</p>
<ul>
<li>常量 <code>math.MaxFloat32</code> 表示 <code>float32</code> 能取到的最大数值，大约是 <code>3.4e38</code>；</li>
<li>常量 <code>math.MaxFloat64</code> 表示 <code>float64</code> 能取到的最大数值，大约是 <code>1.8e308</code>；</li>
<li><code>float32</code> 和 <code>float64</code> 能表示的最小值分别为 <code>1.4e-45</code> 和 <code>4.9e-324</code>。</li>
</ul>
<p>一个 <code>float32</code> 类型的浮点数可以提供大约 <code>6</code> 个十进制数的精度，而 <code>float64</code> 则可以提供约 <code>15</code> 个十进制数的精度，通常应该优先使用 <code>float64</code> 类型，因为 <code>float32</code> 类型的累计计算误差很容易扩散，并且 <code>float32</code> 能精确表示的正整数并不是很大。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var f float32 = 16777216 // 1 &lt;&lt; 24</span><br><span class="line">fmt.Println(f == f+1)    // "true"!</span><br></pre></td></tr></tbody></table></figure>
<p>浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const e = .71828 // 0.71828</span><br><span class="line">const f = 1.     // 1</span><br></pre></td></tr></tbody></table></figure>
<p>很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：</p>
<figure class="highlight plain"><figcaption><span>e 或 E 来指定指数部分</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数</span><br><span class="line">const Planck   = 6.62606957e-34 // 普朗克常数</span><br></pre></td></tr></tbody></table></figure>
<p>用 Printf 函数打印浮点数时可以使用<code>%f</code>来控制保留几位小数:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%f\n", math.Pi)</span><br><span class="line">    fmt.Printf("%.2f\n", math.Pi)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.141593</span><br><span class="line">3.14</span><br></pre></td></tr></tbody></table></figure>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>在计算机中，复数是由两个浮点数表示的，其中一个表示实部<code>（real）</code>，一个表示虚部<code>（imag）</code>。</p>
<p><code>Go</code>语言中复数的类型有两种，分别是  <code>complex128（64 位实数和虚数）</code> 和 <code>complex64（32 位实数和虚数）</code>，其中 <code>complex128</code> 为复数的默认类型。</p>
<p>复数的值由三部分组成 <code>RE</code> + <code>IMi</code>，其中 <code>RE</code> 是实数部分，<code>IM</code> 是虚数部分，<code>RE</code> 和 <code>IM</code> 均为 <code>float</code> 类型，而最后的 <code>i</code> 是虚数单位。</p>
<p>声明复数的语法格式如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name complex128 = complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>name</code> 为复数的变量名，<code>complex128</code> 为复数的类型，<code>=</code> 后面的 <code>complex</code> 为 <code>Go</code> 语言的内置函数用于为复数赋值，<code>x</code> 、<code>y</code> 分别表示构成该复数的两个 <code>float64</code> 类型的数值，<code>x</code> 为实部，<code>y</code> 为虚部。</p>
<p>上面的声明语句也可以简写为下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name := complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个复数 <code>z := complex(x, y)</code>，可以通过 <code>Go</code> 语言的内置函数 <code>real(z)</code> 来获得该复数的实部，也就是 <code>x</code> ；通过 <code>imag(z)</code> 获得该复数的虚部，也就是 <code>y</code> 。</p>
<p>【示例】使用内置的 <code>complex</code> 函数构建复数，并使用 <code>real</code> 和 <code>imag</code> 函数返回复数的实部和虚部：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x complex128 = complex(1, 2) // 1+2i</span><br><span class="line">var y complex128 = complex(3, 4) // 3+4i</span><br><span class="line">fmt.Println(x*y)                 // "(-5+10i)"</span><br><span class="line">fmt.Println(real(x*y))           // "-5"</span><br><span class="line">fmt.Println(imag(x*y))           // "10"</span><br></pre></td></tr></tbody></table></figure>
<p>如果大家对复数的运算法则不是很了解，可以查阅<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin">《复数运算法则》</a>，其中详细的讲解了复数的加减乘除操作。</p>
<p>复数也可以用 <code>==</code> 和 <code>!=</code> 进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。</p>
<p><code>Go</code> 语言内置的 <code>math/cmplx</code> 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 <code>complex128</code> 类型，因为这些内置的包中都使用 <code>complex128</code> 类型作为参数。</p>
<h2 id="输出正弦函数-（Sin）-图像"><a href="#输出正弦函数-（Sin）-图像" class="headerlink" title="输出正弦函数 （Sin） 图像"></a>输出正弦函数 <code>（Sin）</code> 图像</h2><p>在 <code>Go</code> 语言中，正弦函数由 <code>math</code> 包提供，函数入口为 <code>math.Sin</code> ，正弦函数的参数为 <code>float64</code> ，返回值也是 <code>float64</code> 。在使用正弦函数时，根据实际精度可以进行转换。</p>
<p><code>Go</code> 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 <code>JPEG</code>、<code>PNG</code>、<code>GIF</code> 等。</p>
<p>首先给出本节完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/png"</span><br><span class="line">    "log"</span><br><span class="line">    "math"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 图片大小</span><br><span class="line">    const size = 300</span><br><span class="line"></span><br><span class="line">    // 根据给定大小创建灰度图</span><br><span class="line">    pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">    // 遍历每个像素</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        for y := 0; y &lt; size; y++ {</span><br><span class="line">            // 填充为白色</span><br><span class="line">            pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 从0到最大像素生成x坐标</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        // 让sin的值的范围在0~2Pi之间</span><br><span class="line">        s := float64(x) * 2 * math.Pi / size</span><br><span class="line">        // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">        y := size/2 - math.Sin(s)*size/2</span><br><span class="line">        // 用黑色绘制sin轨迹</span><br><span class="line">        pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">    }</span><br><span class="line">    // 创建文件</span><br><span class="line">    file, err := os.Create("sin.png")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    // 使用png格式将数据写入文件</span><br><span class="line">    png.Encode(file, pic) //将image信息写入文件中</span><br><span class="line">    // 关闭文件</span><br><span class="line">    file.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="设置图片背景色"><a href="#设置图片背景色" class="headerlink" title="设置图片背景色"></a>设置图片背景色</h3><p>以下是设置图片背景的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 图片大小</span><br><span class="line">const size = 300</span><br><span class="line"></span><br><span class="line">// 根据给定大小创建灰度图</span><br><span class="line">pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">// 遍历每个像素</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line">    for y := 0; y &lt; size; y++ {</span><br><span class="line">        // 填充为白色</span><br><span class="line">        pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，声明一个 <code>size</code> 常量，值为 <code>300</code>。</li>
<li>第 <code>5</code> 行，使用 <code>image</code> 包的 <code>NewGray()</code> 函数创建一个图片对象，使用区域由 <code>image.Rect</code> 结构提供，<code>image.Rect</code> 描述一个方形的两个定位点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> ，<code>image.Rect(0,0,size,size)</code> 表示使用完整灰度图像素，尺寸为宽 <code>300</code>，长 <code>300</code>。</li>
<li>第 <code>8</code> 行和第 <code>9</code> 行，遍历灰度图的所有像素。</li>
<li>第 <code>11</code> 行，将每一个像素的灰度设为 <code>255</code> ，也就是白色。</li>
</ul>
<p>灰度图是一种常见的图片格式，一般情况下颜色由 <code>8</code> 位组成，灰度范围为 <code>0～255</code> ，<code>0</code> 表示黑色，<code>255</code> 表示白色。</p>
<p>初始化好的灰度图默认的灰度值都是 <code>0</code> ，对的是黑色，由于显示效果的效果不是很好，所以这里将所有像素设置为 <code>255</code>，也就是白色。</p>
<h3 id="绘制正弦函数轨迹"><a href="#绘制正弦函数轨迹" class="headerlink" title="绘制正弦函数轨迹"></a>绘制正弦函数轨迹</h3><p>正弦函数是一个周期函数，定义域是实数集，取值范围是 <code>[-1, 1]</code>。用编程的通俗易懂的话来说就是：<code>math.Sin</code> 函数的参数支持任意浮点数范围，函数返回值的范围总是在 <code>-1～1</code> 之间（包含 <code>1</code>、<code>-1</code>）。</p>
<p>要将正弦函数放在图片上需要考虑以下一些因素：</p>
<ul>
<li><code>math.Sin</code> 的返回值在 <code>-1～1</code> 之间，需要考虑将正弦的输出幅度变大，可以将 <code>math.Sin</code> 的返回值乘以一个常量进行放大。</li>
<li>图片的坐标系原点在左上角，而 <code>math.Sin</code> 基于笛卡尔坐标系原点在左下角，需要对图像进行上下翻转和平移。</li>
</ul>
<p>将这些处理逻辑汇总为代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 从0到最大像素生成x坐标</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line"></span><br><span class="line">    // 让sin的值的范围在0~2Pi之间</span><br><span class="line">    s := float64(x) * 2 * math.Pi / size</span><br><span class="line"></span><br><span class="line">    // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">    y := size/2 - math.Sin(s)*size/2</span><br><span class="line"></span><br><span class="line">    // 用黑色绘制sin轨迹</span><br><span class="line">    pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，生成 <code>0</code> 到 <code>size（300）</code> 的 x 坐标轴。</li>
<li><p>第 <code>5</code> 行，计算 <code>math.Sin</code> 的定义域，这段代码等效为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rate := x / size</span><br><span class="line">s := rate * 2 * math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p><code>x</code> 的范围是 <code>0</code> 到 <code>size</code> ，因此除以 <code>size</code> 后，<code>rate</code> 的范围是 <code>0～1</code> 之间，再乘以 <code>2π</code> 后，<code>s</code> 的范围刚好是 <code>0～2π</code> 之间。</p>
<p><code>float64(x)</code> 表示将整型的 <code>x</code> 变量转换为 <code>float64</code> 类型，之后运算的所有表达式将以 <code>float64</code> 类型进行。</p>
</li>
<li><p>第 <code>8</code> 行中，<code>math.Sin(s)*size/2</code> 表示将正弦函数的返回值幅度从 <code>1</code> 扩大到二分之一的 <code>size</code> 。负号表示将正弦函数图形以图形中心上下翻转。叠加 <code>size/2</code> 表示将图形在 <code>y</code> 轴上向下偏移二分之一的 <code>size</code>（图片坐标系的 <code>y</code> 向下）。</p>
</li>
<li>第 <code>11</code> 行将计算好的 <code>x</code> 轴和 <code>y</code> 轴数据，以灰度为 <code>0</code>（黑色）使用 <code>SetGray()</code> 方法填充到像素中。</li>
</ul>
<p>写入图片的正弦函数图像如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sinImage.png" alt="正弦图片"></p>
<h3 id="写入图片文件"><a href="#写入图片文件" class="headerlink" title="写入图片文件"></a>写入图片文件</h3><p>内存中的正弦函数图形是不可见的，我们选用 <code>PNG</code> 格式将图形输出为文件，<code>Go</code> 语言提供了文件创建函数和 <code>PNG</code> 格式写入函数，代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">file, err := os.Create("sin.png")</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">// 使用PNG格式将数据写入文件</span><br><span class="line">png.Encode(file, pic)  //将image信息写入文件中</span><br><span class="line"></span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，创建 <code>sin.png</code> 的文件。</li>
<li>第 <code>4</code> 行，如果创建文件失败，返回错误，打印错误并终止。</li>
<li>第 <code>8</code> 行，使用 <code>PNG</code> 包，将图形对象写入文件中。</li>
<li>第 <code>11</code> 行，关闭文件。</li>
</ul>
<h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>一个布尔类型的值只有两种：<code>true</code> 或 <code>false</code>。<code>if</code> 和 <code>for</code> 语句的条件部分都是布尔类型的值，并且 <code>==</code> 和 <code>&lt;</code> 等比较操作也会产生布尔型的值。</p>
<p>一元操作符 <code>!</code> 对应逻辑非操作，因此 <code>!true</code> 的值为 <code>false</code>，更复杂一些的写法是 <code>(!true==false) == true</code>，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 <code>x</code> 来表示 <code>x==true</code> 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var aVar = 10</span><br><span class="line">aVar == 5  // false</span><br><span class="line">aVar == 10 // true</span><br><span class="line">aVar != 5  // true</span><br><span class="line">aVar != 10 // false</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口<code>（interface）</code>，那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。</p>
<p>布尔值可以和 <code>&amp;&amp;（AND）</code> 和 <code>||（OR）</code> 操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s != "" &amp;&amp; s[0] == 'x'</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>s[0]</code> 操作如果应用于空字符串将会导致 <code>panic</code> 异常。</p>
<p>因为 <code>&amp;&amp;</code> 的优先级比 <code>||</code> 高（ <code>&amp;&amp;</code> 对应逻辑乘法，<code>||</code> 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if 'a' &lt;= c &amp;&amp; c &lt;= 'z' ||</span><br><span class="line">    'A' &lt;= c &amp;&amp; c &lt;= 'Z' ||</span><br><span class="line">    '0' &lt;= c &amp;&amp; c &lt;= '9' {</span><br><span class="line">    // ...ASCII字母或数字...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>布尔值并不会隐式转换为数字值 <code>0</code> 或 <code>1</code>，反之亦然，必须使用 <code>if</code> 语句显式的进行转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">if b {</span><br><span class="line">    i = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 如果b为真，btoi返回1；如果为假，btoi返回0</span><br><span class="line">func btoi(b bool) int {</span><br><span class="line">    if b {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line">    return 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// itob报告是否为非零。</span><br><span class="line">func itob(i int) bool { return i != 0 }</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code> 语言中不允许将整型强制转换为布尔型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var n bool</span><br><span class="line">fmt.Println(int(n) * 2)</span><br></pre></td></tr></tbody></table></figure>
<p>编译错误，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot convert n (type bool) to type int</span><br></pre></td></tr></tbody></table></figure>
<p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 <code>UTF-8</code> 字符的一个序列（当字符为 <code>ASCII</code> 码表上的字符时则占用 <code>1</code> 个字节，其它字符根据需要占用 <code>2-4</code> 个字节）。</p>
<p><code>UTF-8</code> 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 <code>XML</code> 和 <code>JSON</code> 在内也都使用该编码。由于该编码对占用字节长度的不定性，在 <code>Go</code> 语言中字符串也可能根据需要占用 <code>1</code> 至 <code>4</code> 个字节，这与其它编程语言如 <code>C++</code> 、<code>Java</code> 或者 <code>Python</code> 不同（<code>Java</code> 始终使用 <code>2</code> 个字节）。<code>Go</code> 语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 <code>UTF-8</code> 字符集的文本进行编码和解码。</p>
<p>字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。</p>
<h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>可以使用双引号 <code>""</code> 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p>
<ul>
<li>\n：换行符</li>
<li>\r：回车符</li>
<li>\t：tab 键</li>
<li>\u 或 \U：Unicode 字符</li>
<li>\：反斜杠自身</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var str = "Hello\nGo World~!"</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Go World~!</span><br></pre></td></tr></tbody></table></figure>
<p>一般的比较运算符 <code>（==、!=、&lt;、&lt;=、&gt;=、&gt;）</code> 是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 <code>len()</code> 来获取，例如 <code>len(str)</code>。</p>
<p>字符串的内容（纯字节）可以通过标准索引法来获取，在方括号 <code>[ ]</code> 内写入索引，索引从 <code>0</code> 开始计数：</p>
<ul>
<li>字符串 <code>str</code> 的第 <code>1</code> 个字节：<code>str[0]</code></li>
<li>第 <code>i</code> 个字节：<code>str[i - 1]</code></li>
<li>最后 <code>1</code> 个字节：<code>str[len(str)-1]</code></li>
</ul>
<p>需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。</p>
<p><strong><em>注意：获取字符串中某个字节的地址属于非法行为，例如 <code>&amp;str[i]</code>。</em></strong></p>
<h3 id="字符串拼接符"><a href="#字符串拼接符" class="headerlink" title="字符串拼接符 +"></a>字符串拼接符 <code>+</code></h3><p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。将 <code>s2</code> 追加到 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p>
<p>可以通过下面的方式来对代码中多行的字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := "Beginning of the string " +</span><br><span class="line">"second part of the string"</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号 <code>+</code> 必须放在第一行末尾。</em></strong></p>
<p>也可以使用 <code>+=</code> 来对字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s := "hel" + "lo,"</span><br><span class="line">s += "world!"</span><br><span class="line">fmt.Println(s) //输出 “hello, world!”</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串实现基于-UTF-8-编码"><a href="#字符串实现基于-UTF-8-编码" class="headerlink" title="字符串实现基于 UTF-8 编码"></a>字符串实现基于 <code>UTF-8</code> 编码</h3><p><code>Go</code> 语言中字符串的内部实现使用 <code>UTF-8</code> 编码，通过 <code>rune</code> 类型，可以方便地对每个 <code>UTF-8</code> 字符进行访问。当然，<code>Go</code> 语言也支持按照传统的 <code>ASCII</code> 码方式逐字符进行访问。</p>
<p>关于字符串的 <code>UTF-8</code> 字符访问的详细方法，后面的章节将会详细介绍。</p>
<h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在 <code>Go</code> 语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量<code>（string literal）</code> ，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用 ` 反引号，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const str = `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br><span class="line">`</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br></pre></td></tr></tbody></table></figure>
<p>反引号`，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p>
<p>在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<p>多行字符串一般用于内嵌源码和内嵌数据等，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const codeTemplate = `// Generated by github.com/davyxu/cellnet/</span><br><span class="line">protoc-gen-msg</span><br><span class="line">// DO NOT EDIT!{{range .Protos}}</span><br><span class="line">// Source: {{.Name}}{{end}}</span><br><span class="line">package {{.PackageName}}</span><br><span class="line">{{if gt .TotalMessages 0}}</span><br><span class="line">import (</span><br><span class="line">    "github.com/davyxu/cellnet"</span><br><span class="line">    "reflect"</span><br><span class="line">    _ "github.com/davyxu/cellnet/codec/pb"</span><br><span class="line">)</span><br><span class="line">{{end}}</span><br><span class="line">func init() {</span><br><span class="line">    {{range .Protos}}</span><br><span class="line">    // {{.Name}}{{range .Messages}}</span><br><span class="line">    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}</span><br><span class="line">    {{end}}</span><br><span class="line">}</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码只定义了一个常量 codeTemplate，类型为字符串，使用`定义，字符串的内容为一段代码生成中使用到的 Go 源码格式。</p>
<p>在 ` 间的所有代码均不会被编译器识别，而只是作为字符串的一部分。</p>
<p>字符串类型在业务中的应用可以说是最广泛的，读者需要详细了解字符串的常见用法，请猛击下面的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/36.html">Go语言计算字符串长度——len()和RuneCountInString()</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/37.html">Go语言遍历字符串——获取每一个字符串元素</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/38.html">Go语言字符串截取（获取字符串的某一段字符）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/39.html">Go语言修改字符串</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/40.html">Go语言字符串拼接（连接）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/41.html">Go语言fmt.Sprintf（格式化输出）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/42.html">Go语言Base64编码——电子邮件的基础编码格式</a></li>
</ul>
<h2 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h2><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p>
<p>Go语言的字符有以下两种：</p>
<ul>
<li>一种是 <code>uint8</code> 类型，或者叫 <code>byte</code> 型，代表了 <code>ASCII</code> 码的一个字符。</li>
<li>另一种是 <code>rune</code> 类型，代表一个 <code>UTF-8</code> 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 <code>rune</code> 类型。<code>rune</code> 类型等价于 int32 类型。</li>
</ul>
<p><code>byte</code> 类型是 <code>uint8</code> 的别名，对于只占用 <code>1</code> 个字节的传统 <code>ASCII</code> 编码的字符来说，完全没有问题，例如 <code>var ch byte = 'A'</code>，字符使用单引号括起来。</p>
<p>在 <code>ASCII</code> 码表中，<code>A</code> 的值是 <code>65</code>，使用 <code>16</code> 进制表示则为 <code>41</code>，所以下面的写法是等效的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）</span><br></pre></td></tr></tbody></table></figure>
<p>另外一种可能的写法是 <code>\</code> 后面紧跟着长度为 <code>3</code> 的八进制数，例如 \377。</p>
<p><code>Go</code>语言同样支持 <code>Unicode（UTF-8）</code>，因此字符同样称为 <code>Unicode</code> 代码点或者 <code>runes</code> ，并在内存中使用 <code>int</code> 来表示。在文档中，一般使用格式 <code>U+hhhh</code> 来表示，其中 <code>h</code> 表示一个 <code>16</code> 进制数。</p>
<p>在书写 <code>Unicode</code> 字符时，需要在 <code>16</code> 进制数之前加上前缀 <code>\u</code> 或者 <code>\U</code> 。因为 <code>Unicode</code> 至少占用 <code>2</code> 个字节，所以我们使用 <code>int16</code> 或者 <code>int</code> 类型来表示。如果需要使用到 <code>4</code> 字节，则使用 <code>\u</code> 前缀，如果需要使用到 <code>8</code> 个字节，则使用 <code>\U</code> 前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch int = '\u0041'</span><br><span class="line">var ch2 int = '\u03B2'</span><br><span class="line">var ch3 int = '\U00101234'</span><br><span class="line">fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer</span><br><span class="line">fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character</span><br><span class="line">fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes</span><br><span class="line">fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">65 - 946 - 1053236</span><br><span class="line">A - β - r</span><br><span class="line">41 - 3B2 - 101234</span><br><span class="line">U+0041 - U+03B2 - U+101234</span><br></pre></td></tr></tbody></table></figure>
<p>格式化说明符 <code>%c</code> 用于表示字符，当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数，<code>%U</code> 输出格式为 <code>U+hhhh</code> 的字符串。</p>
<p><code>Unicode</code> 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 <code>ch</code> 代表字符）：</p>
<ul>
<li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li>
<li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li>
<li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li>
</ul>
<h3 id="UTF-8-和-Unicode-有何区别"><a href="#UTF-8-和-Unicode-有何区别" class="headerlink" title="UTF-8 和 Unicode 有何区别"></a>UTF-8 和 Unicode 有何区别</h3><p><code>Unicode</code> 与 <code>ASCII</code> 类似，都是一种字符集。</p>
<p>字符集为每个字符分配一个唯一的 <code>ID</code>，我们使用到的所有字符在 <code>Unicode</code> 字符集中都有一个唯一的 <code>ID</code>，例如上面例子中的 <code>a</code> 在 <code>Unicode</code> 与 <code>ASCII</code> 中的编码都是 <code>97</code>。汉字 <code>你</code> 在 <code>Unicode</code> 中的编码为 <code>20320</code>，在不同国家的字符集中，字符所对应的 <code>ID</code> 也会不同。而无论任何情况下，<code>Unicode</code> 中的字符的 <code>ID</code> 都是不会变化的。</p>
<p><code>UTF-8</code> 是编码规则，将 <code>Unicode</code> 中字符的 <code>ID</code> 以某种方式进行编码，<code>UTF-8</code> 的是一种变长编码规则，从 <code>1</code> 到 <code>4</code> 个字节不等。编码规则如下：</p>
<ul>
<li><code>0xxxxxx</code> 表示文字符号 <code>0～127</code>，兼容 <code>ASCII</code> 字符集。</li>
<li>从 <code>128</code> 到 <code>0x10ffff</code> 表示其他字符。</li>
</ul>
<p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 <code>3</code> 个字节。</p>
<p>广义的 <code>Unicode</code> 指的是一个标准，它定义了字符集及编码规则，即 <code>Unicode</code> 字符集和 <code>UTF-8</code>、<code>UTF-16</code> 编码等。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 <code>Go</code> 语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></tbody></table></figure>
<p>类型 <code>B</code> 的值 = 类型 <code>B</code> (类型 <code>A</code> 的值)</p>
<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></tbody></table></figure>
<p>类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 <code>int16</code> 转换为 <code>int32</code>）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 <code>int32</code> 转换为 <code>int16</code> 或将 <code>float32</code> 转换为 <code>int</code> ），会发生精度丢失（截断）的情况。</p>
<p>只有相同底层类型的变量之间可以进行相互转换（如将 <code>int16</code> 类型转换成 <code>int32</code> 类型），不同底层类型的变量相互转换时会引发编译错误（如将 <code>boo</code>l 类型转换为 <code>int</code> 类型）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        "fmt"</span><br><span class="line">        "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">        // 输出各数值范围</span><br><span class="line">        fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)</span><br><span class="line">        fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)</span><br><span class="line">        fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)</span><br><span class="line">        fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)</span><br><span class="line"></span><br><span class="line">        // 初始化一个32位整型值</span><br><span class="line">        var a int32 = 1047483647</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int32: 0x%x %d\n", a, a)</span><br><span class="line"></span><br><span class="line">        // 将a变量数值转换为十六进制, 发生数值截断</span><br><span class="line">        b := int16(a)</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int16: 0x%x %d\n", b, b)</span><br><span class="line"></span><br><span class="line">        // 将常量保存为float32类型</span><br><span class="line">        var c float32 = math.Pi</span><br><span class="line">        // 转换为int类型, 浮点发生精度丢失</span><br><span class="line">        fmt.Println(int(c))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>11～14 行</code>，输出几个常见整型类型的数值范围。</li>
<li>第 <code>17</code> 行，声明 <code>int32</code> 类型的变量 <code>a</code> 并初始化。</li>
<li>第 <code>19</code> 行，使用 <code>fmt.Printf</code> 的 <code>%x</code> 动词将数值以十六进制格式输出，这一行输出 <code>a</code> 在转换前的 <code>32</code> 位的值。</li>
<li>第 <code>22</code> 行，将 <code>a</code> 的值转换为 <code>int16</code> 类型，也就是从 <code>32</code> 位有符号整型转换为 <code>16</code> 位有符号整型，由于 <code>int16</code> 类型的取值范围比 <code>int32</code> 类型的取值范围小，因此数值会进行截断（精度丢失）。</li>
<li>第 <code>24</code> 行，输出转换后的 <code>a</code> 变量值，也就是 <code>b</code> 的值，同样以十六进制和十进制两种方式进行打印。</li>
<li>第 <code>27</code> 行，<code>math.Pi</code> 是 <code>math</code> 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 <code>math.Pi</code> 被赋值到变量 <code>c</code> 中，因此类型为 <code>float32</code>。</li>
<li>第 <code>29</code> 行，将 <code>float32</code> 转换为 <code>int</code> 类型并输出。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int8 range: -128 127</span><br><span class="line">int16 range: -32768 32767</span><br><span class="line">int32 range: -2147483648 2147483647</span><br><span class="line">int64 range: -9223372036854775808 9223372036854775807</span><br><span class="line">int32: 0x3e6f54ff 1047483647</span><br><span class="line">int16: 0x54ff 21759</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>根据输出结果，<code>16</code> 位有符号整型的范围是 <code>-32768～32767</code>，而变量 <code>a</code> 的值 <code>1047483647</code> 不在这个范围内。<code>1047483647</code> 对应的十六进制为 <code>0x3e6f54ff</code>，转为 <code>int16</code> 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 <code>0x54ff</code>，对应的十进制值为 <code>21759</code>。</p>
<p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 <code>Java</code> 和 <code>.NET</code> 等编程语言不同，<code>Go</code> 语言为程序员提供了控制数据结构指针的能力，<strong>但是，并不能进行指针运算</strong>。<code>Go</code> 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p>
<p>指针 <code>（pointer）</code> 在 <code>Go</code> 语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。</li>
</ul>
<p>受益于这样的约束和拆分，<code>Go</code> 语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p>
<p>切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p>
<p><code>C/C++</code> 中的指针</p>
<p>说到 <code>C/C++</code> 中的指针，会让许多人“谈虎色变”，尤其是对指针的偏移、运算和转换。</p>
<p>其实，指针是 <code>C/C++</code> 语言拥有极高性能的根本所在，在操作大块数据和做偏移时即方便又便捷。因此，操作系统依然使用 <code>C</code> 语言及指针的特性进行编写。</p>
<p><code>C/C++</code> 中指针饱受诟病的根本原因是指针的运算和内存释放，<code>C/C++</code> 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域，我们的计算机操作系统经常需要更新、修复漏洞的本质，就是为解决指针越界访问所导致的“缓冲区溢出”的问题。</p>
<p>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开详细说明。</p>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 <code>32</code> 和 <code>64</code> 位机器上分别占用 <code>4</code> 或 <code>8</code> 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 <code>nil</code>。指针变量通常缩写为 <code>ptr</code> 。</p>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<code>Go</code> 语言中使用在变量名前面添加 <code>&amp;</code> 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr := &amp;v    // v 的类型为 T</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>v</code> 代表被取地址的变量，变量 <code>v</code> 的地址使用变量 <code>ptr</code> 进行接收，<code>ptr</code> 的类型为 <code>*T</code> ，称做 <code>T</code> 的指针类型，<code>*</code> 代表指针。</p>
<p>指针实际用法，可以通过下面的例子了解：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var cat int = 1</span><br><span class="line">    var str string = "banana"</span><br><span class="line">    fmt.Printf("%p %p", &amp;cat, &amp;str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，声明整型变量 <code>cat</code> 。</li>
<li>第 <code>9</code> 行，声明字符串变量 <code>str</code> 。</li>
<li>第 <code>10</code> 行，使用 <code>fmt.Printf</code> 的动词 <code>%p</code> 打印 <code>cat</code> 和 <code>str</code> 变量的内存地址，指针的值是带有 <code>0x</code> 十六进制前缀的一组数据。</li>
</ul>
<p><strong><em>提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</em></strong></p>
<h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>当使用 <code>&amp;</code> 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 <code>*</code> 操作符，也就是指针取值，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个字符串类型</span><br><span class="line">    var house = "Malibu Point 10880, 90265"</span><br><span class="line"></span><br><span class="line">    // 对字符串取地址, ptr类型为*string</span><br><span class="line">    ptr := &amp;house</span><br><span class="line"></span><br><span class="line">    // 打印ptr的类型</span><br><span class="line">    fmt.Printf("ptr type: %T\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf("address: %p\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line"></span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf("value type: %T\n", value)</span><br><span class="line"></span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf("value: %s\n", value)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，准备一个字符串并赋值。</li>
<li>第 <code>13</code> 行，对字符串取地址，将指针保存到变量 <code>ptr</code> 中。</li>
<li>第 <code>16</code> 行，打印变量 <code>ptr</code> 的类型，其类型为 <code>*string</code>。</li>
<li>第 <code>19</code> 行，打印 <code>ptr</code> 的指针地址，地址每次运行都会发生变化。</li>
<li>第 <code>22</code> 行，对 <code>ptr</code> 指针变量进行取值操作，变量 <code>value</code> 的类型为 <code>string</code> 。</li>
<li>第 <code>25</code> 行，打印取值后 <code>value</code> 的类型。</li>
<li>第 <code>28</code> 行，打印 <code>value</code> 的值。</li>
</ul>
<p>取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp;</code> 取出地址，<code>*</code> 根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址操作使用 <code>&amp;</code> 操作符，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值操作使用 <code>*</code> 操作符，可以获得指针变量指向的原变量的值。</li>
</ul>
<h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p>
<p>前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 交换函数</span><br><span class="line">func swap(a, b *int) {</span><br><span class="line"></span><br><span class="line">    // 取a指针的值, 赋给临时变量t</span><br><span class="line">    t := *a</span><br><span class="line"></span><br><span class="line">    // 取b指针的值, 赋给a指针指向的变量</span><br><span class="line">    *a = *b</span><br><span class="line"></span><br><span class="line">    // 将a指针的值赋给b指针指向的变量</span><br><span class="line">    *b = t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备两个变量, 赋值1和2</span><br><span class="line">    x, y := 1, 2</span><br><span class="line"></span><br><span class="line">    // 交换变量值</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line"></span><br><span class="line">    // 输出变量值</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，定义一个交换函数，参数为 <code>a</code> 、<code>b</code>，类型都为 <code>*int</code> 指针类型。</li>
<li>第 <code>9</code> 行，取指针 <code>a</code> 的值，并把值赋给变量 <code>t</code> ，<code>t</code> 此时是 <code>int</code> 类型。</li>
<li>第 <code>12</code> 行，取 <code>b</code> 的指针值，赋给指针 <code>a</code> 指向的变量。注意，此时 <code>*a</code> 的意思不是取 <code>a</code> 指针的值，而是<code>a 指向的变量</code> 。</li>
<li>第 <code>15</code> 行，将 <code>t</code> 的值赋给指针 <code>b</code> 指向的变量。</li>
<li>第 <code>21</code> 行，准备 <code>x</code> 、<code>y</code> 两个变量，分别赋值为 <code>1</code> 和 <code>2</code> ，类型为 <code>int</code> 。</li>
<li>第 <code>24</code> 行，取出 <code>x</code> 和 <code>y</code> 的地址作为参数传给 <code>swap()</code> 函数进行调用。</li>
<li>第 <code>27</code> 行，交换完毕时，输出 <code>x</code> 和 <code>y</code> 的值。</li>
</ul>
<p><code>*</code> 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 <code>a</code> 指针指向的变量。其实归纳起来，<code>*</code> 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p>
<p>如果在 <code>swap()</code> 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) {</span><br><span class="line">    b, a = a, b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    x, y := 1, 2</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>结果表明，交换是不成功的。上面代码中的 <code>swap()</code> 函数交换的是 <code>a</code> 和 <code>b</code> 的地址，在交换完毕后，<code>a</code> 和 <code>b</code> 的变量值确实被交换。但和 <code>a</code> 、<code>b</code> 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>
<h3 id="示例：使用指针变量获取命令行的输入信息"><a href="#示例：使用指针变量获取命令行的输入信息" class="headerlink" title="示例：使用指针变量获取命令行的输入信息"></a>示例：使用指针变量获取命令行的输入信息</h3><p><code>Go</code> 语言内置的 <code>flag</code> 包实现了对命令行参数的解析，<code>flag</code> 包使得开发命令行工具更为简单。</p>
<p>下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 <code>flag</code> 包的解析后即可获取命令行的数据。</p>
<p>【示例】获取命令行输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 导入系统包</span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义命令行参数</span><br><span class="line">var mode = flag.String("mode", "", "process mode")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 解析命令行参数</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // 输出命令行参数</span><br><span class="line">    fmt.Println(*mode)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将这段代码命名为 main.go，然后使用如下命令行运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go --mode=fast</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fast</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，通过 <code>flag.String</code>，定义一个 <code>mode</code> 变量，这个变量的类型是 <code>*string</code>。后面 <code>3</code> 个参数分别如下：<ul>
<li>参数名称：在命令行输入参数时，使用这个名称。</li>
<li>参数值的默认值：与 <code>flag</code> 所使用的函数创建变量类型对应，<code>String</code> 对应字符串、<code>Int</code> 对应整型、<code>Bool</code> 对应布尔型等。</li>
<li>参数说明：使用 <code>-help</code> 时，会出现在说明中。</li>
</ul>
</li>
<li>第 <code>15</code> 行，解析命令行参数，并将结果写入到变量 <code>mode</code> 中。</li>
<li>第 <code>18</code> 行，打印 <code>mode</code> 指针所指向的变量。</li>
</ul>
<p>由于之前已经使用 <code>flag.String</code> 注册了一个名为 <code>mode</code> 的命令行参数，<code>flag</code> 底层知道怎么解析命令行，并且将值赋给 <code>mode*string</code> 指针，在 <code>Parse</code> 调用完毕后，无须从 <code>flag</code> 获取值，而是通过自己注册的这个 <code>mode</code> 指针获取到最终的值。代码运行流程如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/pstr.jpg" alt="图：命令行参数与变量的关系"></p>
<h3 id="创建指针的另一种方法——-new-函数"><a href="#创建指针的另一种方法——-new-函数" class="headerlink" title="创建指针的另一种方法—— new() 函数"></a>创建指针的另一种方法—— <code>new()</code> 函数</h3><p><code>Go</code> 语言还提供了另外一种方法来创建指针变量，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">new(类型)</span><br></pre></td></tr></tbody></table></figure>
<p>一般这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := new(string)</span><br><span class="line">*str = "Go语言教程"</span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></tbody></table></figure>
<p><code>new()</code> 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
<h2 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h2><p>了解下计算机组成里两个非常重要的概念：堆和栈。</p>
<h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>栈只允许从线性表的同一端放入和取出数据，按照后进先出<code>（LIFO，Last InFirst Out）</code>的顺序，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/stackImage.jpg" alt="图：栈的操作及扩展"></p>
<p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p>
<p>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的元素数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除了栈顶部的成员）进行任何查看和修改操作。</p>
<p>栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。</p>
<h4 id="变量和栈有什么关系"><a href="#变量和栈有什么关系" class="headerlink" title="变量和栈有什么关系"></a>变量和栈有什么关系</h4><p>栈可用于内存分配，栈的分配和回收速度非常快。下面的代码展示了栈在内存分配上的作用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func calc(a, b int) int {</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，传入 <code>a</code> 、<code>b</code> 两个整型参数。</li>
<li>第 <code>2</code> 行，声明整型变量 <code>c</code>，运行时，<code>c</code> 会分配一段内存用以存储 <code>c</code> 的数值。</li>
<li>第 <code>3</code> 行，将 <code>a</code> 和 <code>b</code> 相乘后赋值给 <code>c</code>。</li>
<li>第 <code>5</code> 行，声明整型变量 <code>x</code> ，<code>x</code> 也会被分配一段内存。</li>
<li>第 <code>6</code> 行，让 <code>c</code> 乘以 <code>10</code> 后赋值给变量 <code>x</code> 。</li>
<li>第 <code>8</code> 行，返回 <code>x</code> 的值。</li>
</ul>
<p>上面的代码在没有任何优化的情况下，会进行变量 <code>c</code> 和 <code>x</code> 的分配过程。<code>Go</code> 语言默认情况下会将 <code>c</code> 和 <code>x</code> 分配在栈上，这两个变量在 <code>calc()</code> 函数退出时就不再使用，函数结束时，保存 <code>c</code> 和 <code>x</code> 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p>
<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/heapImage.jpg" alt="图：堆的分配及空间"></p>
<p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<h3 id="变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率"><a href="#变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸 （Escape Analysis） —— 自动决定变量分配方式，提高运行效率"></a>变量逃逸 <code>（Escape Analysis）</code> —— 自动决定变量分配方式，提高运行效率</h3><p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 <code>C/C++</code> 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p>
<p><code>Go</code> 语言将这个过程整合到了编译器中，命名为 <code>变量逃逸分析</code> 。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>通过下面的代码来展现 <code>Go</code> 语言如何使用命令行来分析变量逃逸，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 本函数测试入口参数和返回值情况</span><br><span class="line">func dummy(b int) int {</span><br><span class="line">  // 声明一个变量c并赋值</span><br><span class="line">  var c int</span><br><span class="line">  c = b</span><br><span class="line"></span><br><span class="line">  return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 空函数, 什么也不做</span><br><span class="line">func void() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">  // 声明a变量并打印</span><br><span class="line">  var a int</span><br><span class="line"></span><br><span class="line">  // 调用void()函数</span><br><span class="line">  void()</span><br><span class="line"></span><br><span class="line">  // 打印a变量的值和dummy()函数返回</span><br><span class="line">  fmt.Println(a, dummy(0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，<code>dummy()</code> 函数拥有一个参数，返回一个整型值，用来测试函数参数和返回值分析情况。</li>
<li>第 <code>8</code> 行，声明变量 <code>c</code> ，用于演示函数临时变量通过函数返回值返回后的情况。</li>
<li>第 <code>15</code> 行，这是一个空函数，测试没有任何参数函数的分析情况。</li>
<li>第 <code>21</code> 行，在 <code>main()</code> 中声明变量 <code>a</code> ，测试 <code>main()</code> 中变量的分析情况。</li>
<li>第 <code>24</code> 行，调用 <code>void()</code> 函数，没有返回值，测试 <code>void()</code> 调用后的分析情况。</li>
<li>第 <code>27</code> 行，打印 <code>a</code> 和 <code>dummy(0)</code> 的返回值，测试函数返回值没有变量接收时的分析情况。</li>
</ul>
<p>接着使用如下命令行运行上面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run -gcflags "-m -l" goEscapeAnalysis.go</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 运行程序时，<code>-gcflags</code> 参数是编译参数。其中 <code>-m</code> 表示进行内存分配分析，<code>-l</code> 表示避免程序内联，也就是避免进行程序优化。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goEscapeAnalysis.go:27:13: ... argument does not escape</span><br><span class="line">.\goEscapeAnalysis.go:27:13: a escapes to heap</span><br><span class="line">.\goEscapeAnalysis.go:27:22: dummy(0) escapes to heap</span><br><span class="line">0 0</span><br></pre></td></tr></tbody></table></figure>
<p>程序运行结果分析如下：</p>
<ul>
<li>第 <code>2</code> 行，这句提示是默认的，可以忽略。</li>
<li>第 <code>3</code> 行告知“代码的第 <code>27</code> 行的变量 <code>a</code> 逃逸到堆”。</li>
<li>第 <code>4</code> 行告知“dummy(0) 调用逃逸到堆”。由于 <code>dummy()</code> 函数会返回一个整型值，这个值被 <code>fmt.Println</code> 使用后还是会在 <code>main()</code> 函数中继续存在。</li>
</ul>
<p>上面例子中变量 <code>c</code> 是整型，其值通过 <code>dummy()</code> 的返回值“逃出”了 <code>dummy()</code> 函数。变量 <code>c</code> 的值被复制并作为 <code>dummy()</code> 函数的返回值返回，即使变量 <code>c</code> 在 <code>dummy()</code> 函数中分配的内存被释放，也不会影响 <code>main()</code> 中使用 <code>dummy()</code> 返回的值。变量 <code>c</code> 使用栈分配不会影响结果。</p>
<h4 id="取地址发生逃逸"><a href="#取地址发生逃逸" class="headerlink" title="取地址发生逃逸"></a>取地址发生逃逸</h4><p>下面的例子使用结构体做数据，来了解结构体在堆上的分配情况，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明空结构体测试结构体逃逸情况</span><br><span class="line">type Data struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func dummy() *Data {</span><br><span class="line">    // 实例化c为Data类型</span><br><span class="line">    var c Data</span><br><span class="line"></span><br><span class="line">    //返回函数局部变量地址</span><br><span class="line">    return &amp;c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(dummy())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，声明一个空的结构体做结构体逃逸分析。</li>
<li>第 <code>9</code> 行，将 <code>dummy()</code> 函数的返回值修改为 <code>*Data</code> 指针类型。</li>
<li>第 <code>11</code> 行，将变量 <code>c</code> 声明为 <code>Data</code> 类型，此时 <code>c</code> 的结构体为值类型。</li>
<li>第 <code>14</code> 行，取函数局部变量 <code>c</code> 的地址并返回。</li>
<li>第 <code>18</code> 行，打印 <code>dummy()</code> 函数的返回值。</li>
</ul>
<p>执行逃逸分析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goPstrAnalysis.go:11:6: moved to heap: c</span><br><span class="line">.\goPstrAnalysis.go:18:13: ... argument does not escape</span><br><span class="line">&amp;{}</span><br></pre></td></tr></tbody></table></figure>
<p>注意第 <code>2</code> 行出现了新的提示：将 <code>c</code> 移到堆中。这句话表示，<code>Go</code> 编译器已经确认如果将变量 <code>c</code> 分配在栈上是无法保证程序最终结果的，如果这样做，<code>dummy()</code> 函数的返回值将是一个不可预知的内存地址，这种情况一般是 <code>C/C++</code> 语言中容易犯错的地方，引用了一个函数局部变量的地址。</p>
<p><code>Go</code> 语言最终选择将 <code>c</code> 的 <code>Data</code> 结构分配在堆上。然后由垃圾回收器去回收 <code>c</code> 的内存。</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>在使用 <code>Go</code> 语言进行编程时，<code>Go</code> 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于<code>Go</code>语言，在 <code>Java</code> 等语言的编译器优化上也使用了类似的技术。</p>
<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
<li>变量是否被取地址；</li>
<li>变量是否发生逃逸。</li>
</ul>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔</p>
<p>变量的生命周期与变量的作用域有着不可分割的联系：</p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+int(x*size+0.5), size+int(y*size+0.5),</span><br><span class="line">        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br><span class="line">    )               // 小括号另起一行缩进，和大括号的风格保存一致</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，在每次循环的开始会创建临时变量 <code>t</code> ，然后在每次循环迭代中创建临时变量 <code>x</code> 和 <code>y</code>。临时变量 <code>x</code>、<code>y</code> 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p>
<p>栈的和堆的区别在于：</p>
<ul>
<li>堆<code>（heap）</code>：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 <code>malloc</code> 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 <code>free</code> 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；</li>
<li>栈<code>(stack)</code>：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号{ }中定义的局部变量。</li>
</ul>
<p>在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 <code>var</code> 还是 <code>new</code> 关键字声明变量都不会影响编译器的选择。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() {</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func g() {</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，函数 <code>f</code> 里的变量 <code>x</code> 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的。用 <code>Go</code> 语言的术语说，这个局部变量 <code>x</code> 从函数 <code>f</code> 中逃逸了。</p>
<p>相反，当函数 <code>g</code> 返回时，变量 <code>*y</code> 不再被使用，也就是说可以马上被回收的。因此，<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，编译器可以选择在栈上分配 <code>*y</code> 的存储空间，也可以选择在堆上分配，然后由 <code>Go</code> 语言的 <code>GC（垃圾回收机制）</code> 回收这个变量的内存空间。</p>
<p>在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>虽然 <code>Go</code> 语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们仍然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 <code>GC</code> 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>Go</code> 语言中的常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。</p>
<p>常量的定义格式和变量的声明语法类似：<code>const name [type] = value</code> ，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const pi = 3.14159 // 相当于 math.Pi 的近似值</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>Go</code> 语言中，你可以省略类型说明符 <code>[type]</code> ，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = "abc"</code></li>
<li>隐式类型定义： <code>const b = "abc"</code></li>
</ul>
<p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p>
<ul>
<li>正确的做法：<code>const c1 = 2/3</code></li>
<li>错误的做法：<code>const c2 = getNumber()</code> // 引发构建错误: getNumber() 用做值</li>
</ul>
<p>和变量声明一样，可以批量声明多个常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    e  = 2.7182818</span><br><span class="line">    pi = 3.1415926</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和 <code>unsafe.Sizeof</code>。</p>
<p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const IPv4Len = 4</span><br><span class="line"></span><br><span class="line">// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).</span><br><span class="line">func parseIPv4(s string) IP {</span><br><span class="line">    var p [IPv4Len]byte</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code> 是一个命名类型，底层类型是 <code>int64</code>，<code>time.Minute</code> 是对应类型的常量。下面声明的两个常量都是 <code>time.Duration</code> 类型，可以通过 <code>%T</code> 参数打印类型信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const noDelay time.Duration = 0</span><br><span class="line">const timeout = 5 * time.Minute</span><br><span class="line">fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"</span><br><span class="line">fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"</span><br><span class="line">fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"</span><br></pre></td></tr></tbody></table></figure>
<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 1</span><br><span class="line">    b</span><br><span class="line">    c = 2</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) // "1 1 2 2"</span><br></pre></td></tr></tbody></table></figure>
<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 <code>iota</code> 常量生成器语法。</p>
<h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code> ，然后在每一个有常量声明的行加一。</p>
<p>【示例 1】首先定义一个 <code>Weekday</code> 命名类型，然后为一周的每天定义了一个常量，从周日 <code>0</code> 开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>周日将对应 0，周一为 1，以此类推。</p>
<h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p><code>Go</code> 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 <code>int</code> 或 <code>float64</code>，或者是类似 <code>time.Duration</code> 这样的基础类型，但是许多常量并没有一个明确的基础类型。</p>
<p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 <code>256bit</code> 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x float32 = math.Pi</span><br><span class="line">var y float64 = math.Pi</span><br><span class="line">var z complex128 = math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p>如果 <code>math.Pi</code> 被确定为特定类型，比如 <code>float64</code> ，那么结果精度可能会不一样，同时对于需要 <code>float32</code> 或 <code>complex128</code> 类型值的地方则需要一个明确的强制类型转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const Pi64 float64 = math.Pi</span><br><span class="line">var x float32 = float32(Pi64)</span><br><span class="line">var y float64 = Pi64</span><br><span class="line">var z complex128 = complex128(Pi64)</span><br></pre></td></tr></tbody></table></figure>
<p>对于常量面值，不同的写法可能会对应不同的类型。例如 <code>0</code> 、<code>0.0</code> 、<code>0i</code> 和 <code>\u0000</code> 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code> 和 <code>false</code> 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<h2 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举</h2><p><code>Go</code> 语言现阶段没有枚举类型，但是可以使用 <code>const</code> 常量配合上一节 <code>Go语言常量</code> 中介绍的 <code>iota</code> 来模拟枚举类型，请看下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行中，将 <code>int</code> 定义为 <code>Weapon</code> 类型，就像枚举类型的本质是一个 <code>int</code> 类型一样。当然，某些情况下，如果需要 <code>int32</code> 和 <code>int64</code> 的枚举，也是可以的。</li>
<li>第 <code>4</code> 行中，将常量 <code>Arrow</code> 的类型标识为 <code>Weapon</code>，这样标识后，<code>const</code> 下方的常量可以使用 <code>Weapon</code> 作为默认类型。该行使用 <code>iota</code> 进行常量值自动生成，<code>iota</code> 的起始值为 <code>0</code>，一般情况下也是建议枚举从 <code>0</code> 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。</li>
</ul>
<p>一个 <code>const</code> 声明内的每一行常量声明，将会自动套用前面的 <code>iota</code> 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p>
<p>当然，<code>iota</code> 不仅可以生成每次增加 <code>1</code> 的枚举值。还可以利用 <code>iota</code> 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    FlagNone = 1 &lt;&lt; iota</span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf("%d %d %d\n", FlagRed, FlagGreen, FlagBlue)</span><br><span class="line">fmt.Printf("%b %b %b\n", FlagRed, FlagGreen, FlagBlue)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 4 8</span><br><span class="line">10 100 1000</span><br></pre></td></tr></tbody></table></figure>
<p>在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 <code>ioto</code> 自动生成更加方便。</p>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行中 <code>iota</code> 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。</li>
<li>第 <code>8</code> 行，将 <code>3</code> 个枚举按照常量输出，分别输出 <code>2</code>、<code>4</code>、<code>8</code>，都是将 <code>1</code> 每次左移一位的结果。</li>
<li>第 <code>9</code> 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。</li>
</ul>
<h3 id="将枚举值转换为字符串"><a href="#将枚举值转换为字符串" class="headerlink" title="将枚举值转换为字符串"></a>将枚举值转换为字符串</h3><p>枚举在 <code>C#</code> , <code>java</code> 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，<code>C#</code> 中 <code>Week</code> 枚举值 <code>Monday</code> 为 <code>1</code> ，那么可以通过 <code>Week.Monday.ToString()</code> 函数获得 <code>Monday</code> 字符串。</p>
<p><code>Go</code> 语言中也可以实现这一功能，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明芯片类型</span><br><span class="line">type ChipType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None ChipType = iota</span><br><span class="line">    CPU    // 中央处理器</span><br><span class="line">    GPU    // 图形处理器</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func (c ChipType) String() string {</span><br><span class="line">    switch c {</span><br><span class="line">    case None:</span><br><span class="line">        return "None"</span><br><span class="line">    case CPU:</span><br><span class="line">        return "CPU"</span><br><span class="line">    case GPU:</span><br><span class="line">        return "GPU"</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return "N/A"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 输出CPU的值并以整型格式显示</span><br><span class="line">    fmt.Printf("%s %d", CPU, CPU)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CPU 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，将 <code>int</code> 声明为 <code>ChipType</code> 芯片类型。</li>
<li>第 <code>9</code> 行，将 <code>const</code> 里定义的常量值设为 <code>ChipType</code> 类型，且从 <code>0</code> 开始，每行值加 <code>1</code>。</li>
<li>第 <code>14</code> 行，定义 <code>ChipType</code> 类型的方法 <code>String()</code>，返回值为字符串类型。</li>
<li>第 <code>15～22</code> 行，使用 <code>switch</code> 语句判断当前的 <code>ChitType</code> 类型的值，返回对应的字符串。</li>
<li>第 <code>30</code> 行，按整型的格式输出 <code>CPU</code> 的值。</li>
</ul>
<p><code>String()</code> 方法的 <code>ChipType</code> 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，<code>Go</code> 语言会自动寻找 <code>String()</code> 方法并进行调用。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>Go</code> 语言新版本的功能，内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对Go语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。</p>
<p>类型别名是 <code>Go 1.9</code> 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 <code>C/C++</code> 语言中，代码重构升级可以使用宏快速定义一段新的代码，<code>Go</code> 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。</p>
<p>在 <code>Go 1.9</code> 版本之前定义内建类型的代码是这样写的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte uint8</span><br><span class="line">type rune int32</span><br></pre></td></tr></tbody></table></figure>
<p>而在 Go 1.9 版本之后变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></tbody></table></figure>
<p>这个修改就是配合类型别名而进行的修改。</p>
<h3 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h3><p>定义类型别名的写法为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></tbody></table></figure>
<p>类型别名规定：<code>TypeAlias</code> 只是 <code>Type</code> 的别名，本质上 <code>TypeAlias</code> 与 <code>Type</code> 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<p>类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 查看a的类型名</span><br><span class="line">    fmt.Printf("a type: %T\n", a)</span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 查看a2的类型名</span><br><span class="line">    fmt.Printf("a2 type: %T\n", a2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a type: main.NewInt</span><br><span class="line">a2 type: int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，将 <code>NewInt</code> 定义为 <code>int</code> 类型，这是常见的定义类型的方法，通过 <code>type</code> 关键字的定义，<code>NewInt</code> 会形成一种新的类型，<code>NewInt</code> 本身依然具备 <code>int</code> 类型的特性。</li>
<li>第 <code>11</code> 行，将 <code>IntAlias</code> 设置为 <code>int</code> 的一个别名，使用 <code>IntAlias</code> 与 <code>int</code> 等效。</li>
<li>第 <code>16</code> 行，将 <code>a</code> 声明为 <code>NewInt</code> 类型，此时若打印，则 <code>a</code> 的值为 <code>0</code> 。</li>
<li>第 <code>18</code> 行，使用 <code>%T</code> 格式化参数，打印变量 <code>a</code> 本身的类型。</li>
<li>第 <code>21</code> 行，将 <code>a2</code> 声明为 <code>IntAlias</code> 类型，此时打印 <code>a2</code> 的值为 <code>0</code> 。</li>
<li>第 <code>23</code> 行，打印 <code>a2</code> 变量的类型。</li>
</ul>
<p>结果显示 <code>a</code> 的类型是 <code>main.NewInt</code> ，表示 <code>main</code> 包下定义的 <code>NewInt</code> 类型，<code>a2</code> 类型是 <code>int</code> ，<code>IntAlias</code> 类型只会在代码中存在，编译完成时，不会有 <code>IntAlias</code> 类型。</p>
<h3 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h3><p>能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法呢？参见下面的代码演示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，为 <code>time.Duration</code> 设定一个类型别名叫 <code>MyDuration</code> 。</li>
<li>第 <code>11</code> 行，为这个别名添加一个方法。</li>
</ul>
<p>编译上面代码报错，信息如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot define new methods on non-local type time.Duration</span><br></pre></td></tr></tbody></table></figure>
<p>编译器提示：不能在一个非本地的类型 <code>time.Duration</code> 上定义新方法，非本地类型指的就是 <code>time.Duration</code> 不是在 <code>main</code> 包中定义的，而是在 <code>time</code> 包中定义的，与 <code>main</code> 包不在同一个包中，因此不能为不在一个包中的类型定义方法。</p>
<p>解决这个问题有下面两种方法：</p>
<ul>
<li>将第 <code>8</code> 行修改为 <code>type MyDuration time.Duration</code> ，也就是将 <code>MyDuration</code> 从别名改为类型；</li>
<li>将 <code>MyDuration</code> 的别名定义放在 <code>time</code> 包中。</li>
</ul>
<h3 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h3><p>当类型别名作为结构体嵌入的成员时会发生什么情况呢？请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义商标结构</span><br><span class="line">type Brand struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为商标结构添加Show()方法</span><br><span class="line">func (t Brand) Show() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Brand定义一个别名FakeBrand</span><br><span class="line">type FakeBrand = Brand</span><br><span class="line"></span><br><span class="line">// 定义车辆结构</span><br><span class="line">type Vehicle struct {</span><br><span class="line">    // 嵌入两个结构</span><br><span class="line">    FakeBrand</span><br><span class="line">    Brand</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明变量a为车辆类型</span><br><span class="line">    var a Vehicle</span><br><span class="line"></span><br><span class="line">    // 指定调用FakeBrand的Show</span><br><span class="line">    a.FakeBrand.Show()</span><br><span class="line"></span><br><span class="line">    // 取a的类型反射对象</span><br><span class="line">    ta := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 遍历a的所有成员</span><br><span class="line">    for i := 0; i &lt; ta.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // a的成员信息</span><br><span class="line">        f := ta.Field(i)</span><br><span class="line"></span><br><span class="line">        // 打印成员的字段名和类型</span><br><span class="line">        fmt.Printf("FieldName: %v, FieldType: %v\n", f.Name, f.Type.Name())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FieldName: FakeBrand, FieldType: Brand</span><br><span class="line">FieldName: Brand, FieldType: Brand</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>9</code> 行，定义商标结构。</li>
<li>第 <code>13</code> 行，为商标结构添加 <code>Show()</code> 方法。</li>
<li>第 <code>17</code> 行，为 <code>Brand</code> 定义一个别名 <code>FakeBrand</code>。</li>
<li>第 <code>20～25</code> 行，定义车辆结构 <code>Vehicle</code> ，嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 结构。</li>
<li>第 <code>30</code> 行，将 <code>Vechicle</code> 实例化为 <code>a</code> 。</li>
<li>第 <code>33</code> 行，显式调用 <code>Vehicle</code> 中 <code>FakeBrand</code> 的 <code>Show()</code> 方法。</li>
<li>第 <code>36</code> 行，使用反射取变量 <code>a</code> 的反射类型对象，以查看其成员类型。</li>
<li>第 <code>39～42</code> 行，遍历 <code>a</code> 的结构体成员。</li>
<li>第 <code>45</code> 行，打印 <code>Vehicle</code> 类型所有成员的信息。</li>
</ul>
<p>这个例子中，<code>FakeBrand</code> 是 <code>Brand</code> 的一个别名，在 <code>Vehicle</code> 中嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 并不意味着嵌入两个 <code>Brand</code>，<code>FakeBrand</code> 的类型会以名字的方式保留在 <code>Vehicle</code> 的成员中。</p>
<p>如果尝试将第 <code>33</code> 行改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a.Show()</span><br></pre></td></tr></tbody></table></figure>
<p>编译器将发生报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ambiguous selector a.Show</span><br></pre></td></tr></tbody></table></figure>
<p>在调用 <code>Show()</code> 方法时，因为两个类型都有 <code>Show()</code> 方法，会发生歧义，证明 <code>FakeBrand</code> 的本质确实是 <code>Brand</code> 类型。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释在程序中的作用是对程序进行注解和说明，便于对源码的阅读。编译系统在对源代码进行编译时会自动忽略注释的部分，因此注释对于程序的功能实现不起任何作用。在源码中适当地添加注释，能够提高源码的可读性。</p>
<p><code>Go</code> 语言的注释主要分成两类，分别是单行注释和多行注释。</p>
<ul>
<li>单行注释简称行注释，是最常见的注释形式，可以在任何地方使用以 <code>//</code> 开头的单行注释；</li>
<li>多行注释简称块注释，以 <code>/*</code> 开头，并以 <code>*/</code> 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<p>单行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></tbody></table></figure>
<p>多行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">...</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>
<p>每一个包都应该有相关注释，在使用 <code>package</code> 语句声明包名之前添加相应的注释，用来对包的功能及作用进行简要说明。</p>
<p>同时，在 <code>package</code> 语句之前的注释内容将被默认认为是这个包的文档说明。一个包可以分散在多个文件中，但是只需要对其中一个进行注释说明即可。</p>
<p>在多段注释之间可以使用空行分隔加以区分，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Package superman implements methods for saving the world.</span><br><span class="line">//</span><br><span class="line">// Experience has shown that a small number of procedures can prove</span><br><span class="line">// helpful when attempting to save the world.</span><br><span class="line">package superman</span><br></pre></td></tr></tbody></table></figure>
<p>对于代码中的变量、常量、函数等对象最好也都加上对应的注释，这样有利于后期对代码进行维护，例如下面代码中对 <code>enterOrbit</code> 函数的注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// enterOrbit causes Superman to fly into low Earth orbit, a position</span><br><span class="line">// that presents several possibilities for planet salvation.</span><br><span class="line">func enterOrbit() error {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当开发人员需要了解包的一些情况时，可以使用 godoc 来显示包的文档说明，下面来介绍一下 godoc 工具的使用。</p>
<h3 id="godoc-工具"><a href="#godoc-工具" class="headerlink" title="godoc 工具"></a>godoc 工具</h3><p><code>godoc</code> 工具会从 <code>Go</code> 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 <code>web</code> 服务器，<code>Go</code> <a target="_blank" rel="noopener" href="https://golang.google.cn/">语言官网</a>就是通过这种形式实现的。</p>
<p>但是<code>Go</code>语言 <code>1.13</code> 版本移除了 <code>godoc</code> 工具，大家可以通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure>
<p>由于防火墙的原因，国内的用户可能无法通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具，这时候就需要大家来手动操作了。</p>
<ul>
<li>首先从 <a target="_blank" rel="noopener" href="https://github.com/golang/tools.git">GitHub</a> 下载 <code>golang.org/x/tools</code> 包；</li>
<li>然后将下载得到的文件解压到 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools</code> 目录中，没有的话可以手动创建；</li>
<li>打开 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools\cmd\godoc</code> 目录，在该目录下打开命令行工具，并执行 <code>go build</code> 命令，生成 <code>godoc.exe</code> 可执行文件；</li>
<li>最后，将生成的 <code>godoc.exe</code> 文件移动到 <code>GOPATH</code> 下的 <code>bin</code> 目录中。（需要把 <code>GOPATH</code> 下的 <code>bin</code> 目录添加到环境变量 <code>Path</code> 中）</li>
</ul>
<p>完成上述操作后就可以使用 <code>godoc</code> 工具了，<code>godoc</code> 工具一般有以下几种用法：</p>
<ul>
<li><code>go doc package</code>：获取包的文档注释，例如 <code>go doc fmt</code> 会显示使用 <code>godoc</code> 生成的 <code>fmt</code> 包的文档注释；</li>
<li><code>go doc package/subpackage</code>：获取子包的文档注释，例如 <code>go doc container/list</code>；</li>
<li><code>go doc package function</code>：获取某个函数在某个包中的文档注释，例如 <code>go doc fmt Printf</code> 会显示有关 <code>fmt.Printf()</code> 的使用说明。</li>
</ul>
<p>下图演示了使用go doc 命令来获取包的文档注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">godoc package main</span><br></pre></td></tr></tbody></table></figure>
<p><code>godoc</code> 工具还可以获取 <code>Go</code> 安装目录下 <code>../go/src</code> 中的注释内容，并将这些注释内容整合到 <code>web</code> 服务器中供我们预览。在命令行输入 <code>godoc -http=:6060</code> ，然后使用浏览器打开 <code>http://localhost:6060</code> 后，就可以看到本地文档浏览服务器提供的页面。</p>
<h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><code>Go</code> 语言的词法元素包括 <code>5</code> 种，分别是标识符<code>（identifier）</code>、关键字<code>（keyword）</code>、操作符<code>（operator）</code>、分隔符<code>（delimiter）</code>、字面量<code>（literal）</code>，它们是组成 <code>Go</code> 语言代码和程序的最基本单位。</p>
<p>本节我们主要来介绍一下 <code>Go</code> 语言中的关键字和标识符。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。</p>
<p>Go语言中的关键字一共有 25 个：</p>
<table>
  <tbody>
    <tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr>
    <tr><th>case</th><th>defer</th><th>go</th><th>map</th><th>struct</th></tr>
    <tr><th>chan</th><th>else</th><th>goto</th><th>package</th><th>switch</th></tr>
    <tr><th>const</th><th>fallthrough</th><th>if</th><th>range</th><th>type</th></tr>
    <tr><th>continue</th><th>for</th><th>import</th><th>return</th><th>var</th></tr>
  </tbody>
</table>

<p>之所以刻意地将 <code>Go</code> 语言中的关键字保持的这么少，是为了简化在编译过程中的代码解析。和其它语言一样，关键字不能够作标识符使用。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指 <code>Go</code> 语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线_、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p>
<p>下划线<em>是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用</em>作为变量对其它变量进行赋值或运算。</p>
<p>在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。</p>
<p>标识符的命名需要遵守以下规则：</p>
<ul>
<li>由 <code>26</code> 个英文字母、<code>0~9</code>、<code>_</code> 组成；</li>
<li>不能以数字开头，例如 <code>var 1num int</code> 是错误的；</li>
<li><code>Go</code> 语言中严格区分大小写；</li>
<li>标识符不能包含空格；</li>
<li>不能以系统保留关键字作为标识符，比如 <code>break</code> ，<code>if</code> 等等。</li>
</ul>
<p>命名标识符时还需要注意以下几点：</p>
<ul>
<li>标识符的命名要尽量采取简短且有意义；</li>
<li>不能和标准库中的包名重复；</li>
<li>为变量、函数、常量命名时采用驼峰命名法，例如 <code>stuName</code>、<code>getVal</code> ；</li>
</ul>
<p>当然 <code>Go</code> 语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 <code>Java</code> 中的 <code>public</code> ）；如果首字母小写，则表示它只能在本包中使用 (类似于 <code>Java</code> 中 <code>private</code> ）。</p>
<p>在 <code>Go</code> 语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：</p>
<table>
  <tbody>  
    <tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr>
    <tr><th>copy</th><th>false</th><th>float32</th><th>float64</th><th>imag</th><th>int</th><th>int8</th><th>int16</th><th>uint32</th></tr>
    <tr><th>int32</th><th>int64</th><th>iota</th><th>len</th><th>make</th><th>new</th><th>nil</th><th>panic</th><th>uint64</th></tr>
    <tr><th>print</th><th>println</th><th>real</th><th>recover</th><th>string</th><th>true</th><th>uint</th><th>uint8</th><th>uintptr</th></tr>
  </tbody>
</table>

<p>预定义标识符一共有 <code>36</code> 个，主要包含 <code>Go</code> 语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。</p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符是用来在程序运行时执行数学或逻辑运算的，在 <code>Go</code> 语言中，一个表达式可以包含多个运算符，当表达式中存在多个运算符时，就会遇到优先级的问题，此时应该先处理哪个运算符呢？这个就由 <code>Go</code> 语言运算符的优先级来决定的。</p>
<p>比如对于下面的表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b, c int = 16, 4, 2</span><br><span class="line">d := a + b*c</span><br></pre></td></tr></tbody></table></figure>
<p>对于表达式 <code>a + b * c</code> ，如果按照数学规则推导，应该先计算乘法，再计算加法；<code>b * c</code> 的结果为 <code>8</code> ，<code>a + 8</code> 的结果为 <code>24</code> ，所以 <code>d</code> 最终的值也是 <code>24</code> 。实际上 <code>Go</code> 语言也是这样处理的，先计算乘法再计算加法，和数据中的规则一样，读者可以亲自验证一下。</p>
<p>先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。</p>
<p><code>Go</code> 语言有几十种运算符，被分成十几个级别，有的运算符优先级不同，有的运算符优先级相同，请看下表。</p>
<table>
  <thead><tr><th>优先级</th><th>分类</th><th>运算符</th><th>结合性</th></tr></thead>
  <tbody>        
    <tr><th>1</th><th>逗号运算符</th><th>,</th><th>从左到右</th></tr>
    <tr><th>2</th><th>赋值运算符</th><th>=、+=、-=、*=、/=、 %=、 &gt;=、 &lt;&lt;=、&amp;=、^=、|=</th><th>从右到左</th></tr>
    <tr><th>3</th><th>逻辑或</th><th>||</th><th>从左到右</th></tr>
    <tr><th>4</th><th>逻辑与</th><th>&amp;&amp;</th><th>从左到右</th></tr>
    <tr><th>5</th><th>按位或</th><th>|</th><th>从左到右</th></tr>
    <tr><th>6</th><th>按位异或</th><th>^</th><th>从左到右</th></tr>
    <tr><th>7</th><th>按位与</th><th>&amp;</th><th>从左到右</th></tr>
    <tr><th>8</th><th>相等/不等</th><th>==、!=</th><th>从左到右</th></tr>
    <tr><th>9</th><th>关系运算符</th><th>&lt;、&lt;=、&gt;、&gt;=</th><th>从左到右</th></tr>
    <tr><th>10</th><th>位移运算符</th><th>&lt;&lt;、&gt;&gt;</th><th>从左到右</th></tr>
    <tr><th>11</th><th>加法/减法</th><th>+、-</th><th>从左到右</th></tr>
    <tr><th>12</th><th>乘法/除法/取余</th><th>*（乘号）、/、%</th><th>从左到右</th></tr>
    <tr><th>13</th><th>单目运算符</th><th>!、*（指针）、&amp; 、++、--、+（正号）、-（负号）</th><th>从右到左</th></tr>
    <tr><th>14</th><th>后缀运算符</th><th>( )、[ ]、-&gt;</th><th>从左到右</th></tr>
    </tbody>
</table>

<p>注意：优先级值越大，表示优先级越高。</p>
<p>一下子记住所有运算符的优先级并不容易，还好 <code>Go</code> 语言中大部分运算符的优先级和数学中是一样的，大家在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">d := a + (b * c)</span><br></pre></td></tr></tbody></table></figure>
<p>括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p>
<p>运算符的结合性是指相同优先级的运算符在同一个表达式中，且没有括号的时候，操作数计算的顺序，通常有从左到右和从右到左两种方式，例如，<code>+</code> 加法运算符的结合性是从左到右，那么表达式 <code>a + b + c</code> 则可以理解为为 <code>(a + b) + c</code> 。</p>
<h2 id="字符串和数值类型的转换"><a href="#字符串和数值类型的转换" class="headerlink" title="字符串和数值类型的转换"></a>字符串和数值类型的转换</h2><p>在实际开发中我们往往需要对一些常用的数据类型进行转换，如 <code>string</code> 、<code>int</code> 、<code>int64</code> 、<code>float</code> 等数据类型之间的转换，<code>Go</code> 语言中的 <code>strconv</code> 包为我们提供了字符串和基本数据类型之间的转换功能。</p>
<p><code>strconv</code> 包中常用的函数包括 <code>Atoi()</code> 、<code>Itia()</code> 、<code>parse</code> 系列函数、<code>format</code> 系列函数、<code>append</code> 系列函数等，下面就来分别介绍一下。</p>
<h3 id="string-与-int-类型之间的转换"><a href="#string-与-int-类型之间的转换" class="headerlink" title="string 与 int 类型之间的转换"></a>string 与 int 类型之间的转换</h3><p>字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。</p>
<h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4><p>Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Itoa(i int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := 100</span><br><span class="line">    str := strconv.Itoa(num)</span><br><span class="line">    fmt.Printf("type:%T value:%#v\n", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string value:"100"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4><p><code>Atoi()</code> 函数用于将字符串类型的整数转换为 <code>int</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Atoi(s string) (i int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>通过函数签名可以看出 <code>Atoi()</code> 函数有两个返回值，<code>i</code> 为转换成功的整型，<code>err</code> 在转换成功是为空转换失败时为相应的错误信息。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    str2 := "s100"</span><br><span class="line">    num1, err := strconv.Atoi(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str1)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num1, num1)</span><br><span class="line">    }</span><br><span class="line">    num2, err := strconv.Atoi(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str2)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num2, num2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:int value:110</span><br><span class="line">s100 转换失败！</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Parse-系列函数"><a href="#Parse-系列函数" class="headerlink" title="Parse 系列函数"></a>Parse 系列函数</h3><p><code>Parse</code> 系列函数用于将字符串转换为指定类型的值，其中包括 <code>ParseBool()</code> 、<code>ParseFloat()</code> 、<code>ParseInt()</code> 、<code>ParseUint()</code> 。</p>
<h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p><code>ParseBool()</code> 函数用于将字符串转换为 <code>bool</code> 类型的值，它只能接受 <code>1</code> 、<code>0</code> 、<code>t</code> 、<code>f</code> 、<code>T</code> 、<code>F</code> 、<code>true</code> 、<code>false</code> 、<code>True</code> 、<code>False</code> 、<code>TRUE</code> 、<code>FALSE</code> ，其它的值均返回错误，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseBool(str string) (value bool, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    boo1, err := strconv.ParseBool(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str1: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo1)</span><br><span class="line">    }</span><br><span class="line">    str2 := "t"</span><br><span class="line">    boo2, err := strconv.ParseBool(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str2: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str1: strconv.ParseBool: parsing "110": invalid syntax</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h4><p><code>ParseInt()</code> 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>base</code> 指定进制，取值范围是 <code>2</code> 到 <code>36</code>。如果 <code>base</code> 为 <code>0</code> ，则会从字符串前置判断，“0x”是 <code>16</code> 进制，“0”是 <code>8</code> 进制，否则是 <code>10</code> 进制。</li>
<li><code>bitSize</code> 指定结果必须能无溢出赋值的整数类型，<code>0</code> 、<code>8</code> 、<code>16</code> 、<code>32</code> 、<code>64</code> 分别代表 <code>int</code> 、<code>int8</code> 、<code>int16</code> 、<code>int32</code> 、<code>int64</code> 。</li>
<li>返回的 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误，<code>err.Error = ErrSyntax</code> ，如果结果超出类型范围 <code>err.Error = ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "-11"</span><br><span class="line">    num, err := strconv.ParseInt(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h4><p><code>ParseUint()</code> 函数的功能类似于 <code>ParseInt()</code> 函数，但 <code>ParseUint()</code> 函数不接受正负号，用于无符号整型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "11"</span><br><span class="line">    num, err := strconv.ParseUint(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p><code>ParseFloat()</code> 函数用于将一个表示浮点数的字符串转换为 <code>float</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseFloat(s string, bitSize int) (f float64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li>如果 <code>s</code> 合乎语法规则，函数会返回最为接近 <code>s</code> 表示值的一个浮点数（使用 <code>IEEE754</code> 规范舍入）。</li>
<li><code>bitSize</code> 指定了返回值的类型，<code>32</code> 表示 <code>float32</code>，<code>64</code> 表示 <code>float64</code> ；</li>
<li>返回值 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误 <code>err.Error=ErrSyntax</code> ，如果返回值超出表示范围，返回值 <code>f</code> 为 <code>±Inf，err.Error= ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "3.1415926"</span><br><span class="line">    num, err := strconv.ParseFloat(str, 64)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.1415926</span><br></pre></td></tr></tbody></table></figure>
<p><code>Parse</code> 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>
<h3 id="Format-系列函数"><a href="#Format-系列函数" class="headerlink" title="Format 系列函数"></a>Format 系列函数</h3><p><code>Format</code> 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 <code>FormatBool()</code>、<code>FormatInt()</code>、<code>FormatUint()</code>、<code>FormatFloat()</code>。</p>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p><code>FormatBool()</code> 函数可以一个 <code>bool</code> 类型的值转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatBool(b bool) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := true</span><br><span class="line">    str := strconv.FormatBool(num)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatInt(i int64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 <code>i</code> 必须是 <code>int64</code> 类型，参数 <code>base</code> 必须在 <code>2</code> 到 <code>36</code> 之间，返回结果中会使用小写字母“a”到“z”表示大于 <code>10</code> 的数字。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num int64 = 100</span><br><span class="line">    str := strconv.FormatInt(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:64</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h4><p><code>FormatUint()</code> 函数与 <code>FormatInt()</code> 函数的功能类似，但是参数 <code>i</code> 必须是无符号的 <code>uint64</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatUint(i uint64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num uint64 = 110</span><br><span class="line">    str := strconv.FormatUint(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:6e</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p><code>FormatFloat()</code> 函数用于将浮点数转换为字符串类型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>bitSize</code> 表示参数 <code>f</code> 的来源类型（<code>32</code> 表示 <code>float32</code>、<code>64</code> 表示 <code>float64</code>），会据此进行舍入。</li>
<li><code>fmt</code> 表示格式，可以设置为“f”表示 <code>-ddd.dddd</code> 、“b”表示 <code>-ddddp±ddd</code>，指数为二进制、“e”表示 <code>-d.dddde±dd</code> 十进制指数、“E”表示 <code>-d.ddddE±dd</code> 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li><code>prec</code> 控制精度（排除指数部分）：当参数 <code>fmt</code> 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 <code>fmt</code> 为“g”、“G”时，它控制总的数字个数。如果 <code>prec</code> 为 <code>-1</code> ，则代表使用最少数量的、但又必需的数字来表示 <code>f</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num float64 = 3.1415926</span><br><span class="line">    str := strconv.FormatFloat(num, 'E', -1, 64)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:3.1415926E+00</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Append-系列函数"><a href="#Append-系列函数" class="headerlink" title="Append 系列函数"></a>Append 系列函数</h3><p><code>Append</code> 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 <code>AppendBool()</code> 、<code>AppendFloat()</code> 、<code>AppendInt()</code> 、<code>AppendUint()</code> 。</p>
<p><code>Append</code> 系列函数和 <code>Format</code> 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个slice</span><br><span class="line">    b10 := []byte("int (base 10):")</span><br><span class="line">  </span><br><span class="line">    // 将转换为10进制的string，追加到slice中</span><br><span class="line">    b10 = strconv.AppendInt(b10, -42, 10)</span><br><span class="line">    fmt.Println(string(b10))</span><br><span class="line">    b16 := []byte("int (base 16):")</span><br><span class="line">    b16 = strconv.AppendInt(b16, -42, 16)</span><br><span class="line">    fmt.Println(string(b16))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int (base 10):-42</span><br><span class="line">int (base 16):-2a</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言适合做什么</title>
    <url>/posts/30ebccd/</url>
    <content><![CDATA[<p>前面我们已经介绍过了 <code>Go</code> 语言的种种优势和不足，那么我们究竟可以使用 <code>Go</code> 语言来做些什么呢？</p>
<p>其实 <code>Go</code> 语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的网络服务。</p>
<p><code>Go</code> 语言融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性，不仅提高了项目的开发速度，而且后期维护起来也非常轻松。</p>
<p>鉴于 <code>Go</code> 语言的特点和设计的初衷，从以下几个方面来分析 <code>Go</code> 语言擅长的领域：</p>
<ul>
<li>在服务器编程方面，<code>Go</code> 语言适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；</li>
<li>网络编程方面，<code>Go</code> 语言广泛应用于 <code>Web</code> 应用、<code>API</code> 应用、下载应用等；</li>
<li>此外，<code>Go</code> 语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 <code>Go</code> 开发。</li>
</ul>
<p>除了上面介绍到的，<code>Go</code> 语言还可以用来开发底层，例如以太坊、超级账本等都是基于 <code>Go</code> 语言开发的。</p>
<p>而且对于现在比较流行的区块链技术方面，<code>Go</code> 语言也是非常受欢迎的，很多基于区块链的 <code>DApps</code>（去中心化应用）和工具都是用的 <code>Go</code> 语言来实现的。</p>
<p>下面列举了一些基于 <code>Go</code> 语言开发的优秀开源项目：<br>云计算基础设施领域，代表项目：<code>docker</code> 、<code>kubernetes</code> 、<code>etcd</code> 、<code>consul</code> 、<code>cloudflare CDN</code> 、七牛云存储等。<br>基础软件，代表项目：<code>tidb</code> 、<code>influxdb</code> 、<code>cockroachdb</code> 等。<br>微服务，代表项目：<code>go-kit</code> 、<code>micro</code> 、<code>monzo bank</code> 的 <code>typhon</code> 、<code>bilibili</code> 等。<br>互联网基础设施，代表项目：以太坊、<code>hyperledger</code> 等。</p>
<p>总之，<code>Go</code> 语言的优势还是比较多的，比如 <code>Go</code> 语言的性能非常出色，最关键的是在性能强劲的同时还能像解释型语言一样高效地进行开发。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5721.html">Go语言是怎么完成编译的</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4774.html">Go语言依赖管理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/129.html">Go语言map的多键索引</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5722.html">Go语言make和new关键字的区别及实现原理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5571.html">Go语言分布式id生成器</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5728.html">Go语言冒泡排序</a></p>
<h2 id="Go语言依赖管理"><a href="#Go语言依赖管理" class="headerlink" title="Go语言依赖管理"></a>Go语言依赖管理</h2><p>早期的Go语言被很多开发者所吐槽的一个问题就是没有依赖包的管理，不过随着版本的不断更迭，Go语言依赖管理方面也在不断的完善。</p>
<h3 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h3><p>最初的时候Go语言所依赖的所有的第三方包都放在 GOPATH 目录下面，这就导致了同一个包只能保存一个版本的代码，如果不同的项目依赖同一个第三方的包的不同版本，应该怎么解决呢？</p>
<h3 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h3><p>godep 是一个Go语言官方提供的通过 vender 模式来管理第三方依赖的工具，类似的还有由社区维护的准官方包管理工具 dep。</p>
<p>Go语言从 1.5 版本开始开始引入 vendor 模式，如果项目目录下有 vendor 目录，那么Go语言编译器会优先使用 vendor 内的包进行编译、测试等。</p>
<h4 id="安装godep工具"><a href="#安装godep工具" class="headerlink" title="安装godep工具"></a>安装godep工具</h4><p>我们可以通过go get 命令来获取 godep 工具。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get github.com/tools/godep</span><br></pre></td></tr></tbody></table></figure>
<p>命令执行成功后会将 godep 工具的源码下载到 GOPATH 的 src 目录下对应的文件夹中，同时还会在 GOPATH 的 bin 目录下生成一个名为 godep.exe 的可执行文件。</p>
<p>为了方便使用 godep 工具，我们需要将存放 godep.exe 文件的目录添加到环境变量 PATH 中。在系统变量中找到并选中“Path”一行，点击“编辑”按钮，在新弹出的窗口中点击“新建”，然后在最下面一行中填入对应的目录信息。确认无误后点击“确定”。</p>
<h4 id="godep工具的基本命令"><a href="#godep工具的基本命令" class="headerlink" title="godep工具的基本命令"></a>godep工具的基本命令</h4><p>完成上面的操作后，我们就可以在命令行窗口（CMD）中使用 godep 工具了，godep 支持的命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>
    <tr><th>godep save</th><th>将依赖包的信息保存到 Godeps.json 文件中</th></tr>
    <tr><th>godep go</th><th>使用保存的依赖项运行 go 工具</th></tr>
    <tr><th>godep get</th><th>下载并安装指定的包</th></tr>
    <tr><th>godep path</th><th>打印依赖的 GOPATH 路径</th></tr>
    <tr><th>godep restore</th><th>在 GOPATH 中拉取依赖的版本</th></tr>
    <tr><th>godep update</th><th>更新选定的包或 go 版本</th></tr>
    <tr><th>godep diff</th><th>显示当前和以前保存的依赖项集之间的差异</th></tr>
    <tr><th>godep version</th><th>查看版本信息</th></tr>
  </tbody>
</table>

<p>使用 <code>godep help [命令名称]</code> 可以查看命令的帮助信息，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy&gt;godep help go</span><br><span class="line">Args: godep go [-v] [-d] command [arguments]</span><br><span class="line"></span><br><span class="line">Go runs the go tool with a modified GOPATH giving access to</span><br><span class="line">dependencies saved in Godeps.</span><br><span class="line"></span><br><span class="line">Any go tool command can run this way, but "godep go get"</span><br><span class="line">is unnecessary and has been disabled. Instead, use</span><br><span class="line">"godep go install".</span><br><span class="line"></span><br><span class="line">If -v is given, verbose output is enabled.</span><br><span class="line"></span><br><span class="line">If -d is given, debug output is enabled (you probably don't want this, see -v).</span><br></pre></td></tr></tbody></table></figure>
<h4 id="使用godep工具"><a href="#使用godep工具" class="headerlink" title="使用godep工具"></a>使用godep工具</h4><p>执行 <code>godep save</code> 命令，会在当前目录中创建 Godeps 和 vender 两个文件夹。Godeps 文件夹下会生成一个 Godeps.json 文件，用来记录项目中所依赖的包信息；vender 目录则是用来保存当前项目所依赖的所有第三方包。</p>
<p>生成的 Godeps.json 文件的结构如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    "ImportPath": "main",</span><br><span class="line">    "GoVersion": "go1.13",</span><br><span class="line">    "GodepVersion": "v80",</span><br><span class="line">    "Deps": [</span><br><span class="line">        {</span><br><span class="line">            "ImportPath": "github.com/go-gomail/gomail",</span><br><span class="line">            "Comment": "2.0.0-23-g81ebce5",</span><br><span class="line">            "Rev": "81ebce5c23dfd25c6c67194b37d3dd3f338c98b1"</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，“ImportPath”为项目的路径信息，“GoVersion”为Go语言的版本号，“GodepVersion”为 godep 工具的版本号，“Deps”为当前依赖包的路径、版本号信息等等。</p>
<p><strong><em>提示：当引用的第三方包要升级时，只需要修改 Godep.json 里面的依赖包的版本号，然后再次执行 godep save 命令即可。</em></strong></p>
<p>godep 工具的主要功能就是控制Go语言程序编译时依赖包搜索路径的优先级。例如查找项目的某个依赖包，首先会在项目根目录下的 vender 文件夹中查找，如果没有找到就会去 GOAPTH/src 目录下查找。</p>
<h3 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h3><p>go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。</p>
<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。</p>
<ul>
<li>GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。</li>
<li>GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li>
<li>GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。</li>
</ul>
<p>Windows 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set GO111MODULE=on 或者 set GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或者 Linux 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GO111MODULE=on 或者 export GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>使用 go module 的 <code>go mod init</code> 命令后会在当前目录下生成一个 go. mod 文件，并且在编译/运行当前目录下代码或者使用 <code>go get</code> 命令的时候会在当前目录下生成一个 go.sum 文件。</p>
<p>go.mod 文件记录了项目所有的依赖信息，其结构大致如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module github.com/dubbogo/dubbo-go-proxy</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/apache/dubbo-go v1.5.1</span><br><span class="line">	github.com/apache/dubbo-go-hessian2 v1.6.2</span><br><span class="line">	github.com/dubbogo/gost v1.9.2</span><br><span class="line">	github.com/emirpasic/gods v1.12.0</span><br><span class="line">	github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32</span><br><span class="line">	github.com/goinggo/mapstructure v0.0.0-20140717182941-194205d9b4a9</span><br><span class="line">	github.com/kr/fs v0.1.0 // indirect</span><br><span class="line">	github.com/pkg/errors v0.9.1</span><br><span class="line">	github.com/stretchr/testify v1.6.1</span><br><span class="line">	github.com/tools/godep v0.0.0-20180126220526-ce0bfadeb516 // indirect</span><br><span class="line">	github.com/urfave/cli v1.22.4</span><br><span class="line">	go.uber.org/zap v1.15.0</span><br><span class="line">	gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，module 为 go.mod 文件所属的包，require 为项目所依赖的包及版本号，indirect 表示间接引用。</p>
<p>go.sum 文件则是用来记录每个依赖包的版本及哈希值，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=</span><br><span class="line">cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=</span><br><span class="line">cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=</span><br><span class="line">dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=</span><br><span class="line">github.com/Azure/azure-sdk-for-go v40.3.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.0/go.mod h1:xyHB1BMZT0cuDHU7I0+g046+BFDTQ8rEZB0s4Yfa6bI=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.3/go.mod h1:GsRuLYvwzLjjjRoWEIyMUaYq8GNUx2nRB378IPt/1p0=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.10.0/go.mod h1:/FALq9T/kS7b5J5qsQ+RSTUdAmGFqi0vUdVNNx8q630=</span><br></pre></td></tr></tbody></table></figure>
<p>常用的 go mod 命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>
    <tr><th>go mod download</th><th>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</th></tr>
    <tr><th>go mod edit</th><th>编辑 go.mod 文件</th></tr>
    <tr><th>go mod graph</th><th>打印模块依赖图</th></tr>
    <tr><th>go mod init</th><th>初始化当前文件夹，创建 go.mod 文件</th></tr>
    <tr><th>go mod tidy</th><th>增加缺少的包，删除无用的包</th></tr>
    <tr><th>go mod vendor</th><th>将依赖复制到 vendor 目录下</th></tr>
    <tr><th>go mod verify</th><th>校验依赖</th></tr>
    <tr><th>go mod why</th><th>解释为什么需要依赖</th></tr>
  </tbody>
</table>

<h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h4><p>proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过 <code>go get</code>  命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。</p>
<p>目前公开的代理服务器的地址有：</p>
<ul>
<li>goproxy.io</li>
<li>goproxy.cn：（推荐）由国内的七牛云提供。</li>
</ul>
<p>Windows 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或 Linux 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言在 1.13 版本之后 GOPROXY 默认值为 <a target="_blank" rel="noopener" href="https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将">https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将</a> GOPROXY 设置为国内的 goproxy.cn。</p>
<p>使用 <code>go get</code> 命令下载指定版本的依赖包</p>
<p>执行go get 命令，在下载依赖包的同时还可以指定依赖包的版本。</p>
<ul>
<li>运行go get -u命令会将项目中的包升级到最新的次要版本或者修订版本；</li>
<li>运行go get -u=patch命令会将项目中的包升级到最新的修订版本；</li>
<li>运行go get [包名]@[版本号]命令会下载对应包的指定版本或者将对应包升级到指定的版本。</li>
</ul>
<p><strong><em>提示：<code>go get [包名]@[版本号]</code> 命令中版本号可以是 x.y.z 的形式，例如 <code>go get foo@v1.2.3</code> ，也可以是 git 上的分支或 tag，例如 <code>go get foo@master</code> ，还可以是 git 提交时的哈希值，例如 <code>go get foo@e3702bed2</code> 。</em></strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go容器</title>
    <url>/posts/5c78a85/</url>
    <content><![CDATA[<p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p>
<p>在很多语言里，容器是以标准库的方式提供，你可以随时查看这些标准库的代码，了解如何创建，删除，维护内存。</p>
<p>本章将以实用为目的，详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。本章既可以作为教程，也可以作为字典，以方便开发者日常的查询和应用。</p>
<p>其它语言中的容器:</p>
<ul>
<li>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。</li>
<li>C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。</li>
<li>C# 语言通过 .NET 框架提供，如 List 对应数组，LinkedList 对应双链表，Dictionary 对应映射。</li>
<li>Lua 语言的 table 实现了数组和映射的功能，Lua 语言默认没有双链表支持。</li>
</ul>
<h2 id="go-array"><a href="#go-array" class="headerlink" title="go array"></a>go array</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。</p>
<p>和数组对应的类型是 <code>Slice</code>（切片），<code>Slice</code> 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 <code>Slice</code> 工作原理的话需要先理解数组。</p>
<h3 id="Go语言数组的声明"><a href="#Go语言数组的声明" class="headerlink" title="Go语言数组的声明"></a>Go语言数组的声明</h3><p>数组的声明语法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 数组变量名 [元素数量]Type</span><br></pre></td></tr></tbody></table></figure>
<p>语法说明如下所示：</p>
<ul>
<li>数组变量名：数组声明及使用时的变量名。</li>
<li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li>
<li>Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li>
</ul>
<p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 <code>len()</code> 可以返回数组中元素的个数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a [3]int             // 定义三个整数的数组</span><br><span class="line">fmt.Println(a[0])        // 打印第一个元素</span><br><span class="line">fmt.Println(a[len(a)-1]) // 打印最后一个元素</span><br><span class="line">// 打印索引和元素</span><br><span class="line">for i, v := range a {</span><br><span class="line">    fmt.Printf("%d %d\n", i, v)</span><br><span class="line">}</span><br><span class="line">// 仅打印元素</span><br><span class="line">for _, v := range a {</span><br><span class="line">    fmt.Printf("%d\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var q [3]int = [3]int{1, 2, 3}</span><br><span class="line">var r [3]int = [3]int{1, 2}</span><br><span class="line">fmt.Println(r[2]) // "0"</span><br></pre></td></tr></tbody></table></figure>
<p>在数组的定义中，如果在数组长度的位置出现“…”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q := [...]int{1, 2, 3}</span><br><span class="line">fmt.Printf("%T\n", q) // "[3]int"</span><br></pre></td></tr></tbody></table></figure>
<p>数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q := [3]int{1, 2, 3}</span><br><span class="line">q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="比较两个数组是否相等"><a href="#比较两个数组是否相等" class="headerlink" title="比较两个数组是否相等"></a>比较两个数组是否相等</h3><p>如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := [2]int{1, 2}</span><br><span class="line">b := [...]int{1, 2}</span><br><span class="line">c := [2]int{1, 3}</span><br><span class="line">fmt.Println(a == b, a == c, b == c) // "true false false"</span><br><span class="line">d := [3]int{1, 2}</span><br><span class="line">fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历数组——访问每一个数组元素"><a href="#遍历数组——访问每一个数组元素" class="headerlink" title="遍历数组——访问每一个数组元素"></a>遍历数组——访问每一个数组元素</h3><p>遍历数组也和遍历切片类似，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var team [3]string</span><br><span class="line">team[0] = "hammer"</span><br><span class="line">team[1] = "soldier"</span><br><span class="line">team[2] = "mum"</span><br><span class="line"></span><br><span class="line">for k, v := range team {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 hammer</span><br><span class="line">1 soldier</span><br><span class="line">2 mum</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。</li>
<li>第 7 行，将每个键值打印出来。</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。</p>
<p>声明多维数组的语法如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var array_name [size1][size2]...[sizen] array_type</span><br></pre></td></tr></tbody></table></figure>
<p>其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。</p>
<p>以二维数组为例来简单讲解一下多维数组的使用。</p>
<p>二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。</p>
<p>【示例 1】声明二维数组:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型数组，两个维度的长度分别是 4 和 2</span><br><span class="line">var array [4][2]int</span><br><span class="line">// 使用数组字面量来声明并初始化一个二维整型数组</span><br><span class="line">array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}</span><br><span class="line">// 声明并初始化数组中索引为 1 和 3 的元素</span><br><span class="line">array = [4][2]int{1: {20, 21}, 3: {40, 41}}</span><br><span class="line">// 声明并初始化数组中指定的元素</span><br><span class="line">array = [4][2]int{1: {0: 20}, 3: {1: 41}}</span><br></pre></td></tr></tbody></table></figure>
<p>下图展示了上面示例中声明的二维数组在每次声明并初始化后包含的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Array2.gif" alt="图：二维数组及其外层数组和内层数组的值"></p>
<p>为了访问单个元素，需要反复组合使用[ ]方括号，如下所示。</p>
<p>【示例 2】为二维数组的每个元素赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个 2×2 的二维整型数组</span><br><span class="line">var array [2][2]int</span><br><span class="line">// 设置每个元素的整型值</span><br><span class="line">array[0][0] = 10</span><br><span class="line">array[0][1] = 20</span><br><span class="line">array[1][0] = 30</span><br><span class="line">array[1][1] = 40</span><br></pre></td></tr></tbody></table></figure>
<p>只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。</p>
<p>【示例 3】同样类型的多维数组赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明两个二维整型数组</span><br><span class="line">var array1 [2][2]int</span><br><span class="line">var array2 [2][2]int</span><br><span class="line">// 为array2的每个元素赋值</span><br><span class="line">array2[0][0] = 10</span><br><span class="line">array2[0][1] = 20</span><br><span class="line">array2[1][0] = 30</span><br><span class="line">array2[1][1] = 40</span><br><span class="line">// 将 array2 的值复制给 array1</span><br><span class="line">array1 = array2</span><br></pre></td></tr></tbody></table></figure>
<p>因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。</p>
<p>【示例 4】使用索引为多维数组赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里</span><br><span class="line">var array3 [2]int = array1[1]</span><br><span class="line">// 将数组中指定的整型值复制到新的整型变量里</span><br><span class="line">var value int = array1[1][0]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="go-slice"><a href="#go-slice" class="headerlink" title="go slice"></a>go slice</h2><p>切片（Slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p>
<p>Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slice.jpg" alt="图：切片结构和内存分配"></p>
<h3 id="从数组或切片生成新的切片"><a href="#从数组或切片生成新的切片" class="headerlink" title="从数组或切片生成新的切片"></a>从数组或切片生成新的切片</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p>
<p>从连续内存区域生成切片是常见的操作，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">slice [开始位置 : 结束位置]</span><br></pre></td></tr></tbody></table></figure>
<p>语法说明如下：</p>
<ul>
<li>slice：表示目标切片对象；</li>
<li>开始位置：对应目标切片对象的索引；</li>
<li>结束位置：对应目标切片的结束索引。</li>
</ul>
<p>从数组生成切片，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a  = [3]int{1, 2, 3}</span><br><span class="line">fmt.Println(a, a[1:2])</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]  [2]</span><br></pre></td></tr></tbody></table></figure>
<p>其中 [2] 就是 a[1:2] 切片操作的结果。</p>
<p>从数组或切片生成新的切片拥有如下特性：</p>
<ul>
<li>取出的元素数量为：结束位置 - 开始位置；</li>
<li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li>
<li>当缺省开始位置时，表示从连续区域开头到结束位置；</li>
<li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li>
<li>两者同时缺省时，与切片本身等效；</li>
<li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li>
</ul>
<p>根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。</p>
<p>下面通过实例来熟悉切片的特性。</p>
<h4 id="从指定范围中生成切片"><a href="#从指定范围中生成切片" class="headerlink" title="从指定范围中生成切片"></a>从指定范围中生成切片</h4><p>切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var highRiseBuilding [30]int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 30; i++ {</span><br><span class="line">        highRiseBuilding[i] = i + 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 区间</span><br><span class="line">fmt.Println(highRiseBuilding[10:15])</span><br><span class="line"></span><br><span class="line">// 中间到尾部的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[20:])</span><br><span class="line"></span><br><span class="line">// 开头到中间指定位置的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[:2])</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[11 12 13 14 15]</span><br><span class="line">[21 22 23 24 25 26 27 28 29 30]</span><br><span class="line">[1 2]</span><br></pre></td></tr></tbody></table></figure>
<p>代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。</p>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，尝试出租一个区间楼层。</li>
<li>第 11 行，出租 20 层以上。</li>
<li>第 14 行，出租 2 层以下，一般是商用铺面。</li>
</ul>
<p>切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p>
<h4 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h4><p>生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[:])</span><br></pre></td></tr></tbody></table></figure>
<p>a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure>
<p>重置切片，清空拥有的元素<br>把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[0:0])</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="直接声明新的切片"><a href="#直接声明新的切片" class="headerlink" title="直接声明新的切片"></a>直接声明新的切片</h3><p>除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name []Type</span><br></pre></td></tr></tbody></table></figure>
<p>其中 name 表示切片的变量名，Type 表示切片对应的元素类型。</p>
<p>下面代码展示了切片声明的使用过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明字符串切片</span><br><span class="line">var strList []string</span><br><span class="line"></span><br><span class="line">// 声明整型切片</span><br><span class="line">var numList []int</span><br><span class="line"></span><br><span class="line">// 声明一个空切片</span><br><span class="line">var numListEmpty = []int{}</span><br><span class="line"></span><br><span class="line">// 输出3个切片</span><br><span class="line">fmt.Println(strList, numList, numListEmpty)</span><br><span class="line"></span><br><span class="line">// 输出3个切片大小</span><br><span class="line">fmt.Println(len(strList), len(numList), len(numListEmpty))</span><br><span class="line"></span><br><span class="line">// 切片判定空的结果</span><br><span class="line">fmt.Println(strList == nil)</span><br><span class="line">fmt.Println(numList == nil)</span><br><span class="line">fmt.Println(numListEmpty == nil)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[] [] []</span><br><span class="line">0 0 0</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明一个字符串切片，切片中拥有多个字符串。</li>
<li>第 5 行，声明一个整型切片，切片中拥有多个整型数值。</li>
<li>第 8 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。</li>
<li>第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。</li>
<li>第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。</li>
<li>第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。</li>
<li>第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。</li>
</ul>
<p>切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 append() 函数向切片中添加元素。</p>
<h3 id="使用-make-函数构造切片"><a href="#使用-make-函数构造切片" class="headerlink" title="使用 make() 函数构造切片"></a>使用 make() 函数构造切片</h3><p>如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make( []Type, size, cap )</span><br></pre></td></tr></tbody></table></figure>
<p>其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := make([]int, 2)</span><br><span class="line">b := make([]int, 2, 10)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(len(a), len(b))</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 0] [0 0]</span><br><span class="line">2 2</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。</p>
<p>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p>
<p><strong><em>提醒:使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</em></strong></p>
<h3 id="append-为切片添加元素"><a href="#append-为切片添加元素" class="headerlink" title="append()为切片添加元素"></a>append()为切片添加元素</h3><p>Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a, 1) // 追加1个元素</span><br><span class="line">a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式</span><br><span class="line">a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包</span><br></pre></td></tr></tbody></table></figure>
<p>不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。</p>
<p>切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var numbers []int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    numbers = append(numbers, i)</span><br><span class="line">    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">len: 1  cap: 1 pointer: 0xc0420080e8</span><br><span class="line">len: 2  cap: 2 pointer: 0xc042008150</span><br><span class="line">len: 3  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 4  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 5  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 6  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 7  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 8  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 9  cap: 16 pointer: 0xc042074000</span><br><span class="line">len: 10  cap: 16 pointer: 0xc042074000</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明一个整型切片。</li>
<li>第 4 行，循环向 numbers 切片中添加 10 个数。</li>
<li>第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。</li>
</ul>
<p>通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。</p>
<p>往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。</p>
<ul>
<li>员工和工位就是切片中的元素。</li>
<li>办公地就是分配好的内存。</li>
<li>搬家就是重新分配内存。</li>
<li>无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。</li>
<li>由于搬家后地址发生变化，因此内存“地址”也会有修改。</li>
</ul>
<p>除了在切片的尾部追加，我们还可以在切片的开头添加元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = []int{1,2,3}</span><br><span class="line">a = append([]int{0}, a...) // 在开头添加1个元素</span><br><span class="line">a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片</span><br></pre></td></tr></tbody></table></figure>
<p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p>
<p>因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x</span><br><span class="line">a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片</span><br></pre></td></tr></tbody></table></figure>
<p>每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。</p>
<h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p>
<p>copy() 函数的使用格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">copy( destSlice, srcSlice []T) int</span><br></pre></td></tr></tbody></table></figure>
<p>其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。</p>
<p>下面的代码展示了使用 copy() 函数将一个切片复制到另一个切片的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">slice1 := []int{1, 2, 3, 4, 5}</span><br><span class="line">slice2 := []int{5, 4, 3}</span><br><span class="line">copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中</span><br><span class="line">copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre></td></tr></tbody></table></figure>
<p>虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题。</p>
<p>【示例】通过代码演示对切片的引用和复制操作后对切片元素的影响。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 设置元素数量为1000</span><br><span class="line">    const elementCount = 1000</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    srcData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将切片赋值</span><br><span class="line">    for i := 0; i &lt; elementCount; i++ {</span><br><span class="line">        srcData[i] = i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 引用切片数据</span><br><span class="line">    refData := srcData</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    copyData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将数据复制到新的切片空间中</span><br><span class="line">    copy(copyData, srcData)</span><br><span class="line"></span><br><span class="line">    // 修改原始数据的第一个元素</span><br><span class="line">    srcData[0] = 999</span><br><span class="line"></span><br><span class="line">    // 打印引用切片的第一个元素</span><br><span class="line">    fmt.Println(refData[0])</span><br><span class="line"></span><br><span class="line">    // 打印复制切片的第一个和最后一个元素</span><br><span class="line">    fmt.Println(copyData[0], copyData[elementCount-1])</span><br><span class="line"></span><br><span class="line">    // 复制原始数据从4到6(不包含)</span><br><span class="line">    copy(copyData, srcData[4:6])</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        fmt.Printf("%d ", copyData[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">999</span><br><span class="line">0 999</span><br><span class="line">4 5 2 3 4 5 6 7 8 9</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义元素总量为 1000。</li>
<li>第 11 行，预分配拥有 1000 个元素的整型切片，这个切片将作为原始数据。</li>
<li>第 14～16 行，将 srcData 填充 0～999 的整型值。</li>
<li>第 19 行，将 refData 引用 srcData，切片不会因为等号操作进行元素的复制。</li>
<li>第 22 行，预分配与 srcData 等大（大小相等）、同类型的切片 copyData。</li>
<li>第 24 行，使用 copy() 函数将原始数据复制到 copyData 切片空间中。</li>
<li>第 27 行，修改原始数据的第一个元素为 999。</li>
<li>第 30 行，引用数据的第一个元素将会发生变化。</li>
<li>第 33 行，打印复制数据的首位数据，由于数据是复制的，因此不会发生变化。</li>
<li>第 36 行，将 srcData 的局部数据复制到 copyData 中。</li>
<li>第 38～40 行，打印复制局部数据后的 copyData 元素。</li>
</ul>
<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。</p>
<h4 id="从开头位置删除"><a href="#从开头位置删除" class="headerlink" title="从开头位置删除"></a>从开头位置删除</h4><p>删除开头的元素可以直接移动数据指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[1:] // 删除开头1个元素</span><br><span class="line">a = a[N:] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = append(a[:0], a[1:]...) // 删除开头1个元素</span><br><span class="line">a = append(a[:0], a[N:]...) // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>还可以用 copy() 函数来删除开头的元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:copy(a, a[1:])] // 删除开头1个元素</span><br><span class="line">a = a[:copy(a, a[N:])] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<h4 id="从中间位置删除"><a href="#从中间位置删除" class="headerlink" title="从中间位置删除"></a>从中间位置删除</h4><p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3, ...}</span><br><span class="line">a = append(a[:i], a[i+1:]...) // 删除中间1个元素</span><br><span class="line">a = append(a[:i], a[i+N:]...) // 删除中间N个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素</span><br></pre></td></tr></tbody></table></figure>
<h4 id="从尾部删除"><a href="#从尾部删除" class="headerlink" title="从尾部删除"></a>从尾部删除</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:len(a)-1] // 删除尾部1个元素</span><br><span class="line">a = a[:len(a)-N] // 删除尾部N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。</p>
<p>【示例】删除切片指定位置的元素。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    seq := []string{"a", "b", "c", "d", "e"}</span><br><span class="line"></span><br><span class="line">    // 指定删除位置</span><br><span class="line">    index := 2</span><br><span class="line"></span><br><span class="line">    // 查看删除位置之前的元素和之后的元素</span><br><span class="line">    fmt.Println(seq[:index], seq[index+1:])</span><br><span class="line"></span><br><span class="line">    // 将删除点前后的元素连接起来</span><br><span class="line">    seq = append(seq[:index], seq[index+1:]...)</span><br><span class="line"></span><br><span class="line">    fmt.Println(seq)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[a b] [d e]</span><br><span class="line">[a b d e]</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明一个字符串切片，保存含有从 a 到 e 的字符串。</li>
<li>第 9 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。</li>
<li>第 12 行，seq[:index] 表示的就是被删除元素的前半部分，值为 [a b]，seq[index+1:] 表示的是被删除元素的后半部分，值为 [d e]。</li>
<li>第 15 行，使用 append() 函数将两个切片连接起来。</li>
<li>第 17 行，输出连接好的新切片，此时，索引为 2 的元素已经被删除。</li>
</ul>
<p>代码的删除过程可以使用下图来描述。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceremove.jpg" alt="图：切片删除元素的操作过程"></p>
<p>Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p>
<p><strong><em>提示:连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。</em></strong></p>
<h3 id="循环迭代切片"><a href="#循环迭代切片" class="headerlink" title="循环迭代切片"></a>循环迭代切片</h3><p>通过前面的学习我们了解到切片其实就是多个相同类型元素的连续集合，既然切片是一个集合，那么我们就可以迭代其中的元素，Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每一个元素，并显示其值</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 4 行中的 index 和 value 分别用来接收 range 关键字返回的切片中每个元素的索引和值，这里的 index 和 value 不是固定的，读者也可以定义成其它的名字。</p>
<p>上面代码的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Index: 0 Value: 10</span><br><span class="line">Index: 1 Value: 20</span><br><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>当迭代切片时，关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slicerange.gif" alt="图：使用 range 迭代切片会创建每个元素的副本"></p>
<p>需要强调的是，range 返回的是每个元素的副本，而不是直接返回对该元素的引用，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示值和地址</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &amp;value, &amp;slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100</span><br><span class="line">Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104</span><br><span class="line">Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108</span><br><span class="line">Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C</span><br></pre></td></tr></tbody></table></figure>
<p>因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &amp;slice[index]）。</p>
<p>如果不需要索引值，也可以使用下划线 <code>_</code> 来忽略这个值，代码如下所示。</p>
<p>【示例 2】使用空白标识符（下划线）来忽略索引值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示其值</span><br><span class="line">for _, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d\n", value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br><span class="line">Value: 30</span><br><span class="line">Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环，代码如下所示。</p>
<p>【示例 3】使用传统的 for 循环对切片进行迭代</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 从第三个元素开始迭代每个元素</span><br><span class="line">for index := 2; index &lt; len(slice); index++ {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>在前面几节的学习中我们了解了两个特殊的内置函数 len() 和 cap()，可以用于处理数组、切片和通道，对于切片，函数 len() 可以返回切片的长度，函数 cap() 可以返回切片的容量，在上面的示例中，使用到了函数 len() 来控制循环迭代的次数。</p>
<p>当然，range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等，这些我们将在后面的学习中详细介绍。</p>
<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>Go语言中同样允许使用多维切片，声明一个多维切片的语法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></tbody></table></figure>
<p>其中，sliceName 为切片的名字，sliceType为切片的类型，每个 <code>[ ]</code> 代表着一个维度，切片有几个维度就需要几个 <code>[ ]</code> 。</p>
<p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">//为二维切片赋值</span><br><span class="line">slice = [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码也可以简写为下面的样子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中展示了一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片，切片 slice 的值如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerwei.gif" alt="图：整型切片的切片的值"></p>
<p>通过上图可以看到外层的切片包括两个元素，每个元素都是一个切片，第一个元素中的切片使用单个整数 10 来初始化，第二个元素中的切片包括两个整数，即 100 和 200。</p>
<p>这种组合可以让用户创建非常复杂且强大的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，前面介绍过的关于内置函数 append() 的规则也可以应用到组合后的切片上，如下所示。</p>
<p>【示例】组合切片的切片</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br><span class="line">// 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] = append(slice[0], 20)</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言里使用 append() 函数处理追加的方式很简明，先增长切片，再将新的整型切片赋值给外层切片的第一个元素，当上面代码中的操作完成后，再将切片复制到外层切片的索引为 0 的元素，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerweiappend.gif" alt="图：append 操作之后外层切片索引为 0 的元素的布局"></p>
<p>即便是这么简单的多维切片，操作时也会涉及众多的布局和值，在函数间这样传递数据结构会很复杂，不过切片本身结构很简单，可以用很小的成本在函数间传递。</p>
<h2 id="go-map"><a href="#go-map" class="headerlink" title="go map"></a>go map</h2><p>Go语言中 map 是一种特殊的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value。</p>
<p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p>
<h3 id="map-概念"><a href="#map-概念" class="headerlink" title="map 概念"></a>map 概念</h3><p>map 是引用类型，可以使用如下方式声明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var mapname map[keytype]valuetype</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>mapname 为 map 的变量名。</li>
<li>keytype 为键类型。</li>
<li>valuetype 是键对应的值类型。</li>
</ul>
<p><strong><em>提示：[keytype] 和 valuetype 之间允许有空格。</em></strong></p>
<p>在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目。</p>
<p>【示例】</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var mapLit map[string]int</span><br><span class="line">    //var mapCreated map[string]float32</span><br><span class="line">    var mapAssigned map[string]int</span><br><span class="line">    mapLit = map[string]int{"one": 1, "two": 2}</span><br><span class="line">    mapCreated := make(map[string]float32)</span><br><span class="line">    mapAssigned = mapLit</span><br><span class="line">    mapCreated["key1"] = 4.5</span><br><span class="line">    mapCreated["key2"] = 3.14159</span><br><span class="line">    mapAssigned["two"] = 3</span><br><span class="line">    fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])</span><br><span class="line">    fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])</span><br><span class="line">    fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])</span><br><span class="line">    fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Map literal at "one" is: 1</span><br><span class="line">Map created at "key2" is: 3.14159</span><br><span class="line">Map assigned at "two" is: 3</span><br><span class="line">Map literal at "ten" is: 0</span><br></pre></td></tr></tbody></table></figure>
<p>示例中 mapLit 演示了使用 <code>{key1: value1, key2: value2}</code> 的格式来初始化 map ，就像数组和结构体一样。</p>
<p>上面代码中的 mapCreated 的创建方式 <code>mapCreated := make(map[string]float)</code> 等价于 <code>mapCreated := map[string]float{}</code> 。</p>
<p>mapAssigned 是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。</p>
<p>注意：可以使用 <code>make()</code> ，但不能使用 <code>new()</code> 来构造 map，如果错误的使用 <code>new()</code> 分配了一个引用对象，会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mapCreated := new(map[string]float)</span><br></pre></td></tr></tbody></table></figure>
<p>接下来当我们调用 <code>mapCreated["key1"] = 4.5</code> 的时候，编译器会报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">invalid operation: mapCreated["key1"] (index of type *map[string]float).</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h3><p>和数组不同，map 可以根据新增的 key-value 动态的伸缩，因此它不存在固定长度或者最大限制，但是也可以选择标明 map 的初始容量 capacity，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make(map[keytype]valuetype, cap)</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map2 := make(map[string]float, 100)</span><br></pre></td></tr></tbody></table></figure>
<p>当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p>
<p>这里有一个 map 的具体例子，即将音阶和对应的音频映射起来：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">noteFrequency := map[string]float32 {</span><br><span class="line">"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,</span><br><span class="line">"G0": 24.50, "A0": 27.50, "B0": 30.87, "A4": 440}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="用切片作为-map-的值"><a href="#用切片作为-map-的值" class="headerlink" title="用切片作为 map 的值"></a>用切片作为 map 的值</h3><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mp1 := make(map[int][]int)</span><br><span class="line">mp2 := make(map[int]*[]int)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map-遍历"><a href="#map-遍历" class="headerlink" title="map 遍历"></a>map 遍历</h3><p>map 的遍历过程使用 for range 循环完成，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>遍历对于Go语言的很多对象来说都是差不多的，直接使用 for range 语法即可，遍历时，可以同时获得键和值，如只遍历值，可以使用下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for _, v := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将不需要的键使用_改为匿名变量形式。</p>
<p>只遍历键时，使用下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for k := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>无须将值改为匿名变量形式，忽略值即可。</p>
<p><strong><em>注意：遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。</em></strong></p>
<p>如果需要特定顺序的遍历结果，正确的做法是先排序，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">// 声明一个切片保存map数据</span><br><span class="line">var sceneList []string</span><br><span class="line"></span><br><span class="line">// 将map数据遍历复制到切片中</span><br><span class="line">for k := range scene {</span><br><span class="line">    sceneList = append(sceneList, k)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 对切片进行排序</span><br><span class="line">sort.Strings(sceneList)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">fmt.Println(sceneList)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[brazil china route]</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个 map 实例，键为字符串，值为整型。</li>
<li>第 4～6 行，将 3 个键值对写入 map 中。</li>
<li>第 9 行，声明 sceneList 为字符串切片，以缓冲和排序 map 中的所有元素。</li>
<li>第 12 行，将 map 中元素的键遍历出来，并放入切片中。</li>
<li>第 17 行，对 sceneList 字符串切片进行排序，排序时，sceneList 会被修改。</li>
<li>第 20 行，输出排好序的 map 的键。</li>
</ul>
<p>sort.Strings 的作用是对传入的字符串切片进行字符串字符的升序排列，排序接口的使用将在后面的章节中介绍。</p>
<h3 id="map-删除和清空"><a href="#map-删除和清空" class="headerlink" title="map 删除和清空"></a>map 删除和清空</h3><p>Go语言提供了一个内置函数 delete()，用于删除容器内的元素，下面我们简单介绍一下如何用 delete() 函数删除 map 内的元素。</p>
<h4 id="使用-delete-函数从-map-中删除键值对"><a href="#使用-delete-函数从-map-中删除键值对" class="headerlink" title="使用 delete() 函数从 map 中删除键值对"></a>使用 delete() 函数从 map 中删除键值对</h4><p>使用 delete() 内建函数从 map 中删除一组键值对，delete() 函数的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">delete(map, 键)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 map 为要删除的 map 实例，键为要删除的 map 中键值对的键。</p>
<p>从 map 中删除一组键值对可以通过下面的代码来完成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">delete(scene, "brazil")</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">route 66</span><br><span class="line">china 960</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子中使用 delete() 函数将 brazil 从 scene 这个 map 中删除了。</p>
<h4 id="清空-map-中的所有元素"><a href="#清空-map-中的所有元素" class="headerlink" title="清空 map 中的所有元素"></a>清空 map 中的所有元素</h4><p>有意思的是，Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p>
<h3 id="map的多键索引——多个数值条件可以同时查询"><a href="#map的多键索引——多个数值条件可以同时查询" class="headerlink" title="map的多键索引——多个数值条件可以同时查询"></a>map的多键索引——多个数值条件可以同时查询</h3><p>在大多数的编程语言中，映射容器的键必须以单一值存在。这种映射方法经常被用在诸如信息检索上，如根据通讯簿的名字进行检索。但随着查询条件越来越复杂，检索也会变得越发困难。下面例子中涉及通讯簿的结构，结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 人员档案</span><br><span class="line">type Profile struct {</span><br><span class="line">    Name    string   // 名字</span><br><span class="line">    Age     int      // 年龄</span><br><span class="line">    Married bool     // 已婚</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>并且准备好了一堆原始数据，需要算法实现构建索引和查询的过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    list := []*Profile{</span><br><span class="line">        {Name: "张三", Age: 30, Married: true},</span><br><span class="line">        {Name: "李四", Age: 21},</span><br><span class="line">        {Name: "王麻子", Age: 21},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildIndex(list)</span><br><span class="line"></span><br><span class="line">    queryData("张三", 30)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要用算法实现 buildIndex() 构建索引函数及 queryData() 查询数据函数，查询到结果后将数据打印出来。</p>
<p>下面，分别基于传统的基于哈希值的多键索引和利用 map 特性的多键索引进行查询。</p>
<h4 id="基于哈希值的多键索引及查询"><a href="#基于哈希值的多键索引及查询" class="headerlink" title="基于哈希值的多键索引及查询"></a>基于哈希值的多键索引及查询</h4><p>传统的数据索引过程是将输入的数据做特征值。这种特征值有几种常见做法：</p>
<ul>
<li>将特征使用某种算法转为整数，即哈希值，使用整型值做索引。</li>
<li>将特征转为字符串，使用字符串做索引。</li>
</ul>
<p>数据都基于特征值构建好索引后，就可以进行查询。查询时，重复这个过程，将查询条件转为特征值，使用特征值进行查询得到结果。</p>
<h5 id="字符串转哈希值"><a href="#字符串转哈希值" class="headerlink" title="字符串转哈希值"></a>字符串转哈希值</h5><p>查询键（classicQueryKey）的特征值需要将查询键中每一个字段转换为整型，字符串也需要转换为整型值，这里使用一种简单算法将字符串转换为需要的哈希值，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func simpleHash(str string) (ret int) {</span><br><span class="line"></span><br><span class="line">    // 遍历字符串中的每一个ASCII字符</span><br><span class="line">    for i := 0; i &lt; len(str); i++ {</span><br><span class="line">        // 取出字符</span><br><span class="line">        c := str[i]</span><br><span class="line"></span><br><span class="line">        // 将字符的ASCII码相加</span><br><span class="line">        ret += int(c)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行传入需要计算哈希值的字符串。</li>
<li>第 4 行，根据字符串的长度，遍历这个字符串的每一个字符，以 ASCII 码为单位。</li>
<li>第 9 行，c 变量的类型为 uint8，将其转为 int 类型并累加。</li>
</ul>
<p>哈希算法有很多，这里只是选用一种大家便于理解的算法。哈希算法的选用的标准是尽量减少重复键的发生，俗称“哈希冲撞”，即同样两个字符串的哈希值重复率降到最低。</p>
<h5 id="查询键"><a href="#查询键" class="headerlink" title="查询键"></a>查询键</h5><p>有了哈希算法函数后，将哈希函数用在查询键结构中。查询键结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type classicQueryKey struct {</span><br><span class="line">    Name string  // 要查询的名字</span><br><span class="line">    Age  int     // 要查询的年龄</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 计算查询键的哈希值</span><br><span class="line">func (c *classicQueryKey) hash() int {</span><br><span class="line">    // 将名字的Hash和年龄哈希合并</span><br><span class="line">    return simpleHash(c.Name) + c.Age*1000000</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明查询键的结构，查询键包含需要索引和查询的字段。</li>
<li>第 8 行，查询键的成员方法哈希，通过调用这个方法获得整个查询键的哈希值。</li>
<li>第 10 行，查询键哈希的计算方法：使用 simpleHash() 函数根据给定的名字字符串获得其哈希值。同时将年龄乘以 1000000 与名字哈希值相加。</li>
</ul>
<p>哈希值构建过程如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicQueryKey.jpg" alt="哈希值构建过程"></p>
<h5 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h5><p>本例需要快速查询，因此需要提前对已有的数据构建索引。前面已经准备好了数据查询键，使用查询键获得哈希即可对数据进行快速索引，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建哈希值到数据的索引关系</span><br><span class="line">var mapper = make(map[int][]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建数据索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有的数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建数据的查询索引</span><br><span class="line">        key := classicQueryKey{profile.Name, profile.Age}</span><br><span class="line"></span><br><span class="line">        // 计算数据的哈希值, 取出已经存在的记录</span><br><span class="line">        existValue := mapper[key.hash()]</span><br><span class="line"></span><br><span class="line">        // 将当前数据添加到已经存在的记录切片中</span><br><span class="line">        existValue = append(existValue, profile)</span><br><span class="line"></span><br><span class="line">        // 将切片重新设置到映射中</span><br><span class="line">        mapper[key.hash()] = existValue</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，实例化一个 map，键类型为整型，保存哈希值；值类型为 *Profile，为通讯簿的数据格式。</li>
<li>第 5 行，构建索引函数入口，传入数据切片。</li>
<li>第 8 行，遍历数据切片的所有数据元素。</li>
<li>第 11 行，使用查询键（classicQueryKey）来辅助计算哈希值，查询键需要填充两个字段，将数据中的名字和年龄赋值到查询键中进行保存。</li>
<li>第 14 行，使用查询键的哈希方法计算查询键的哈希值。通过这个值在 mapper 索引中查找相同哈希值的数据切片集合。因为哈希函数不能保证不同数据的哈希值一定完全不同，因此要考虑在发生哈希值重复时的处理办法。</li>
<li>第 17 行，将当前数据添加到可能存在的切片中。</li>
<li>第 20 行，将新添加好的数据切片重新赋值到相同哈希的 mapper 中。</li>
</ul>
<p>具体哈希结构如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicMap.jpg" alt="图：哈希结构"></p>
<p>这种多键的算法就是哈希算法。map 的多个元素对应哈希的“桶”。哈希函数的选择决定桶的映射好坏，如果哈希冲撞很厉害，那么就需要将发生冲撞的相同哈希值的元素使用切片保存起来。</p>
<h5 id="经典查询逻辑"><a href="#经典查询逻辑" class="headerlink" title="经典查询逻辑"></a>经典查询逻辑</h5><p>从已经构建好索引的数据中查询需要的数据流程如下：</p>
<ul>
<li>给定查询条件（名字、年龄）。</li>
<li>根据查询条件构建查询键。</li>
<li>查询键生成哈希值。</li>
<li>根据哈希值在索引中查找数据集合。</li>
<li>遍历数据集合逐个与条件比对。</li>
<li>获得结果。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据给定查询条件构建查询键</span><br><span class="line">    keyToQuery := classicQueryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 计算查询键的哈希值并查询, 获得相同哈希值的所有结果集合</span><br><span class="line">    resultList := mapper[keyToQuery.hash()]</span><br><span class="line"></span><br><span class="line">    // 遍历结果集合</span><br><span class="line">    for _, result := range resultList {</span><br><span class="line"></span><br><span class="line">        // 与查询结果比对, 确认找到打印结果</span><br><span class="line">        if result.Name == name &amp;&amp; result.Age == age {</span><br><span class="line">            fmt.Println(result)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 没有查询到时, 打印结果</span><br><span class="line">    fmt.Println("no found")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，查询条件（名字、年龄）。</li>
<li>第 4 行，根据查询条件构建查询键。</li>
<li>第 7 行，使用查询键计算哈希值，使用哈希值查询相同哈希值的所有数据集合。</li>
<li>第 10 行，遍历所有相同哈希值的数据集合。</li>
<li>第 13 行，将每个数据与查询条件进行比对，如果一致，表示已经找到结果，打印并返回。</li>
<li>第 20 行，没有找到记录时，打印 no found。</li>
</ul>
<h4 id="利用-map-特性的多键索引及查询"><a href="#利用-map-特性的多键索引及查询" class="headerlink" title="利用 map 特性的多键索引及查询"></a>利用 map 特性的多键索引及查询</h4><p>使用结构体进行多键索引和查询比传统的写法更为简单，最主要的区别是无须准备哈希函数及相应的字段无须做哈希合并。看下面的实现流程。</p>
<h5 id="经典构建索引"><a href="#经典构建索引" class="headerlink" title="经典构建索引"></a>经典构建索引</h5><p>代码如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type queryKey struct {</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建查询键到数据的映射</span><br><span class="line">var mapper = make(map[queryKey]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建查询索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建查询键</span><br><span class="line">        key := queryKey{</span><br><span class="line">            Name: profile.Name,</span><br><span class="line">            Age:  profile.Age,</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 保存查询键</span><br><span class="line">        mapper[key] = profile</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，与基于哈希值的查询键的结构相同。</li>
<li>第 8 行，在 map 的键类型上，直接使用了查询键结构体。注意，这里不使用查询键的指针。同时，结果只有 <code>*Profile</code> 类型，而不是 <code>*Profile</code> 切片，表示查到的结果唯一。</li>
<li>第 17 行，类似的，使用遍历到的数据的名字和年龄构建查询键。</li>
<li>第 23 行，更简单的，直接将查询键保存对应的数据。</li>
</ul>
<h5 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 根据条件查询数据</span><br><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据查询条件构建查询键</span><br><span class="line">    key := queryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 根据键值查询数据</span><br><span class="line">    result, ok := mapper[key]</span><br><span class="line"></span><br><span class="line">    // 找到数据打印出来</span><br><span class="line">    if ok {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("no found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行，根据查询条件（名字、年龄）构建查询键。</li>
<li>第 8 行，直接使用查询键在 map 中查询结果。</li>
<li>第 12 行，找到结果直接打印。</li>
<li>第 14 行，没有找到结果打印 no found。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>基于哈希值的多键索引查询和利用 map 特性的多键索引查询的代码复杂程度显而易见。聪明的程序员都会利用 Go语言的特性进行快速的多键索引查询。</p>
<p>其实，利用 map 特性的例子中的 map 类型即便修改为下面的格式，也一样可以获得同样的结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var mapper = make(map[interface{}]*Profile)</span><br></pre></td></tr></tbody></table></figure>
<p>代码量大大减少的关键是：Go语言的底层会为 map 的键自动构建哈希值。能够构建哈希值的类型必须是非动态类型、非指针、函数、闭包。</p>
<ul>
<li>非动态类型：可用数组，不能用切片。</li>
<li>非指针：每个指针数值都不同，失去哈希意义。</li>
<li>函数、闭包不能作为 map 的键。</li>
</ul>
<h3 id="sync-Map（同步map"><a href="#sync-Map（同步map" class="headerlink" title="sync.Map（同步map)"></a>sync.Map（同步map)</h3><p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p>
<p>下面来看下并发情况下读写 map 时会出现的问题，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个int到int的映射</span><br><span class="line">m := make(map[int]int)</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行写入</span><br><span class="line">    for {</span><br><span class="line">        m[1] = 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行读取</span><br><span class="line">    for {</span><br><span class="line">        _ = m[1]</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 无限循环, 让并发程序在后台执行</span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码会报错，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></tbody></table></figure>
<p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p>
<p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<p>sync.Map 有以下特性：</p>
<ul>
<li>无须初始化，直接声明即可。</li>
<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
<li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li>
</ul>
<p>并发安全的 sync.Map 演示代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">      "fmt"</span><br><span class="line">      "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var scene sync.Map</span><br><span class="line"></span><br><span class="line">    // 将键值对保存到sync.Map</span><br><span class="line">    scene.Store("greece", 97)</span><br><span class="line">    scene.Store("london", 100)</span><br><span class="line">    scene.Store("egypt", 200)</span><br><span class="line"></span><br><span class="line">    // 从sync.Map中根据键取值</span><br><span class="line">    fmt.Println(scene.Load("london"))</span><br><span class="line"></span><br><span class="line">    // 根据键删除对应的键值对</span><br><span class="line">    scene.Delete("london")</span><br><span class="line"></span><br><span class="line">    // 遍历所有sync.Map中的键值对</span><br><span class="line">    scene.Range(func(k, v interface{}) bool {</span><br><span class="line"></span><br><span class="line">        fmt.Println("iterate:", k, v)</span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100 true</span><br><span class="line">iterate: egypt 200</span><br><span class="line">iterate: greece 97</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，声明 scene，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li>
<li>第 13～15 行，将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li>
<li>第 18 行，提供一个 sync.Map 的键给 scene.Load() 方法后将查询到键对应的值返回。</li>
<li>第 21 行，sync.Map 的 Delete 可以使用指定的键将对应的键值对删除。</li>
<li>第 24 行，Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li>
</ul>
<p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>
<h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h2><p>列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p>
<p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.jpg" alt="图：三人单向通知电话号码形成单链表结构"></p>
<p>如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.jpg" alt="图：三人相互通知电话号码形成双链表结构"></p>
<p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。</p>
<p>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/removelinklist.jpg" alt="图：从双链表中删除一人的电话号码"></p>
<p>在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</p>
<p>1) 通过 container/list 包的 New() 函数初始化 list</p>
<figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></tbody></table></figure>
<p>2) 通过 var 关键字声明初始化 list</p>
<figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 list.List</span><br></pre></td></tr></tbody></table></figure>
<p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。</p>
<h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。</p>
<p><strong><em>提示：这两个方法都会返回一个 `</em>list.Element<code>结构，如果在以后的使用中需要删除插入的元素，则只能通过</code><em>list.Element` 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。</em></strong></p>
<p>下面代码展示如何给 list 添加元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack("fist")</span><br><span class="line">l.PushFront(67)</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个列表实例。</li>
<li>第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。</li>
<li>第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。</li>
</ul>
<p>列表插入元素的方法如下表所示。</p>
<table>
  <thead><tr><th>方  法</th><th>功  能</th></tr></thead>
  <tbody>
    <tr><th>InsertAfter(v interface {}, mark * Element) * Element</th><th>在 mark 点之后插入元素，mark 点由其他插入函数提供</th></tr>
    <tr><th>InsertBefore(v interface {}, mark * Element) *Element</th><th>在 mark 点之前插入元素，mark 点由其他插入函数提供</th></tr>
    <tr><th>PushBackList(other *List)</th><th>添加 other 列表元素到尾部</th></tr>
    <tr><th>PushFrontList(other *List)</th><th>添加 other 列表元素到头部</th></tr>
  </tbody>
</table>

<h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。</p>
<p>列表操作元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "container/list"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    // 尾部添加</span><br><span class="line">    l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">    // 头部添加</span><br><span class="line">    l.PushFront(67)</span><br><span class="line"></span><br><span class="line">    // 尾部添加后保存元素句柄</span><br><span class="line">    element := l.PushBack("fist")</span><br><span class="line"></span><br><span class="line">    // 在fist之后添加high</span><br><span class="line">    l.InsertAfter("high", element)</span><br><span class="line"></span><br><span class="line">    // 在fist之前添加noon</span><br><span class="line">    l.InsertBefore("noon", element)</span><br><span class="line"></span><br><span class="line">    // 使用</span><br><span class="line">    l.Remove(element)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，创建列表实例。</li>
<li>第 9 行，将字符串 canon 插入到列表的尾部。</li>
<li>第 12 行，将数值 67 添加到列表的头部。</li>
<li>第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。</li>
<li>第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。</li>
<li>第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。</li>
<li>第 24 行，移除 element 变量对应的元素。</li>
</ul>
<p>下表中展示了每次操作后列表的实际元素情况。</p>
<p>列表元素操作的过程</p>
<table>
  <thead><tr><th>操作内容</th><th>列表元素</th></tr></thead>
  <tbody>
    <tr><th>l.PushBack("canon")</th><th>canon</th></tr>
    <tr><th>l.PushFront(67)</th><th>67, canon</th></tr>
    <tr><th>element := l.PushBack("fist")</th><th>67, canon, fist</th></tr>
    <tr><th>l.InsertAfter("high", element)</th><th>67, canon, fist, high</th></tr>
    <tr><th>l.InsertBefore("noon", element)</th><th>67, canon, noon, fist, high</th></tr>
    <tr><th>l.Remove(element)</th><th>67, canon, noon, high</th></tr>
  </tbody>
</table>

<h3 id="遍历列表——访问列表的每一个元素"><a href="#遍历列表——访问列表的每一个元素" class="headerlink" title="遍历列表——访问列表的每一个元素"></a>遍历列表——访问列表的每一个元素</h3><p>遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">// 尾部添加</span><br><span class="line">l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">// 头部添加</span><br><span class="line">l.PushFront(67)</span><br><span class="line"></span><br><span class="line">for i := l.Front(); i != nil; i = i.Next() {</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">67</span><br><span class="line">canon</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个列表实例。</li>
<li>第 4 行，将 canon 放入列表尾部。</li>
<li>第 7 行，在队列头部放入 67。</li>
<li>第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。</li>
<li>第 10 行，使用遍历返回的 <code>*list.Element</code> 的 Value 成员取得放入列表时的原值。</li>
</ul>
<h2 id="go-nil：空值-零值"><a href="#go-nil：空值-零值" class="headerlink" title="go nil：空值/零值"></a>go nil：空值/零值</h2><p>在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串””，而指针、切片、映射、通道、函数和接口的零值则是 nil。</p>
<p>nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。</p>
<p>下面通过几个方面来介绍一下Go语言中 nil。</p>
<h3 id="nil-标识符是不能比较的"><a href="#nil-标识符是不能比较的" class="headerlink" title="nil 标识符是不能比较的"></a>nil 标识符是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(nil==nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:8:21: invalid operation: nil == nil (operator == not defined on nil)</span><br></pre></td></tr></tbody></table></figure>
<p>这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; None == None</span><br><span class="line">True</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的运行结果不难看出，== 对于 nil 来说是一种未定义的操作。</p>
<h3 id="nil-不是关键字或保留字"><a href="#nil-不是关键字或保留字" class="headerlink" title="nil 不是关键字或保留字"></a>nil 不是关键字或保留字</h3><p>nil 并不是Go语言的关键字或者保留字，也就是说我们可以定义一个名称为 nil 的变量，比如下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var nil = errors.New("my god")</span><br></pre></td></tr></tbody></table></figure>
<p>虽然上面的声明语句可以通过编译，但是并不提倡这么做。</p>
<h3 id="nil-没有默认类型"><a href="#nil-没有默认类型" class="headerlink" title="nil 没有默认类型"></a>nil 没有默认类型</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%T", nil)</span><br><span class="line">    print(nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:9:10: use of untyped nil</span><br></pre></td></tr></tbody></table></figure>
<h3 id="不同类型-nil-的指针是一样的"><a href="#不同类型-nil-的指针是一样的" class="headerlink" title="不同类型 nil 的指针是一样的"></a>不同类型 nil 的指针是一样的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var arr []int</span><br><span class="line">    var num *int</span><br><span class="line">    fmt.Printf("%p\n", arr)</span><br><span class="line">    fmt.Printf("%p", num)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x0</span><br><span class="line">0x0</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出 arr 和 num 的指针都是 0x0。</p>
<h3 id="不同类型的-nil-是不能比较的"><a href="#不同类型的-nil-是不能比较的" class="headerlink" title="不同类型的 nil 是不能比较的"></a>不同类型的 nil 是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    fmt.Printf(m == ptr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:20: invalid operation: arr == ptr (mismatched types []int and *int)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="两个相同类型的-nil-值也可能无法比较"><a href="#两个相同类型的-nil-值也可能无法比较" class="headerlink" title="两个相同类型的 nil 值也可能无法比较"></a>两个相同类型的 nil 值也可能无法比较</h3><p>在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的，下面的语句无法编译。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    var s2 []int</span><br><span class="line">    fmt.Printf(s1 == s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:19: invalid operation: s1 == s2 (slice can only be compared to nil)</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的错误提示可以看出，能够将上述不可比较类型的空值直接与 nil 标识符进行比较，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    fmt.Println(s1 == nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<h3 id="nil-是-map、slice、pointer、channel、func、interface-的零值"><a href="#nil-是-map、slice、pointer、channel、func、interface-的零值" class="headerlink" title="nil 是 map、slice、pointer、channel、func、interface 的零值"></a>nil 是 map、slice、pointer、channel、func、interface 的零值</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    var c chan int</span><br><span class="line">    var sl []int</span><br><span class="line">    var f func()</span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Printf("%#v\n", m)</span><br><span class="line">    fmt.Printf("%#v\n", ptr)</span><br><span class="line">    fmt.Printf("%#v\n", c)</span><br><span class="line">    fmt.Printf("%#v\n", sl)</span><br><span class="line">    fmt.Printf("%#v\n", f)</span><br><span class="line">    fmt.Printf("%#v\n", i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[int]string(nil)</span><br><span class="line">(*int)(nil)</span><br><span class="line">(chan int)(nil)</span><br><span class="line">[]int(nil)</span><br><span class="line">(func())(nil)</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>零值是Go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值。</p>
<h3 id="不同类型的-nil-值占用的内存大小可能是不一样的"><a href="#不同类型的-nil-值占用的内存大小可能是不一样的" class="headerlink" title="不同类型的 nil 值占用的内存大小可能是不一样的"></a>不同类型的 nil 值占用的内存大小可能是不一样的</h3><p>一个类型的所有的值的内存布局都是一样的，nil 也不例外，nil 的大小与同类型中的非 nil 类型的大小是一样的。但是不同类型的 nil 值的大小可能不同。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "unsafe"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var p *struct{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( p ) ) // 8</span><br><span class="line"></span><br><span class="line">    var s []int</span><br><span class="line">    fmt.Println( unsafe.Sizeof( s ) ) // 24</span><br><span class="line"></span><br><span class="line">    var m map[int]bool</span><br><span class="line">    fmt.Println( unsafe.Sizeof( m ) ) // 8</span><br><span class="line"></span><br><span class="line">    var c chan string</span><br><span class="line">    fmt.Println( unsafe.Sizeof( c ) ) // 8</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line">    fmt.Println( unsafe.Sizeof( f ) ) // 8</span><br><span class="line"></span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( i ) ) // 16</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">8</span><br><span class="line">24</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure>
<p>具体的大小取决于编译器和架构，上面打印的结果是在 64 位架构和标准编译器下完成的，对应 32 位的架构的，打印的大小将减半。</p>
<h2 id="make和new关键字的区别及实现原理"><a href="#make和new关键字的区别及实现原理" class="headerlink" title="make和new关键字的区别及实现原理"></a>make和new关键字的区别及实现原理</h2><p>Go语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化，下面我们就来具体介绍一下。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>在Go语言中，new 函数描述如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="line">// not a value, and the value returned is a pointer to a newly</span><br><span class="line">// allocated zero value of that type.</span><br><span class="line">func new(Type) *Type</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。</p>
<p>【示例】使用 new 函数为变量分配内存空间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var sum *int</span><br><span class="line">sum = new(int) //分配空间</span><br><span class="line">*sum = 98</span><br><span class="line">fmt.Println(*sum)</span><br></pre></td></tr></tbody></table></figure>
<p>当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Student struct {</span><br><span class="line">   name string</span><br><span class="line">   age int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var s *Student</span><br><span class="line">s = new(Student) //分配空间</span><br><span class="line">s.name ="dequan"</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure>
<p>这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277]</span><br><span class="line">goroutine 1 [running]:</span><br></pre></td></tr></tbody></table></figure>
<p>这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p>
<p>在Go语言中，make 函数的描述如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// The make built-in function allocates and initializes an object of type</span><br><span class="line">// slice, map, or chan (only). Like new, the first argument is a type, not a</span><br><span class="line">// value. Unlike new, make's return type is the same as the type of its</span><br><span class="line">// argument, not a pointer to it. The specification of the result depends on</span><br><span class="line">// the type:</span><br><span class="line">// Slice: The size specifies the length. The capacity of the slice is</span><br><span class="line">// equal to its length. A second integer argument may be provided to</span><br><span class="line">// specify a different capacity; it must be no smaller than the</span><br><span class="line">// length, so make([]int, 0, 10) allocates a slice of length 0 and</span><br><span class="line">// capacity 10.</span><br><span class="line">// Map: An empty map is allocated with enough space to hold the</span><br><span class="line">// specified number of elements. The size may be omitted, in which case</span><br><span class="line">// a small starting size is allocated.</span><br><span class="line">// Channel: The channel's buffer is initialized with the specified</span><br><span class="line">// buffer capacity. If zero, or the size is omitted, the channel is</span><br><span class="line">// unbuffered.</span><br><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。</p>
<p><strong><em>注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。</em></strong></p>
<p>Go语言中的 new 和 make 主要区别如下：</p>
<ul>
<li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；</li>
<li>new 分配返回的是指针，即类型 <code>*Type</code> 。make 返回引用，即 Type；</li>
<li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>接下来我们将分别介绍一下 make 和 new 在初始化不同<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。</p>
<h4 id="make原理"><a href="#make原理" class="headerlink" title="make原理"></a>make原理</h4><p>我们已经了解了 make 在创建 slice、map 和 channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>初始化原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/maketypecheck.gif" alt="GOLang Make TypeCheck"></p>
<p>在编译期的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。</p>
<h4 id="new原理"><a href="#new原理" class="headerlink" title="new原理"></a>new原理</h4><p>内置函数 new 会在编译期的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func callnew(t *types.Type) *Node {</span><br><span class="line">    if t.NotInHeap() {</span><br><span class="line">        yyerror("%v is go:notinheap; heap allocation disallowed", t)</span><br><span class="line">    }</span><br><span class="line">    dowidth(t)</span><br><span class="line"></span><br><span class="line">    if t.Size() == 0 {</span><br><span class="line">        z := newname(Runtimepkg.Lookup("zerobase"))</span><br><span class="line">        z.SetClass(PEXTERN)</span><br><span class="line">        z.Type = t</span><br><span class="line">        return typecheck(nod(OADDR, z, nil), ctxExpr)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fn := syslook("newobject")</span><br><span class="line">    fn = substArgTypes(fn, t)</span><br><span class="line">    v := mkcall1(fn, types.NewPtr(t), nil, typename(t))</span><br><span class="line">    v.SetNonNil(true)</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func walkstmt(n *Node) *Node {</span><br><span class="line">    switch n.Op {</span><br><span class="line">    case ODCL:</span><br><span class="line">        v := n.Left</span><br><span class="line">        if v.Class() == PAUTOHEAP {</span><br><span class="line">            if prealloc[v] == nil {</span><br><span class="line">                prealloc[v] = callnew(v.Type)</span><br><span class="line">            }</span><br><span class="line">            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])</span><br><span class="line">            nn.SetColas(true)</span><br><span class="line">            nn = typecheck(nn, ctxStmt)</span><br><span class="line">            return walkstmt(nn)</span><br><span class="line">        }</span><br><span class="line">    case ONEW:</span><br><span class="line">        if n.Esc == EscNone {</span><br><span class="line">            r := temp(n.Type.Elem())</span><br><span class="line">            r = nod(OAS, r, nil)</span><br><span class="line">            r = typecheck(r, ctxStmt)</span><br><span class="line">            init.Append(r)</span><br><span class="line">            r = nod(OADDR, r.Left, nil)</span><br><span class="line">            r = typecheck(r, ctxExpr)</span><br><span class="line">            n = r</span><br><span class="line">        } else {</span><br><span class="line">            n = callnew(n.Type.Elem())</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。</p>
<p>newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func newobject(typ *_type) unsafe.Pointer {</span><br><span class="line">    return mallocgc(typ.size, typ, true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="make-和new-总结"><a href="#make-和new-总结" class="headerlink" title="make 和new 总结"></a>make 和new 总结</h3><p>最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>容器</tag>
        <tag>集合</tag>
        <tag>数组</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Go流程控制</title>
    <url>/posts/91175219/</url>
    <content><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<p>Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。另外，还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号{}括起来的代码块，否则就忽略该代码块继续执行后续的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">} else {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第三个分支，则可以使用下面这种三个独立分支的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition1 {</span><br><span class="line">    // do something</span><br><span class="line">} else if condition2 {</span><br><span class="line">    // do something else</span><br><span class="line">}else {</span><br><span class="line">    // catch-all or default</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。</p>
<p>关键字 if 和 else 之后的左大括号 <code>{</code> 必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号 <code>}</code> 必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p>
<p>非法的 Go 代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if x{</span><br><span class="line">}</span><br><span class="line">else { // 无效的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号 <code>}</code> 与对应的 if 关键字垂直对齐。</p>
<p>在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过下面的例子来了解 if 的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ten int = 11</span><br><span class="line">if ten &gt; 10 {</span><br><span class="line">    fmt.Println("&gt;10")</span><br><span class="line">} else {</span><br><span class="line">    fmt.Println("&lt;=10")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明整型变量并赋值 11。</li>
<li>第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。</li>
<li>第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。</li>
</ul>
<h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if err := Connect(); err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p>
<p>err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p>
<p>这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</p>
<p><strong><em>提示:在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</em></strong></p>
<h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for (循环结构)"></a>for (循环结构)</h2><p>与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 C++ 中非常接近：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    sum += i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号()括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 <code>for(;;){}</code> 和 <code>do{} while(1);</code> ，而直接简化为如下的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for {</span><br><span class="line">    sum++</span><br><span class="line">    if sum &gt; 100 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用循环语句时，需要注意的有以下几点：</p>
<ul>
<li>左花括号 <code>{</code> 必须与 for 处于同一行。</li>
<li>Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li>
<li>Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ {</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        if i &gt; 5 {</span><br><span class="line">            break JLoop</span><br><span class="line">        }</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">JLoop:</span><br><span class="line">// ...</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，break 语句终止的是 JLoop 标签处的外层循环。</p>
<h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。</p>
<p>初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">step := 2</span><br><span class="line">for ; step &gt; 0; step-- {</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p>
<h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。</p>
<h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><p>下面代码忽略条件表达式，但是保留结束语句，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for ; ; i++ {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。</li>
<li>第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。</li>
</ul>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>上面的代码还可以改写为更美观的写法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。</li>
<li>第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。</li>
</ul>
<p>无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。</p>
<h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><p>在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for i &lt;= 10 {</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在代码第 3 行中，将之前使用 <code>if i&gt;10{}</code> 判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。</p>
<p>上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p>
<h3 id="输出九九乘法表"><a href="#输出九九乘法表" class="headerlink" title="输出九九乘法表"></a>输出九九乘法表</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 遍历, 决定处理第几行</span><br><span class="line">    for y := 1; y &lt;= 9; y++ {</span><br><span class="line"></span><br><span class="line">        // 遍历, 决定这一行有多少列</span><br><span class="line">        for x := 1; x &lt;= y; x++ {</span><br><span class="line">            fmt.Printf("%d*%d=%d ", x, y, x*y)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 手动生成回车</span><br><span class="line">        fmt.Println()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2 2*2=4</span><br><span class="line">1*3=3 2*3=6 3*3=9</span><br><span class="line">1*4=4 2*4=8 3*4=12 4*4=16</span><br><span class="line">1*5=5 2*5=10 3*5=15 4*5=20 5*5=25</span><br><span class="line">1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36</span><br><span class="line">1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49</span><br><span class="line">1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64</span><br><span class="line">1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，生成 1～9 的数字，对应乘法表的每一行，也就是被乘数。</li>
<li>第 11 行，乘法表每一行中的列数随着行数的增加而增加，这一行的 x 表示该行有多少列。</li>
<li>第 16 行，打印一个空行，实际作用就是换行。</li>
</ul>
<p>这段程序按行优先打印，打印完一行，换行（第 16 行），接着执行下一行乘法表直到整个数值循环完毕。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, val := range coll {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for pos, char := range str {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每个 rune 字符和索引在 for range 循环中是一一对应的，它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。</p>
<p>通过 for range 遍历的返回值有一定的规律：</p>
<ul>
<li>数组、切片、字符串返回索引和值。</li>
<li>map 返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ul>
<h3 id="遍历数组、切片——获得索引和值"><a href="#遍历数组、切片——获得索引和值" class="headerlink" title="遍历数组、切片——获得索引和值"></a>遍历数组、切片——获得索引和值</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, value := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d  value:%d\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0  value:1</span><br><span class="line">key:1  value:2</span><br><span class="line">key:2  value:3</span><br><span class="line">key:3  value:4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历字符串——获得字符"><a href="#遍历字符串——获得字符" class="headerlink" title="遍历字符串——获得字符"></a>遍历字符串——获得字符</h3><p>Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。</p>
<p>下面这段代码展示了如何遍历字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var str = "hello 你好"</span><br><span class="line">for key, value := range str {</span><br><span class="line">    fmt.Printf("key:%d value:0x%x\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0 value:0x68</span><br><span class="line">key:1 value:0x65</span><br><span class="line">key:2 value:0x6c</span><br><span class="line">key:3 value:0x6c</span><br><span class="line">key:4 value:0x6f</span><br><span class="line">key:5 value:0x20</span><br><span class="line">key:6 value:0x4f60</span><br><span class="line">key:9 value:0x597d</span><br></pre></td></tr></tbody></table></figure>
<p>代码中的变量 value，实际类型是 rune 类型，以十六进制打印出来就是字符的编码。</p>
<h3 id="遍历-map——获得-map-的键和值"><a href="#遍历-map——获得-map-的键和值" class="headerlink" title="遍历 map——获得 map 的键和值"></a>遍历 map——获得 map 的键和值</h3><p>对于 map 类型来说，for range 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们是一对一对出现的，下面的代码演示了如何遍历 map。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for key, value := range m {</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello 100</span><br><span class="line">world 200</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</em></strong></p>
<h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p>for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。</p>
<p>下面代码为我们展示了通道的遍历：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    c &lt;- 1</span><br><span class="line">    c &lt;- 2</span><br><span class="line">    c &lt;- 3</span><br><span class="line">    close(c)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">for v := range c {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行创建了一个整型类型的通道。</li>
<li>第 3 行启动了一个 goroutine，其逻辑的实现体现在第 5～8 行，实现功能是往通道中推送数据 1、2、3，然后结束并关闭通道。</li>
<li>这段 goroutine 在声明结束后，在第 9 行马上被执行。</li>
<li>从第 11 行开始，使用 for range 对通道 c 进行遍历，其实就是不断地从通道中取数据，直到通道被关闭。</li>
</ul>
<h3 id="在遍历中选择希望获得的变量"><a href="#在遍历中选择希望获得的变量" class="headerlink" title="在遍历中选择希望获得的变量"></a>在遍历中选择希望获得的变量</h3><p>在使用 for range 循环遍历某个对象时，一般不会同时需要 key 或者 value，这个时候可以采用一些技巧，让代码变得更简单，下面将前面的例子修改一下，参考下面的代码示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, value := range m {</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子中将 key 变成了下划线 <code>_</code> ，这里的下划线就是匿名变量。</p>
<ul>
<li>可以理解为一种占位符。</li>
<li>匿名变量本身不会进行空间分配，也不会占用一个变量的名字。</li>
<li>在 for range 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li>
</ul>
<p>再看一个匿名变量的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, _ := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d \n", key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0</span><br><span class="line">key:1</span><br><span class="line">key:2</span><br><span class="line">key:3</span><br></pre></td></tr></tbody></table></figure>
<p>在该例子中，value 被设置为匿名变量，只使用 key，而 key 本身就是切片的索引，所以例子输出索引。</p>
<p>我们总结一下 for 的功能：</p>
<ul>
<li>Go语言的 for 包含初始化语句、条件表达式、结束语句，这 3 个部分均可缺省。</li>
<li>for range 支持对数组、切片、字符串、map、通道进行遍历操作。</li>
<li>在需要时，可以使用匿名变量对 for range 的变量进行选取。</li>
</ul>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p>
<p>相对于C语言和 Java 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。</p>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = "hello"</span><br><span class="line">switch a {</span><br><span class="line">case "hello":</span><br><span class="line">    fmt.Println(1)</span><br><span class="line">case "world":</span><br><span class="line">    fmt.Println(2)</span><br><span class="line">default:</span><br><span class="line">    fmt.Println(0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。</p>
<h4 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h4><p>当出现多个 case 要放在一起的时候，可以写成下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = "mum"</span><br><span class="line">switch a {</span><br><span class="line">case "mum", "daddy":</span><br><span class="line">    fmt.Println("family")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不同的 case 表达式使用逗号分隔。</p>
<h4 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h4><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var r int = 11</span><br><span class="line">switch {</span><br><span class="line">case r &gt; 10 &amp;&amp; r &lt; 20:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意，这种情况的 switch 后面不再需要跟判断变量。</p>
<h3 id="跨越-case-的-fallthrough——兼容C语言的-case-设计"><a href="#跨越-case-的-fallthrough——兼容C语言的-case-设计" class="headerlink" title="跨越 case 的 fallthrough——兼容C语言的 case 设计"></a>跨越 case 的 fallthrough——兼容C语言的 case 设计</h3><p>在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var s = "hello"</span><br><span class="line">switch {</span><br><span class="line">case s == "hello":</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">    fallthrough</span><br><span class="line">case s != "world":</span><br><span class="line">    fmt.Println("world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure>
<p>新编写的代码，不建议使用 fallthrough。</p>
<h2 id="goto语句——跳转到指定的标签"><a href="#goto语句——跳转到指定的标签" class="headerlink" title="goto语句——跳转到指定的标签"></a>goto语句——跳转到指定的标签</h2><p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p>
<h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var breakAgain bool</span><br><span class="line"></span><br><span class="line">    // 外循环</span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        // 内循环</span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            // 满足某个条件时, 退出循环</span><br><span class="line">            if y == 2 {</span><br><span class="line"></span><br><span class="line">                // 设置退出标记</span><br><span class="line">                breakAgain = true</span><br><span class="line"></span><br><span class="line">                // 退出本次循环</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 根据标记, 还需要退出一次循环</span><br><span class="line">        if breakAgain {</span><br><span class="line">                break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，构建外循环。</li>
<li>第 13 行，构建内循环。</li>
<li>第 16 行，当 y==2 时需要退出所有的 for 循环。</li>
<li>第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。</li>
<li>第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。</li>
<li>第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。</li>
<li>第 34 行，退出所有循环后，打印 done。</li>
</ul>
<p>将上面的代码使用Go语言的 goto 语句进行优化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            if y == 2 {</span><br><span class="line">                // 跳转到标签</span><br><span class="line">                goto breakHere</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 手动返回, 避免执行进入标签</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">    // 标签</span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。</li>
<li>第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。</li>
<li>第 23 行，定义 breakHere 标签。</li>
</ul>
<p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p>
<h3 id="使用-goto-集中处理错误"><a href="#使用-goto-集中处理错误" class="headerlink" title="使用 goto 集中处理错误"></a>使用 goto 集中处理错误</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = secondCheckError()</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println("done")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，执行某逻辑，返回错误。</li>
<li>第 2～6 行，如果发生错误，打印错误退出进程。</li>
<li>第 8 行，执行某逻辑，返回错误。</li>
<li>第 10～14 行，发生错误后退出流程。</li>
<li>第 16 行，没有任何错误，打印完成。</li>
</ul>
<p>在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。</p>
<p>使用 goto 语句来实现同样的逻辑：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> err := firstCheckError()</span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = secondCheckError()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。</li>
<li>第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。</li>
</ul>
<h2 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h2><p>Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。</p>
<p>跳出指定循环：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            case 3:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，外层循环的标签。</li>
<li>第 8 行和第 9 行，双层循环。</li>
<li>第 10 行，使用 switch 进行数值分支判断。</li>
<li>第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。</li>
</ul>
<h2 id="continue（继续下一次循环）"><a href="#continue（继续下一次循环）" class="headerlink" title="continue（继续下一次循环）"></a>continue（继续下一次循环）</h2><p>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line"></span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。</li>
</ul>
<h3 id="示例：聊天机器人"><a href="#示例：聊天机器人" class="headerlink" title="示例：聊天机器人"></a>示例：聊天机器人</h3><p>结合咱们之前的学习，本节带领大家来编写一个聊天机器人的雏形，下面的代码中展示了一个简单的聊天程序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 准备从标准输入读取数据。</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println("Please input your name:")</span><br><span class="line">    // 读取数据直到碰到 \n 为止。</span><br><span class="line">    input, err := inputReader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">        // 异常退出。</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    } else {</span><br><span class="line">        // 用切片操作删除最后的 \n 。</span><br><span class="line">        name := input[:len(input)-2]</span><br><span class="line">        fmt.Printf("Hello, %s! What can I do for you?\n", name)</span><br><span class="line">    }</span><br><span class="line">    for {</span><br><span class="line">        input, err = inputReader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        input = input[:len(input)-2]</span><br><span class="line">        // 全部转换为小写。</span><br><span class="line">        input = strings.ToLower(input)</span><br><span class="line">        switch input {</span><br><span class="line">        case "":</span><br><span class="line">            continue</span><br><span class="line">        case "nothing", "bye":</span><br><span class="line">            fmt.Println("Bye!")</span><br><span class="line">            // 正常退出。</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println("Sorry, I didn't catch you.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个聊天程序在问候用户之后会不断地询问“是否可以帮忙”，但是实际上它什么忙也帮不上，因为它现在什么也听不懂，除了 nothing 和 bye，一看到这两个词，它就会与用户“道别”，停止运行，现在试运行一下这个命令源码文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Please input your name:</span><br><span class="line">Robert</span><br><span class="line">Hello, Robert! What can I do for you?</span><br><span class="line">A piece of cake , please .</span><br><span class="line">Sorry, I didn't catch you.</span><br><span class="line">bye</span><br><span class="line">Bye!</span><br></pre></td></tr></tbody></table></figure>
<p>注意，其中的“-&gt;”符号之后的内容是我们输入的。</p>
<h3 id="示例：词频统计"><a href="#示例：词频统计" class="headerlink" title="示例：词频统计"></a>示例：词频统计</h3><p>从数据挖掘到语言学习本身，文本分析功能的应用非常广泛，本一节我们来分析一个例子，它是文本分析最基本的一种形式：统计出一个文件里单词出现的频率。</p>
<p>示例中频率统计后的结果以两种不同的方式显示，一种是将单词按照字母顺序把单词和频率排列出来，另一种是按照有序列表的方式把频率和对应的单词显示出来，完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">    "unicode"</span><br><span class="line">    "unicode/utf8"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader,</span><br><span class="line">    frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax ||</span><br><span class="line">                utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序的运行结果如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run .\main.go small-file.txt</span><br><span class="line">Word       Frequency</span><br><span class="line">ability                     1</span><br><span class="line">about                     1</span><br><span class="line">above                     3</span><br><span class="line">years                      1</span><br><span class="line">you                    128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Frequency → Words</span><br><span class="line">    1 ability, about, absence, absolute, absolutely, abuse, accessible, ...</span><br><span class="line">    2 accept, acquired, after, against, applies, arrange, assumptions, ...</span><br><span class="line">...</span><br><span class="line">128    you</span><br><span class="line">151    or</span><br><span class="line">192    to</span><br><span class="line">221    of</span><br><span class="line">345    the</span><br></pre></td></tr></tbody></table></figure>
<p>其中，small-file.txt 为待统计的文件名，它不是固定的，可以根据实际情况自行调整。由于输出的结果太多，所以上面只截取了部分内容。</p>
<p>通过上面的输出结果可以看出，第一种输出是比较直接的，我们可以使用一个map[string]int类型的结构来保存每一个单词的频率，但是要得到第二种输出结果我们需要将整个映射反转成多值类型的映射，如map[int][]string，也就是说，键是频率而值则是所有具有这个频率的单词。</p>
<p>接下来我们将从程序的 main() 函数开始，从上到下分析。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>main() 函数首先分析命令行参数，之后再进行相应处理。</p>
<p>我们使用复合语法创建一个空的映射，用来保存从文件读到的每一个单词和对应的频率，接着我们遍历从命令行得到的每一个文件，分析每一个文件后更新 frequencyForWord 的数据。</p>
<p>得到第一个映射之后，我们就可以输出第一个报告了（按照字母顺序排列的列表），然后我们创建一个反转的映射，输出第二个报告（按出现频率统计并排序的列表）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 Unix 类系统（如 Linux 或 Mac OS X 等）的命令行工具默认会自动处理通配符（也就是说，<code>*.txt</code> 能匹配任意后缀为 <code>.txt</code> 的文件，如 <code>README.txt</code> 和 <code>INSTALL.txt</code> 等），而 Windows 平台的命令行工具（CMD）不支持通配符，所以如果用户在命令行输入 <code>*.txt</code>，那么程序只能接收到 <code>*.txt</code> 。</p>
<p>为了保持平台之间的一致性，这里使用 commandLineFiles() 函数来实现跨平台的处理，当程序运行在 Windows 平台时，实现文件名通配功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>updateFrequencies() 函数纯粹就是用来处理文件的，它打开给定的文件，并使用 defer 在函数返回时关闭文件，这里我们将文件作为一个 <code>*bufio.Reader</code>（使用 bufio.NewReader() 函数创建）传给 readAndUpdateFrequencies() 函数，因为这个函数是以字符串的形式一行一行地读取数据的，所以实际的工作都是在 readAndUpdateFrequencies() 函数里完成的，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第一部分的代码我们应该很熟悉了，用了一个无限循环来一行一行地读一个文件，当读到文件结尾或者出现错误的时候就退出循环，将错误报告给用户但并不退出程序，因为还有很多其他的文件需要去处理。</p>
<p>任意一行都可能包括标点、数字、符号或者其他非单词字符，所以我们需要逐个单词地去读，将每一行分隔成若干个单词并使用 SplitOnNonLetters() 函数忽略掉非单词的字符，并且过滤掉字符串开头和结尾的空白。</p>
<p>只需要记录含有两个以上（包括两个）字母的单词，可以通过使用 if 语句，如 utf8.RuneCountlnString(word) &gt; 1 来完成。</p>
<p>上面描述的 if 语句有一点性能损耗，因为它会分析整个单词，所以在这个程序里我们增加了一个判断条件，用来检査这个单词的字节数是否大于 utf8.UTFMax（utf8.UTFMax 是一个常量，值为 4，用来表示一个 UTF-8 字符最多需要几个字节）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SplitOnNonLetters() 函数用来在非单词字符上对一个字符串进行切分，首先我们为 strings.FieldsFunc() 函数创建一个匿名函数 notALetter，如果传入的是字符那就返回 false，否则返回 true，然后返回调用函数 strings.FieldsFunc() 的结果，调用的时候将给定的字符串和 notALetter 作为它的参数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>计算出了 frequencyForWord 之后，调用 reportByWords() 将它的数据打印出来，因为我们需要将输出结果按照字母顺序排序好，所以首先要创建一个空的容量足够大的 []string 切片来保存所有在 frequencyForWord 里的单词。</p>
<p>第一个循环遍历映射里的所有项，把每个单词追加到 words 字符串切片里去，使用 append() 函数只需要把给定的单词追加到第 len(words) 个索引位置上即可，words 的长度会自动增加 1。</p>
<p>得到了 words 切片之后，对它进行排序，这个在 readAndUpdateFrequencies() 函数中已经处理好了。</p>
<p>经过排序之后我们打印两列标题，第一个是 “Word”，为了能让 Frequency 最后一个字符 y 右对齐，需要在 “Word” 后打印一些空格，通过 <code>%*s</code> 可以实现的打印固定长度的空白，也可以使用 <code>%s</code> 来打印 strings.Repeat(“ “, gap) 返回的字符串。</p>
<p>最后，我们将单词和它们的频率用两列方式按照字母顺序打印出来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的函数首先创建一个空的映射，用来保存反转的结果，但是我们并不知道它到底要保存多少个项，因此我们假设它和原来的映射容量一样大，然后简单地遍历原来的映射，将它的值作为键保存到反转的映射里，并将键增加到对应的值里去，新的映射的值就是一个字符串切片，即使原来的映射有多个键对应同一个值，也不会丢掉任何数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数的结构和 reportByWords() 函数很相似，它首先创建一个切片用来保存频率，并按照频率升序排列，然后再计算需要容纳的最大长度并以此作为第一列的宽度，之后输出报告的标题，最后，遍历输出所有的频率并按照字母升序输出对应的单词，如果一个频率有超过两个对应的单词则单词之间使用逗号分隔开。</p>
<h3 id="示例：缩进排序"><a href="#示例：缩进排序" class="headerlink" title="示例：缩进排序"></a>示例：缩进排序</h3><p>演示如何将字符串按照等级（缩进级别）进行排序，完整代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">var original = []string{</span><br><span class="line">    "Nonmetals",</span><br><span class="line">    "    Hydrogen",</span><br><span class="line">    "    Carbon",</span><br><span class="line">    "    Nitrogen",</span><br><span class="line">    "    Oxygen",</span><br><span class="line">    "Inner Transitionals",</span><br><span class="line">    "    Lanthanides",</span><br><span class="line">    "        Europium",</span><br><span class="line">    "        Cerium",</span><br><span class="line">    "    Actinides",</span><br><span class="line">    "        Uranium",</span><br><span class="line">    "        Plutonium",</span><br><span class="line">    "        Curium",</span><br><span class="line">    "Alkali Metals",</span><br><span class="line">    "    Lithium",</span><br><span class="line">    "    Sodium",</span><br><span class="line">    "    Potassium",</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("|     Original      |       Sorted      |")</span><br><span class="line">    fmt.Println("|-------------------|-------------------|")</span><br><span class="line">    sorted := SortedIndentedStrings(original) // 最初是 []string</span><br><span class="line">    for i := range original {                 // 在全局变量中设置</span><br><span class="line">        fmt.Printf("|%-19s|%-19s|\n", original[i], sorted[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意 SortedIndentedStrings() 函数有一个很重要的前提就是，字符串的缩进是通过读到的空格或缩进的个数来决定的，下面来看一下输出结果，为了方便对比，这里将排序前的结果放在左边，排序后的结果放在右边。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">|     Original      |       Sorted      |</span><br><span class="line">|-------------------|-------------------|</span><br><span class="line">|Nonmetals          |Alkali Metals      |</span><br><span class="line">|    Hydrogen       |    Lithium        |</span><br><span class="line">|    Carbon         |    Potassium      |</span><br><span class="line">|    Nitrogen       |    Sodium         |</span><br><span class="line">|    Oxygen         |Inner Transitionals|</span><br><span class="line">|Inner Transitionals|    Actinides      |</span><br><span class="line">|    Lanthanides    |        Curium     |</span><br><span class="line">|        Europium   |        Plutonium  |</span><br><span class="line">|        Cerium     |        Uranium    |</span><br><span class="line">|    Actinides      |    Lanthanides    |</span><br><span class="line">|        Uranium    |        Cerium     |</span><br><span class="line">|        Plutonium  |        Europium   |</span><br><span class="line">|        Curium     |Nonmetals          |</span><br><span class="line">|Alkali Metals      |    Carbon         |</span><br><span class="line">|    Lithium        |    Hydrogen       |</span><br><span class="line">|    Sodium         |    Nitrogen       |</span><br><span class="line">|    Potassium      |    Oxygen         |</span><br></pre></td></tr></tbody></table></figure>
<p>其中，SortedIndentedStrings() 函数和它的辅助函数使用到了递归、函数引用以及指向切片的指针等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sort.Interface 接口定义了 3 个方法 Len()、Less() 和 Swap()，它们的函数签名和 Entries 中的同名方法是一样的，这就意味着我们可以使用标准库里的 sort.Sort() 函数来对一个 Entries 进行排序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>导出的函数 SortedIndentedStrings() 就做了这个工作，虽然我们已经对它进行了重构，让它把所有东西都传递给辅助函数，函数 populateEntries() 传入一个 []string 并返回一个对应的 Entries（[]Entry 类型）。</p>
<p>而函数 sortedEntries() 需要传入一个 Entries，然后返回一个排过序的 []string（根据缩进的级别进行排序）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateEntries() 函数首先以字符串的形式得到给定切片里的一级缩进（如有 4 个空格的字符串）和它占用的字节数，然后创建一个空的 Entries，并遍历切片里的每一个字符串，判断该字符串的缩进级别，再创建一个用于排序的键。</p>
<p>下一步，调用自定义函数 addEntry()，将当前字符串的级别、键、字符串本身，以及指向 entries 的地址作为参数，这样 addEntry() 就能创建一个新的 Entry 并能够正确地将它追加到 entries 里去，最后返回 entries。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>computeIndent() 函数主要是用来判断缩进使用的是什么字符，例如空格或者缩进符等，以及一个缩进级别占用多少个这样的字符。</p>
<p>因为第一级的字符串可能没有缩进，所以函数必须迭代所有的字符串，一旦它发现某个字符串的行首是空格或者缩进，函数马上返回表示缩进的字符以及一个缩进所占用的字符数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addEntry() 是一个递归函数，它创建一个新的 Entry，如果这个 Entry 的 level 是 0，那就直接增加到 entries 里去，否则，就将它作为另一个 Entry 的子集。</p>
<p>我们必须确定这个函数传入的是一个 *Entries 而不是传递一个 entries 引用（切片的默认行为），因为我们是要将数据追加到 entries 里，追加到一个引用会导致无用的本地副本且原来的数据实际上并没有被修改。</p>
<p>如果 level 是 0，表明这个字符串是顶级项，因此必须将它直接追加到 <code>*entries</code> ，实际上情况要更复杂一些，因为 level 是相对传入的 <code>*entries</code> 而言的，第一次调用 addEntry() 时，<code>*entries</code> 是一个第一级的 Entries，但函数进入递归后，*entries 就可能是某个 Entry 的子集。</p>
<p>我们使用内置的 append() 函数来追加新的 Entry，并使用 <code>*</code> 操作符获得 entries 指针指向的值，这就保证了任何改变对调用者来说都是可见的，新增的 Entry 包含给定的 key 和 value，以及一个空的子 Entries，这是递归的结束条件。</p>
<p>如果 level 大于 0，则我们必须将它追加到上一级 Entry 的 children 字段里去，这里我们只是简单地递归调用 addEntry() 函数，最后一个参数可能是我们目前为止见到的最复杂的表达式了。</p>
<p>子表达式 entries.Len() - 1 产生一个 int 型整数，表示 <code>*entries</code> 指向的 Entries 值的最后一个条目的索引位置（注意 Entries.Len() 传入的是一个 Entries 值而不是 <code>*Entries</code> 指针，不过Go语言也可以自动对 entries 指针进行解引用并调用相应的方法）。</p>
<p>完整的表达式（&amp;(…) 除外）访问了 Entries 最后一个 Entry 的 children 字段（这也是一个 Entries 类型），所以如果把这个表达式作为一个整体，实际上我们是将 Entries 里最后一个 Entry 的 children 字段的内存地址作为递归调用的参数，因为 addEntry() 最后一个参数是 *Entries 类型的。</p>
<p>为了帮助大家弄清楚到底发生了什么，下面的代码和上述代码中 else 代码块中的那个调用是一样的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">theEntries := *entries</span><br><span class="line">lastEntry := &amp;theEntries[theEntries.Len()-1]</span><br><span class="line">addEntry(level-1, key, value, &amp;lastEntry.children)</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们创建 theEntries 变量用来保存 *entries 指针指向的值，这里没有什么开销因为不会产生复制，实际上 theEntries 相当于一个指向 Entries 值的别名。</p>
<p>然后我们取得最后一项的内存地址（即一个指针），如果不取地址的话就会取到最后一项的副本，最后递归调用 addEntry() 函数，并将最后一项的 children 字段的地址作为参数传递给它。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当调用 sortedEntries() 函数的时候，Entries 显示的结构和原先程序输出的字符串是一样的，每一个缩进的字符串都是上一级缩进的子级，而且还可能有下一级的缩进，依次类推。</p>
<p>创建了 Entries 之后，SortedIndentedStrings() 函数调用上面这个函数去生成一个排好序的字符串切片 []string，这个函数首先创建一个空的 []string 用来保存最后的结果，然后对 entries 进行排序。</p>
<p>Entries 实现了 sort.Interface 接口，因此我们可以直接使用 sort.Sort() 函数根据 Entry 的 key 字段来对 Entries 进行排序（这是 Entries.Less() 的实现方式），这个排序只是作用于第一级的 Entry，对其他未排序的子集是没有任何影响的。</p>
<p>为了能够对 children 字段以及 children 的 children 等进行递归排序，函数遍历第一级的每一个项并调用 populateIndentedStrings() 函数，传入这个 Entry 类型的项和一个指向 []string 切片的指针。</p>
<p>切片可以传递给函数并由函数更新内容（如替换切片里的某些项），但是这里需要往切片里新增一些数据，所以这里将一个指向切片的指针（也就是指针的指针）作为参数传进去，并将指针指向的内容设置为 append() 函数的返回结果，可能是一个新的切片，也可能是原先的切片。</p>
<p>另一种办法就是传入切片的值，然后返回 append() 之后的切片，但是必须将返回的结果赋值给原来的切片变量（例如 slice = function(slice)），不过这么做的话，很难正确地使用递归函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateIndentedStrings() 函数将顶级项追加到创建的切片，然后对顶级项的子项进行排序，并递归调用自身对每一个子项做同样的处理，这就相当于对每一项的子项以及子项的子项等都做了排序，所以整个字符串切片就是已经排好序的了。</p>
<h3 id="示例：二分查找算法"><a href="#示例：二分查找算法" class="headerlink" title="示例：二分查找算法"></a>示例：二分查找算法</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找算法的前提是传入的序列是有序的（降序或升序），并且有一个目标值。</p>
<p>二分查找的核心思想是将 n 个元素分成大致相等的两部分，取中间值 <code>a[n/2]</code> 与 x 做比较，如果 <code>x=a[n/2]</code> ，则找到 x ，算法中止，如果 <code>x&lt;a[n/2]</code> ，则只要在数组 a 的左半部分继续搜索 x，如果 <code>x&gt;a[n/2]</code> ，则只要在数组 a 的右半部搜索 x。</p>
<p>二分查找虽然性能比较优秀，但应用场景也比较有限，底层必须依赖数组，并且还要求数据是有序的，对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁插入、删除操作的数据。</p>
<p>程序实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">二分查找函数，假设有序数组的顺序是从小到大</span><br><span class="line">*/</span><br><span class="line">func BinaryFind(arr *[]int, leftIndex int, rightIndex int, findValue int) {</span><br><span class="line"></span><br><span class="line">    //判断leftIndex是否大于rightIndex</span><br><span class="line">    if leftIndex &gt; rightIndex {</span><br><span class="line">        fmt.Println("未找到")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //先找到中间的下标</span><br><span class="line">    middle := (leftIndex + rightIndex) / 2</span><br><span class="line"></span><br><span class="line">    if (*arr)[middle] &gt; findValue {</span><br><span class="line">        fmt.Printf("小于中间 middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, leftIndex, middle-1, findValue)</span><br><span class="line">        //要查找的数，范围应该在leftIndex与 middle-1 之间</span><br><span class="line">        BinaryFind(arr, leftIndex, middle-1, findValue)</span><br><span class="line"></span><br><span class="line">    } else if (*arr)[middle] &lt; findValue {</span><br><span class="line">        fmt.Printf("大于中间  middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, middle+1, rightIndex, findValue)</span><br><span class="line">        //要查找的数，范围应该在middle+1与 rightIndex 之间</span><br><span class="line">        BinaryFind(arr, middle+1, rightIndex, findValue)</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("找到了，下标为：%v \n", middle)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //定义一个数组</span><br><span class="line">    arr := []int{1, 3, 7, 12, 17, 20, 30, 50, 55, 75}</span><br><span class="line">    BinaryFind(&amp;arr, 0, len(arr)-1, 30)</span><br><span class="line">    fmt.Println("main arr=", arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">大于中间  middle：4, leftIndex： 0 rightIndex：9 findValue：30</span><br><span class="line">小于中间  middle：7, leftIndex： 5 rightIndex：9 findValue：30</span><br><span class="line">大于中间  middle：5, leftIndex： 5 rightIndex：6 findValue：30</span><br><span class="line">找到了，下标为：6</span><br><span class="line">main arr= [1 3 7 12 17 20 30 50 55 75]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：冒泡排序"><a href="#示例：冒泡排序" class="headerlink" title="示例：冒泡排序"></a>示例：冒泡排序</h3><p>冒泡排序法是一种最简单的交换类排序方法，它是通过相邻数据的交换逐步将无序列表排列为有序列表。</p>
<p>冒泡排序的基本原理是重复地循环遍历要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大或者首字母从 Z 到 A）错误就把两个元素的位置交换过来，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>冒泡排序的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p>下面通过一个实例来演示一下冒泡排序，完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">   "fmt"</span><br><span class="line">)</span><br><span class="line">/**</span><br><span class="line">冒泡排序</span><br><span class="line">*/</span><br><span class="line">func main() {</span><br><span class="line">    arr := [...]int{21,32,12,33,34,34,87,24}</span><br><span class="line">    var n = len(arr)</span><br><span class="line">    fmt.Println("--------没排序前--------\n",arr)</span><br><span class="line">    for i := 0; i &lt;= n-1; i++ {</span><br><span class="line">        fmt.Println("--------第",i+1,"次冒泡--------")</span><br><span class="line">        for j := i; j &lt;= n-1; j++ {</span><br><span class="line">            if arr[i] &gt; arr[j] {</span><br><span class="line">                t := arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = t</span><br><span class="line">            }</span><br><span class="line">            fmt.Println(arr)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("--------最终结果--------\n",arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">--------没排序前--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">--------第 1 次冒泡--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">--------第 2 次冒泡--------</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">--------第 3 次冒泡--------</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">--------第 4 次冒泡--------</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">--------第 5 次冒泡--------</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 6 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 7 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------第 8 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------最终结果--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="四种冒泡排序写法"><a href="#四种冒泡排序写法" class="headerlink" title="四种冒泡排序写法"></a>四种冒泡排序写法</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//用于计数排序中访问了多少次序列</span><br><span class="line">var cnt int= 0</span><br><span class="line"></span><br><span class="line">//最原始的冒泡排序</span><br><span class="line">func buble_sort(a []int){</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{//相邻元素两两比较</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//增加标志判断是否发生交换，如果没有发生交换，表明序列有序，结束比较，直接退出</span><br><span class="line">func flag_sort(a []int){</span><br><span class="line">    flag := true//默认序列有序</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false//发生交换--表明序列无序--需要进行下一次比较</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//除了标志位以外，记录最后一次发生交换的下标，更能减少不必要的比较</span><br><span class="line">func better_sort(a []int){</span><br><span class="line">    flag := true</span><br><span class="line">    k := len(a)-1//控制内部比较循环</span><br><span class="line">    n := 0//记录最后一次发生交换的下标</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        n = 0//每次访问待排序序列之初默认序列有序，没有发生交换，最后交换的下标就是0</span><br><span class="line">        for j := 0; j &lt; k; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false</span><br><span class="line">                n = j//保存最后一次交换的下标</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        if flag {//如果这趟走完，没有发生交换，则原数组有序</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        k = n//最后一次交换的位置给k，减少比较的次数</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//鸡尾酒冒泡排序--先从低到高，再从高到低--分为两大步骤，结合标志判断</span><br><span class="line">func cocktail_sort(a []int) {</span><br><span class="line">    left := 0</span><br><span class="line">    right := len(a) - 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    flag := true</span><br><span class="line">    for(left &lt; right){</span><br><span class="line">        flag = true</span><br><span class="line">        for i :=left; i &lt; right; i++{// 前半轮,将最大元素放到后面</span><br><span class="line">            if (a[i] &gt; a[i+1]) {</span><br><span class="line">                a[i], a[i+1] = a[i+1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        right--</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for i :=right; i &gt; left; i--{// 后半轮,将最小元素放到前面</span><br><span class="line">            if (a[i] &lt; a[i-1]) {</span><br><span class="line">                a[i], a[i-1] = a[i-1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        left++</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    b := [...]int{8,7,6,1,4,3,2,5}</span><br><span class="line">    buble_sort(b[:])</span><br><span class="line">    fmt.Println(b,cnt)</span><br><span class="line"></span><br><span class="line">    c := []int{2,3,4,5,6,1}</span><br><span class="line">    cocktail_sort(c)</span><br><span class="line">    fmt.Println(c,cnt)</span><br><span class="line"></span><br><span class="line">    d := []int{8,7,6,1,4,3,2,5}</span><br><span class="line">    flag_sort(d)</span><br><span class="line">    fmt.Println(d,cnt)</span><br><span class="line"></span><br><span class="line">    e := []int{2,3,4,5,6,1}</span><br><span class="line">    better_sort(e)</span><br><span class="line">    fmt.Println(e,cnt)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Go语言分布式id生成器"><a href="#Go语言分布式id生成器" class="headerlink" title="Go语言分布式id生成器"></a>Go语言分布式id生成器</h3><p>有时我们需要能够⽣成类似 MySQL 自增 ID 这样不断增大，同时又不会重复的 ID。以支持业务中的⾼并发场景。比较典型的是电商促销时短时间内会有大量的订单涌入到系统，比如每秒 10w+。明星出轨时会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。</p>
<p>在插入数据库之前，我们需要给这些消息、订单先打上一个 ID，然后再插⼊到我们的数据库。对这个 ID 的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进⾏排序。</p>
<p>Twitter 的 snowflake 算法是这种场景下的一个典型解法。先来看看 snowflake 是怎么回事，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/snowflake.gif" alt="图：snowflake 中的比特位分布"></p>
<p>⾸先确定我们的数值是 64 位的 int64 类型，被划分为了四部分，不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的 ID，然后再五位来表示机器的实例 ID，最后是 12 位的循环自增 ID（到达 1111,1111,1111 后会归 0）。</p>
<p>这样的机制可以⽀持我们在同一台机器上，同一毫秒内产⽣ 2 ^ 12 = 4096 条消息。一秒共 409.6 万条消息。从值域上来讲完全够⽤了。</p>
<p>数据中心加上实例 ID 共有 10 位，可以⽀持我们每数据中心部署 32 台机器，所有数据中心共 1024 台实例。</p>
<p>表示 timestamp 的 41 位，可以⽀持我们使用 69 年。当然，我们的时间毫秒计数不会真的从 1970 年开始记，那样我们的系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的 timestamp 实际上只是相对于某个时间的增量，比如我们的系统上线是 2018-08-01，那么我们可以把这个 timestamp 当作是从 2018-08-01 00:00:00.000 的偏移量。</p>
<h4 id="worker-id-分配"><a href="#worker-id-分配" class="headerlink" title="worker_id 分配"></a>worker_id 分配</h4><p>timestamp、datacenter_id、worker_id 和 sequence_id 这四个字段中，timestamp 和 sequence_id 是由程序在运⾏期⽣成的。但 datacenter_id 和 worker_id 需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的 ID 有冲突）。</p>
<p>一般不同数据中⼼的机器，会提供对应的获取数据中心 ID 的 API，所以 datacenter_id 我们可以在部署阶段轻松地获取到。而 worker_id 是我们逻辑上给机器分配的一个 ID，这个要怎么办呢？比较简单的想法是由能够提供这种自增 ID 功能的工具来支持，比如 MySQL:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; insert into a (ip) values("10.1.2.101");</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select last_insert_id();</span><br><span class="line">+------------------+</span><br><span class="line">| last_insert_id()     |</span><br><span class="line">+------------------+</span><br><span class="line">| 2                          |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<p>从 MySQL 中获取到 worker_id 之后，就把这个 worker_id 直接持久化到本地，以避免每次上线时都需要获取新的 worker_id，让单实例的 worker_id 可以始终保持不变。</p>
<p>当然，使用 MySQL 相当于给我们简单的 id 生成服务增加了一个外部依赖，依赖越多，我们的服务的可运维性就越差。</p>
<p>考虑到集群中即使有单个 ID 生成服务的实例挂了，也就是损失一段时间的一部分 ID，所以我们也可以更简单暴力一些，把 worker_id 直接写在 worker 的配置中，上线时由部署脚本完成 worker_id 字段替换</p>
<h4 id="标准-snowflake-实现"><a href="#标准-snowflake-实现" class="headerlink" title="标准 snowflake 实现"></a>标准 snowflake 实现</h4><p>github.com/bwmarrin/snowflake 是一个相当轻量化的 snowflake 的 Go 实现。其文档对各位使用的定义如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosnowflake.gif" alt="图：snowflake库"></p>
<p>和标准的 snowflake 完全一致。使用上比较简单：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "github.com/bwmarrin/snowflake"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    n, err := snowflake.NewNode(1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        id := n.Generate()</span><br><span class="line">        fmt.Println("id", id)</span><br><span class="line">        fmt.Println(</span><br><span class="line">            "node: ", id.Node(),</span><br><span class="line">            "step: ", id.Step(),</span><br><span class="line">            "time: ", id.Time(),</span><br><span class="line">            "\n",</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">go: finding module for package github.com/bwmarrin/snowflake</span><br><span class="line">go: downloading github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">go: found github.com/bwmarrin/snowflake in github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">id 1318484268032200704</span><br><span class="line">node:  1 step:  0 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200705</span><br><span class="line">node:  1 step:  1 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200706</span><br><span class="line">node:  1 step:  2 time:  1603186120409</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC</span><br><span class="line">// You may customize this to set a different epoch for your application.</span><br><span class="line">Epoch int64 = 1288834974657</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Node</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">NodeBits uint8 = 10</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Step</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">StepBits uint8 = 12</span><br></pre></td></tr></tbody></table></figure>
<p>Epoch 就是本节开头讲的起始时间，NodeBits 指的是机器编号的位⻓，StepBits 指的是自增序列的位⻓。</p>
<h4 id="sonyflake"><a href="#sonyflake" class="headerlink" title="sonyflake"></a>sonyflake</h4><p>sonyflake 是 Sony 公司的一个开源项目，基本思路和 snowflake 差不多，不过位分配上稍有不同，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sonyflake.gif" alt="图：sonyflake"></p>
<p>这⾥的时间只用了 39 个 bit，但时间的单位变成了 10ms，所以理论上比 41 位表示的时间还要久（174 年）。</p>
<p>Sequence ID 和之前的定义一致，Machine ID 其实就是节点 ID。sonyflake 与众不同的地方在于其在启动阶段的参数配置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewSonyflake(st Settings) *Sonyflake</span><br></pre></td></tr></tbody></table></figure>
<p>Settings 数据结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Settings struct {</span><br><span class="line">    StartTime time.Time</span><br><span class="line">    MachineID func() (uint16, error)</span><br><span class="line">    CheckMachineID func(uint16) bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>StartTime 选项和我们之前的 Epoch 差不多，如果不设置的话，默认是从 2014-09-01 00:00:00 +0000 UTC 开始。</p>
<p>MachineID 可以由用户自定义的函数，如果用户不定义的话，会默认将本机 IP 的低 16 位作为 machineid。</p>
<p>CheckMachineID 是由用户提供的检查 MachineID 是否冲突的函数。这里的设计还是比较巧秒的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查 MachineID 是否冲突的逻辑。如果公司有现成的 Redis 集群，那么我们可以很轻松地用 Redis 的集合类型来检查冲突。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure>
<p>使用起来也比较简单，这里省略了一些逻辑简单的函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">    "github.com/sony/sonyflake"</span><br><span class="line">)</span><br><span class="line">func getMachineID() (uint16, error) {</span><br><span class="line">    var machineID uint16</span><br><span class="line">    var err error</span><br><span class="line">    machineID = readMachineIDFromLocalFile()</span><br><span class="line">    if machineID == 0 {</span><br><span class="line">        machineID, err = generateMachineID()</span><br><span class="line">        if err != nil {</span><br><span class="line">            return 0, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return machineID, nil</span><br><span class="line">}</span><br><span class="line">func checkMachineID(machineID uint16) bool {</span><br><span class="line">    saddResult, err := saddMachineIDToRedisSet()</span><br><span class="line">    if err != nil || saddResult == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    err := saveMachineIDToLocalFile(machineID)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return false</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    t, _ := time.Parse("2006-01-02", "2018-01-01")</span><br><span class="line">    settings := sonyflake.Settings{</span><br><span class="line">        StartTime: t,</span><br><span class="line">        MachineID: getMachineID,</span><br><span class="line">        CheckMachineID: checkMachineID,</span><br><span class="line">    }</span><br><span class="line">    sf := sonyflake.NewSonyflake(settings)</span><br><span class="line">    id, err := sf.NextID()</span><br><span class="line">    if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Go函数</title>
    <url>/posts/fbeb39a4/</url>
    <content><![CDATA[<p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p>
<p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p>
<p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p>
<ul>
<li>函数本身可以作为值进行传递。</li>
<li>支持匿名函数和闭包（closure）。</li>
<li>函数可以满足接口。</li>
</ul>
<h2 id="函数声明（函数定义）"><a href="#函数声明（函数定义）" class="headerlink" title="函数声明（函数定义）"></a>函数声明（函数定义）</h2><p>函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。</p>
<p>因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</p>
<p>编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。</p>
<p>当函数执行到代码块最后一行 <code>}</code> 之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。</p>
<p>Go语言里面拥三种类型的函数：</p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者 lambda 函数</li>
<li>方法</li>
</ul>
<h3 id="普通函数声明（定义）"><a href="#普通函数声明（定义）" class="headerlink" title="普通函数声明（定义）"></a>普通函数声明（定义）</h3><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func 函数名(形式参数列表)(返回值列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</p>
<p>如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func hypot(x, y float64) float64 {</span><br><span class="line">    return math.Sqrt(x*x + y*y)</span><br><span class="line">}</span><br><span class="line">fmt.Println(hypot(3,4)) // "5"</span><br></pre></td></tr></tbody></table></figure>
<p>x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。</p>
<p>如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。</p>
<p>正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func f(i, j, k int, s, t string) { /* ... */ }</span><br><span class="line">func f(i int, j int, k int, s string, t string) { /* ... */ }</span><br></pre></td></tr></tbody></table></figure>
<p>下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符 <code>_</code> 可以强调某个参数未被使用。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func add(x int, y int) int {return x + y}</span><br><span class="line">func sub(x, y int) (z int) { z = x - y; return}</span><br><span class="line">func first(x int, _ int) int { return x }</span><br><span class="line">func zero(int, int) int { return 0 }</span><br><span class="line">fmt.Printf("%T\n", add) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", sub) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", first) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", zero) // "func(int, int) int"</span><br></pre></td></tr></tbody></table></figure>
<p>函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p>
<p>每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p>在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := connectToNetwork()</span><br></pre></td></tr></tbody></table></figure>
<p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。</p>
<p>其它编程语言中函数的返回值</p>
<ul>
<li>C/C++ 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果，C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。</li>
<li>C# 语言也没有多返回值特性，C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。</li>
<li>lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。</li>
</ul>
<p>Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</p>
<h4 id="同一种类型返回值"><a href="#同一种类型返回值" class="headerlink" title="同一种类型返回值"></a>同一种类型返回值</h4><p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。</p>
<p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func typedTwoValues() (int, int) {</span><br><span class="line">    return 1, 2</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    a, b := typedTwoValues()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p>
<h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p>
<p>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。</p>
<p>下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line"></span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，对两个整型返回值进行命名，分别为 a 和 b。</li>
<li>第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。</li>
<li>第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line">    a = 1</span><br><span class="line">    return a, 2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示:同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func namedRetValues() (a, b int, int)</span><br></pre></td></tr></tbody></table></figure>
<p>编译报错提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mixed named and unnamed function parameters</span><br></pre></td></tr></tbody></table></figure>
<p>意思是：在函数参数中混合使用了命名和非命名参数。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p>
<p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p>
<p>Go语言的函数调用格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>函数名：需要调用的函数名。</li>
<li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li>
<li>返回值变量列表：多个返回值使用逗号分隔。</li>
</ul>
<p>例如，加法函数调用样式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">result := add(1,1)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：将秒转换为具体的时间"><a href="#示例：将秒转换为具体的时间" class="headerlink" title="示例：将秒转换为具体的时间"></a>示例：将秒转换为具体的时间</h3><p>使用一个数值表示时间中的“秒”值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。</p>
<p>【示例】将秒解析为时间单位：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    // 定义每分钟的秒数</span><br><span class="line">    SecondsPerMinute = 60</span><br><span class="line"></span><br><span class="line">    // 定义每小时的秒数</span><br><span class="line">    SecondsPerHour = SecondsPerMinute * 60</span><br><span class="line"></span><br><span class="line">    // 定义每天的秒数</span><br><span class="line">    SecondsPerDay = SecondsPerHour * 24</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将传入的“秒”解析为3种时间单位</span><br><span class="line">func resolveTime(seconds int) (day int, hour int, minute int) {</span><br><span class="line"></span><br><span class="line">    day = seconds / SecondsPerDay</span><br><span class="line">    hour = seconds / SecondsPerHour</span><br><span class="line">    minute = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将返回值作为打印参数</span><br><span class="line">    fmt.Println(resolveTime(1000))</span><br><span class="line"></span><br><span class="line">    // 只获取小时和分钟</span><br><span class="line">    _, hour, minute := resolveTime(18000)</span><br><span class="line">    fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">    // 只获取天</span><br><span class="line">    day, _, _ := resolveTime(90000)</span><br><span class="line">    fmt.Println(day)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 0 16</span><br><span class="line">5 300</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，定义每分钟的秒数。</li>
<li>第 10 行，定义每小时的秒数，SecondsPerHour 常量值会在编译期间计算出结果。</li>
<li>第 13 行，定义每天的秒数。</li>
<li>第 17 行，定义 resolveTime() 函数，根据输入的秒数，返回 3 个整型值，含义分别是秒数对应的天数、小时数和分钟数（取整）。</li>
<li>第 29 行中，给定 1000 秒，对应是 16（16.6667 取整）分钟的秒数，resolveTime() 函数返回的 3 个变量会传递给 fmt.Println() 函数进行打印，因为 fmt.Println() 使用了可变参数，可以接收不定量的参数。</li>
<li>第 32 行，将 resolveTime() 函数中的 3 个返回值使用变量接收，但是第一个返回参数使用匿名函数接收，表示忽略这个变量。</li>
<li>第 36 行，忽略后两个返回值，只使用第一个返回值。</li>
</ul>
<h3 id="示例：函数中的参数传递效果测试"><a href="#示例：函数中的参数传递效果测试" class="headerlink" title="示例：函数中的参数传递效果测试"></a>示例：函数中的参数传递效果测试</h3><p>Go语言中传入和返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。</p>
<p>下面通过一个例子来详细了解Go语言的参数值传递。请先看完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import"fmt"</span><br><span class="line"></span><br><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Data struct {</span><br><span class="line">    complax []int //测试切片在参数传递中的效果</span><br><span class="line">    instance InnerData //实例分配的innerData</span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试数据类型"><a href="#测试数据类型" class="headerlink" title="测试数据类型"></a>测试数据类型</h4><p>为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Datas truct{</span><br><span class="line">    complax []int//测试切片在参数传递中的效果</span><br><span class="line"></span><br><span class="line">    instance InnerData//实例分配的innerData</span><br><span class="line"></span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct{</span><br><span class="line">    aint</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，将Data声明为结构体类型，结构体是拥有多个字段的复杂结构。</li>
<li>第3行，complax为整型切片类型，切片是一种动态类型，内部以指针存在。</li>
<li>第5行，instance成员以InnerData类型作为Data的成员。</li>
<li>第7行，将ptr声明为InnerData的指针类型。</li>
<li>第11行，声明一个内嵌的结构InnerData。</li>
</ul>
<h4 id="值传递的测试函数"><a href="#值传递的测试函数" class="headerlink" title="值传递的测试函数"></a>值传递的测试函数</h4><p>本节中定义的passByValue()函数用于值传递的测试，该函数的参数和返回值都是Data类型。在调用中，Data的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量。代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line"></span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行，使用格式化的%+v动词输出in变量的详细结构，以便观察Data结构在传递前后的内部数值的变化情况。</li>
<li>第8行，打印传入参数inFunc的指针地址。在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。</li>
<li>第10行，将传入的变量作为返回值返回，返回的过程将发生值复制。</li>
</ul>
<h4 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h4><p>测试流程会准备一个Data格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针。通过调用测试函数，传入Data结构数据，并获得返回值，对比输入和输出后的Data结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第3行，创建一个Data结构的实例in。</li>
<li>第4行，将切片数据赋值到in的complax成员。</li>
<li>第5行，为in的instance成员赋值InnerData结构的数据。</li>
<li>第6行，为in的ptr成员赋值InnerData的指针类型数据。</li>
<li>第10行，打印输入结构的成员情况。</li>
<li>第13行，打印输入结构的指针地址。</li>
<li>第16行，传入in结构，调用passByvalue()测试函数获得out返回，此时，passByValue()函数会打印in传入后的数据成员情况。</li>
<li>第19行，打印返回值out变量的成员情况。</li>
<li>第22行，打印输出结构的地址。<br>运行代码，输出结果为：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">invalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninptr:0xc0000b4330ninFuncvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninFuncptr:0xc0000b43c0no</span><br><span class="line">utvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}noutptr:0xc0000b4390n</span><br></pre></td></tr></tbody></table></figure>
<p>从运行结果中发现：</p>
<ul>
<li>所有的Data结构的指针地址发生了变化，意味着所有的结构都是一块新的内存，无论是将Data结构传入函数内部，还是通过函数返回值传回Data都会发生复制行为。</li>
<li>所有的Data结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。</li>
<li>Data结构的ptr成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。</li>
</ul>
<h3 id="函数变量——把函数作为值保存到变量中"><a href="#函数变量——把函数作为值保存到变量中" class="headerlink" title="函数变量——把函数作为值保存到变量中"></a>函数变量——把函数作为值保存到变量中</h3><p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fire() {</span><br><span class="line">    fmt.Println("fire")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line"></span><br><span class="line">    f = fire</span><br><span class="line"></span><br><span class="line">    f()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fire</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 7 行，定义了一个 fire() 函数。</li>
<li>第 13 行，将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil。</li>
<li>第 15 行，将 fire() 函数作为值，赋给函数变量 f，此时 f 的值为 fire() 函数。</li>
<li>第 17 行，使用函数变量 f 进行函数调用，实际调用的是 fire() 函数。</li>
</ul>
<h3 id="字符串的链式处理"><a href="#字符串的链式处理" class="headerlink" title="字符串的链式处理"></a>字符串的链式处理</h3><p>使用SQL语言从数据库中获取数据时，可以对原始数据进行排序（sortby）、分组（groupby）和去重（distinct）等操作。SQL将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。</p>
<p>对数据的操作进行多步骤的处理被称为链式处理。本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。</p>
<p>完整代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(strstring) string {</span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list:=[]string {"goscanner","goparser","gocompiler","goprinter","goformater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>字符串处理函数（StringProccess）需要外部提供数据源：一个字符串切片 <code>（list[]string）</code>，另外还要提供一个链式处理函数的切片 <code>（chain[]func(string)string）</code>，链式处理切片中的一个处理函数的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func(string) string</span><br></pre></td></tr></tbody></table></figure>
<p>这种处理函数能够接受一个字符串输入，处理后输出。</p>
<p>strings包中将字符串变为小写就是一种处理函数的形式，<code>strings.ToLower()</code> 函数能够将传入的字符串的每一个字符变为小写，<code>strings.ToLower</code>定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ToLower(s string) string</span><br></pre></td></tr></tbody></table></figure>
<p>字符串处理函数（StringProccess）内部遍历每一个数据源提供的字符串，每个字符串都需要经过一系列链式处理函数处理后被重新放回切片，参见下面代码。</p>
<p>字符串的链式处理：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，传入字符串切片list作为数据源，一系列的处理函数作为chain处理链。</li>
<li>第5行，遍历字符串切片的每个字符串，依次对每个字符串进行处理。</li>
<li>第8行，将当前字符串保存到result变量中，作为第一个处理函数的参数。</li>
<li>第11行，遍历每一个处理函数，将字符串按顺序经过这些处理函数处理。</li>
<li>第14行，result变量即是每个处理函数的输入变量，处理后的变量又会重新保存到result变量中。</li>
<li>第18行，将处理完的字符串保存回切片中。</li>
</ul>
<h4 id="自定义的处理函数"><a href="#自定义的处理函数" class="headerlink" title="自定义的处理函数"></a>自定义的处理函数</h4><p>处理函数可以是系统提供的处理函数，如将字符串变大写或小写，也可以使用自定义函数。本例中的字符串处理的逻辑是使用一个自定义的函数实现移除指定go前缀的过程，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(str string) string {</span><br><span class="line"></span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此函数使用了strings.TrimPrefix()函数实现移除字符串的指定前缀。处理后，移除前缀的字符串结果将通过removePrefix()函数的返回值返回。</p>
<h4 id="字符串处理主流程"><a href="#字符串处理主流程" class="headerlink" title="字符串处理主流程"></a>字符串处理主流程</h4><p>字符串处理的主流程包含以下几个步骤：</p>
<ul>
<li>准备要处理的字符串列表。</li>
<li>准备字符串处理链。</li>
<li>处理字符串列表。</li>
<li>打印输出后的字符串列表。</li>
</ul>
<p>详细流程参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list := []string {"go scanner","go parser","go compiler","go printer","go formater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，定义字符串切片，字符串包含go前缀及空格。</li>
<li>第13行，准备处理每个字符串的处理链，处理的顺序与函数在切片中的位置一致。removePrefix()为自定义的函数，功能是移除go前缀；移除前缀的字符串左边有一个空格，使用strings.TrimSpace移除，这个函数的定义刚好符合处理函数的格式：func(string)string；strings.ToUpper用于将字符串转为大写。</li>
<li>第20行，传入字符串切片和字符串处理链，通过StringProcess()函数对字符串进行处理。</li>
<li>第23行，遍历字符串切片的每一个字符串，打印处理好的字符串结果。</li>
</ul>
<p><strong><em>提示:链式处理器是一种常见的编程设计。Netty是使用Java语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty中就有类似的链式处理器的设计。</em></strong></p>
<p>Netty可以使用类似的处理链对封包进行收发编码及处理。Netty的开发者可以分为3种：</p>
<ul>
<li>第一种是Netty底层开发者</li>
<li>第二种是每个处理环节的开发者</li>
<li>第三种是业务实现者，在实际开发环节中，后两种开发者往往是同一批开发者。</li>
</ul>
<p>链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。</p>
<h2 id="匿名函数——没有函数名字的函数"><a href="#匿名函数——没有函数名字的函数" class="headerlink" title="匿名函数——没有函数名字的函数"></a>匿名函数——没有函数名字的函数</h2><p>Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。</p>
<h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func(参数列表)(返回参数列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的定义就是没有名字的普通函数定义。</p>
<h4 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h4><p>匿名函数可以在声明后调用，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}(100)</span><br></pre></td></tr></tbody></table></figure>
<p>注意第3行 <code>}</code> 后的 <code>(100)</code> ，表示对匿名函数进行调用，传递参数为 100。</p>
<h4 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h4><p>匿名函数可以被赋值，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 将匿名函数体保存到f()中</span><br><span class="line">f := func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 使用f()调用</span><br><span class="line">f(100)</span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p>
<h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) {</span><br><span class="line"></span><br><span class="line">    for _, v := range list {</span><br><span class="line">        f(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int{1, 2, 3, 4}, func(v int) {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。</li>
<li>第 18 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。</li>
<li>第 19～20 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。</li>
</ul>
<p>匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string {</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用匿名函数实现操作封装"><a href="#使用匿名函数实现操作封装" class="headerlink" title="使用匿名函数实现操作封装"></a>使用匿名函数实现操作封装</h3><p>下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var skillParam = flag.String("skill", "", "skill to perform")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    var skill = map[string]func(){</span><br><span class="line">        "fire": func() {</span><br><span class="line">            fmt.Println("chicken fire")</span><br><span class="line">        },</span><br><span class="line">        "run": func() {</span><br><span class="line">            fmt.Println("soldier run")</span><br><span class="line">        },</span><br><span class="line">        "fly": func() {</span><br><span class="line">            fmt.Println("angel fly")</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if f, ok := skill[*skillParam]; ok {</span><br><span class="line">        f()</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("skill not found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义命令行参数 skill，从命令行输入 <code>--skill</code> 可以将 <code>=</code> 后的字符串传入 skillParam 指针变量。</li>
<li>第 12 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。</li>
<li>第 14 行，定义一个从字符串映射到 <code>func()</code> 的 map，然后填充这个 map。</li>
<li>第 15～23 行，初始化 map 的键值对，值为匿名函数。</li>
<li>第 26 行，skillParam 是一个 <code>*string</code> 类型的指针变量，使用 <code>*skillParam</code> 获取到命令行传过来的值，并在 <code>map</code> 中查找对应命令行参数指定的字符串的函数。</li>
<li>第 29 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。</li>
</ul>
<p>运行代码，结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fly</span><br><span class="line">angel fly</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fire</span><br><span class="line">chicken fire</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=run</span><br><span class="line">soldier run</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=go</span><br><span class="line">skill not found</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数类型实现接口"><a href="#函数类型实现接口" class="headerlink" title="函数类型实现接口"></a>函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将对结构体与函数实现接口的过程进行对比。</p>
<p>完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明接口变量</span><br><span class="line">    var invoker Invoker</span><br><span class="line"></span><br><span class="line">    // 实例化结构体</span><br><span class="line">    s := new(Struct)</span><br><span class="line"></span><br><span class="line">    // 将实例化的结构体赋值到接口</span><br><span class="line">    invoker = s</span><br><span class="line"></span><br><span class="line">    // 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line"></span><br><span class="line">    // 将匿名函数转为FuncCaller类型，再赋值给接口</span><br><span class="line">    invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">        fmt.Println("from function", v)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 使用接口调用FuncCaller.Call，内部会调用函数本体</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">from struct hello</span><br><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure>
<p>有如下一个接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call()方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个接口需要实现 Call() 方法，调用时会传入一个 interface{} 类型的变量，这种类型的变量表示任意类型的值。</p>
<p>接下来，使用结构体进行接口实现。</p>
<h3 id="结构体实现接口"><a href="#结构体实现接口" class="headerlink" title="结构体实现接口"></a>结构体实现接口</h3><p>结构体实现 Invoker 接口的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义结构体，该例子中的结构体无须任何成员，主要展示实现 Invoker 的方法。</li>
<li>第 6 行，Call() 为结构体的方法，该方法的功能是打印 from struct 和传入的 interface{} 类型的值。</li>
</ul>
<p>将定义的 Struct 类型实例化，并传入接口中进行调用，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 实例化结构体</span><br><span class="line">s := new(Struct)</span><br><span class="line"></span><br><span class="line">// 将实例化的结构体赋值到接口</span><br><span class="line">invoker = s</span><br><span class="line"></span><br><span class="line">// 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明 Invoker 类型的变量。</li>
<li>第 5 行，使用 new 将结构体实例化，此行也可以写为 <code>s := &amp;Struct</code>。</li>
<li>第 8 行，s 类型为 <code>*Struct</code> ，已经实现了 Invoker 接口类型，因此赋值给 invoker 时是成功的。</li>
<li>第 11 行，通过接口的 <code>Call()</code> 方法，传入 hello ，此时将调用 Struct 结构体的 <code>Call()</code> 方法。</li>
</ul>
<p>接下来，对比下函数实现结构体的差异。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">from struct hello</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数体实现接口"><a href="#函数体实现接口" class="headerlink" title="函数体实现接口"></a>函数体实现接口</h3><p>函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f()函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，将 func(interface{}) 定义为 FuncCaller 类型。</li>
<li>第 5 行，FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。</li>
<li>第 8 行，FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。</li>
</ul>
<p>上面代码只是定义了函数类型，需要函数本身进行逻辑处理，FuncCaller 无须被实例化，只需要将函数转换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 将匿名函数转为FuncCaller类型, 再赋值给接口</span><br><span class="line">invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">    fmt.Println("from function", v)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 使用接口调用FuncCaller.Call, 内部会调用函数本体</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明接口变量。</li>
<li>第 5 行，将 func(v interface{}){} 匿名函数转换为 FuncCaller 类型（函数签名才能转换），此时 FuncCaller 类型实现了 Invoker 的 Call() 方法，赋值给 invoker 接口是成功的。</li>
<li>第 10 行，使用接口方法调用。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HTTP包中的例子"><a href="#HTTP包中的例子" class="headerlink" title="HTTP包中的例子"></a>HTTP包中的例子</h3><p>HTTP 包中包含有 Handler 接口定义，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Handler interface {</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Handler 用于定义每个 HTTP 的请求和响应的处理过程。</p>
<p>同时，也可以使用处理函数实现接口，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="line"></span><br><span class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。</p>
<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></tbody></table></figure>
<p>同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/closure.jpg" alt="图：闭包与函数引用"></p>
<p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</p>
<p><strong><em>其它编程语言中的闭包</em></strong></p>
<p>闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。</p>
<p>闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。</p>
<p>在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。</p>
<p>闭包在各种语言中的实现也是不尽相同的，在 Lua 语言中，无论闭包还是函数都属于 Prototype 概念，被捕获的变量以 Upvalue 的形式引用到闭包中。</p>
<p>C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。</p>
<h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 准备一个字符串</span><br><span class="line">str := "hello world"</span><br><span class="line"></span><br><span class="line">// 创建一个匿名函数</span><br><span class="line">foo := func() {</span><br><span class="line"></span><br><span class="line">    // 匿名函数中访问str</span><br><span class="line">    str = "hello dude"</span><br><span class="line">}</span><br><span class="line">// 调用匿名函数</span><br><span class="line">foo()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，准备一个字符串用于修改。</li>
<li>第 5 行，创建一个匿名函数。</li>
<li>第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。</li>
<li>第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。</li>
</ul>
<p>代码输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello dude</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：闭包的记忆效应"><a href="#示例：闭包的记忆效应" class="headerlink" title="示例：闭包的记忆效应"></a>示例：闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p>
<p>累加器的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 提供一个值, 每次调用函数会指定对值进行累加</span><br><span class="line">func Accumulate(value int) func() int {</span><br><span class="line"></span><br><span class="line">    // 返回一个闭包</span><br><span class="line">    return func() int {</span><br><span class="line"></span><br><span class="line">        // 累加</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        // 返回一个累加值</span><br><span class="line">        return value</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator := Accumulate(1)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator)</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator2 := Accumulate(10)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator2())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0xc000006028</span><br><span class="line">11</span><br><span class="line">0xc000006038</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。</li>
<li>第 11 行，返回一个闭包函数，每次返回会创建一个新的函数实例。</li>
<li>第 14 行，对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</li>
<li>第 17 行，将修改后的值通过闭包的返回值返回。</li>
<li>第 24 行，创建一个累加器，初始值为 1，返回的 accumulator 是类型为 func()int 的函数变量。</li>
<li>第 27 行，调用 accumulator() 时，代码从 11 行开始执行匿名函数逻辑，直到第 17 行返回。</li>
<li>第 32 行，打印累加器的函数地址。</li>
</ul>
<p>对比输出的日志发现 accumulator 与 accumulator2 输出的函数地址不同，因此它们是两个不同的闭包实例。</p>
<p>每调用一次 accumulator 都会自动对引用的变量进行累加。</p>
<h3 id="示例：闭包实现生成器"><a href="#示例：闭包实现生成器" class="headerlink" title="示例：闭包实现生成器"></a>示例：闭包实现生成器</h3><p>闭包的记忆效应被用于实现类似于<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>中工厂模式的生成器，下面的例子展示了创建一个玩家生成器的过程。</p>
<p>玩家生成器的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 创建一个玩家生成器, 输入名称, 输出生成器</span><br><span class="line">func playerGen(name string) func() (string, int) {</span><br><span class="line"></span><br><span class="line">    // 血量一直为150</span><br><span class="line">    hp := 150</span><br><span class="line"></span><br><span class="line">    // 返回创建的闭包</span><br><span class="line">    return func() (string, int) {</span><br><span class="line"></span><br><span class="line">        // 将变量引用到闭包中</span><br><span class="line">        return name, hp</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个玩家生成器</span><br><span class="line">    generator := playerGen("high noon")</span><br><span class="line"></span><br><span class="line">    // 返回玩家的名字和血量</span><br><span class="line">    name, hp := generator()</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(name, hp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">high noon 150</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，playerGen() 需要提供一个名字来创建一个玩家的生成函数。</li>
<li>第 11 行，声明并设定 hp 变量为 150。</li>
<li>第 14～18 行，将 hp 和 name 变量引用到匿名函数中形成闭包。</li>
<li>第 24 行中，通过 playerGen 传入参数调用后获得玩家生成器。</li>
<li>第 27 行，调用这个玩家生成器函数，可以获得玩家的名称和血量。</li>
</ul>
<p>闭包还具有一定的封装性，第 11 行的变量是 playerGen 的局部变量，playerGen 的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。</p>
<h2 id="可变参数（变参函数）"><a href="#可变参数（变参函数）" class="headerlink" title="可变参数（变参函数）"></a>可变参数（变参函数）</h2><p>在C语言时代大家一般都用过 printf() 函数，从那个时候开始其实已经在感受可变参数的魅力和价值，如同C语言中的 printf() 函数，Go语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能。</p>
<p>本节我们将介绍可变参数的用法。合适地使用可变参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等。</p>
<h3 id="可变参数类型"><a href="#可变参数类型" class="headerlink" title="可变参数类型"></a>可变参数类型</h3><p>可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func myfunc(args ...int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面这段代码的意思是，函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int，所以它可以用如下方式调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">myfunc(2, 3, 4)</span><br><span class="line">myfunc(1, 3, 7, 13)</span><br></pre></td></tr></tbody></table></figure>
<p>形如 <code>...type</code> 格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖 <code>（syntactic sugar）</code> ，即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。</p>
<p>从内部实现机理上来说，类型 <code>...type</code> 本质上是一个数组切片，也就是 <code>[]type</code> ，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。</p>
<p>假如没有 <code>...type</code> 这样的语法糖，开发者将不得不这么写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func myfunc2(args []int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从函数的实现角度来看，这没有任何影响，该怎么写就怎么写，但从调用方来说，情形则完全不同：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">myfunc2([]int{1, 3, 7, 13})</span><br></pre></td></tr></tbody></table></figure>
<p>大家会发现，我们不得不加上 <code>[]int{}</code> 来构造一个数组切片实例，但是有了 <code>...type</code> 这个语法糖，我们就不用自己来处理了。</p>
<h3 id="任意类型的可变参数"><a href="#任意类型的可变参数" class="headerlink" title="任意类型的可变参数"></a>任意类型的可变参数</h3><p>之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Printf(format string, args ...interface{}) {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用 <code>interface{}</code> 传递任意类型数据是Go语言的惯例用法，使用 <code>interface{}</code> 仍然是类型安全的，这和 C/C++ 不太一样，下面通过示例来了解一下如何分配传入 <code>interface{}</code> 类型的数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func MyPrintf(args ...interface{}) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        switch arg.(type) {</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, "is an int value.")</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, "is a string value.")</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, "is an int64 value.")</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, "is an unknown type.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var v1 int = 1</span><br><span class="line">    var v2 int64 = 234</span><br><span class="line">    var v3 string = "hello"</span><br><span class="line">    var v4 float32 = 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该程序的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 is an int value.</span><br><span class="line">234 is an int64 value.</span><br><span class="line">hello is a string value.</span><br><span class="line">1.234 is an unknown type.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历可变参数列表——获取每一个参数的值"><a href="#遍历可变参数列表——获取每一个参数的值" class="headerlink" title="遍历可变参数列表——获取每一个参数的值"></a>遍历可变参数列表——获取每一个参数的值</h3><p>可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个函数, 参数数量为0~n, 类型约束为字符串</span><br><span class="line">func joinStrings(slist ...string) string {</span><br><span class="line"></span><br><span class="line">    // 定义一个字节缓冲, 快速地连接字符串</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    // 遍历可变参数列表slist, 类型为[]string</span><br><span class="line">    for _, s := range slist {</span><br><span class="line">        // 将遍历出的字符串连续写入字节数组</span><br><span class="line">        b.WriteString(s)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将连接好的字节数组转换为字符串并输出</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 输入3个字符串, 将它们连成一个字符串</span><br><span class="line">    fmt.Println(joinStrings("pig ", "and", " rat"))</span><br><span class="line">    fmt.Println(joinStrings("hammer", " mom", " and", " hawk"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">pig and rat</span><br><span class="line">hammer mom and hawk</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义了一个可变参数的函数，slist 的类型为 []string，每一个参数的类型都是 string，也就是说，该函数只接受字符串类型作为参数。</li>
<li>第 11 行，bytes.Buffer 在这个例子中的作用类似于 StringBuilder，可以高效地进行字符串连接操作。</li>
<li>第 13 行，遍历 slist 可变参数，s 为每个参数的值，类型为 string。</li>
<li>第 15 行，将每一个传入参数放到 bytes.Buffer 中。</li>
<li>第 19 行，将 bytes.Buffer 中的数据转换为字符串作为函数返回值返回。</li>
<li>第 24 行，输入 3 个字符串，使用 joinStrings() 函数将参数连接为字符串输出。</li>
<li>第 25 行，输入 4 个字符串，连接后输出。</li>
</ul>
<p>如果要获取可变参数的数量，可以使用 len() 函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。</p>
<h3 id="获得可变参数类型——获得每一个参数的类型"><a href="#获得可变参数类型——获得每一个参数的类型" class="headerlink" title="获得可变参数类型——获得每一个参数的类型"></a>获得可变参数类型——获得每一个参数的类型</h3><p>当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型，下面的代码演示将一系列不同类型的值传入 printTypeValue() 函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。</p>
<p>打印类型及值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printTypeValue(slist ...interface{}) string {</span><br><span class="line"></span><br><span class="line">    // 字节缓冲作为快速字符串连接</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    // 遍历参数</span><br><span class="line">    for _, s := range slist {</span><br><span class="line"></span><br><span class="line">        // 将interface{}类型格式化为字符串</span><br><span class="line">        str := fmt.Sprintf("%v", s)</span><br><span class="line"></span><br><span class="line">        // 类型的字符串描述</span><br><span class="line">        var typeString string</span><br><span class="line"></span><br><span class="line">        // 对s进行类型断言</span><br><span class="line">        switch s.(type) {</span><br><span class="line">        case bool:    // 当s为布尔类型时</span><br><span class="line">            typeString = "bool"</span><br><span class="line">        case string:    // 当s为字符串类型时</span><br><span class="line">            typeString = "string"</span><br><span class="line">        case int:    // 当s为整型类型时</span><br><span class="line">            typeString = "int"</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 写字符串前缀</span><br><span class="line">        b.WriteString("value: ")</span><br><span class="line"></span><br><span class="line">        // 写入值</span><br><span class="line">        b.WriteString(str)</span><br><span class="line"></span><br><span class="line">        // 写类型前缀</span><br><span class="line">        b.WriteString(" type: ")</span><br><span class="line"></span><br><span class="line">        // 写类型字符串</span><br><span class="line">        b.WriteString(typeString)</span><br><span class="line"></span><br><span class="line">        // 写入换行符</span><br><span class="line">        b.WriteString("\n")</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将不同类型的变量通过printTypeValue()打印出来</span><br><span class="line">    fmt.Println(printTypeValue(100, "str", true))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">value: 100 type: int</span><br><span class="line">value: str type: string</span><br><span class="line">value: true type: bool</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，printTypeValue() 输入不同类型的值并输出类型和值描述。</li>
<li>第 11 行，bytes.Buffer 字节缓冲作为快速字符串连接。</li>
<li>第 14 行，遍历 slist 的每一个元素，类型为 interface{}。</li>
<li>第 17 行，使用 fmt.Sprintf 配合%v动词，可以将 interface{} 格式的任意值转为字符串。</li>
<li>第 20 行，声明一个字符串，作为变量的类型名。</li>
<li>第 23 行，switch s.(type) 可以对 interface{} 类型进行类型断言，也就是判断变量的实际类型。</li>
<li>第 24～29 行为 s 变量可能的类型，将每种类型的对应类型字符串赋值到 typeString 中。</li>
<li>第 33～42 行为写输出格式的过程。</li>
</ul>
<h3 id="在多个可变参数函数中传递参数"><a href="#在多个可变参数函数中传递参数" class="headerlink" title="在多个可变参数函数中传递参数"></a>在多个可变参数函数中传递参数</h3><p>可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加 <code>...</code> ，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p>
<p>下面的例子模拟 print() 函数及实际调用的 rawPrint() 函数，两个函数都拥有可变参数，需要将参数从 print 传递到 rawPrint 中。</p>
<p>可变参数传递：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 实际打印的函数</span><br><span class="line">func rawPrint(rawList ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 遍历可变参数切片</span><br><span class="line">    for _, a := range rawList {</span><br><span class="line"></span><br><span class="line">        // 打印参数</span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印函数封装</span><br><span class="line">func print(slist ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 将slist可变参数切片完整传递给下一个函数</span><br><span class="line">    rawPrint(slist...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    print(1, 2, 3)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 9～13 行，遍历 rawPrint() 的参数列表 rawList 并打印。</li>
<li>第 20 行，将变量在 print 的可变参数列表中添加 <code>...</code> 后传递给 rawPrint()。</li>
<li>第 25 行，传入 1、2、3 这 3 个整型值并进行打印。</li>
</ul>
<p>如果尝试将第 20 行修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rawPrint("fmt", slist)</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行代码，将输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure>
<p>此时，slist（类型为 <code>[]interface{}</code> ）将被作为一个整体传入 rawPrint()，rawPrint() 函数中遍历的变量也就是 slist 的切片值。</p>
<p>可变参数使用 <code>...</code> 进行传递与切片间使用 append 连接是同一个特性。</p>
<h2 id="defer（延迟执行语句）"><a href="#defer（延迟执行语句）" class="headerlink" title="defer（延迟执行语句）"></a>defer（延迟执行语句）</h2><p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</p>
<p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p>
<h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出），下面的代码是将一系列的数值打印语句按顺序延迟处理，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer begin")</span><br><span class="line"></span><br><span class="line">    // 将defer放入延迟调用栈</span><br><span class="line">    defer fmt.Println(1)</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line"></span><br><span class="line">    // 最后一个放入, 位于栈顶, 最先调用</span><br><span class="line">    defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer end")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">defer begin</span><br><span class="line">defer end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>结果分析如下：</p>
<ul>
<li>代码的延迟顺序与最终的执行顺序是反向的。</li>
<li>延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。</li>
</ul>
<h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p>
<p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。</p>
<h4 id="使用延迟并发解锁"><a href="#使用延迟并发解锁" class="headerlink" title="使用延迟并发解锁"></a>使用延迟并发解锁</h4><p>在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    // 一个演示用的映射</span><br><span class="line">    valueByKey      = make(map[string]int)</span><br><span class="line">    // 保证使用映射时的并发安全的互斥锁</span><br><span class="line">    valueByKeyGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 根据键读取值</span><br><span class="line">func readValue(key string) int {</span><br><span class="line">    // 对共享资源加锁</span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">    // 取值</span><br><span class="line">    v := valueByKey[key]</span><br><span class="line">    // 对共享资源解锁</span><br><span class="line">    valueByKeyGuard.Unlock()</span><br><span class="line">    // 返回值</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，实例化一个 map，键是 string 类型，值为 int。</li>
<li>第 5 行，map 默认不是并发安全的，准备一个 sync.Mutex 互斥量保护 map 的访问。</li>
<li>第 9 行，readValue() 函数给定一个键，从 map 中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。</li>
<li>第 11 行，使用互斥量加锁。</li>
<li>第 13 行，从 map 中获取值。</li>
<li>第 15 行，使用互斥量解锁。</li>
<li>第 17 行，返回获取到的 map 值。</li>
</ul>
<p>使用 defer 语句对上面的语句进行简化，参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func readValue(key string) int {</span><br><span class="line"></span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line"></span><br><span class="line">    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用</span><br><span class="line">    defer valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return valueByKey[key]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中第 6~8 行是对前面代码的修改和添加的代码，代码说明如下：</p>
<ul>
<li>第 6 行在互斥量加锁后，使用 defer 语句添加解锁，该语句不会马上执行，而是等 readValue() 函数返回时才会被执行。</li>
<li>第 8 行，从 map 查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。</li>
</ul>
<h4 id="使用延迟释放文件句柄"><a href="#使用延迟释放文件句柄" class="headerlink" title="使用延迟释放文件句柄"></a>使用延迟释放文件句柄</h4><p>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源，在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 根据文件名查询其大小</span><br><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    // 根据文件名打开文件, 返回文件句柄和错误</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    // 如果打开时发生错误, 返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件状态信息</span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    // 如果获取信息时发生错误, 关闭文件并返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        f.Close()</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件大小</span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // 关闭文件</span><br><span class="line">    f.Close()</span><br><span class="line"></span><br><span class="line">    // 返回文件大小</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义获取文件大小的函数，返回值是 64 位的文件大小值。</li>
<li>第 5 行，使用 os 包提供的函数 Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。</li>
<li>第 8 行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为 0。</li>
<li>第 13 行，此时文件句柄 f 可以正常使用，使用 f 的方法 Stat() 来获取文件的信息，获取信息时，可能也会发生错误。</li>
<li>第 16～19 行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用 f 的 Close() 方法来关闭文件，否则会发生资源泄露。</li>
<li>第 22 行，获取文件大小。</li>
<li>第 25 行，关闭文件、释放资源。</li>
<li>第 28 行，返回获取到的文件大小。</li>
</ul>
<p>在上面的例子中，第 25 行是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 延迟调用Close, 此时Close不会被调用</span><br><span class="line">    defer f.Close()</span><br><span class="line"></span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        // defer机制触发, 调用Close关闭文件</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // defer机制触发, 调用Close关闭文件</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对比前面代码修改的部分，代码说明如下：</p>
<ul>
<li>第 10 行，在文件正常打开后，使用 defer，将 f.Close() 延迟调用，注意，不能将这一句代码放在第 4 行空行处，一旦文件打开错误，f 将为空，在延迟语句触发时，将触发宕机错误。</li>
<li>第 16 行和第 22 行，defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源。</li>
</ul>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>很对编程语言都支持递归函数，Go语言也不例外，所谓递归函数指的是在函数内部调用函数自身的函数，从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，如计算给定数字阶乘、产生斐波系列等。</p>
<p>构成递归需要具备以下条件：</p>
<ul>
<li>一个问题可以被拆分成多个子问题；</li>
<li>拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；</li>
<li>不能无限制的调用本身，子问题需要有退出递归状态的条件。</li>
</ul>
<p><strong><em>注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。</em></strong></p>
<p>下面通过几个示例来演示一下递归函数的使用。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>下面我们就以递归函数的经典示例 —— 斐波那契数列为例，演示如何通过Go语言编写的递归函数来打印斐波那契数列。</p>
<p>数列的形式如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, …</span><br></pre></td></tr></tbody></table></figure>
<p>使用Go语言递归函数实现斐波那契数列的具体代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("fibonacci(%d) is: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fibonacci(1) is: 1</span><br><span class="line">fibonacci(2) is: 1</span><br><span class="line">fibonacci(3) is: 2</span><br><span class="line">fibonacci(4) is: 3</span><br><span class="line">fibonacci(5) is: 5</span><br><span class="line">fibonacci(6) is: 8</span><br><span class="line">fibonacci(7) is: 13</span><br><span class="line">fibonacci(8) is: 21</span><br><span class="line">fibonacci(9) is: 34</span><br><span class="line">fibonacci(10) is: 55</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a>数字阶乘</h3><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作 <code>n!</code> ，“基斯顿·卡曼”在 1808 年发明了 <code>n!</code> 这个运算符号。</p>
<p>例如，<code>n!=1×2×3×…×n</code> ，阶乘亦可以递归方式定义：<code>0!=1，n!=(n-1)!×n</code> 。</p>
<p>使用递归函数计算给定数的阶乘，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func Factorial(n uint64) (result uint64) {</span><br><span class="line">    if n &gt; 0 {</span><br><span class="line">        result = n * Factorial(n-1)</span><br><span class="line">        return result</span><br><span class="line">    }</span><br><span class="line">    return 1</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var i int = 10</span><br><span class="line">    fmt.Printf("%d 的阶乘是 %d\n", i, Factorial(uint64(i)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">10 的阶乘是 3628800</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多个函数组成递归"><a href="#多个函数组成递归" class="headerlink" title="多个函数组成递归"></a>多个函数组成递归</h3><p>Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%d is even: is %t\n", 16, even(16)) // 16 is even: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 17, odd(17))</span><br><span class="line">    // 17 is odd: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 18, odd(18))</span><br><span class="line">    // 18 is odd: is false</span><br><span class="line">}</span><br><span class="line">func even(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return odd(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func odd(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    return even(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func RevSign(nr int) int {</span><br><span class="line">    if nr &lt; 0 {</span><br><span class="line">        return -nr</span><br><span class="line">    }</span><br><span class="line">    return nr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行效果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">16 is even: is true</span><br><span class="line">17 is odd: is true</span><br><span class="line">18 is odd: is false</span><br></pre></td></tr></tbody></table></figure>
<h2 id="处理运行时错误"><a href="#处理运行时错误" class="headerlink" title="处理运行时错误"></a>处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p>
<ul>
<li>一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。</li>
<li>在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。</li>
</ul>
<p>Go语言没有类似 Java 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p>
<p>Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p>
<h3 id="net-包中的例子"><a href="#net-包中的例子" class="headerlink" title="net 包中的例子"></a>net 包中的例子</h3><p>net.Dial() 是Go语言系统包 net 即中的一个函数，一般用于创建一个 Socket 连接。</p>
<p>net.Dial 拥有两个返回值，即 Conn 和 error，这个函数是阻塞的，因此在 Socket 操作后，会返回 Conn 连接对象和 error，如果发生错误，error 会告知错误的类型，Conn 会返回空。</p>
<p>根据Go语言的错误处理机制，Conn 是其重要的返回值，因此，为这个函数增加一个错误返回，类似为 error，参见下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Dial(network, address string) (Conn, error) {</span><br><span class="line">    var d Dialer</span><br><span class="line">    return d.Dial(network, address)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 io 包中的 Writer 接口也拥有错误返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>io 包中还有 Closer 接口，只有一个错误返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="错误接口的定义格式"><a href="#错误接口的定义格式" class="headerlink" title="错误接口的定义格式"></a>错误接口的定义格式</h3><p>error 是 Go 系统声明的接口类型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误</p>
<h3 id="自定义一个错误"><a href="#自定义一个错误" class="headerlink" title="自定义一个错误"></a>自定义一个错误</h3><p>返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var err = errors.New("this is an error")</span><br></pre></td></tr></tbody></table></figure>
<p>错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。</p>
<h4 id="errors-包"><a href="#errors-包" class="headerlink" title="errors 包"></a>errors 包</h4><p>Go语言的 errors 中对 New 的定义非常简单，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建错误对象</span><br><span class="line">func New(text string) error {</span><br><span class="line">    return &amp;errorString{text}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 错误字符串</span><br><span class="line">type errorString struct {</span><br><span class="line">    s string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 返回发生何种错误</span><br><span class="line">func (e *errorString) Error() string {</span><br><span class="line">    return e.s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，将 errorString 结构体实例化，并赋值错误描述的成员。</li>
<li>第 7 行，声明 errorString 结构体，拥有一个成员，描述错误内容。</li>
<li>第 12 行，实现 error 接口的 Error() 方法，该方法返回成员中的错误描述。</li>
</ul>
<h4 id="在代码中使用错误定义"><a href="#在代码中使用错误定义" class="headerlink" title="在代码中使用错误定义"></a>在代码中使用错误定义</h4><p>下面的代码会定义一个除法函数，当除数为 0 时，返回一个预定义的除数为 0 的错误。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义除数为0的错误</span><br><span class="line">var errDivisionByZero = errors.New("division by zero")</span><br><span class="line"></span><br><span class="line">func div(dividend, divisor int) (int, error) {</span><br><span class="line"></span><br><span class="line">    // 判断除数为0的情况并返回</span><br><span class="line">    if divisor == 0 {</span><br><span class="line">        return 0, errDivisionByZero</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 正常计算，返回空错误</span><br><span class="line">    return dividend / divisor, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println(div(1, 0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 division by zero</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 9 行，预定义除数为 0 的错误。</li>
<li>第 11 行，声明除法函数，输入被除数和除数，返回商和错误。</li>
<li>第 14 行，在除法计算中，如果除数为 0，计算结果为无穷大，为了避免这种情况，对除数进行判断，并返回商为 0 和除数为 0 的错误对象。</li>
<li>第 19 行，进行正常的除法计算，没有发生错误时，错误对象返回 nil。</li>
</ul>
<h3 id="示例：在解析中使用自定义错误"><a href="#示例：在解析中使用自定义错误" class="headerlink" title="示例：在解析中使用自定义错误"></a>示例：在解析中使用自定义错误</h3><p>使用 errors.New 定义的错误字符串的错误类型是无法提供丰富的错误信息的，那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。</p>
<p>下面代码将实现一个解析错误（ParseError），这种错误包含两个内容，分别是文件名和行号，解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，就需要将文件名和行号返回。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个解析错误</span><br><span class="line">type ParseError struct {</span><br><span class="line">    Filename string // 文件名</span><br><span class="line">    Line     int    // 行号</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现error接口，返回错误描述</span><br><span class="line">func (e *ParseError) Error() string {</span><br><span class="line">    return fmt.Sprintf("%s:%d", e.Filename, e.Line)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一些解析错误</span><br><span class="line">func newParseError(filename string, line int) error {</span><br><span class="line">    return &amp;ParseError{filename, line}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var e error</span><br><span class="line">    // 创建一个错误实例，包含文件名和行号</span><br><span class="line">    e = newParseError("main.go", 1)</span><br><span class="line"></span><br><span class="line">    // 通过error接口查看错误描述</span><br><span class="line">    fmt.Println(e.Error())</span><br><span class="line"></span><br><span class="line">    // 根据错误接口具体的类型，获取详细错误信息</span><br><span class="line">    switch detail := e.(type) {</span><br><span class="line">    case *ParseError: // 这是一个解析错误</span><br><span class="line">        fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)</span><br><span class="line">    default: // 其他类型的错误</span><br><span class="line">        fmt.Println("other error")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main.go:1</span><br><span class="line">Filename: main.go Line: 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，声明了一个解析错误的结构体，解析错误包含有 2 个成员，分别是文件名和行号。</li>
<li>第 14 行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。</li>
<li>第 19 行，根据给定的文件名和行号创建一个错误实例。</li>
<li>第 25 行，声明一个错误接口类型。</li>
<li>第 27 行，创建一个实例，这个错误接口内部是 <code>*ParserError</code> 类型，携带有文件名 main.go 和行号 1。</li>
<li>第 30 行，调用 Error() 方法，通过第 15 行返回错误的详细信息。</li>
<li>第 33 行，通过错误断言，取出发生错误的详细类型。</li>
<li>第 34 行，通过分析这个错误的类型，得知错误类型为 <code>*ParserError</code> ，此时可以获取到详细的错误信息。</li>
<li>第 36 行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。</li>
</ul>
<p>错误对象都要实现 error 接口的 Error() 方法，这样，所有的错误都可以获得字符串的描述，如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。</p>
<h2 id="宕机（panic）——程序终止运行"><a href="#宕机（panic）——程序终止运行" class="headerlink" title="宕机（panic）——程序终止运行"></a>宕机（panic）——程序终止运行</h2><p>Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。</p>
<p>宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，宕机有时也是一种合理的止损方法。</p>
<p>一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。</p>
<p>对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。</p>
<p>虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。</p>
<h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。</p>
<p>Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    panic("crash")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行崩溃并输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: crash</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:4 +0x40</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func panic(v interface{})    //panic() 的参数可以是任意类型的。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在运行依赖的必备资源缺失时主动触发宕机"><a href="#在运行依赖的必备资源缺失时主动触发宕机" class="headerlink" title="在运行依赖的必备资源缺失时主动触发宕机"></a>在运行依赖的必备资源缺失时主动触发宕机</h3><p>regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。</p>
<p>编译正则表达式函数有两种，具体如下：</p>
<h4 id="func-Compile-expr-string-Regexp-error"><a href="#func-Compile-expr-string-Regexp-error" class="headerlink" title="func Compile(expr string) (*Regexp, error)"></a>func Compile(expr string) (*Regexp, error)</h4><p>编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。</p>
<h4 id="func-MustCompile-str-string-Regexp"><a href="#func-MustCompile-str-string-Regexp" class="headerlink" title="func MustCompile(str string) *Regexp"></a>func MustCompile(str string) *Regexp</h4><p>当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。</p>
<p>MustCompile 的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func MustCompile(str string) *Regexp {</span><br><span class="line">    regexp, error := Compile(str)</span><br><span class="line">    if error != nil {</span><br><span class="line">        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())</span><br><span class="line">    }</span><br><span class="line">    return regexp</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。</li>
<li>第 2 行，Compile() 是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。</li>
<li>第 3 和第 4 行判断如果有错，则使用 panic() 触发宕机。</li>
<li>第 6 行，没有错误时返回正则表达式对象。</li>
</ul>
<p>手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。</p>
<h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    defer fmt.Println("宕机后要做的事情1")</span><br><span class="line">    defer fmt.Println("宕机后要做的事情2")</span><br><span class="line">    panic("宕机")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">宕机后要做的事情2</span><br><span class="line">宕机后要做的事情1</span><br><span class="line">panic: 宕机</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:8 +0xf8</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 6 行和第 7 行使用 defer 语句延迟了 2 个语句。</li>
<li>第 8 行发生宕机。</li>
</ul>
<p>宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。</p>
<h2 id="宕机恢复（recover）——防止程序崩溃"><a href="#宕机恢复（recover）——防止程序崩溃" class="headerlink" title="宕机恢复（recover）——防止程序崩溃"></a>宕机恢复（recover）——防止程序崩溃</h2><p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p>
<p>通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
<p><strong><em>提示:在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。</em></strong></p>
<p>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。</p>
<h3 id="让程序在崩溃时继续执行"><a href="#让程序在崩溃时继续执行" class="headerlink" title="让程序在崩溃时继续执行"></a>让程序在崩溃时继续执行</h3><p>下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。</p>
<p>保护运行函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 崩溃时需要传递的上下文信息</span><br><span class="line">type panicContext struct {</span><br><span class="line">    function string // 所在函数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 保护方式允许一个函数</span><br><span class="line">func ProtectRun(entry func()) {</span><br><span class="line"></span><br><span class="line">    // 延迟处理的函数</span><br><span class="line">    defer func() {</span><br><span class="line"></span><br><span class="line">        // 发生宕机时，获取panic传递的上下文并打印</span><br><span class="line">        err := recover()</span><br><span class="line"></span><br><span class="line">        switch err.(type) {</span><br><span class="line">        case runtime.Error: // 运行时错误</span><br><span class="line">            fmt.Println("runtime error:", err)</span><br><span class="line">        default: // 非运行时错误</span><br><span class="line">            fmt.Println("error:", err)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    entry()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("运行前")</span><br><span class="line"></span><br><span class="line">    // 允许一段手动触发的错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机前")</span><br><span class="line"></span><br><span class="line">        // 使用panic传递上下文</span><br><span class="line">        panic(&amp;panicContext{</span><br><span class="line">            "手动触发panic",</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 故意造成空指针访问错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机前")</span><br><span class="line"></span><br><span class="line">        var a *int</span><br><span class="line">        *a = 1</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Println("运行后")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">运行前</span><br><span class="line">手动宕机前</span><br><span class="line">error: &amp;{手动触发panic}</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">运行后</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 9 行声明描述错误的结构体，保存执行错误的函数。</li>
<li>第 17 行使用 defer 将闭包延迟执行，当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。</li>
<li>第 20 行，recover() 获取到 panic 传入的参数。</li>
<li>第 22 行，使用 switch 对 err 变量进行类型断言。</li>
<li>第 23 行，如果错误是有 Runtime 层抛出的运行时错误，如空指针访问、除数为 0 等情况，打印运行时错误。</li>
<li>第 25 行，其他错误，打印传递过来的错误数据。</li>
<li>第 44 行，使用 panic 手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover 就会获取到这个结构体信息，并打印出来。</li>
<li>第 57 行，模拟代码中空指针赋值造成的错误，此时会由 Runtime 层抛出错误，被 ProtectRun() 函数的 recover() 函数捕获到。</li>
</ul>
<h3 id="panic-和-recover-的关系"><a href="#panic-和-recover-的关系" class="headerlink" title="panic 和 recover 的关系"></a>panic 和 recover 的关系</h3><p>panic 和 recover 的组合有如下特性：</p>
<ul>
<li>有 panic 没 recover，程序宕机。</li>
<li>有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li>
</ul>
<p><strong><em>提示:虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。</em></strong></p>
<p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。</p>
<p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>
<h2 id="计算函数执行时间"><a href="#计算函数执行时间" class="headerlink" title="计算函数执行时间"></a>计算函数执行时间</h2><p>函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，要得到函数的运行时间，最简单的办法就是在函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，这个时间间隔就是函数的运行时间。</p>
<p>在Go语言中我们可以使用 time 包中的 Since() 函数来获取函数的运行时间，Go语言官方文档中对 Since() 函数的介绍是这样的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Since(t Time) Duration</span><br></pre></td></tr></tbody></table></figure>
<p>Since() 函数返回从 t 到现在经过的时间，等价于 <code>time.Now().Sub(t)</code> 。</p>
<p>【示例】使用 Since() 函数获取函数的运行时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Since(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">该函数执行完成耗时： 39.8933ms</span><br></pre></td></tr></tbody></table></figure>
<p>上面我们提到了 <code>time.Now().Sub()</code> 的功能类似于 Since() 函数，想要使用 <code>time.Now().Sub()</code> 获取函数的运行时间只需要把我们上面代码的第 14 行简单修改一下就行。</p>
<p>【示例 2】使用 time.Now().Sub() 获取函数的运行时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Now().Sub(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">该函数执行完成耗时： 36.8769ms</span><br></pre></td></tr></tbody></table></figure>
<p>由于计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。</p>
<h2 id="通过内存缓存来提升性能"><a href="#通过内存缓存来提升性能" class="headerlink" title="通过内存缓存来提升性能"></a>通过内存缓存来提升性能</h2><p>前面我们介绍了递归函数，递归函数的缺点就是比较消耗内存，而且效率比较低，那么我们要怎样提高程序的执行效率呢？</p>
<p>当在进行大量计算的时候，提升性能最直接有效的一种方式是避免重复计算，通过在内存中缓存并重复利用缓存从而避免重复执行相同计算的方式称为内存缓存。</p>
<p>下面我们以经典的递归求斐波那契数列为例，来对比一下普通实现方法和加入内存缓存后程序的执行情况。</p>
<h3 id="普通的实现方法"><a href="#普通的实现方法" class="headerlink" title="普通的实现方法"></a>普通的实现方法</h3><p>普通方法的实现思路是，要计算数列中第 n 个数字，需要先得到它前面的两个数，以此类推。这么做的弊端是会产生大量的重复计算，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt;= 40; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 1.2324148s</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出，获取第 40 位的数字所需要的时间是 1.2324148 秒（这个时间可能根据计算机性能的差异，略有不同）。</p>
<h3 id="内存缓存的实现方法"><a href="#内存缓存的实现方法" class="headerlink" title="内存缓存的实现方法"></a>内存缓存的实现方法</h3><p>内存缓存的实现思路是在计算得到第 n 个数的同时，将它的值保存到数组中索引为 n 的位置上，在后续的计算中先在数组中查找所需要的值是否计算过，如果找到了，则直接从数组中获取，如果没找到，则再进行计算，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const LIM = 41</span><br><span class="line"></span><br><span class="line">var fibs [LIM]uint64</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var result uint64 = 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt; LIM; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res uint64) {</span><br><span class="line">    // 记忆化：检查数组中是否已知斐波那契（n）</span><br><span class="line">    if fibs[n] != 0 {</span><br><span class="line">        res = fibs[n]</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 12.0316ms</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出，同样获取数列第 40 位的数字，使用内存缓存后所用的时间为 12.0316 毫秒，对比之前未使用内存缓存时的执行效率，可见内存缓存的优势还是相当明显的。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>Go语言中提供了MD5、SHA-1等几种哈希函数，下面我们用例子做一个介绍，代码如下所示</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestString := "Hi,pandaman!"</span><br><span class="line">    Md5Inst := md5.New()</span><br><span class="line">    Md5Inst.Write( []byte(TestString))</span><br><span class="line">    Result := Md5Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">    Sha1Inst := sha1.New()</span><br><span class="line">    Sha1Inst.Write([]byte(TestString))</span><br><span class="line">    Result = Sha1Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个程序的执行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">70af690adf124b2e828b4d8904ad142a</span><br><span class="line">49d37c25ef2a62b4cfcf3689c649510390e14875</span><br></pre></td></tr></tbody></table></figure>
<p>再举一个例子，对文件内容计算SHA1，具体代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestFile := "goPstrAnalysis.go"</span><br><span class="line">    infile , inerr := os.Open(TestFile)</span><br><span class="line">    if inerr == nil {</span><br><span class="line">        md5h := md5.New()</span><br><span class="line">        io.Copy( md5h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n" , md5h.Sum([]byte("")),TestFile)</span><br><span class="line">        sha1h := sha1.New()</span><br><span class="line">        io.Copy( sha1h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n",sha1h.Sum([]byte("")),TestFile)</span><br><span class="line">    }else{</span><br><span class="line">        fmt.Println(inerr)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">7350776e62ab13bc1a8be3812ba32211 goPstrAnalysis.go</span><br><span class="line">da39a3ee5e6b4b0d3255bfef95601890afd80709 goPstrAnalysis.go</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数的底层实现"><a href="#函数的底层实现" class="headerlink" title="函数的底层实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4784.html">函数的底层实现</a></h2><p>基于堆栈式的程序执行模型决定了函数是语言的一个核心元素，分析Go语言函数的底层实现，对理解整个程序的执行过程有很大的帮助，研究底层实现有两种办法，一种是看语言编译器源码，分析其对函数的各个特性的处理逻辑，另一种是反汇编，将可执行程序反汇编出来。</p>
<p>本节使用反汇编这种短、平、快的方法，首先介绍Go语言的函数调用规约，接着介绍Go语言使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/asm/">汇编语言</a>的基本概念，然后通过反汇编技术来剖析Go语言函数某些特性的底层实现。</p>
<h3 id="函数调用规约"><a href="#函数调用规约" class="headerlink" title="函数调用规约"></a>函数调用规约</h3><p>Go语言函数使用的是 caller-save 的模式，即由调用者负责保存寄存器，所以在函数的头尾不会出现 <code>push ebp; mov esp ebp</code> 这样的代码，相反其是在主调函数调用被调函数的前后有一个保存现场和恢复现场的动作。</p>
<p>主调函数保存和恢复现场的通用逻辑如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//开辟栈空间，压栈 BP 保存现场</span><br><span class="line">    SUBQ $x, SP    //为函数开辟裁空间</span><br><span class="line">    MOVQ BP, y(SP) //保存当前函数 BP 到 y(SP）位置， y 为相对 SP 的偏移量</span><br><span class="line">    LEAQ y(SP), BP //重直 BP，使其指向刚刚保存 BP 旧值的位置，这里主要</span><br><span class="line">                   //是方便后续 BP 的恢复</span><br><span class="line">//弹出栈，恢复 BP</span><br><span class="line">    MOVQ y(SP), BP //恢复 BP 的值为调用前的值</span><br><span class="line">    ADDQ $x, SP    //恢复 SP 的值为函数开始时的位</span><br></pre></td></tr></tbody></table></figure>
<h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><p>Go 编译器产生的汇编代码是一种中间抽象态，它不是对机器码的映射，而是和平台无关的一个中间态汇编描述，所以汇编代码中有些寄存器是真实的，有些是抽象的，几个抽象的寄存器如下：</p>
<ul>
<li>SB (Static base pointer)：静态基址寄存器，它和全局符号一起表示全局变量的地址。</li>
<li>FP (Frame pointer)：栈帧寄存器，该寄存器指向当前函数调用栈帧的栈底位置。</li>
<li>PC (Program counter)：程序计数器，存放下一条指令的执行地址，很少直接操作该寄存器，一般是 CALL、RET 等指令隐式的操作。</li>
<li>SP (Stack pointer)：栈顶寄存器，一般在函数调用前由主调函数设置 SP 的值对栈空间进行分配或回收。</li>
</ul>
<h4 id="Go-汇编简介"><a href="#Go-汇编简介" class="headerlink" title="Go 汇编简介"></a>Go 汇编简介</h4><p>1) Go 汇编器采用 AT&amp;T 风格的汇编，早期的实现来自 plan9 汇编器，源操作数在前，目的操作数在后。</p>
<p>2) Go 内嵌汇编和反汇编产生的代码并不是一一对应的，汇编编译器对内嵌汇编程序自动做了调整，主要差别就是增加了保护现场，以及函数调用前的保持 PC 、SP 偏移地址重定位等逻辑，反汇编代码更能反映程序的真实执行逻辑。</p>
<p>3) Go 的汇编代码并不是和具体硬件体系结构的机器码一一对应的，而是一种半抽象的描述，寄存器可能是抽象的，也可能是具体的。</p>
<p>下面代码的分析基于 AMD64 位架构下的 Linux 环境。</p>
<h3 id="多值返回分析"><a href="#多值返回分析" class="headerlink" title="多值返回分析"></a>多值返回分析</h3><p>多值返回函数 swap 的源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func swap (a, b int) (x int, y int) {</span><br><span class="line">    x = b</span><br><span class="line">    y = a</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    swap(10, 20)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译生成汇编如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//- S 产生汇编的代码</span><br><span class="line">//- N 禁用优化</span><br><span class="line">//- 1 禁用内联</span><br><span class="line"></span><br><span class="line">GOOS=linux GOARCH=amd64 go tool compile -1 -N -S swap.go &gt;swap.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>汇编代码分析:</p>
<p>1) swap 函数和 main 函数汇编代码分析。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"".swap STEXT nosplit size=39 args=0x20 locals=0x0</span><br><span class="line">    0x0000 00000 (swap.go:4) TEXT  "".swap(SB), NOSPLIT, $0 - 32</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $0, gclocals.ff19ed39bdde8a01a800918ac3ef0ec7(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $1, gclocals.33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4)  MOVQ  $0, "".x+24(SP)</span><br><span class="line">    0x0009 00009 (swap.go:4)  MOVQ  $0, "".y+32(SP)</span><br><span class="line">    0x0012 00018 (swap.go:5)  MOVQ  "".b+16(SP), AX</span><br><span class="line">    0x0017 00023 (swap.go:5)  MOVQ  AX, "".x+24(SP)</span><br><span class="line">    0xOO1c 00028 (swap.go:6)  MOVQ  "".a+8(SP), AX</span><br><span class="line">    0x0021 00033 (swap.go:6)  MOVQ  AX, "".y+32(SP)</span><br><span class="line">    0x0026 00038 (swap.go:7)  RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"".main STEXT size=68 args=0x0 locals=0x28</span><br><span class="line">    0x0000 00000 (swap.go:10) TEXT "".main(SB), $40 - 0</span><br><span class="line">    0x0000 00000 (swap.go:10) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (swap.go:10) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (swap.go:10) JLS 61</span><br><span class="line">    0x000f 00015 (swap.go:10) SUBQ $40, SP</span><br><span class="line">    0x0013 00019 (swap.go:10) MOVQ BP, 32 (SP)</span><br><span class="line">    0x0018 00024 (swap.go:10) LEAQ 32(SP), BP</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $0, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $1, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:11) MOVQ $10, (SP)</span><br><span class="line">    0x0025 00037 (swap.go:11) MOVQ $20 , 8 (SP)</span><br><span class="line">    0x002e 00046 (swap.go:11) PCDATA $0 , $0</span><br><span class="line">    0x002e 00046 (swap.go:11) CALL "". swap(SB)</span><br><span class="line">    0x0033 00051 (swap.go:12) MOVQ 32(SP), BP</span><br><span class="line">    0x0038 00056 (swap.go:12) ADDQ $40, SP</span><br><span class="line">    0x003c 00060 (swap.go:12) RET</span><br><span class="line">    0x003d 00061 (swap.go:12) NOP</span><br><span class="line">    0x003d 00061 (swap.go:10) PCDATA $0, $ - 1</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行初始化返回值 x 为 0。</li>
<li>第 6 行初始化返回值 y 为 0。</li>
<li>第 7～8 行取第 2 个参数赋值给返回值 x。</li>
<li>第 9～10 行取第 1 个参数赋值给返回值 y。</li>
<li>第 11 行函数返回，同时进行栈回收，FUNCDATA 和垃圾收集可以忽略。</li>
<li>第 15～24 行 main 函数堆栈初始化：开辟栈空间，保存 BP 寄存器。</li>
<li>第 25 行初始化 add 函数的调用参数 1 的值为 10。</li>
<li>第 26 行初始化 add 函数的调用参数 2 的值为 20。</li>
<li>第 28 行调用 swap 函数，注意 call 隐含一个将 swap 下一条指令地址压栈的动作，即 sp=sp+8。</li>
<li>所以可以看到在 swap 里面的所有变量的相对位置都发生了变化，都在原来的地址上 ＋8。</li>
<li>第 29～30 行恢复栈空间。</li>
</ul>
<p>从汇编的代码得知：</p>
<ul>
<li>函数的调用者负责环境准备，包括为参数和返回值开辟栈空间。</li>
<li>寄存器的保存和恢复也由调用方负责。</li>
<li>函数调用后回收栈空间，恢复 BP 也由主调函数负责。</li>
</ul>
<p>函数的多值返回实质上是在栈上开辟多个地址分别存放返回值，这个并没有什么特别的地方，如果返回值是存放到堆上的，则多了一个复制的动作。</p>
<p>main 调用 swap 函数栈的结构如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gofuncstack.gif" alt="图：Go函数栈"></p>
<p>函数调用前己经为返回值和参数分配了栈空间，分配顺序是从右向左的，先是返回值，然后是参数，通用的栈模型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">＋----------＋</span><br><span class="line"> | 返回值 y   |</span><br><span class="line"> |------------|</span><br><span class="line"> | 返回值 x   |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 b    |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 a    |</span><br><span class="line">＋----------＋</span><br></pre></td></tr></tbody></table></figure>
<p>函数的多返回值是主调函数预先分配好空间来存放返回值，被调函数执行时将返回值复制到该返回位置来实现的。</p>
<h3 id="闭包底层实现"><a href="#闭包底层实现" class="headerlink" title="闭包底层实现"></a>闭包底层实现</h3><p>下面通过汇编和源码对照的方式看一下 Go 闭包的内部实现。</p>
<p>程序源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">//函数返回引用了外部变量 i 的闭包</span><br><span class="line">func a(i int) func () {</span><br><span class="line">    return func() {</span><br><span class="line">        print(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f := a (1)</span><br><span class="line">    f ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译汇编如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S c2_7_4a.go &gt;c2_7_4a.s 2&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>关键汇编代码及分析如下：</p>
<p>函数 a 和函数 main 对应的汇编代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"".a STEXT size=91 args=0x10 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) TEXT "".a(SB), $24-16</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:3) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:3) JLS 84</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:3) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:3) MOVQ BP , 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:3) LEAQ 16(SP), BP</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $0, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb (SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:4) LEAQ type.noalg.struct{ F uintptr; "".i int}(SB), AX</span><br><span class="line">    0x0024 00036 (c2_7_4a.go:4) MOVQ AX, (SP)</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) PCDATA $0, $0</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) CALL runtime.newobject(SB)</span><br><span class="line">    0x002d 00045 (c2_7_4a.go:4) MOVQ 8(SP), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:4) LEAQ "".a.funcl(SB), CX</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:4) MOVQ CX, (AX)</span><br><span class="line">    0x003c 00060 (c2_7_4a.go:3) MOVQ "".i+32(SP), CX</span><br><span class="line">    0x0041 00065 (c2_7_4a.go:4) MOVQ CX, 8(AX)</span><br><span class="line">    0x0045 00069 (c2_7_4a.go:4) MOVQ AX, "".~r1+40(SP)</span><br><span class="line">    0x004a 00074 (c2_7_4a.go:4) MOVQ 16(SP), BP</span><br><span class="line">    0x004f 00079 (c2_7_4a.go:4) ADDQ $24, SP</span><br><span class="line">"".main STEXT size=69 args=0x0 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) TEXT "".main(SB), $24-0</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:9) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:9) JLS 62</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:9) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:9) MOVQ BP, 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:9) LEAQ 16(SP), BP</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $0, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:10) MOVQ $1, (SP)</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) PCDATA $0, $0</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) CALL "".a(SB)</span><br><span class="line">    0x002a 00042 (c2_7_4a.go:10) MOVQ 8(SP), DX</span><br><span class="line">    0x002f 00047 (c2_7_4a.go:11) MOVQ (DX), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) PCDATA $0, $0</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) CALL AX</span><br><span class="line">    0x0034 00052 (c2_7_4a.go:15) MOVQ 16(SP), BP</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:15) ADDQ $24, SP</span><br><span class="line">    0x003d 00061 (c2_7_4a.go:15) RET</span><br></pre></td></tr></tbody></table></figure>
<h4 id="func-a-函数分析"><a href="#func-a-函数分析" class="headerlink" title="func a() 函数分析"></a>func a() 函数分析</h4><ul>
<li>第 1～10 行环境准备。</li>
<li>第 11 行这里我们看到 <code>type.noalg.struct { F uintptr; "".i int }(SB)</code> 这个符号是一个闭包类型的数据，闭包类型的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>如下：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    i int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>闭包的结构很简单，一个是函数指针，另一个是对外部环境的引用。注意，这里仅仅是打印 i，并没有修改 i，Go语言编译器并没有传递地址而是传递值。</p>
<ul>
<li>第 11 行将闭包类型元信息放到 (SP) 位置，(SP) 地址存放的是 CALL 函数调用的第一个参数。</li>
<li><p>第 14 行创建闭包对象，我们来看一下 runtime.newobject 的函数原型，该函数的输入参数是一个类型信息，返回值是根据该类型信息构造出来的对象地址。</p>
  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// src/runtime/malloc.go</span><br><span class="line">func newobject(typ *_type) unsafe.Pointer</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 15 行将 newobject 返回的对象地址复制给 AX 寄存器。</p>
</li>
<li>第 16 行将 a 函数里面的匿名函数 a.func 指针复制到 CX 寄存器。</li>
<li>第 17 行将 CX 寄存器中存放的 a.func 函数指针复制到闭包对象的函数指针位置。</li>
<li>第 18、19 行将外部闭包变量 i 的值复制到闭包对象的 i 处。</li>
<li>第 20 行复制闭包对象指针值到函数返回值位置 <code>"".～r1+40(SP)</code>。</li>
</ul>
<h4 id="main-函数分析"><a href="#main-函数分析" class="headerlink" title="main() 函数分析"></a>main() 函数分析</h4><ul>
<li>第 23～32 行准备环境。</li>
<li>第 33 行将立即数 1 复制到 (SP) 位置，为后续的 CALL 指令准备参数。</li>
<li>第 35 行调用函数 a()。</li>
<li>第 36 行复制函数返回值到 DX 寄存器。</li>
<li>第 37 行间接寻址，复制闭包对象中的函数指针到 AX 寄存器。</li>
<li>第 39 行调用 AX 寄存器指向的函数。</li>
<li>第 40～42 行恢复环境，并返回。</li>
</ul>
<p>通过汇编代码的分析，我们清楚地看到 Go 实现闭包是通过返回一个如下的结构来实现的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    env *Type</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>F 是返回的匿名函数指针，env 是对外部环境变量的引用集合，如果闭包内没有修改外部变量，则 Go 编译器直接优化为值传递，如上面的例子中的代码所示，反之则是通过指针传递的。</p>
<h2 id="Test功能测试函数详解"><a href="#Test功能测试函数详解" class="headerlink" title="Test功能测试函数详解"></a>Test功能测试函数详解</h2><p>Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。</p>
<h3 id="为什么需要测试"><a href="#为什么需要测试" class="headerlink" title="为什么需要测试"></a>为什么需要测试</h3><p>完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少 bug，有两种有效的方式分别是代码审核和测试，Go语言中提供了 testing 包来实现单元测试功能。</p>
<h3 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h3><p>要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以 <code>_test.go</code> 结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func TestXxx( t *testing.T ){</span><br><span class="line">    //......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编写测试用例有以下几点需要注意：</p>
<ul>
<li>测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；</li>
<li>测试用例的文件名必须以_test.go结尾；</li>
<li>需要使用 import 导入 testing 包；</li>
<li>测试函数的名称要以Test或Benchmark开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li>
<li>单元测试则以 <code>(t *testing.T)</code> 作为参数，性能测试以 <code>(t *testing.B)</code> 做为参数；</li>
<li>测试用例文件使用 <code>go test</code> 命令来执行，源码中不需要 <code>main()</code> 函数作为入口，所有以 <code>_test.go</code> 结尾的源码文件内以 <code>Test</code> 开头的函数都会自动执行。</li>
</ul>
<p>Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。</p>
<h3 id="单元（功能）测试"><a href="#单元（功能）测试" class="headerlink" title="单元（功能）测试"></a>单元（功能）测试</h3><p>在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">// 根据长宽获取面积</span><br><span class="line">func GetArea(weight int, height int) int {</span><br><span class="line">    return weight * height</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行测试命令，运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -v</span><br><span class="line">=== RUN   TestGetArea</span><br><span class="line">--- PASS: TestGetArea (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.535s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="性能（压力）测试"><a href="#性能（压力）测试" class="headerlink" title="性能（压力）测试"></a>性能（压力）测试</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -bench="."</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/dubbogo/dubbo-go-proxy/com/chebada</span><br><span class="line">BenchmarkGetArea-4      1000000000</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   1.217s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。</p>
<p>将 demo_test.go 代码改造成如下所示的样子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行测试命令，运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 14.3% of statements</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.517s</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Go结构体</title>
    <url>/posts/e56582fa/</url>
    <content><![CDATA[<p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。</p>
<p>Go 语言中的类型可以被实例化，使用 <code>new</code> 或 <code>&amp;</code> 构造的类型实例的类型是类型的指针。</p>
<p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值。</li>
<li>字段名必须唯一。</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<h2 id="关于-Go-语言的类（class）"><a href="#关于-Go-语言的类（class）" class="headerlink" title="关于 Go 语言的类（class）"></a>关于 Go 语言的类（class）</h2><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p>
<p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。</p>
<p>结构体成员也可以称为“字段”，这些字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值；</li>
<li>字段名必须唯一；</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<p>使用关键字 type 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。</p>
<p>结构体的定义格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type 类型名 struct {</span><br><span class="line">    字段1 字段1类型</span><br><span class="line">    字段2 字段2类型</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>struct{}：表示结构体类型，<code>type 类型名 struct{}</code> 可以理解为将 struct{} 结构体定义为类型名的类型。</li>
<li>字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。</li>
<li>字段1类型、字段2类型……：表示结构体各个字段的类型。</li>
</ul>
<p>使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Color struct {</span><br><span class="line">    R, G, B byte</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实例化结构体"><a href="#实例化结构体" class="headerlink" title="实例化结构体"></a>实例化结构体</h2><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。</p>
<p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。</p>
<p>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p>
<h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。</p>
<p>基本实例化格式如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ins T</span><br></pre></td></tr></tbody></table></figure>
<p>其中，T 为结构体类型，ins 为结构体的实例。</p>
<p>用结构体表示的点结构（Point）的实例化过程请参见下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var p Point</span><br><span class="line">p.X = 10</span><br><span class="line">p.Y = 20</span><br></pre></td></tr></tbody></table></figure>
<p>在例子中，使用 <code>.</code> 来访问结构体的成员变量，如 <code>p.X</code> 和 <code>p.Y</code> 等，结构体成员变量的赋值方法与普通变量一致。</p>
<h3 id="创建指针类型的结构体"><a href="#创建指针类型的结构体" class="headerlink" title="创建指针类型的结构体"></a>创建指针类型的结构体</h3><p>Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</p>
<p>使用 new 的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := new(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>T 为类型，可以是结构体、整型、字符串等。</li>
<li>ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。</li>
</ul>
<p>Go语言让我们可以像访问普通结构体一样使用 <code>.</code> 来访问结构体指针的成员。</p>
<p>下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Player struct{</span><br><span class="line">    Name string</span><br><span class="line">    HealthPoint int</span><br><span class="line">    MagicPoint int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tank := new(Player)</span><br><span class="line">tank.Name = "Canon"</span><br><span class="line">tank.HealthPoint = 300</span><br></pre></td></tr></tbody></table></figure>
<p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p>
<h4 id="Go语言和-C-C"><a href="#Go语言和-C-C" class="headerlink" title="Go语言和 C/C++"></a>Go语言和 C/C++</h4><p>在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用 <code>-&gt;</code> 操作符。</p>
<p>在Go语言中，访问结构体指针的成员变量时可以继续使用 <code>.</code> ，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖 <code>（Syntactic sugar）</code> 技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code> 。</p>
<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <code>&amp;</code> 取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := &amp;T{}</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>T 表示结构体类型。</li>
<li>ins 为结构体的实例，类型为 <code>*T</code> ，是指针类型。</li>
</ul>
<p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ype Command struct {</span><br><span class="line">    Name    string    // 指令名称</span><br><span class="line">    Var     *int      // 指令绑定的变量</span><br><span class="line">    Comment string    // 指令的注释</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var version int = 1</span><br><span class="line"></span><br><span class="line">cmd := &amp;Command{}</span><br><span class="line">cmd.Name = "version"</span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = "show version"</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，定义 Command 结构体，表示命令行指令</li>
<li>第 3 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步。</li>
<li>第 7 行，命令绑定的目标整型变量：版本号。</li>
<li>第 9 行，对结构体取地址实例化。</li>
<li>第 10～12 行，初始化成员字段。</li>
</ul>
<p>取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func newCommand(name string, varref *int, comment string) *Command {</span><br><span class="line">    return &amp;Command{</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cmd = newCommand(</span><br><span class="line">    "version",</span><br><span class="line">    &amp;version,</span><br><span class="line">    "show version",</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="初始化结构体的成员变量"><a href="#初始化结构体的成员变量" class="headerlink" title="初始化结构体的成员变量"></a>初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。</p>
<h3 id="使用“键值对”初始化结构体"><a href="#使用“键值对”初始化结构体" class="headerlink" title="使用“键值对”初始化结构体"></a>使用“键值对”初始化结构体</h3><p>结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。</p>
<p>键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。</p>
<p>结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。</p>
<p>1)键值对初始化结构体的书写格式</p>
<p>键值对初始化的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1: 字段1的值,</span><br><span class="line">    字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>结构体类型：定义结构体时的类型名称。</li>
<li>字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。</li>
<li>字段1的值、字段2的值：结构体成员字段的初始值。</li>
</ul>
<p>键值之间以 <code>:</code> 分隔，键值对之间以 <code>,</code> 分隔。</p>
<p>2)使用键值对填充结构体的例子</p>
<p>下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type People struct {</span><br><span class="line">    name  string</span><br><span class="line">    child *People</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">relation := &amp;People{</span><br><span class="line">    name: "爷爷",</span><br><span class="line">    child: &amp;People{</span><br><span class="line">        name: "爸爸",</span><br><span class="line">        child: &amp;People{</span><br><span class="line">                name: "我",</span><br><span class="line">        },</span><br><span class="line">    },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，定义 People 结构体。</li>
<li>第 2 行，结构体的字符串字段。</li>
<li>第 3 行，结构体的结构体指针字段，类型是 *People。</li>
<li>第 6 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。</li>
<li>第 8 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。</li>
</ul>
<p><strong><em>提示：结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</em></strong></p>
<h3 id="使用多个值的列表初始化结构体"><a href="#使用多个值的列表初始化结构体" class="headerlink" title="使用多个值的列表初始化结构体"></a>使用多个值的列表初始化结构体</h3><p>Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。</p>
<p>1)多个值列表初始化结构体的书写格式</p>
<p>多个值使用逗号分隔初始化结构体，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1的值,</span><br><span class="line">    字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用这种格式初始化时，需要注意：</p>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>键值对与值列表的初始化形式不能混用。</li>
</ul>
<p>2)多个值列表初始化结构体的例子</p>
<p>下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Address struct {</span><br><span class="line">    Province    string</span><br><span class="line">    City        string</span><br><span class="line">    ZipCode     int</span><br><span class="line">    PhoneNumber string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">addr := Address{</span><br><span class="line">    "四川",</span><br><span class="line">    "成都",</span><br><span class="line">    610000,</span><br><span class="line">    "0",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(addr)</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{四川 成都 610000 0}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。</p>
<p>1)匿名结构体定义格式和初始化写法</p>
<p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    // 匿名结构体字段定义</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}{</span><br><span class="line">    // 字段值初始化</span><br><span class="line">    初始化字段1: 字段1的值,</span><br><span class="line">    初始化字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>字段1、字段2……：结构体定义的字段名。</li>
<li>初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。</li>
<li>字段类型1、字段类型2……：结构体定义字段的类型。</li>
<li>字段1的值、字段2的值……：结构体初始化字段的初始值。</li>
</ul>
<p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2)使用匿名结构体的例子</p>
<p>在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 打印消息类型, 传入匿名结构体</span><br><span class="line">func printMsgType(msg *struct {</span><br><span class="line">    id   int</span><br><span class="line">    data string</span><br><span class="line">}) {</span><br><span class="line"></span><br><span class="line">    // 使用动词%T打印msg的类型</span><br><span class="line">    fmt.Printf("%T\n", msg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个匿名结构体</span><br><span class="line">    msg := &amp;struct {  // 定义部分</span><br><span class="line">        id   int</span><br><span class="line">        data string</span><br><span class="line">    }{  // 值初始化部分</span><br><span class="line">        1024,</span><br><span class="line">        "hello",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printMsgType(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">*struct { id int; data string }</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义 printMsgType() 函数，参数为 msg，类型为 <code>*struct{id int data string}</code> ，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。</li>
<li>第 14 行，使用字符串格式化中的 <code>%T</code> 动词，将 msg 的类型名打印出来。</li>
<li>第 20 行，对匿名结构体进行实例化，同时初始化成员。</li>
<li>第 21 和 22 行，定义匿名结构体的字段。</li>
<li>第 24 和 25 行，给匿名结构体字段赋予初始值。</li>
<li>第 28 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li>
</ul>
<p>匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。</p>
<p>其他编程语言构造函数的一些常见功能及特性如下：</p>
<ul>
<li>每个类可以添加构造函数，多个构造函数使用函数重载实现。</li>
<li>构造函数一般与类名同名，且没有返回值。</li>
<li>构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。</li>
<li>对于 C++ 来说，还有默认构造函数、拷贝构造函数等。</li>
</ul>
<h3 id="多种方式创建和初始化结构体——模拟构造函数重载"><a href="#多种方式创建和初始化结构体——模拟构造函数重载" class="headerlink" title="多种方式创建和初始化结构体——模拟构造函数重载"></a>多种方式创建和初始化结构体——模拟构造函数重载</h3><p>如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByName(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByColor(color string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Color: color,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行定义 Cat 结构，包含颜色和名字字段。</li>
<li>第 6 行定义用名字构造猫结构的函数，返回 Cat 指针。</li>
<li>第 7 行取地址实例化猫的结构体。</li>
<li>第 8 行初始化猫的名字字段，忽略颜色字段。</li>
<li>第 12 行定义用颜色构造猫结构的函数，返回 Cat 指针。</li>
</ul>
<p>在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。</p>
<h3 id="带有父子关系的结构体的构造和初始化——模拟父级构造调用"><a href="#带有父子关系的结构体的构造和初始化——模拟父级构造调用" class="headerlink" title="带有父子关系的结构体的构造和初始化——模拟父级构造调用"></a>带有父子关系的结构体的构造和初始化——模拟父级构造调用</h3><p>黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type BlackCat struct {</span><br><span class="line">    Cat  // 嵌入Cat, 类似于派生</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造基类”</span><br><span class="line">func NewCat(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造子类”</span><br><span class="line">func NewBlackCat(color string) *BlackCat {</span><br><span class="line">    cat := &amp;BlackCat{}</span><br><span class="line">    cat.Color = color</span><br><span class="line">    return cat</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。</li>
<li>第 11 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。</li>
<li>第 18 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。</li>
<li>第 19 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。</li>
<li>第 20 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。</li>
</ul>
<p>这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。</p>
<p>总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。</p>
<h2 id="方法和接收器"><a href="#方法和接收器" class="headerlink" title="方法和接收器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/69.html">方法和接收器</a></h2><p>在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。</p>
<p>接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误 <code>invalid receiver type…</code> 。</p>
<p>接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。</p>
<p>类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。</p>
<p><strong><em>提示:在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</em></strong></p>
<h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><p>本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。</p>
<p>1)面向过程实现方法<br>面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将一个物品放入背包的过程</span><br><span class="line">func Insert(b *Bag, itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    bag := new(Bag)</span><br><span class="line"></span><br><span class="line">    Insert(bag, 1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。</li>
<li>第 6 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。</li>
<li>第 7 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。</li>
<li>第 12 行，创建背包实例 bag。</li>
<li>第 14 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。</li>
</ul>
<p>Insert() 函数将 <code>*Bag</code> 参数放在第一位，强调 Insert 会操作 <code>*Bag</code> 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p>
<p>2)Go语言的结构体方法</p>
<p>将背包及放入背包的物品中使用Go语言的结构体和方法方式编写，为 <code>*Bag</code> 创建一个方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (b *Bag) Insert(itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    b := new(Bag)</span><br><span class="line"></span><br><span class="line">    b.Insert(1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 5 行中，<code>Insert(itemid int)</code> 的写法与函数一致，<code>(b *Bag)</code> 表示接收器，即 Insert 作用的对象实例。</p>
<p>每个方法只能有一个接收器，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goreceiver.jpg" alt="图：接收器"></p>
<p>第 13 行中，在 Insert() 转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用 b 的 Insert。</p>
<h3 id="接收器——方法作用的目标"><a href="#接收器——方法作用的目标" class="headerlink" title="接收器——方法作用的目标"></a>接收器——方法作用的目标</h3><p>接收器的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各部分的说明：</p>
<ul>
<li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li>
<li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：格式与函数定义一致。</li>
</ul>
<p>接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p>
<p>1)理解指针类型的接收器</p>
<p>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。</p>
<p>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p>
<p>在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义属性结构</span><br><span class="line">type Property struct {</span><br><span class="line">    value int  // 属性值</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置属性值</span><br><span class="line">func (p *Property) SetValue(v int) {</span><br><span class="line"></span><br><span class="line">    // 修改p的成员变量</span><br><span class="line">    p.value = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 取属性值</span><br><span class="line">func (p *Property) Value() int {</span><br><span class="line">    return p.value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化属性</span><br><span class="line">    p := new(Property)</span><br><span class="line"></span><br><span class="line">    // 设置值</span><br><span class="line">    p.SetValue(100)</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(p.Value())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，定义一个属性结构，拥有一个整型的成员变量。</li>
<li>第 11 行，定义属性值的方法。</li>
<li>第 14 行，设置属性值方法的接收器类型为指针，因此可以修改成员值，即便退出方法，也有效。</li>
<li>第 18 行，定义获取值的方法。</li>
<li>第 25 行，实例化属性结构。</li>
<li>第 28 行，设置值，此时成员变量变为 100。</li>
<li>第 31 行，获取成员变量。</li>
</ul>
<p>2)理解非指针类型的接收器</p>
<p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p>
<p>点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义点结构</span><br><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 非指针接收器的加方法</span><br><span class="line">func (p Point) Add(other Point) Point {</span><br><span class="line"></span><br><span class="line">    // 成员值与参数相加后返回新的结构</span><br><span class="line">    return Point{p.X + other.X, p.Y + other.Y}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 初始化点</span><br><span class="line">    p1 := Point{1, 1}</span><br><span class="line">    p2 := Point{2, 2}</span><br><span class="line"></span><br><span class="line">    // 与另外一个点相加</span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    fmt.Println(result)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{3 3}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义一个点结构，拥有 X 和 Y 两个整型分量。</li>
<li>第 14 行，为 Point 结构定义一个 Add() 方法，传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如P4 := P1.Add( P2 ).Add( P3 )</li>
<li>第 23 和 24 行，初始化两个点 p1 和 p2。</li>
<li>第 27 行，将 p1 和 p2 相加后返回结果。</li>
<li>第 30 行，打印结果。</li>
</ul>
<p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改。</p>
<p>3)指针和非指针接收器的使用</p>
<p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p>
<h3 id="示例：二维矢量模拟玩家移动"><a href="#示例：二维矢量模拟玩家移动" class="headerlink" title="示例：二维矢量模拟玩家移动"></a>示例：二维矢量模拟玩家移动</h3><p>在游戏中，一般使用二维矢量保存玩家的位置，使用矢量运算可以计算出玩家移动的位置，本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。</p>
<p>1)实现二维矢量结构</p>
<p>矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算，在计算机中，使用拥有 X 和 Y 两个分量的 Vec2 结构体实现数学中二维向量的概念，详细实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "math"</span><br><span class="line"></span><br><span class="line">type Vec2 struct {</span><br><span class="line">    X, Y float32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 加</span><br><span class="line">func (v Vec2) Add(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X + other.X,</span><br><span class="line">        v.Y + other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 减</span><br><span class="line">func (v Vec2) Sub(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X - other.X,</span><br><span class="line">        v.Y - other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 乘</span><br><span class="line">func (v Vec2) Scale(s float32) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{v.X * s, v.Y * s}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 距离</span><br><span class="line">func (v Vec2) DistanceTo(other Vec2) float32 {</span><br><span class="line">    dx := v.X - other.X</span><br><span class="line">    dy := v.Y - other.Y</span><br><span class="line"></span><br><span class="line">    return float32(math.Sqrt(float64(dx*dx + dy*dy)))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 插值</span><br><span class="line">func (v Vec2) Normalize() Vec2 {</span><br><span class="line">    mag := v.X*v.X + v.Y*v.Y</span><br><span class="line">    if mag &gt; 0 {</span><br><span class="line">        oneOverMag := 1 / float32(math.Sqrt(float64(mag)))</span><br><span class="line">        return Vec2{v.X * oneOverMag, v.Y * oneOverMag}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return Vec2{0, 0}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行声明了一个 Vec2 结构体，包含两个方向的单精度浮点数作为成员。</li>
<li>第 10～16 行定义了 Vec2 的 Add() 方法，使用自身 Vec2 和通过 Add() 方法传入的 Vec2 进行相加，相加后，结果以返回值形式返回，不会修改 Vec2 的成员。</li>
<li>第 20 行定义了 Vec2 的减法操作。</li>
<li>第 29 行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale() 方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。</li>
<li>第 35 行定义了计算两个矢量的距离，math.Sqrt() 是开方函数，参数是 float64，在使用时需要转换，返回值也是 float64，需要转换回 float32。</li>
<li>第 43 行定义矢量单位化。</li>
</ul>
<p>2)实现玩家对象</p>
<p>玩家对象负责存储玩家的当前位置、目标位置和速度，使用 MoveTo() 方法为玩家设定移动的目标，使用 Update() 方法更新玩家位置，在 Update() 方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。</p>
<p>① 使用矢量减法，将目标位置（targetPos）减去当前位置（currPos）即可计算出位于两个位置之间的新矢量，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/targetpos.jpg" alt="图：计算玩家方向矢量"></p>
<p>② 使用 Normalize() 方法将方向矢量变为模为 1 的单位化矢量，这里需要将矢量单位化后才能进行后续计算，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/normalize.jpg" alt="图：单位化方向矢量"></p>
<p>③ 获得方向后，将单位化方向矢量根据速度进行等比缩放，速度越快，速度数值越大，乘上方向后生成的矢量就越长（模很大），如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/scale.jpg" alt="图：根据速度缩放方向"></p>
<p>④ 将缩放后的方向添加到当前位置后形成新的位置，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/addpost.jpg" alt="图：缩放后的方向叠加位置形成新位置"></p>
<p>下面是玩家对象的具体代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Player struct {</span><br><span class="line">    currPos   Vec2    // 当前位置</span><br><span class="line">    targetPos Vec2    // 目标位置</span><br><span class="line">    speed     float32 // 移动速度</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 移动到某个点就是设置目标位置</span><br><span class="line">func (p *Player) MoveTo(v Vec2) {</span><br><span class="line"></span><br><span class="line">    p.targetPos = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取当前的位置</span><br><span class="line">func (p *Player) Pos() Vec2 {</span><br><span class="line">    return p.currPos</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 是否到达</span><br><span class="line">func (p *Player) IsArrived() bool {</span><br><span class="line"></span><br><span class="line">    // 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点</span><br><span class="line">    return p.currPos.DistanceTo(p.targetPos) &lt; p.speed</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 逻辑更新</span><br><span class="line">func (p *Player) Update() {</span><br><span class="line">    if !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 计算出当前位置指向目标的朝向</span><br><span class="line">        dir := p.targetPos.Sub(p.currPos).Normalize()</span><br><span class="line"></span><br><span class="line">        // 添加速度矢量生成新的位置</span><br><span class="line">        newPos := p.currPos.Add(dir.Scale(p.speed))</span><br><span class="line"></span><br><span class="line">        // 移动完成后，更新当前位置</span><br><span class="line">        p.currPos = newPos</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建新玩家</span><br><span class="line">func NewPlayer(speed float32) *Player {</span><br><span class="line"></span><br><span class="line">    return &amp;Player{</span><br><span class="line">        speed: speed,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，结构体 Player 定义了一个玩家的基本属性和方法，结构体的 currPos 表示当前位置，speed 表示速度。</li>
<li>第 10 行，定义玩家的移动方法，逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由 Update() 方法负责。</li>
<li>第 16 行，使用 Pos 方法实现玩家 currPos 的属性访问封装。</li>
<li>第 21 行，判断玩家是否到达目标点，玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。</li>
<li>第 28 行，玩家移动时位置更新的主要实现。</li>
<li>第 29 行，如果已经到达，则不必再更新。</li>
<li>第 32 行，数学中，两矢量相减将获得指向被减矢量的新矢量，Sub() 方法返回的新矢量使用 Normalize() 方法单位化，最终返回的 dir 矢量就是移动方向。</li>
<li>第 35 行，在当前的位置上叠加根据速度缩放的方向计算出新的位置 newPos。</li>
<li>第 38 行，将新位置更新到 currPos，为下一次移动做准备。</li>
<li>第 44 行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。</li>
</ul>
<p>3)处理移动逻辑</p>
<p>将 Player 实例化后，设定玩家移动的最终目标点，之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化玩家对象，并设速度为0.5</span><br><span class="line">    p := NewPlayer(0.5)</span><br><span class="line"></span><br><span class="line">    // 让玩家移动到3,1点</span><br><span class="line">    p.MoveTo(Vec2{3, 1})</span><br><span class="line"></span><br><span class="line">    // 如果没有到达就一直循环</span><br><span class="line">    for !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 更新玩家位置</span><br><span class="line">        p.Update()</span><br><span class="line"></span><br><span class="line">        // 打印每次移动后的玩家位置</span><br><span class="line">        fmt.Println(p.Pos())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 NewPlayer() 函数构造一个 <code>*Player</code> 玩家对象，并设移动速度为 <code>0.5</code> ，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。</li>
<li>第 11 行，设定玩家移动的最终目标为 X 为 3，Y 为 1。</li>
<li>第 14 行，构造一个循环，条件是没有到达时一直循环。</li>
<li>第 17 行，不停地更新玩家位置，如果玩家到达目标，p.IsArrived 将会变为 true。</li>
<li>第 20 行，打印每次更新后玩家的位置。</li>
</ul>
<p>本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。</p>
<h2 id="为任意类型添加方法"><a href="#为任意类型添加方法" class="headerlink" title="为任意类型添加方法"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/70.html">为任意类型添加方法</a></h2><p>Go语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。</p>
<h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if  v == 0 {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if  v.IsZero() {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为基本类型添加方法的详细实现流程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将int定义为MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">// 为MyInt添加IsZero()方法</span><br><span class="line">func (m MyInt) IsZero() bool {</span><br><span class="line">    return m == 0</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为MyInt添加Add()方法</span><br><span class="line">func (m MyInt) Add(other int) int {</span><br><span class="line">    return other + int(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.IsZero())</span><br><span class="line"></span><br><span class="line">    b = 1</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.Add(2))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">true</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 type MyInt int 将 int 定义为自定义的 MyInt 类型。</li>
<li>第 11 行，为 MyInt 类型添加 IsZero() 方法，该方法使用了 (m MyInt) 的非指针接收器，数值类型没有必要使用指针接收器。</li>
<li>第 16 行，为 MyInt 类型添加 Add() 方法。</li>
<li>第 17 行，由于 m 的类型是 MyInt 类型，但其本身是 int 类型，因此可以将 m 从 MyInt 类型转换为 int 类型再进行计算。</li>
<li>第 24 行，调用 b 的 IsZero() 方法，由于使用非指针接收器，b的值会被复制进入 IsZero() 方法进行判断。</li>
<li>第 28 行，调用 b 的 Add() 方法，同样也是非指针接收器，结果直接通过 Add() 方法返回。</li>
</ul>
<h3 id="http包中的类型方法"><a href="#http包中的类型方法" class="headerlink" title="http包中的类型方法"></a>http包中的类型方法</h3><p>Go语言提供的 http 包里也大量使用了类型方法，Go语言使用 http 包进行 HTTP 的请求，使用 http 包的 NewRequest() 方法可以创建一个 HTTP 请求，填充请求中的 http 头（req.Header），再调用 http.Client 的 Do 方法，将传入的 HTTP 请求发送出去。</p>
<p>下面代码演示创建一个 HTTP 请求，并且设定 HTTP 头。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "net/http"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    client := &amp;http.Client{}</span><br><span class="line"></span><br><span class="line">    // 创建一个http请求</span><br><span class="line">    req, err := http.NewRequest("POST", "http://www.163.com/", strings.NewReader("key=value"))</span><br><span class="line"></span><br><span class="line">    // 发现错误就打印并退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 为请求头添加信息</span><br><span class="line">    req.Header.Add("User-Agent", "myClient")</span><br><span class="line"></span><br><span class="line">    // 开始请求</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line">    // 处理请求的错误</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(string(data))</span><br><span class="line"></span><br><span class="line">    defer resp.Body.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;405 Not Allowed&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor="white"&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;405 Not Allowed&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，实例化 HTTP 的客户端，请求需要通过这个客户端实例发送。</li>
<li>第 14 行，使用 POST 方式向网易的服务器创建一个 HTTP 请求，第三个参数为 HTTP 的 Body 部分，Body 部分的内容来自字符串，但参数只能接受 io.Reader 类型，因此使用 strings.NewReader() 创建一个字符串的读取器，返回的 io.Reader 接口作为 http 的 Body 部分供 NewRequest() 函数读取，创建请求只是构造一个请求对象，不会连接网络。</li>
<li>第 24 行，为创建好的 HTTP 请求的头部添加 User-Agent，作用是表明用户的代理特性。</li>
<li>第 27 行，使用客户端处理请求，此时 client 将 HTTP 请求发送到网易服务器，服务器响应请求后，将信息返回并保存到 resp 变量中。</li>
<li>第 37 行，读取响应的 Body 部分并打印。</li>
</ul>
<p>由于我们构造的请求不是网易服务器所支持的类型，所以服务器返回操作不被运行的 405 错误。</p>
<p>在本例子第 24 行中使用的 req.Header 的类型为 http.Header，就是典型的自定义类型，并且拥有自己的方法，http.Header 的部分定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Header map[string][]string</span><br><span class="line"></span><br><span class="line">func (h Header) Add(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (h Header) Set(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (h Header) Get(key string) string {</span><br><span class="line">    return textproto.MIMEHeader(h).Get(key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，Header 实际是一个以字符串为键、字符串切片为值的映射。</li>
<li>第 3 行，Add() 为 Header 的方法，map 是一个引用类型，因此即便使用 (h Header) 的非指针接收器，也可以修改 map 的值。</li>
</ul>
<p>为类型添加方法的过程是一个语言层特性，使用类型方法的代码经过编译器编译后的代码运行效率与传统的面向过程或面向对象的代码没有任何区别，因此，为了代码便于理解，可以在编码时使用Go语言的类型方法特性。</p>
<h3 id="time-包中的类型方法"><a href="#time-包中的类型方法" class="headerlink" title="time 包中的类型方法"></a>time 包中的类型方法</h3><p>Go语言提供的 time 包主要用于时间的获取和计算等，在这个包中，也使用了类型方法，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(time.Second.String())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 9 行的 time.Second 是一个常量，下面代码的加粗部分就是 time.Second 的定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond  = 1000 * Nanosecond</span><br><span class="line">    Millisecond  = 1000 * Microsecond</span><br><span class="line">    Second       = 1000 * Millisecond</span><br><span class="line">    Minute       = 60 * Second</span><br><span class="line">    Hour         = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Second 的类型为 Duration，而 Duration 实际是一个 int64 的类型，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></tbody></table></figure>
<p>它拥有一个 String 的方法，部分定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (d Duration) String() string {</span><br><span class="line">    // 一系列生成buf的代码</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    return string(buf[w:])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Duration.String 可以将 Duration 的值转为字符串。</p>
<h2 id="使用事件系统实现事件的响应和处理"><a href="#使用事件系统实现事件的响应和处理" class="headerlink" title="使用事件系统实现事件的响应和处理"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/71.html">使用事件系统实现事件的响应和处理</a></h2><p>Go语言可以将类型的方法与普通函数视为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。这个特性和 C# 中的代理（delegate）类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数或类型的方法。</p>
<p>本节中，首先将用简单的例子了解Go语言是如何将方法与函数视为一个概念，接着会实现一个事件系统，事件系统能有效地将事件触发与响应两端代码解耦。</p>
<h3 id="方法和函数的统一调用"><a href="#方法和函数的统一调用" class="headerlink" title="方法和函数的统一调用"></a>方法和函数的统一调用</h3><p>本节的例子将让一个结构体的方法（class.Do）的参数和一个普通函数（funcDo）的参数完全一致，也就是方法与函数的签名一致。然后使用与它们签名一致的函数变量（delegate）分别赋值方法与函数，接着调用它们，观察实际效果。</p>
<p>详细实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明一个结构体</span><br><span class="line">type class struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 给结构体添加Do方法</span><br><span class="line">func (c *class) Do(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call method do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 普通函数的Do</span><br><span class="line">func funcDo(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call function do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个函数回调</span><br><span class="line">    var delegate func(int)</span><br><span class="line"></span><br><span class="line">    // 创建结构体实例</span><br><span class="line">    c := new(class)</span><br><span class="line"></span><br><span class="line">    // 将回调设为c的Do方法</span><br><span class="line">    delegate = c.Do</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line"></span><br><span class="line">    // 将回调设为普通函数</span><br><span class="line">    delegate = funcDo</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，为结构体添加一个 Do() 方法，参数为整型。这个方法的功能是打印提示和输入的参数值。</li>
<li>第 16 行，声明一个普通函数，参数也是整型，功能是打印提示和输入的参数值。</li>
<li>第 24 行，声明一个 delegate 的变量，类型为 <code>func(int)</code> ，与 funcDo 和 class 的 Do() 方法的参数一致。</li>
<li>第 30 行，将 c.Do 作为值赋给 delegate 变量。</li>
<li>第 33 行，调用 delegate() 函数，传入 100 的参数。此时会调用 c 实例的 Do() 方法。</li>
<li>第 36 行，将 funcDo 赋值给 delegate。</li>
<li>第 39 行，调用 delegate()，传入 100 的参数。此时会调用 funcDo() 方法。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">call method do: 100</span><br><span class="line">call function do: 100</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码能运行的基础在于：无论是普通函数还是结构体的方法，只要它们的签名一致，与它们签名一致的函数变量就可以保存普通函数或是结构体方法。</p>
<p>了解了Go语言的这一特性后，我们就可以将这个特性用在事件中。</p>
<h3 id="事件系统基本原理"><a href="#事件系统基本原理" class="headerlink" title="事件系统基本原理"></a>事件系统基本原理</h3><p>事件系统可以将事件派发者与事件处理者解耦。例如，网络底层可以生成各种事件，在网络连接上后，网络底层只需将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。或者再比如，你注册、关注或者订阅某“大V”的社交消息后，“大V”发生的任何事件都会通知你，但他并不用了解粉丝们是如何为她喝彩或者疯狂的。如下图所示为事件系统基本原理图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goeventbus.jpg" alt="图：事件系统基本原理"></p>
<p>一个事件系统拥有如下特性：</p>
<ul>
<li>能够实现事件的一方，可以根据事件 ID 或名字注册对应的事件。</li>
<li>事件发起者，会根据注册信息通知这些注册者。</li>
<li>一个事件可以有多个实现方响应。</li>
</ul>
<p>通过下面的步骤详细了解事件系统的构成及使用。</p>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>事件系统需要为外部提供一个注册入口。这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来，详细实现请参考下面代码的 RegisterEvent() 函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 实例化一个通过字符串映射函数切片的map</span><br><span class="line">var eventByName = make(map[string][]func(interface{}))</span><br><span class="line"></span><br><span class="line">// 注册事件，提供事件名和回调函数</span><br><span class="line">func RegisterEvent(name string, callback func(interface{})) {</span><br><span class="line"></span><br><span class="line">    // 通过名字查找事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 在列表切片中添加函数</span><br><span class="line">    list = append(list, callback)</span><br><span class="line"></span><br><span class="line">    // 将修改的事件列表切片保存回去</span><br><span class="line">    eventByName[name] = list</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用事件</span><br><span class="line">func CallEvent(name string, param interface{}) {</span><br><span class="line"></span><br><span class="line">    // 通过名字找到事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 遍历这个事件的所有回调</span><br><span class="line">    for _, callback := range list {</span><br><span class="line"></span><br><span class="line">        // 传入参数调用回调</span><br><span class="line">        callback(param)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，创建一个 map 实例，这个 map 通过事件名（string）关联回调列表 <code>（[]func(interface{}）</code> ，同一个事件名称可能存在多个事件回调，因此使用回调列表保存。回调的函数声明为 <code>func(interface{})</code> 。</li>
<li>第 7 行，提供给外部的通过事件名注册响应函数的入口。</li>
<li>第 10 行，eventByName 通过事件名（name）进行查询，返回回调列表 <code>（[]func(interface{}）</code>。</li>
<li>第 13 行，为同一个事件名称在已经注册的事件回调的列表中再添加一个回调函数。</li>
<li>第 16 行，将修改后的函数列表设置到 map 的对应事件名中。</li>
</ul>
<p>拥有事件名和事件回调函数列表的关联关系后，就需要开始准备事件调用的入口了。</p>
<h3 id="事件调用"><a href="#事件调用" class="headerlink" title="事件调用"></a>事件调用</h3><p>事件调用方和注册方是事件处理中完全不同的两个角色。事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理；事件注册方通过事件系统注册应该响应哪些事件及如何使用回调函数处理这些事件。事件调用的详细实现请参考上面代码的 CallEvent() 函数。</p>
<p>代码说明如下：</p>
<ul>
<li>第 20 行，调用事件的入口，提供事件名称 name 和参数 param。事件的参数表示描述事件具体的细节，例如门打开的事件触发时，参数可以传入谁进来了。</li>
<li>第 23 行，通过注册事件回调的 eventByName 和事件名字查询处理函数列表 list。</li>
<li>第 26 行，遍历这个事件列表，如果没有找到对应的事件，list 将是一个空切片。</li>
<li>第 29 行，将每个函数回调传入事件参数并调用，就会触发事件实现方的逻辑处理。</li>
</ul>
<h3 id="使用事件系统"><a href="#使用事件系统" class="headerlink" title="使用事件系统"></a>使用事件系统</h3><p>例子中，在 main() 函数中调用事件系统的 CallEvent 生成 OnSkill 事件，这个事件有两个处理函数，一个是角色的 OnEvent() 方法，还有一个是函数 GlobalEvent()，详细代码实现过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明角色的结构体</span><br><span class="line">type Actor struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为角色添加一个事件处理函数</span><br><span class="line">func (a *Actor) OnEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("actor event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 全局事件</span><br><span class="line">func GlobalEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("global event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个角色</span><br><span class="line">    a := new(Actor)</span><br><span class="line"></span><br><span class="line">    // 注册名为OnSkill的回调</span><br><span class="line">    RegisterEvent("OnSkill", a.OnEvent)</span><br><span class="line"></span><br><span class="line">    // 再次在OnSkill上注册全局事件</span><br><span class="line">    RegisterEvent("OnSkill", GlobalEvent)</span><br><span class="line">    // 调用事件，所有注册的同名函数都会被调用</span><br><span class="line">    CallEvent("OnSkill", 100)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明一个角色的结构体。在游戏中，角色是常见的对象，本例中，角色也是 OnSkill 事件的响应处理方。</li>
<li>第 10 行，为角色结构添加一个 OnEvent() 方法，这个方法拥有 param 参数，类型为 interface{}，与事件系统的函数（func(interface{})）签名一致。</li>
<li>第 16 行为全局事件响应函数。有时需要全局进行侦听或者处理一些事件，这里使用普通函数实现全局事件的处理。</li>
<li>第 27 行，注册一个 OnSkill 事件，实现代码由 a 的 OnEvent 进行处理。也就是 Actor的OnEvent() 方法。</li>
<li>第 30 行，注册一个 OnSkill 事件，实现代码由 GlobalEvent 进行处理，虽然注册的是同一个名字的事件，但前面注册的事件不会被覆盖，而是被添加到事件系统中，关联 OnSkill 事件的函数列表中。</li>
<li>第 33 行，模拟处理事件，通过 CallEvent() 函数传入两个参数，第一个为事件名，第二个为处理函数的参数。</li>
</ul>
<p>整个例子运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">actor event: 100</span><br><span class="line">global event: 100</span><br></pre></td></tr></tbody></table></figure>
<p>结果演示，角色和全局的事件会按注册顺序顺序地触发。</p>
<p>一般来说，事件系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统认为所有实现函数都是平等的。也就是说，无论例子中的 a.OnEvent 先注册，还是 GlobalEvent() 函数先注册，最终谁先被调用，都是无所谓的，开发者不应该去关注和要求保证调用的顺序。</p>
<p>一个完善的事件系统还会提供移除单个和所有事件的方法。</p>
<h2 id="类型内嵌和结构体内嵌"><a href="#类型内嵌和结构体内嵌" class="headerlink" title="类型内嵌和结构体内嵌"></a>类型内嵌和结构体内嵌</h2><p>结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。</p>
<p>可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go语言中的继承是通过内嵌或组合来实现的，所以可以说，在Go语言中，相比较于继承，组合更受青睐。</p>
<p>考虑如下的程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type innerS struct {</span><br><span class="line">    in1 int</span><br><span class="line">    in2 int</span><br><span class="line">}</span><br><span class="line">type outerS struct {</span><br><span class="line">    b int</span><br><span class="line">    c float32</span><br><span class="line">    int // anonymous field</span><br><span class="line">    innerS //anonymous field</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    outer := new(outerS)</span><br><span class="line">    outer.b = 6</span><br><span class="line">    outer.c = 7.5</span><br><span class="line">    outer.int = 60</span><br><span class="line">    outer.in1 = 5</span><br><span class="line">    outer.in2 = 10</span><br><span class="line">    fmt.Printf("outer.b is: %d\n", outer.b)</span><br><span class="line">    fmt.Printf("outer.c is: %f\n", outer.c)</span><br><span class="line">    fmt.Printf("outer.int is: %d\n", outer.int)</span><br><span class="line">    fmt.Printf("outer.in1 is: %d\n", outer.in1)</span><br><span class="line">    fmt.Printf("outer.in2 is: %d\n", outer.in2)</span><br><span class="line">    // 使用结构体字面量</span><br><span class="line">    outer2 := outerS{6, 7.5, 60, innerS{5, 10}}</span><br><span class="line">    fmt.Printf("outer2 is:", outer2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">outer.b is: 6</span><br><span class="line">outer.c is: 7.500000</span><br><span class="line">outer.int is: 60</span><br><span class="line">outer.in1 is: 5</span><br><span class="line">outer.in2 is: 10</span><br><span class="line">outer2 is:{6 7.5 60 {5 10}}</span><br></pre></td></tr></tbody></table></figure>
<p>通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。</p>
<h3 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h3><p>同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type A struct {</span><br><span class="line">    ax, ay int</span><br><span class="line">}</span><br><span class="line">type B struct {</span><br><span class="line">    A</span><br><span class="line">    bx, by float32</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    b := B{A{1, 2}, 3.0, 4.0}</span><br><span class="line">    fmt.Println(b.ax, b.ay, b.bx, b.by)</span><br><span class="line">    fmt.Println(b.A)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">{1 2}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go语言的结构体内嵌有如下特性。</p>
<p>1)内嵌的结构体可以直接访问其成员变量</p>
<p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p>
<p>2)内嵌结构体的字段名是它的类型名</p>
<p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var c Color</span><br><span class="line">c.BasicColor.R = 1</span><br><span class="line">c.BasicColor.G = 1</span><br><span class="line">c.BasicColor.B = 0</span><br></pre></td></tr></tbody></table></figure>
<p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p>
<h2 id="结构体内嵌模拟类的继承"><a href="#结构体内嵌模拟类的继承" class="headerlink" title="结构体内嵌模拟类的继承"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/73.html">结构体内嵌模拟类的继承</a></h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p>
<p>面向对象的设计原则中也建议对象最好不要使用多重继承，有些面向对象语言从语言层面就禁止了多重继承，如 C# 和 Java 语言。鸟类同时继承自可行走类和飞行类，这显然是存在问题的。在面向对象思想中要正确地实现对象的多重特性，只能使用一些精巧的设计来补救。</p>
<p>Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p>
<p>下面的代码使用Go语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p>
<p>人和鸟的特性：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 可飞行的</span><br><span class="line">type Flying struct{}</span><br><span class="line"></span><br><span class="line">func (f *Flying) Fly() {</span><br><span class="line">    fmt.Println("can fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 可行走的</span><br><span class="line">type Walkable struct{}</span><br><span class="line"></span><br><span class="line">func (f *Walkable) Walk() {</span><br><span class="line">    fmt.Println("can calk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 人类</span><br><span class="line">type Human struct {</span><br><span class="line">    Walkable // 人类能行走</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 鸟类</span><br><span class="line">type Bird struct {</span><br><span class="line">    Walkable // 鸟类能行走</span><br><span class="line">    Flying   // 鸟类能飞行</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化鸟类</span><br><span class="line">    b := new(Bird)</span><br><span class="line">    fmt.Println("Bird: ")</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line"></span><br><span class="line">    // 实例化人类</span><br><span class="line">    h := new(Human)</span><br><span class="line">    fmt.Println("Human: ")</span><br><span class="line">    h.Walk()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明可飞行结构（Flying）。</li>
<li>第 8 行，为可飞行结构添加飞行方法 Fly()。</li>
<li>第 13 行，声明可行走结构（Walkable）。</li>
<li>第 15 行，为可行走结构添加行走方法 Walk()。</li>
<li>第 20 行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备“可行走”特性</li>
<li>第 25 行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。</li>
<li>第 33 行，实例化鸟类结构。</li>
<li>第 35 和 36 行，调用鸟类可以使用的功能，如飞行和行走。</li>
<li>第 39 行，实例化人类结构。</li>
<li>第 41 行，调用人类能使用的功能，如行走。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></tbody></table></figure>
<p>使用Go语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go语言会在编译时检查能否使用这些特性。</p>
<h2 id="初始化内嵌结构体"><a href="#初始化内嵌结构体" class="headerlink" title="初始化内嵌结构体"></a>初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p>
<p>车辆结构的组装和初始化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 引擎</span><br><span class="line">type Engine struct {</span><br><span class="line">    Power int    // 功率</span><br><span class="line">    Type  string // 类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: Engine{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行定义车轮结构。</li>
<li>第 11 行定义引擎结构。</li>
<li>第 17 行定义车结构，由车轮和引擎结构体嵌入。</li>
<li>第 27 行，将 Car 的 Wheel 字段使用 Wheel 结构体进行初始化。</li>
<li>第 32 行，将 Car 的 Engine 字段使用 Engine 结构体进行初始化。</li>
</ul>
<h3 id="初始化内嵌匿名结构体"><a href="#初始化内嵌匿名结构体" class="headerlink" title="初始化内嵌匿名结构体"></a>初始化内嵌匿名结构体</h3><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    // 引擎</span><br><span class="line">    Engine struct {</span><br><span class="line">        Power int    // 功率</span><br><span class="line">        Type  string // 类型</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: struct {</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        }{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 14 行中原来的 Engine 结构体被直接定义在 Car 的结构体中。这种嵌入的写法就是将原来的结构体类型转换为 <code>struct{…}</code> 。</li>
<li>第 30 行，需要对 Car 的 Engine 字段进行初始化，由于 Engine 字段的类型并没有被单独定义，因此在初始化其字段时需要先填写 <code>struct{…}</code> 声明其类型。</li>
<li>第 34 行开始填充这个匿名结构体的数据，按“键：值”格式填充。</li>
</ul>
<h2 id="内嵌结构体成员名字冲突"><a href="#内嵌结构体成员名字冲突" class="headerlink" title="内嵌结构体成员名字冲突"></a>内嵌结构体成员名字冲突</h2><p>嵌入结构体内部可能拥有相同的成员名，成员重名时会发生什么？下面通过例子来讲解。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type A struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type B struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type C struct {</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.A.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行和第 11 行分别定义了两个拥有 <code>a int</code> 字段的结构体。</li>
<li>第 15 行的结构体嵌入了 A 和 B 的结构体。</li>
<li>第 21 行实例化 C 结构体。</li>
<li>第 22 行按常规的方法，访问嵌入结构体 A 中的 a 字段，并赋值 1。</li>
<li>第 23 行可以正常输出实例化 C 结构体。</li>
</ul>
<p>接着，将第 22 行修改为如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时再编译运行，编译器报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.\main.go:22:3: ambiguous selector c.a</span><br></pre></td></tr></tbody></table></figure>
<p>编译器告知 C 的选择器 a 引起歧义，也就是说，编译器无法决定将 1 赋给 C 中的 A 还是 B 里的字段 a。</p>
<p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p>
<h2 id="使用匿名结构体解析JSON数据"><a href="#使用匿名结构体解析JSON数据" class="headerlink" title="使用匿名结构体解析JSON数据"></a>使用匿名结构体解析JSON数据</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。XML、ASN.1和Google的ProtocolBuffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>
<p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的 <code>encoding/json</code> 、<code>encoding/xml</code> 、<code>encoding/asn1</code> 等包提供支持，并且这类包都有着相似的API接口。</p>
<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的 <code>Unicode</code> 字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是 <code>Uhhhh</code> 转义数字来表示一个UTF-16编码，而不是Go语言的rune类型。</p>
<p>手机拥有屏幕、电池、指纹识别等信息，将这些信息填充为JSON格式的数据。如果需要选择性地分离JSON中的数据则较为麻烦。Go语言中的匿名结构体可以方便地完成这个操作。</p>
<p>首先给出完整的代码，然后再讲解每个部分。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p>首先，定义手机的各种数据结构体，如屏幕和电池，参考如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码定义了屏幕结构体和电池结构体，它们分别描述屏幕和电池的各种细节参数。</p>
<h3 id="准备JSON数据"><a href="#准备JSON数据" class="headerlink" title="准备JSON数据"></a>准备JSON数据</h3><p>准备手机数据结构，填充数据，将数据序列化为JSON格式的字节数组，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行定义了一个匿名结构体。这个结构体内嵌了Screen和Battery结构体，同时临时加入了HasTouchID字段。</li>
<li>第10行，为刚声明的匿名结构体填充屏幕数据。</li>
<li>第17行，填充电池数据。</li>
<li>第22行，填充指纹识别字段。</li>
<li>第26行，使用json.Marshal进行JSON序列化，将raw变量序列化为[]byte格式的JSON数据。</li>
</ul>
<h3 id="分离JSON数据"><a href="#分离JSON数据" class="headerlink" title="分离JSON数据"></a>分离JSON数据</h3><p>调用genJsonData获得JSON数据，将需要的字段填充到匿名结构体实例中，通过json.Unmarshal反序列化JSON数据达成分离JSON数据效果。代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，调用genJsonData()函数，获得[]byte类型的JSON数据。</li>
<li>第6行，将jsonData的[]byte类型的JSON数据转换为字符串格式并打印输出。</li>
<li>第9行，构造匿名结构体，填充Screen结构和HasTouchID字段，第12行中的 <code>{}</code> 表示将结构体实例化。</li>
<li>第15行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第9行定义的结构体格式序列化到screenAndTouch中。</li>
<li>第18行，打印输出screenAndTouch中的详细数据信息。</li>
<li>第21行，构造匿名结构体，填充Battery结构和HasTouchID字段。</li>
<li>第27行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第21行定义的结构体格式序列化到batteryAndTouch中。</li>
<li>第30行，打印输出batteryAndTouch的详细数据信息。</li>
</ul>
<p>完整的代码执行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">{"Size":5.5,"ResX":1920,"ResY":1080,"Capacity":2910,"HasTouchID":true}</span><br><span class="line">{Screen:{Size:5.5 ResX:1920 ResY:1080} HasTouchID:true}</span><br><span class="line">{Battery:{Capacity:2910} HasTouchID:true}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="垃圾回收和SetFinalizer"><a href="#垃圾回收和SetFinalizer" class="headerlink" title="垃圾回收和SetFinalizer"></a>垃圾回收和SetFinalizer</h2><p>Go语言自带垃圾回收机制（GC）。GC 通过独立的进程执行，它会搜索不再使用的变量，并将其释放。需要注意的是，GC 在运行时会占用机器资源。</p>
<p>GC 是自动进行的，如果要手动进行 GC，可以使用 runtime.GC() 函数，显式的执行 GC。显式的进行 GC 只在某些特殊的情况下才有用，比如当内存资源不足时调用 runtime.GC() ，这样会立即释放一大片内存，但是会造成程序短时间的性能下降。</p>
<p>finalizer（终止器）是与对象关联的一个函数，通过 runtime.SetFinalizer 来设置，如果某个对象定义了 finalizer，当它被 GC 时候，这个 finalizer 就会被调用，以完成一些特定的任务，例如发信号或者写日志等。</p>
<p>在Go语言中 SetFinalizer 函数是这样定义的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func SetFinalizer(x, f interface{})</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明如下：</p>
<ul>
<li>参数 x 必须是一个指向通过 new 申请的对象的指针，或者通过对复合字面值取址得到的指针。</li>
<li>参数 f 必须是一个函数，它接受单个可以直接用 x 类型值赋值的参数，也可以有任意个被忽略的返回值。</li>
</ul>
<p>SetFinalizer 函数可以将 x 的终止器设置为 f，当垃圾收集器发现 x 不能再直接或间接访问时，它会清理 x 并调用 f(x)。</p>
<p>另外，x 的终止器会在 x 不能直接或间接访问后的任意时间被调用执行，不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个 os.File 对象时没有调用其 Close 方法，该 os.File 对象可以使用终止器去关闭对应的操作系统文件描述符。</p>
<p>终止器会按依赖顺序执行：如果 A 指向 B，两者都有终止器，且 A 和 B 没有其它关联，那么只有 A 的终止器执行完成，并且 A 被释放后，B 的终止器才可以执行。</p>
<p>如果 <code>*x</code> 的大小为 0 字节，也不保证终止器会执行。</p>
<p>此外，我们也可以使用 <code>SetFinalizer(x, nil)</code> 来清理绑定到 x 上的终止器。</p>
<p><strong><em>提示：终止器只有在对象被 GC 时，才会被执行。其他情况下，都不会被执行，即使程序正常结束或者发生错误。</em></strong></p>
<p>【示例】在函数 entry() 中定义局部变量并设置 finalizer，当函数 entry() 执行完成后，在 main 函数中手动触发 GC，查看 finalizer 的执行情况。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "runtime"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">type Road int</span><br><span class="line">func findRoad(r *Road) {</span><br><span class="line">    log.Println("road:", *r)</span><br><span class="line">}</span><br><span class="line">func entry() {</span><br><span class="line">    var rd Road = Road(999)</span><br><span class="line">    r := &amp;rd</span><br><span class="line">    runtime.SetFinalizer(r, findRoad)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    entry()</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        runtime.GC()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2020/10/21 17:47:28 road: 999</span><br></pre></td></tr></tbody></table></figure>
<h2 id="将结构体数据保存为JSON格式数据"><a href="#将结构体数据保存为JSON格式数据" class="headerlink" title="将结构体数据保存为JSON格式数据"></a>将结构体数据保存为JSON格式数据</h2><p>JSON格式是一种用途广泛的对象文本格式。在Go语言中，结构体可以通过系统提供的json.Marshal()函数进行序列化。为了演示怎样通过反射获取结构体成员及各种值的过程，下面使用反射将结构体序列化为文本数据。</p>
<h3 id="数据结构及入口函数"><a href="#数据结构及入口函数" class="headerlink" title="数据结构及入口函数"></a>数据结构及入口函数</h3><p>将结构体序列化为JSON的步骤如下：</p>
<ul>
<li>准备数据结构体。</li>
<li>准备要序列化的结构体数据。</li>
<li>调用序列化函数。</li>
</ul>
<p>具体代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //声明技能结构</span><br><span class="line">    type Skill struct {</span><br><span class="line">        Name string</span><br><span class="line">        Level int</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明角色结构</span><br><span class="line">    type Actor struct {</span><br><span class="line">        Name string</span><br><span class="line">        Age int</span><br><span class="line"></span><br><span class="line">        Skills []Skill</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //填充基本角色数据</span><br><span class="line">    a := Actor {</span><br><span class="line">        Name : "cowboy",</span><br><span class="line">        Age:37,</span><br><span class="line">        Skills:[]Skill {</span><br><span class="line">            {</span><br><span class="line">                Name:"Rollandroll",</span><br><span class="line">                Level:1</span><br><span class="line">            },{</span><br><span class="line">                Name:"Flashyourdogeye",</span><br><span class="line">                Level:2</span><br><span class="line">            },{</span><br><span class="line">                Name:"TimetohaveLunch",</span><br><span class="line">                Level:3</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if result , err := MarshalJson(a) ; err == nil {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4～15行声明了一些结构体，用于描述一个角色的信息。</li>
<li>第18～27行，实例化了Actor结构体，并且填充了一些基本的角色数据。</li>
<li>第35行，调用自己实现的MarshalJson()函数，将Actor实例化的数据转换为JSON字符串。</li>
<li>第36行，如果操作成功将打印出数据。</li>
<li>第38行，如果操作有错误将打印错误。</li>
</ul>
<p>完整代码输出如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{"Name":"cowboy","Age":37,"Skills":[{"Name":"Rollandroll","Level":1},{"Name":"Flashyourdogeye","Level":2},{"Name":"TimetohaveLunch","Level":3}]}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="序列化主函数"><a href="#序列化主函数" class="headerlink" title="序列化主函数"></a>序列化主函数</h4><p>MarshalJson()是序列化过程的主要函数入口，通过这个函数会调用不同类型的子序列化函数。MarshalJson()传入一个interface{}的数据，并将这个数据转换为JSON字符串返回，如果发生错误，则返回错误信息。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func MarshalJson(v interface{})(string,error){</span><br><span class="line"></span><br><span class="line">    //准备一个缓冲</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    //将任意值转换为json并输出到缓冲</span><br><span class="line">    if err:= writeAny(&amp;b , reflect.ValueOf(v)) ; err == nil {</span><br><span class="line">        return b.String() , nil</span><br><span class="line">    } else {</span><br><span class="line">        return "" , err</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，使用bytes.Buffer构建一个缓冲，这个对象类似于其他语言中的StringBuilder，在大量字符串连接时，推荐使用这个结构。</li>
<li>第7行，调用writeAny()函数，将bytes.Buffer以指针的方式传入，以方便将各种类型的数据都写入这个bytes.Buffer中。同时，将v转换为反射值对象并传入。</li>
<li>第8行，如果没有错误发生时，将bytes.Buffer的内容转换为字符串井返回。</li>
<li>第10行，发生错误时，远回空字符串结果和错误。</li>
</ul>
<p>MarshalJson()这个函数其实是对writeAny()函数的一个封装，将外部的interface{}类型转换为内部的reflect.Value类型，同时构建输出缓冲，将一些复杂的操作简化，方便外部使用。</p>
<h4 id="任意值序列化"><a href="#任意值序列化" class="headerlink" title="任意值序列化"></a>任意值序列化</h4><p>writeAny()函数传入一个字节缓冲和反射值对象，将反射值对象转换为JSON格式并写入字节缓冲中。</p>
<p>代码如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//将任意值转换为json并输出到缓冲</span><br><span class="line">func writeAny(buff *bytes.Buffer, value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    switch value.Kind() {</span><br><span class="line">        case reflect.String:</span><br><span class="line">            //写入带有双引号括起来的字符串</span><br><span class="line">            buff.WriteString(strconv.Quote(value.String()))</span><br><span class="line">        case reflect.Int:</span><br><span class="line">            //将整形转换为字符串并写入缓冲</span><br><span class="line">            buff.WriteString(strconv.FormatInt(value.Int(),10))</span><br><span class="line"></span><br><span class="line">        case reflect.Slice:</span><br><span class="line">            return writeSlice(buff,value)</span><br><span class="line"></span><br><span class="line">        case reflect.Struct:</span><br><span class="line">            return writeStruct(buff,value)</span><br><span class="line">        default:</span><br><span class="line">            //遇到不认识的种类，返回错误</span><br><span class="line">            return errors.New("unsupportkind:"+value.Kind().String())</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，根据传入反射值对象的种类进行判断，如字符串、整型、切片及结构体。</li>
<li>第7行，当传入值为字符串种类时，使用reflect.Value的String函数将传入值转换为字符串，再将字符串用双引号括起来，strconv.Quote()函数提供了比较正规的封装。最终使用bytes.Buffer的WriteString()函数，将前面输出的字符串写入缓冲中。</li>
<li>第10行，当传入值为整型时，使用reflect.Value的Int()函数，将传入值转换为整型，再将整型以十进制格式使用strconv.FormatInt()函数格式化为字符串，最后写入缓冲中。</li>
<li>第11行，使用writeSlice()函数把切片序列化为JSON操作。</li>
<li>第14行，使用writeStruct()函数把切片序列化为JSON操作。</li>
<li>第17行，遇到不能识别的类型，函数返回错误。</li>
</ul>
<p>writeAny()函数是整个序列化中非常重要的环节，可以通过扩充switch中的种类扩充序列化能识别的类型。</p>
<h4 id="切片序列化"><a href="#切片序列化" class="headerlink" title="切片序列化"></a>切片序列化</h4><p>writeAny()函数中会调用writeSlice()函数将切片类型转换为JSON格式的字符串并将数据写入缓冲中。代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//将切片转换为json并输出到缓冲</span><br><span class="line">func writeSlice(buff *bytes.Buffer,value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //写入切片开始标记</span><br><span class="line">    buff.WriteString("[")</span><br><span class="line"></span><br><span class="line">    //遍历每个切片元素</span><br><span class="line">    for s:=0 ; s &lt; value.Len() ; s++ {</span><br><span class="line">        sliceValue := value.Index(s)</span><br><span class="line"></span><br><span class="line">        //写入每个切片元素</span><br><span class="line">        writeAny(buff,sliceValue)</span><br><span class="line"></span><br><span class="line">        //写入每个元素尾部逗号，最后一个字段不添加</span><br><span class="line">        if s &lt; value.Len() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入切片结束标记</span><br><span class="line">    buff.WriteString("]")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行和第21行分别写入JSON数组的开始标识 <code>“[”</code> 和结束标识 <code>“]”</code> 。</li>
<li>第8行和第9行，使用reflect.Value的Len()方法和Index()方法遍历切片的所有元素。Len()方法返回切片的长度，Index()方法根据给定的索引找到对应的索引。</li>
<li>第12行，通过reflect.Value类型的Index方法获得reflect.Value类型的sliceValue，再将sliceValue传入writeAny()函数并继续对这个值进行递归序列化。</li>
<li>第15～17行，JSON格式规定：每个数组成员由逗号分隔且最后一个元素后不加逗号，这里就是遵守这个规定。</li>
<li>由于writeAny的功能较为完善，因此序列化切片只需要添加头尾标识符及元素分隔符就可以了。</li>
</ul>
<h4 id="结构体序列化"><a href="#结构体序列化" class="headerlink" title="结构体序列化"></a>结构体序列化</h4><p>在JSON格式中，切片是一系列值的序列，以方括号开头和结尾：结构体由键值对组成，以大括号开始和结束。两种结构的元素均以逗号分隔。序列化结构体的实现过程代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//将结构体序列化为json并输出到缓冲</span><br><span class="line">func writeStruct(buff *bytes.Buffer , value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //取值的类型对象</span><br><span class="line">    valueType := value.Type()</span><br><span class="line"></span><br><span class="line">    //写入结构体左大括号</span><br><span class="line">    buff.WriteString("{")</span><br><span class="line"></span><br><span class="line">    //遍历结构体的所有值</span><br><span class="line">    for i:=0 ; i &lt; value.NumField() ; i++ {</span><br><span class="line"></span><br><span class="line">        //获取每个字段的字段值(reflect.Value)</span><br><span class="line">        fieldValue := value.Field(i)</span><br><span class="line"></span><br><span class="line">        //获取每个字段的类型(reflect.StructField)</span><br><span class="line">        fieldType := valueType.Field(i)</span><br><span class="line"></span><br><span class="line">        //写入字段名左双引号</span><br><span class="line">        buff.WriteString(""")</span><br><span class="line"></span><br><span class="line">        //写入字段名</span><br><span class="line">        buff.WriteString(fieldType.Name)</span><br><span class="line"></span><br><span class="line">        //写入字段名右双引号和冒号</span><br><span class="line">        buff.WriteString("":")</span><br><span class="line"></span><br><span class="line">        //写入每个字段值</span><br><span class="line">        writeAny(buff,fieldValue)</span><br><span class="line"></span><br><span class="line">        //写入每个字段尾部逗号，最后一个字段不添加</span><br><span class="line">        if i &lt; value.NumField() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入结构体右大括号</span><br><span class="line">    buff.WriteString("}")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行，遍历结构体获取值时，习惯性取出反射类型对象。</li>
<li>第8行和第38行，分别写入结构体开头和结尾的标识符。</li>
<li>第11行，根据reflect.Value的NumField()方法遍历结构体的成员值。</li>
<li>第14行，获取每一个结构体成员的反射值对象。</li>
<li>第17行，获取每一个结构体成员的反射类型对象，类型信息必须从类型对象中获取，反射值对象无法提供字段的类型信息，如果尝试从fieldValue.Type()中获得类型对象，那么取到的是值本身的类型对象，而不是结构体成员类型信息。</li>
<li>第20行，写入字段左边的双引号，双引号本身需要使用“”进行转义，从这里开始写入键值对。</li>
<li>第23行，根据结构体成员类型信息写入宇段名。</li>
<li>第26行，写入字段名右边的双引号和冒号。</li>
<li>第29行，递归调用任意值序列化函数writeAny()，将fieldValue继续序列化。</li>
<li>第32行，和切片一样，多个结构体字段间也是以逗号分隔，最后一个字段后面不接逗号。</li>
</ul>
<h4 id="JSON总结"><a href="#JSON总结" class="headerlink" title="JSON总结"></a>JSON总结</h4><p>上面例子只支持整型、字符串、切片和结构体类型序列化为JSON格式。如果需要扩充类型，可以在writeAny()函数中添加。程序功能和结构上还有一些不足，例如：</p>
<ul>
<li>没有处理各种异常情况，切片或结构体为空时应该提前判断，否则会触发岩机。</li>
<li>可以支持结构体标签（StructTag），方便自定义JSON的键名及忽略某些字段的序列化过程，避免这些字段被序列化到JSON中。</li>
<li>支持缩进且可以自定义缩进字符，将JSON序列化后的内容格式化，方便查看。</li>
<li>默认应该序列化为[]byte字节数组，外部自己转换为字符串。在大部分的使用中，JSON一般以字节数组方式解析、存储、传输，很少以字符串方式解析，因此避免字节数组和字符串的转换可以提高一些性能。</li>
</ul>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以避免在使用数组时需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表允许插入和移除表上任意位置上的结点，但是不允许随机存取。链表有三种类型：单向链表、双向链表以及循环链表。</p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表中每个结点包含两部分，分别是数据域和指针域，上一个结点的指针指向下一结点，依次相连，形成链表。</p>
<p>这里介绍三个概念：首元结点、头结点和头指针。</p>
<ul>
<li>首元结点：就是链表中存储第一个元素的结点，如下图中 a1 的位置。</li>
<li>头结点：它是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以存储链表的长度或者其它的信息，也可以为空不存储任何信息。</li>
<li>头指针：它是指向链表中第一个结点的指针。若链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向首元结点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.gif" alt="图：单向链表"></p>
<p>头结点在链表中不是必须的，但增加头结点有以下几点好处：</p>
<ul>
<li>增加了头结点后，首元结点的地址保存在头结点的指针域中，对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。</li>
<li>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若链表为空的话，那么头结点的指针域为空。</li>
</ul>
<h3 id="使用-Struct-定义单链表"><a href="#使用-Struct-定义单链表" class="headerlink" title="使用 Struct 定义单链表"></a>使用 Struct 定义单链表</h3><p>利用 Struct 可以包容多种数据类型的特性，使用它作为链表的结点是最合适不过了。一个结构体内可以包含若干成员，这些成员可以是基本类型、自定义类型、数组类型，也可以是指针类型。这里可以使用指针类型成员来存放下一个结点的地址。</p>
<p>【示例 1】使用 Struct 定义一个单向链表。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Node struct {</span><br><span class="line">    Data  int</span><br><span class="line">    Next  *node</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中成员 Data 用来存放结点中的有用数据，Next 是指针类型的成员，它指向 Node struct 类型数据，也就是下一个结点的数据类型。</p>
<p>【示例 2】为链表赋值，并遍历链表中的每个结点。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data int</span><br><span class="line">    next *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node) { //遍历</span><br><span class="line">    for p != nil {</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p = p.next //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 1</span><br><span class="line">    var node1 = new(Node)</span><br><span class="line">    node1.data = 2</span><br><span class="line"></span><br><span class="line">    head.next = node1</span><br><span class="line">    var node2 = new(Node)</span><br><span class="line">    node2.data = 3</span><br><span class="line"></span><br><span class="line">    node1.next = node2</span><br><span class="line">    Shownode(head)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{1 0xc00004c1e0}</span><br><span class="line">{2 0xc00004c1f0}</span><br><span class="line">{3 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>单链表的结点插入方法一般使用头插法或者尾插法。</p>
<p>1)头插法</p>
<p>每次插入在链表的头部插入结点，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录头结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        node.next = tail   //将新插入的node的next指向头结点</span><br><span class="line">        tail = &amp;node      //重新赋值头结点</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(tail) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{9 0xc000036270}</span><br><span class="line">{8 0xc000036260}</span><br><span class="line">{7 0xc000036250}</span><br><span class="line">{6 0xc000036240}</span><br><span class="line">{5 0xc000036230}</span><br><span class="line">{4 0xc000036220}</span><br><span class="line">{3 0xc000036210}</span><br><span class="line">{2 0xc000036200}</span><br><span class="line">{1 0xc0000361f0}</span><br><span class="line">{0 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>2)尾插法</p>
<p>每次插入结点在尾部，这也是我们较为习惯的方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录最末尾的结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        (*tail).next = &amp;node</span><br><span class="line">        tail = &amp;node</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(head) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{0 0xc0000361f0}</span><br><span class="line">{1 0xc000036200}</span><br><span class="line">{2 0xc000036210}</span><br><span class="line">{3 0xc000036220}</span><br><span class="line">{4 0xc000036230}</span><br><span class="line">{5 0xc000036240}</span><br><span class="line">{6 0xc000036250}</span><br><span class="line">{7 0xc000036260}</span><br><span class="line">{8 0xc000036270}</span><br><span class="line">{9 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以速度较慢。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p>
<p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。</p>
<p>循环链表跟单链表唯一的区别就在尾结点。单向链表的尾结点指针指向空地址，表示这就是最后的结点了，而循环链表的尾结点指针是指向链表的头结点，它像一个环一样首尾相连，所以叫作“循环”链表，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/circlelinklist.gif" alt="图：循环链表"></p>
<p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题，尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.gif" alt="图：双向链表"></p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<h2 id="数据I-O对象及操作"><a href="#数据I-O对象及操作" class="headerlink" title="数据I/O对象及操作"></a>数据I/O对象及操作</h2><p>在Go语言中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。在实际开发过程中，无论是实现 web 应用程序，还是控制台输入输出，又或者是网络操作，都不可避免的会遇到 I/O 操作。</p>
<p>Go语言标准库的 bufio 包中，实现了对数据 I/O 接口的缓冲功能。这些功能封装于接口 io.ReadWriter、io.Reader 和 io.Writer 中，并对应创建了 ReadWriter、Reader 或 Writer 对象，在提供缓冲的同时实现了一些文本基本 I/O 操作功能。</p>
<h3 id="ReadWriter-对象"><a href="#ReadWriter-对象" class="headerlink" title="ReadWriter 对象"></a>ReadWriter 对象</h3><p>ReadWriter 对象可以对数据 I/O 接口 io.ReadWriter 进行输入输出缓冲操作，ReadWriter 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type ReadWriter struct {</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，ReadWriter 对象中存放了一对 Reader 和 Writer 指针，它同时提供了对数据 I/O 对象的读写缓冲功能。</p>
<p>可以使用 NewReadWriter() 函数创建 ReadWriter 对象，该函数的功能是根据指定的 Reader 和 Writer 创建一个 ReadWriter 对象，ReadWriter 对象将会向底层 io.ReadWriter 接口写入数据，或者从 io.ReadWriter 接口读取数据。该函数原型声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</span><br></pre></td></tr></tbody></table></figure>
<p>在函数 NewReadWriter() 中，参数 r 是要读取的来源 Reader 对象，参数 w 是要写入的目的 Writer 对象。</p>
<h3 id="Reader-对象"><a href="#Reader-对象" class="headerlink" title="Reader 对象"></a>Reader 对象</h3><p>Reader 对象可以对数据 I/O 接口 io.Reader 进行输入缓冲操作，Reader 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Reader struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下 Reader 对象没有定义初始值，输入缓冲区最小值为 16。当超出限制时，另创建一个二倍的存储空间</p>
<h3 id="创建-Reader-对象"><a href="#创建-Reader-对象" class="headerlink" title="创建 Reader 对象"></a>创建 Reader 对象</h3><p>可以创建 Reader 对象的函数一共有两个，分别是 NewReader() 和 NewReaderSize()，下面分别介绍。</p>
<p>1)NewReader() 函数</p>
<p>NewReader() 函数的功能是按照缓冲区默认长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewReader(rd io.Reader) *Reader</span><br></pre></td></tr></tbody></table></figure>
<p>2)NewReaderSize() 函数</p>
<p>NewReaderSize() 函数的功能是按照指定的缓冲区长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 rd 是 io.Reader 接口，参数 size 是指定的缓冲区字节长度。</p>
<h3 id="操作-Reader-对象"><a href="#操作-Reader-对象" class="headerlink" title="操作 Reader 对象"></a>操作 Reader 对象</h3><p>操作 Reader 对象的方法共有 11 个，分别是 Read()、ReadByte()、ReadBytes()、ReadLine()、ReadRune ()、ReadSlice()、ReadString()、UnreadByte()、UnreadRune()、Buffered()、Peek()，下面分别介绍。</p>
<p>1)Read() 方法</p>
<p>Read() 方法的功能是读取数据，并存放到字节切片 p 中。Read() 执行结束会返回已读取的字节数，因为最多只调用底层的 io.Reader 一次，所以返回的 n 可能小于 len(p)，当字节流结束时，n 为 0，err 为 io. EOF。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>在方法 Read() 中，参数 p 是用于存放读取数据的字节切片。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [128]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>2)ReadByte() 方法</p>
<p>ReadByte() 方法的功能是读取并返回一个字节，如果没有字节可读，则返回错误信息。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadByte() (c byte,err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    c, err := r.ReadByte()</span><br><span class="line">    fmt.Println(string(c), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>3)ReadBytes() 方法</p>
<p>ReadBytes() 方法的功能是读取数据直到遇到第一个分隔符“delim”，并返回读取的字节序列（包括“delim”）。如果 ReadBytes 在读到第一个“delim”之前出错，它返回已读取的数据和那个错误（通常是 io.EOF）。只有当返回的数据不以“delim”结尾时，返回的 err 才不为空值。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadBytes(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>4)ReadLine() 方法</p>
<p>ReadLine() 是一个低级的用于读取一行数据的方法，大多数调用者应该使用 ReadBytes(‘\n’) 或者 ReadString(‘\n’)。ReadLine 返回一行，不包括结尾的回车字符，如果一行太长（超过缓冲区长度），参数 isPrefix 会设置为 true 并且只返回前面的数据，剩余的数据会在以后的调用中返回。</p>
<p>当返回最后一行数据时，参数 isPrefix 会置为 false。返回的字节切片只在下一次调用 ReadLine 前有效。ReadLine 会返回一个非空的字节切片或一个错误，方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Golang is a beautiful language. \r\n I like it!")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    line, prefix, err := r.ReadLine()</span><br><span class="line">    fmt.Println(string(line), prefix, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Golang is a beautiful language.  false &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>5)ReadRune() 方法</p>
<p>ReadRune() 方法的功能是读取一个 UTF-8 编码的字符，并返回其 Unicode 编码和字节数。如果编码错误，ReadRune 只读取一个字节并返回 unicode.ReplacementChar(U+FFFD) 和长度 1。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    ch, size, err := r.ReadRune()</span><br><span class="line">    fmt.Println(string(ch), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>6)ReadSlice() 方法</p>
<p>ReadSlice() 方法的功能是读取数据直到分隔符“delim”处，并返回读取数据的字节切片，下次读取数据时返回的切片会失效。如果 ReadSlice 在查找到“delim”之前遇到错误，它返回读取的所有数据和那个错误（通常是 io.EOF）。</p>
<p>如果缓冲区满时也没有查找到“delim”，则返回 ErrBufferFull 错误。ReadSlice 返回的数据会在下次 I/O 操作时被覆盖，大多数调用者应该使用 ReadBytes 或者 ReadString。只有当 line 不以“delim”结尾时，ReadSlice 才会返回非空 err。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br><span class="line">Go语言入门教程 EOF</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure>
<p>7)ReadString() 方法</p>
<p>ReadString() 方法的功能是读取数据直到分隔符“delim”第一次出现，并返回一个包含“delim”的字符串。如果 ReadString 在读取到“delim”前遇到错误，它返回已读字符串和那个错误（通常是 io.EOF）。只有当返回的字符串不以“delim”结尾时，ReadString 才返回非空 err。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) ReadString(delim byte) (line string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadString(delim)</span><br><span class="line">    fmt.Println(line, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>8)UnreadByte() 方法</p>
<p>UnreadByte() 方法的功能是取消已读取的最后一个字节（即把字节重新放回读取缓冲区的前部）。只有最近一次读取的单个字节才能取消读取。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) UnreadByte() error</span><br></pre></td></tr></tbody></table></figure>
<p>9)UnreadRune() 方法</p>
<p>UnreadRune() 方法的功能是取消读取最后一次读取的 Unicode 字符。如果最后一次读取操作不是 ReadRune，UnreadRune 会返回一个错误（在这方面它比 UnreadByte 更严格，因为 UnreadByte 会取消上次任意读操作的最后一个字节）。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) UnreadRune() error</span><br></pre></td></tr></tbody></table></figure>
<p>10)Buffered() 方法</p>
<p>Buffered() 方法的功能是返回可从缓冲区读出数据的字节数, 示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [14]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn := r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">    n, err = r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn = r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Go语言入门 14 &lt;nil&gt;</span><br><span class="line">6</span><br><span class="line">教程 6 &lt;nil&gt;</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<p>11)Peek() 方法</p>
<p>Peek() 方法的功能是读取指定字节数的数据，这些被读取的数据不会从缓冲区中清除。在下次读取之后，本次返回的字节切片会失效。如果 Peek 返回的字节数不足 n 字节，则会同时返回一个错误说明原因，如果 n 比缓冲区要大，则错误为 ErrBufferFull。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Reader) Peek(n int) ([]byte, error)</span><br></pre></td></tr></tbody></table></figure>
<p>在方法 Peek() 中，参数 n 是希望读取的字节数。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    bl, err := r.Peek(8)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(14)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(20)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Go语言 &lt;nil&gt;</span><br><span class="line">Go语言入门 &lt;nil&gt;</span><br><span class="line">Go语言入门教程 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Writer-对象"><a href="#Writer-对象" class="headerlink" title="Writer 对象"></a>Writer 对象</h3><p>Writer 对象可以对数据 I/O 接口 io.Writer 进行输出缓冲操作，Writer 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Writer struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下 Writer 对象没有定义初始值，如果输出缓冲过程中发生错误，则数据写入操作立刻被终止，后续的写操作都会返回写入异常错误。</p>
<h3 id="创建-Writer-对象"><a href="#创建-Writer-对象" class="headerlink" title="创建 Writer 对象"></a>创建 Writer 对象</h3><p>创建 Writer 对象的函数共有两个分别是 NewWriter() 和 NewWriterSize()，下面分别介绍一下。</p>
<p>1)NewWriter() 函数</p>
<p>NewWriter() 函数的功能是按照默认缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewWriter(wr io.Writer) *Writer</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 wr 是 io.Writer 接口，Writer 对象会将数据写入该接口。</p>
<p>2)NewWriterSize() 函数</p>
<p>NewWriterSize() 函数的功能是按照指定的缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewWriterSize(wr io.Writer, size int) *Writer</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 wr 是 io.Writer 接口，参数 size 是指定的缓冲区字节长度。</p>
<h3 id="操作-Writer-对象"><a href="#操作-Writer-对象" class="headerlink" title="操作 Writer 对象"></a>操作 Writer 对象</h3><p>操作 Writer 对象的方法共有 7 个，分别是 Available()、Buffered()、Flush()、Write()、WriteByte()、WriteRune() 和 WriteString() 方法，下面分别介绍。</p>
<p>1)Available() 方法</p>
<p>Available() 方法的功能是返回缓冲区中未使用的字节数，该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) Available() int</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Available())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Available())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 4096</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：4080</span><br></pre></td></tr></tbody></table></figure>
<p>2)Buffered() 方法</p>
<p>Buffered() 方法的功能是返回已写入当前缓冲区中的字节数，该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) Buffered() int</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Buffered())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Buffered())</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println("执行 Flush 方法后，写入的字节数为：", w.Buffered())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该例测试结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 0</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：16</span><br><span class="line">执行 Flush 方法后，写入的字节数为： 0</span><br></pre></td></tr></tbody></table></figure>
<p>3)Flush() 方法</p>
<p>Flush() 方法的功能是把缓冲区中的数据写入底层的 io.Writer，并返回错误信息。如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) Flush() error</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("未执行 Flush 缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Printf("执行 Flush 后缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">未执行 Flush 缓冲区输出 ""</span><br><span class="line">执行 Flush 后缓冲区输出 "C语言中文网"</span><br></pre></td></tr></tbody></table></figure>
<p>4)Write() 方法</p>
<p>Write() 方法的功能是把字节切片 p 写入缓冲区，返回已写入的字节数 nn。如果 nn 小于 len(p)，则同时返回一个错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 p 是要写入的字节切片。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    n, err := w.Write(p)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>5)WriteByte() 方法</p>
<p>WriteByte() 方法的功能是写入一个字节，如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">unc (b *Writer) WriteByte(c byte) error</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 c 是要写入的字节数据，比如 ASCII 字符。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var c byte = 'G'</span><br><span class="line">    err := w.WriteByte(c)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>6)WriteRune() 方法</p>
<p>WriteRune() 方法的功能是以 UTF-8 编码写入一个 Unicode 字符，返回写入的字节数和错误信息。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) WriteRune(r rune) (size int,err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 r 是要写入的 Unicode 字符。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var r rune = 'G'</span><br><span class="line">    size, err := w.WriteRune(r)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该例测试结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">G 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>7)WriteString() 方法</p>
<p>WriteString() 方法的功能是写入一个字符串，并返回写入的字节数和错误信息。如果返回的字节数小于 len(s)，则同时返回一个错误说明原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (b *Writer) WriteString(s string) (int, error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 s 是要写入的字符串。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    s := "C语言中文网"</span><br><span class="line">    n, err := w.WriteString(s)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>结构体</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>Go接口</title>
    <url>/posts/d3175357/</url>
    <content><![CDATA[<p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p>
<p>Go 语言中使用组合实现对象特性的描述。对象的内部使用结构体内嵌组合对象应该具有的特性，对外通过接口暴露能使用的特性。</p>
<p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p>
<p>其它编程语言中的接口</p>
<p>接口是一种较为常见的特性，很多语言都有接口特性。C/C++、C# 语言中的接口都可以多重派生实现接口组合；在苹果的 Objective C 中与接口类似的功能被称为 Protocol，这种叫法比接口更形象、具体。</p>
<p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p>
<h2 id="接口声明（定义）"><a href="#接口声明（定义）" class="headerlink" title="接口声明（定义）"></a>接口声明（定义）</h2><p>Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。</p>
<p>但是Go语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</p>
<p>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</p>
<p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p>
<p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p>
<h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成。接口的形式代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type 接口类型名 interface{</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。</li>
<li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type writer interface{</span><br><span class="line">    Write([]byte) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="开发中常见的接口及写法"><a href="#开发中常见的接口及写法" class="headerlink" title="开发中常见的接口及写法"></a>开发中常见的接口及写法</h3><p>Go语言提供的很多包中都有接口，例如 io 包中提供的 Writer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个接口可以调用 Write() 方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。</p>
<p>类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用 String() 方法时，都可以获得对象对应的字符串。在 fmt 包中定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Stringer 接口在Go语言中的使用频率非常高，功能类似于 Java 或者 C# 语言里的 ToString 的操作。</p>
<p>Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。</p>
<p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p>
<p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p>
<p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p>
<h3 id="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><a href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致" class="headerlink" title="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"></a>接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p>
<p>为了抽象数据写入的过程，定义 DataWriter 接口来描述数据写入需要实现的方法，接口中的 WriteData() 方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现 WriteData 方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现 DataWriter 接口的 WriteData 方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考下面的代码。</p>
<p>数据写入器的抽象：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义文件结构，用于实现DataWriter</span><br><span class="line">type file struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现DataWriter接口的WriteData方法</span><br><span class="line">func (d *file) WriteData(data interface{}) error {</span><br><span class="line"></span><br><span class="line">    // 模拟写入数据</span><br><span class="line">    fmt.Println("WriteData:", data)</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化file</span><br><span class="line">    f := new(file)</span><br><span class="line"></span><br><span class="line">    // 声明一个DataWriter的接口</span><br><span class="line">    var writer DataWriter</span><br><span class="line"></span><br><span class="line">    // 将接口赋值f，也就是*file类型</span><br><span class="line">    writer = f</span><br><span class="line"></span><br><span class="line">    // 使用DataWriter接口进行数据写入</span><br><span class="line">    writer.WriteData("data")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，输入一个 interface{} 类型的 data，返回一个 error 结构表示可能发生的错误。</li>
<li>第 17 行，file 的 WriteData() 方法使用指针接收器。输入一个 interface{} 类型的 data，返回 error。</li>
<li>第 27 行，实例化 file 赋值给 f，f 的类型为 <code>*file</code> 。</li>
<li>第 30 行，声明 DataWriter 类型的 writer 接口变量。</li>
<li>第 33 行，将 <code>*file</code> 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</li>
<li>第 36 行，DataWriter 接口类型的 writer 使用 WriteData() 方法写入一个字符串。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">WriteData: data</span><br></pre></td></tr></tbody></table></figure>
<p>本例中调用及实现关系如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writewriter.jpg" alt="图：WriteWriter的实现过程"></p>
<p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p>
<p>1)函数名不一致导致的报错</p>
<p>在以上代码的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改 file 结构的 WriteData() 方法名，将这个方法签名（第17行）修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (d *file) WriteDataX(data interface{}) error {</span><br></pre></td></tr></tbody></table></figure>
<p>编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing WriteData method)</span><br></pre></td></tr></tbody></table></figure>
<p>报错的位置在第 33 行。报错含义是：不能将 f 变量（类型 <code>*file</code>）视为 DataWriter 进行赋值。原因：<code>*file</code> 类型未实现 DataWriter 接口（丢失 WriteData 方法）。</p>
<p>WriteDataX 方法的签名本身是合法的。但编译器扫描到第 33 行代码时，发现尝试将 <code>*file</code> 类型赋值给 DataWriter 时，需要检查 <code>*file</code> 类型是否完全实现了 DataWriter 接口。显然，编译器因为没有找到 DataWriter 需要的 WriteData() 方法而报错。</p>
<p>2)实现接口的方法签名不一致导致的报错</p>
<p>将修改的代码恢复后，再尝试修改 WriteData() 方法，把 data 参数的类型从 interface{} 修改为 int 类型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (d *file) WriteData(data int) error {</span><br></pre></td></tr></tbody></table></figure>
<p>编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (wrong type for WriteData method)</span><br><span class="line">                have WriteData(int) error</span><br><span class="line">                want WriteData(interface {}) error</span><br></pre></td></tr></tbody></table></figure>
<p>这次未实现 DataWriter 的理由变为（错误的 WriteData() 方法类型）发现 <code>WriteData(int)error</code> ，期望 <code>WriteData(interface{})error</code> 。</p>
<p>这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。</p>
<h3 id="接口被实现的条件二：接口中所有方法均被实现"><a href="#接口被实现的条件二：接口中所有方法均被实现" class="headerlink" title="接口被实现的条件二：接口中所有方法均被实现"></a>接口被实现的条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p>
<p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line"></span><br><span class="line">    // 能否写入</span><br><span class="line">    CanWrite() bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></tbody></table></figure>
<p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p>
<p>Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p>
<p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p>
<p><strong><em>提示:传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。</em></strong></p>
<p>对于Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。</p>
<h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><p>在Go语言中类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系</p>
<h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p>
<p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p>
<p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Socket struct {</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Socket 结构的 Write() 方法实现了 io.Writer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同时，Socket 结构也实现了 io.Closer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosocket.jpg" alt="图：接口的使用和实现过程"></p>
<p>在代码中使用 Socket 结构实现的 Writer 接口和 Closer 接口代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 使用io.Writer的代码, 并不知道Socket和io.Closer的存在</span><br><span class="line">func usingWriter( writer io.Writer){</span><br><span class="line">    writer.Write( nil )</span><br><span class="line">}</span><br><span class="line">// 使用io.Closer, 并不知道Socket和io.Writer的存在</span><br><span class="line">func usingCloser( closer io.Closer) {</span><br><span class="line">    closer.Close()</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    // 实例化Socket</span><br><span class="line">    s := new(Socket)</span><br><span class="line">    usingWriter(s)</span><br><span class="line">    usingCloser(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。</p>
<h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p>
<p>Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 一个服务需要满足能够开启和写日志的功能</span><br><span class="line">type Service interface {</span><br><span class="line">    Start()  // 开启服务</span><br><span class="line">    Log(string)  // 日志输出</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 日志器</span><br><span class="line">type Logger struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Log()方法</span><br><span class="line">func (g *Logger) Log(l string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 游戏服务</span><br><span class="line">type GameService struct {</span><br><span class="line">    Logger  // 嵌入日志器</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Start()方法</span><br><span class="line">func (g *GameService) Start() {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义服务接口，一个服务需要实现 Start() 方法和日志方法。</li>
<li>第 8 行，定义能输出日志的日志器结构。</li>
<li>第 12 行，为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</li>
<li>第 17 行，定义 GameService 结构。</li>
<li>第 18 行，在 GameService 中嵌入 Logger 日志器，以实现日志功能。</li>
<li>第 22 行，GameService 的 Start() 方法实现了 Service 的 Start() 方法。</li>
</ul>
<p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var s Service = new(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></tbody></table></figure>
<p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p>
<h2 id="接口的nil判断"><a href="#接口的nil判断" class="headerlink" title="接口的nil判断"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/128.html">接口的nil判断</a></h2><p>nil 在 Go 语言中只能被赋值给指针和接口。接口在底层的实现有两个部分：type 和 data。在源码中，显式地将 nil 赋值给接口时，接口的 type 和 data 都将为 nil。此时，接口与 nil 值判断是相等的。但如果将一个带有类型的 nil 赋值给接口时，只有 data 为 nil，而 type 为 nil，此时，接口与 nil 判断将不相等。</p>
<h3 id="接口与-nil-不相等"><a href="#接口与-nil-不相等" class="headerlink" title="接口与 nil 不相等"></a>接口与 nil 不相等</h3><p>下面代码使用 MyImplement() 实现 fmt 包中的 Stringer 接口，这个接口的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 GetStringer() 函数中将返回这个接口。通过 *MyImplement 指针变量置为 nil 提供 GetStringer 的返回值。在 main() 中，判断 GetStringer 与 nil 是否相等，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义一个结构体</span><br><span class="line">type MyImplement struct{}</span><br><span class="line"></span><br><span class="line">// 实现fmt.Stringer的String方法</span><br><span class="line">func (m *MyImplement) String() string {</span><br><span class="line"></span><br><span class="line">    return "hi"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在函数中返回fmt.Stringer接口</span><br><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    // 赋nil</span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    // 返回变量</span><br><span class="line">    return s</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 判断返回值是否为nil</span><br><span class="line">    if GetStringer() == nil {</span><br><span class="line">        fmt.Println("GetStringer() == nil")</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("GetStringer() != nil")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，实现 fmt.Stringer 的 String() 方法。</li>
<li>第 21 行，s 变量此时被 fmt.Stringer 接口包装后，实际类型为 *MyImplement，值为 nil 的接口。</li>
<li>第 27 行，使用 GetStringer() 的返回值与 nil 判断时，虽然接口里的 value 为 nil，但 type 带有 *MyImplement 信息，使用 == 判断相等时，依然不为 nil。</li>
</ul>
<h3 id="发现-nil-类型值返回时直接返回-nil"><a href="#发现-nil-类型值返回时直接返回-nil" class="headerlink" title="发现 nil 类型值返回时直接返回 nil"></a>发现 nil 类型值返回时直接返回 nil</h3><p>为了避免这类误判的问题，可以在函数返回时，发现带有 nil 的指针时直接返回 nil，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    if s == nil {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类型断言简述"><a href="#类型断言简述" class="headerlink" title="类型断言简述"></a>类型断言简述</h2><p>类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p>
<p>在Go语言中类型断言的语法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p>
<p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：</p>
<ul>
<li>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。</li>
<li>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。</li>
<li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = 10</span><br><span class="line">    value, ok := x.(int)</span><br><span class="line">    fmt.Print(value, ",", ok)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">10,true</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = "Hello"</span><br><span class="line">    value := x.(int)</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: interface conversion: interface {} is string, not int</span><br></pre></td></tr></tbody></table></figure>
<p>类型断言还可以配合 switch 使用，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a int</span><br><span class="line">    a = 10</span><br><span class="line">    getType(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func getType(a interface{}) {</span><br><span class="line">    switch a.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println("the type of a is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println("the type of a is string")</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Println("the type of a is float")</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println("unknown type")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">the type of a is int</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实现日志系统（支持多种输出方式）"><a href="#实现日志系统（支持多种输出方式）" class="headerlink" title="实现日志系统（支持多种输出方式）"></a>实现日志系统（支持多种输出方式）</h2><p>日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，如命令行、文件、网络等。</p>
<p>本例将搭建一个支持多种写入器的日志系统，可以自由扩展多种日志写入设备。</p>
<h3 id="日志对外接口"><a href="#日志对外接口" class="headerlink" title="日志对外接口"></a>日志对外接口</h3><p>本例中定义一个日志写入器接口（LogWriter），要求写入设备必须遵守这个接口协议才能被日志器（Logger）注册。日志器有一个写入器的注册方法（Logger的RegisterWriter()方法）。</p>
<p>日志器还有一个Log()方法，进行日志的输出，这个函数会将日志写入到所有已经注册的日志写入器（LogWriter）中，详细代码实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//声明日志写入器接口</span><br><span class="line">type LogWriter interface{</span><br><span class="line">    Write(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//日志器</span><br><span class="line">type Logger struct{</span><br><span class="line">    //这个日志器用到的日志写入器</span><br><span class="line">    writerList []LogWriter</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//注册一个日志写入器</span><br><span class="line">func(l *Logger) RegisterWriter ( writer LogWriter ) {</span><br><span class="line">    l.writerList = append(l.writerList , writer )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//将一个data类型的数据写入日志</span><br><span class="line">func(l *Logger) Log ( data interface{}){</span><br><span class="line"></span><br><span class="line">    //遍历所有注册的写入器</span><br><span class="line">    for _ , writer := range l.writerList {</span><br><span class="line"></span><br><span class="line">        //将日志输出到每一个写入器中</span><br><span class="line">        writer.Write(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建日志器的实例</span><br><span class="line">func NewLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    return &amp;Logger{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，声明日志写入器接口。这个接口可以被外部使用。日志的输出可以有多种设备，这个写入器就是用来实现一个日志的输出设备。</li>
<li>第9行，声明日志器结构。日志器使用writeList记录输出到哪些设备上。</li>
<li>第15行，使用日志器方法RegisterWriter()将一个日志写入器（LogWriter）注册到日志器（Logger）中。注册的意思就是将日志写入器的接口添加到writeList中。</li>
<li>第20行，日志器的Log()方法可以将interface{}类型的data写入到注册过的日志写入器中。</li>
<li>第23行，遍历日志器拥有的所有日志写入器。</li>
<li>第26行，将本次日志的内容写入日志写入器。</li>
<li>第31行，创建日志器的实例。</li>
</ul>
<p>这个例子中，为了最大程度地展示接口的用法，仅仅只是将数据直接写入日志写入器中。复杂一些的日志器还可以将日期、级别等信息合并到数据中一并写入日志。</p>
<h3 id="文件写入器"><a href="#文件写入器" class="headerlink" title="文件写入器"></a>文件写入器</h3><p>文件写入器（fileWriter）是众多日志写入器（LogWriter）中的一种。文件写入器的功能是根据一个文件名创建日志文件（fileWriter的SetFile方法）。在有日志写入时，将日志写入文件中。</p>
<p>文件写入器代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明文件写入器</span><br><span class="line">type fileWriter struct{</span><br><span class="line">    file *os.File</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//设置文件写入器写入的文件名</span><br><span class="line">func(f *fileWriter) SetFile ( filename string ) (err error ) {</span><br><span class="line"></span><br><span class="line">    //如果文件已经打开,关闭前一个文件</span><br><span class="line">    if f.file != nil {</span><br><span class="line">        f.file.Close()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个文件并保存文件句柄</span><br><span class="line">    f.file , err = os.Create(filename)</span><br><span class="line"></span><br><span class="line">    //如果创建的过程出现错误,则返回错误</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *fileWriter) Write ( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //日志文件可能没有创建成功</span><br><span class="line">    if f.file == nil {</span><br><span class="line"></span><br><span class="line">        //日志文件没有准备好</span><br><span class="line">        return errors.New("file not created")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入文件中</span><br><span class="line">    _ , err := f.file.Write([]byte(str))</span><br><span class="line"></span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建文件写入器实例</span><br><span class="line">func newFileWriter() *fileWriter {</span><br><span class="line">    return &amp;fileWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，声明文件写入器，在结构体中保存一个文件句柄，以方便每次写入时操作。</li>
<li>第15行，文件写入器通过文件名创建文件，这里通过SetFile的参数提供一个文件名，并创建文件。</li>
<li>第18行，考虑到SetFile()方法可以被多次调用（函数可重入性），假设之前已经调用过SetFile()后再次调用，此时的f.file不为空，就需要关闭之前的文件，重新创建新的文件。</li>
<li>第23行，根据文件名创建文件，如果发生错误，通过SetFile的返回值返回。</li>
<li>第30行，fileWriter的Write()方法实现了LogWriter接口的Write()方法。</li>
<li>第33行，如果文件没有准备好，文件句柄为nil，此时使用errors包的New()函数返回一个错误对象，包含一个字符串“filenotcreated”。</li>
<li>第40行，通过Write()方法传入的data参数是interface{}类型，而f.file的Write()方法需要的是[]byte类型。使用fmt.Sprintf将data转换为字符串，这里使用的格式化参数是%v，意思是将data按其本来的值转换为字符串。</li>
<li>第43行，通过f.file的Write()方法，将str字符串转换为[]byte字节数组，再写入到文件中。如果发生错误，则返回。</li>
</ul>
<p>在操作文件时，会出现文件无法创建、无法写入等错误。开发中尽量不要忽略这些底层报出的错误，应该处理可能发生的所有错误。</p>
<p>文件使用完后，要注意使用os.File的Close()方法进行及时关闭，否则文件再次访问时会因为其属性出现无法读取、无法写入等错误。</p>
<p><strong>提示:</strong></p>
<p>一个完备的文件写入器会提供多种写入文件的模式，例子中使用的模式是将日志添加到日志文件的尾部。随着文件越来越大，文件的访问效率和查看便利性也会大大降低。此时，就需要另外一种写入模式：滚动写入文件。</p>
<p>滚动写入文件模式也是将日志添加到文件的尾部，但当文件达到设定的期望大小时，会自动开启一个新的文件继续写入文件，最终将获得多个日志文件。</p>
<p>日志文件名不仅可以按照文件大小进行分割，还可以按照日期范围进行分割。在到达设定的日期范围，如每天、每小时的周期范围时，日志器会自动创建新的日志文件。这种日志文件创建方法也能方便开发者按日志查看日志。</p>
<h3 id="命令行写入器"><a href="#命令行写入器" class="headerlink" title="命令行写入器"></a>命令行写入器</h3><p>在UNIX的思想中，一切皆文件。文件包括内存、磁盘、网络和命令行等。这种抽象方法方便我们访问这些看不见摸不着的虚拟资源。命令行在Go语言中也是一种文件，os.Stdout对应标准输出，一般表示屏幕，也就是命令行，也可以被重定向为打印机或者磁盘文件；os.Stderr对应标准错误输出，一般将错误输出到日志中，不过大多数情况，os.Stdout会与os.Stderr合并输出；os.Stdin对应标准输入，一般表示键盘。os.Stdout、os.Stderr、os.Stdin都是 <code>*os.File</code> 类型，和文件一样实现了io.Writer接口的Write()方法。</p>
<p>下面的代码展示如何将命令行抽象为日志写入器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//命令行写入器</span><br><span class="line">type consoleWriter struct {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *consoleWriter) Write( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入命令行中</span><br><span class="line">    _ , err := os.Stdout.Write([]byte(str))</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建命令行写入器实例</span><br><span class="line">func newConsoleWriter() *consoleWriter {</span><br><span class="line">    return &amp;consoleWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，声明consoleWriter结构，以实现命令行写入器。</li>
<li>第13行，consoleWriter的Write()方法实现了日志写入接口（LogWriter）的Write()方法。</li>
<li>第16行，与fileWriter类似，这里也将data通过fmt.Sprintf序列化为字符串。</li>
<li>第19行，与fileWriter类似，这里也将str字符串转换为字节数组并写入标准输出os.Stdout。写入后的内容就会显示在命令行中。</li>
<li>第25行，创建命令行写入器的实例。</li>
</ul>
<p>除了命令行写入器（consoleWriter）和文件写入器（fileWriter），读者还可以自行使用net包中的Socket封装实现网络写入器socketWriter，让日志可以写入远程的服务器中或者可以跨进程进行日志保存和分析。</p>
<h3 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h3><p>在程序中使用日志器一般会先通过代码创建日志器（Logger），为日志器添加输出设备（fileWriter、consoleWriter等）。这些设备中有一部分需要一些参数设定，如文件日志写入器需要提供文件名（fileWriter的SetFile()方法）。</p>
<p>下面代码中展示了使用日志器的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">//创建日志器</span><br><span class="line">func createLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    //创建日志器</span><br><span class="line">    l := NewLogger()</span><br><span class="line"></span><br><span class="line">    //创建命令行写入器</span><br><span class="line">    cw := newConsoleWriter()</span><br><span class="line"></span><br><span class="line">    //注册命令行写入器到日志器中</span><br><span class="line">    l.RegisterWriter(cw)</span><br><span class="line"></span><br><span class="line">    //创建文件写入器</span><br><span class="line">    fw := newFileWriter()</span><br><span class="line"></span><br><span class="line">    //设置文件名</span><br><span class="line">    if err := fw.SetFile("log.log"); err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //注册文件写入器到日志器中</span><br><span class="line">    l.RegisterWriter(fw)</span><br><span class="line"></span><br><span class="line">    return l</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备日志器</span><br><span class="line">    l := createLogger()</span><br><span class="line"></span><br><span class="line">    //写一个日志</span><br><span class="line">    l.Log("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行，一个创建日志的过程。这个过程一般隐藏在系统初始化中。程序启动时初始化一次。</li>
<li>第9行，创建一个日志器的实例，后面的代码会使用到它。</li>
<li>第12行，创建一个命令行写入器。如果全局有很多日志器，命令行写入器可以被共享，全局只会有一份。</li>
<li>第18行，创建一个文件写入器。一个程序的日志一般只有一个，因此不同的日志器也应该共享一个文件写入器。</li>
<li>第21行，创建好的文件写入器需要初始化写入的文件，通过文件名确定写入的文件。设置的过程可能会发生错误，发生错误时会输出错误信息。</li>
<li>第26行，将文件写入器注册到日志器中。</li>
<li>第34行，在程序一开始创建日志器。</li>
<li>第37行，往创建好的日志器中写入日志。</li>
</ul>
<p>编译整个代码并运行，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></tbody></table></figure>
<p>同时，当前目录的log.log文件中也会出现hello字符。</p>
<p><strong>提示:</strong></p>
<p>Go语言的log包实现了一个小型的日志系统。这个日志系统可以在创建日志器时选择输出设备、日志前缀及flag，函数定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func New(out io.Writer,prefix string,flag int) *Logger { return &amp;Logger{out:out,prefix:prefix,flag:flag }}</span><br></pre></td></tr></tbody></table></figure>
<p>在flag中，还可以定制日志中是否输出日期、日期精度和详细文件名等。</p>
<p>这个日志器在编写时，也最大程度地保证了输出的效率，如果读者对日志器的编写比较感兴趣，可以在log包的基础上进行扩展，形成方便自己使用的日志库。</p>
<h2 id="排序（借助sort-Interface接口）"><a href="#排序（借助sort-Interface接口）" class="headerlink" title="排序（借助sort.Interface接口）"></a>排序（借助sort.Interface接口）</h2><p>排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要 15 行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。</p>
<p>幸运的是，sort 包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。</p>
<p>相比之下，Go语言的 sort.Sort 函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型 sort.Interface 来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 的三个方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package sort</span><br><span class="line">type Interface interface {</span><br><span class="line">    Len() int            // 获取元素数量</span><br><span class="line">    Less(i, j int) bool // i，j是序列元素的指数。</span><br><span class="line">    Swap(i, j int)        // 交换元素</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用 sort.Sort 函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型 MyStringList  和它的 Len，Less 和 Swap 方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type MyStringList  []string</span><br><span class="line">func (p MyStringList ) Len() int { return len(m) }</span><br><span class="line">func (p MyStringList ) Less(i, j int) bool { return m[i] &lt; m[j] }</span><br><span class="line">func (p MyStringList ) Swap(i, j int) { m[i], m[j] = m[j], m[i] }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用sort-Interface接口进行排序"><a href="#使用sort-Interface接口进行排序" class="headerlink" title="使用sort.Interface接口进行排序"></a>使用sort.Interface接口进行排序</h3><p>对一系列字符串进行排序时，使用字符串切片（ <code>[]string</code> ）承载多个字符串。使用 type 关键字，将字符串切片（ <code>[]string</code> ）定义为自定义类型 MyStringList。为了让 sort 包能识别 MyStringList，能够对 MyStringList 进行排序，就必须让 MyStringList 实现 sort.Interface 接口。</p>
<p>下面是对字符串排序的详细代码（代码1）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将[]string定义为MyStringList类型</span><br><span class="line">type MyStringList []string</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的获取元素数量方法</span><br><span class="line">func (m MyStringList) Len() int {</span><br><span class="line">    return len(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的比较元素方法</span><br><span class="line">func (m MyStringList) Less(i, j int) bool {</span><br><span class="line">    return m[i] &lt; m[j]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的交换元素方法</span><br><span class="line">func (m MyStringList) Swap(i, j int) {</span><br><span class="line">    m[i], m[j] = m[j], m[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个内容被打乱顺序的字符串切片</span><br><span class="line">    names := MyStringList{</span><br><span class="line">        "3. Triple Kill",</span><br><span class="line">        "5. Penta Kill",</span><br><span class="line">        "2. Double Kill",</span><br><span class="line">        "4. Quadra Kill",</span><br><span class="line">        "1. First Blood",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(names)</span><br><span class="line"></span><br><span class="line">    // 遍历打印结果</span><br><span class="line">    for _, v := range names {</span><br><span class="line">            fmt.Printf("%s\n", v)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. First Blood</span><br><span class="line">2. Double Kill</span><br><span class="line">3. Triple Kill</span><br><span class="line">4. Quadra Kill</span><br><span class="line">5. Penta Kill</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，接口实现不受限于结构体，任何类型都可以实现接口。要排序的字符串切片 <code>[]string</code> 是系统定制好的类型，无法让这个类型去实现 sort.Interface 排序接口。因此，需要将 <code>[]string</code> 定义为自定义的类型。</li>
<li>第 12 行，实现获取元素数量的 Len() 方法，返回字符串切片的元素数量。</li>
<li>第 17 行，实现比较元素的 Less() 方法，直接取 m 切片的 i 和 j 元素值进行小于比较，并返回比较结果。</li>
<li>第 22 行，实现交换元素的 Swap() 方法，这里使用Go语言的多变量赋值特性实现元素交换。</li>
<li><p>第 29 行，由于将 <code>[]string</code> 定义成 MyStringList 类型，字符串切片初始化的过程等效于下面的写法</p>
  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">names := []string {</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 38 行，使用 sort 包的 Sort() 函数，将 names（MyStringList类型）进行排序。排序时，sort 包会通过 MyStringList 实现的 Len()、Less()、Swap() 这 3 个方法进行数据获取和修改。</p>
</li>
<li>第 41 行，遍历排序好的字符串切片，并打印结果。</li>
</ul>
<h3 id="常见类型的便捷排序"><a href="#常见类型的便捷排序" class="headerlink" title="常见类型的便捷排序"></a>常见类型的便捷排序</h3><p>通过实现 sort.Interface 接口的排序过程具有很强的可定制性，可以根据被排序对象比较复杂的特性进行定制。例如，需要多种排序逻辑的需求就适合使用 sort.Interface 接口进行排序。但大部分情况中，只需要对字符串、整型等进行快速排序。Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。</p>
<p>1)字符串切片的便捷排序</p>
<p>sort 包中有一个 StringSlice 类型，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type StringSlice []string</span><br><span class="line"></span><br><span class="line">func (p StringSlice) Len() int           { return len(p) }</span><br><span class="line">func (p StringSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p StringSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure>
<p>sort 包中的 StringSlice 的代码与 MyStringList 的实现代码几乎一样。因此，只需要使用 sort 包的 StringSlice 就可以更简单快速地进行字符串排序。将代码1中的排序代码简化后如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">names := sort.StringSlice{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Sort(names)</span><br></pre></td></tr></tbody></table></figure>
<p>简化后，只要两句代码就实现了字符串排序的功能。</p>
<p>2)对整型切片进行排序</p>
<p>除了字符串可以使用 sort 包进行便捷排序外，还可以使用 sort.IntSlice 进行整型切片的排序。sort.IntSlice 的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line"></span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p IntSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure>
<p>sort 包在 sort.Interface 对各类型的封装上还有更进一步的简化，下面使用 sort.Strings 继续对代码1进行简化，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">names := []string{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Strings(names)</span><br><span class="line"></span><br><span class="line">// 遍历打印结果</span><br><span class="line">for _, v := range names {</span><br><span class="line">    fmt.Printf("%s\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，需要排序的字符串切片。</li>
<li>第 9 行，使用 sort.Strings 直接对字符串切片进行排序。</li>
</ul>
<p>3)sort包内建的类型排序接口一览</p>
<p>Go语言中的 sort 包中定义了一些常见类型的排序方法，如下表所示。</p>
<table>
    <thead><tr><th>类  型</th><th>实现 sort.lnterface的类型</th><th>直接排序方法</th><th>说  明</th></tr></thead>
    <tbody>
        <tr><th>字符串（String）</th><th>StringSlice</th><th>sort.Strings(a [] string)</th><th>字符 ASCII 值升序</th></tr>
        <tr><th>整型（int）</th><th>IntSlice</th><th>sort.Ints(a []int)</th><th>数值升序</th></tr>
        <tr><th>双精度浮点（float64）</th><th>Float64Slice</th><th>sort.Float64s(a []float64)</th><th>数值升序</th></tr>
    </tbody>
</table>

<p>编程中经常用到的 int32、int64、float32、bool 类型并没有由 sort 包实现，使用时依然需要开发者自己编写。</p>
<h3 id="对结构体数据进行排序"><a href="#对结构体数据进行排序" class="headerlink" title="对结构体数据进行排序"></a>对结构体数据进行排序</h3><p>除了基本类型的排序，也可以对结构体进行排序。结构体比基本类型更为复杂，排序时不能像数值和字符串一样拥有一些固定的单一原则。结构体的多个字段在排序中可能会存在多种排序的规则，例如，结构体中的名字按字母升序排列，数值按从小到大的顺序排序。一般在多种规则同时存在时，需要确定规则的优先度，如先按名字排序，再按年龄排序等。</p>
<p>1)完整实现sort.Interface进行结构体排序</p>
<p>将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程如下。</p>
<p>结构体排序代码（代码2）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明英雄的分类</span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">// 定义HeroKind常量, 类似于枚举</span><br><span class="line">const (</span><br><span class="line">    None HeroKind = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义英雄名单的结构</span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string  // 英雄的名字</span><br><span class="line">    Kind HeroKind  // 英雄的种类</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将英雄指针的切片定义为Heros类型</span><br><span class="line">type Heros []*Hero</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口取元素数量方法</span><br><span class="line">func (s Heros) Len() int {</span><br><span class="line">    return len(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口比较元素方法</span><br><span class="line">func (s Heros) Less(i, j int) bool {</span><br><span class="line"></span><br><span class="line">    // 如果英雄的分类不一致时, 优先对分类进行排序</span><br><span class="line">    if s[i].Kind != s[j].Kind {</span><br><span class="line">        return s[i].Kind &lt; s[j].Kind</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 默认按英雄名字字符升序排列</span><br><span class="line">    return s[i].Name &lt; s[j].Name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口交换元素方法</span><br><span class="line">func (s Heros) Swap(i, j int) {</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备英雄列表</span><br><span class="line">    heros := Heros{</span><br><span class="line">        &amp;Hero{"吕布", Tank},</span><br><span class="line">        &amp;Hero{"李白", Assassin},</span><br><span class="line">        &amp;Hero{"妲己", Mage},</span><br><span class="line">        &amp;Hero{"貂蝉", Assassin},</span><br><span class="line">        &amp;Hero{"关羽", Tank},</span><br><span class="line">        &amp;Hero{"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(heros)</span><br><span class="line"></span><br><span class="line">    // 遍历英雄列表打印排序结果</span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;{Name:关羽 Kind:1}</span><br><span class="line">&amp;{Name:吕布 Kind:1}</span><br><span class="line">&amp;{Name:李白 Kind:2}</span><br><span class="line">&amp;{Name:貂蝉 Kind:2}</span><br><span class="line">&amp;{Name:妲己 Kind:3}</span><br><span class="line">&amp;{Name:诸葛亮 Kind:3}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，将 int 声明为 HeroKind 英雄类型，后面会将这个类型当做枚举来使用。</li>
<li>第 13 行，定义一些英雄类型常量，可以理解为枚举的值。</li>
<li>第 26 行，为了方便实现 sort.Interface 接口，将 <code>[]*Hero</code> 定义为 Heros 类型。</li>
<li>第 29 行，Heros 类型实现了 sort.Interface 的 Len() 方法，返回英雄的数量。</li>
<li>第 34 行，Heros 类型实现了 sort.Interface 的 Less() 方法，根据英雄字段的比较结果决定如何排序。</li>
<li>第 37 行，当英雄的分类不一致时，优先按分类的枚举数值从小到大排序。</li>
<li>第 42 行，英雄分类相等的情况下，默认根据英雄的名字字符升序排序。</li>
<li>第 46 行，Heros 类型实现了 sort.Interface 的 Swap() 方法，交换英雄元素的位置。</li>
<li>第 53～60 行，准备一系列英雄数据。</li>
<li>第 63 行，使用 sort 包进行排序。</li>
<li>第 66 行，遍历所有排序完成的英雄数据。</li>
</ul>
<p>2)使用sort.Slice进行切片元素排序</p>
<p>从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice() 函数进行更为简便的排序方法。sort.Slice() 函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为 <code>func(i,j int) bool</code>，sort.Slice() 函数的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Slice(slice interface{}, less func(i, j int) bool)</span><br></pre></td></tr></tbody></table></figure>
<p>使用 sort.Slice() 函数，对代码2重新优化的完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string</span><br><span class="line">    Kind HeroKind</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    heros := []*Hero{</span><br><span class="line">        {"吕布", Tank},</span><br><span class="line">        {"李白", Assassin},</span><br><span class="line">        {"妲己", Mage},</span><br><span class="line">        {"貂蝉", Assassin},</span><br><span class="line">        {"关羽", Tank},</span><br><span class="line">        {"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sort.Slice(heros, func(i, j int) bool {</span><br><span class="line">        if heros[i].Kind != heros[j].Kind {</span><br><span class="line">            return heros[i].Kind &lt; heros[j].Kind</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return heros[i].Name &lt; heros[j].Name</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 33 行到第 39 行部分是新添加的 sort.Slice() 及回调函数部分。对比前面的代码，这里去掉了 Heros 及接口实现部分的代码。</p>
<p>使用 sort.Slice() 不仅可以完成结构体切片排序，还可以对各种切片类型进行自定义排序。</p>
<h2 id="接口的嵌套组合"><a href="#接口的嵌套组合" class="headerlink" title="接口的嵌套组合"></a>接口的嵌套组合</h2><p>在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。</p>
<p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。</p>
<h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go语言的 io 包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3 个接口，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type WriteCloser interface {</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行定义了写入器（Writer），如这个接口较为常用，常用于 I/O 设备的数据写入。</li>
<li>第 5 行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。</li>
<li>第 9 行定义了写入关闭器（WriteCloser），这个接口由 Writer 和 Closer 两个接口嵌入。也就是说，WriteCloser 同时拥有了 Writer 和 Closer 的特性。</li>
</ul>
<h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><p>在代码中使用 io.Writer、io.Closer 和 io.WriteCloser 这 3 个接口时，只需要按照接口实现的规则实现 io.Writer 接口和 io.Closer 接口即可。而 io.WriteCloser 接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了 io.Writer 和 io.Closer 接口，详细实现代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个设备结构</span><br><span class="line">type device struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Writer的Write()方法</span><br><span class="line">func (d *device) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Closer的Close()方法</span><br><span class="line">func (d *device) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明写入关闭器, 并赋予device的实例</span><br><span class="line">    var wc io.WriteCloser = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    wc.Write(nil)</span><br><span class="line"></span><br><span class="line">    // 关闭设备</span><br><span class="line">    wc.Close()</span><br><span class="line"></span><br><span class="line">    // 声明写入器, 并赋予device的新实例</span><br><span class="line">    var writeOnly io.Writer = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    writeOnly.Write(nil)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行定义了 device 结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的 3 种接口。</li>
<li>第 12 行，实现了 io.Writer 的 Write() 方法。</li>
<li>第 17 行，实现了 io.Closer 的 Close() 方法。</li>
<li>第 24 行，对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</li>
<li>第 27 行，调用了 wc（io.WriteCloser接口）的 Write() 方法，由于 wc 被赋值 <code>*device</code> ，因此最终会调用 device 的 Write() 方法。</li>
<li>第 30 行，与 27 行类似，最终调用 device 的 Close() 方法。</li>
<li>第 33 行，再次创建一个 device 的实例，writeOnly 是一个 io.Writer 接口，这个接口只有 Write() 方法。</li>
<li>第 36 行，writeOnly 只能调用 Write() 方法，没有 Close() 方法。</li>
</ul>
<p>为了整理思路，将上面的实现、调用关系使用图方式来展现，参见图 1 和图 2。</p>
<p>1)io.WriteCloser的实现及调用过程如图 1 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writecloser.jpg" alt="图1：io.WriteCloser 的实现及调用过程"></p>
<p>2)io.Writer 的实现调用过程如图 2 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writer.jpg" alt="图2：io.Write 的实现及调用过程"></p>
<p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p>
<h2 id="接口和类型之间的转换"><a href="#接口和类型之间的转换" class="headerlink" title="接口和类型之间的转换"></a>接口和类型之间的转换</h2><p>Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。</p>
<h3 id="类型断言的格式"><a href="#类型断言的格式" class="headerlink" title="类型断言的格式"></a>类型断言的格式</h3><p>类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p>
<p>类型断言的基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量。</p>
<p>这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File) // 成功: f == os.Stdout</span><br><span class="line">c := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer</span><br></pre></td></tr></tbody></table></figure>
<p>第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 i 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，w 和 rw 都持有 os.Stdout 因此它们每个有一个动态类型 *os.File，但是变量 w 是一个 io.Writer 类型只对外公开出文件的 Write 方法，然而 rw 变量也只公开它的 Read 方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) // 成功：*os.file具有读写功能</span><br><span class="line">w = new(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) // 死机：*字节计数器没有读取方法</span><br></pre></td></tr></tbody></table></figure>
<p>如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于 nil 接口值的情况。</p>
<p>如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">t,ok := i.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true。这里 ok 可以被认为是：i 接口是否实现 T 类型的结果。</p>
<h3 id="将接口转换为其他接口"><a href="#将接口转换为其他接口" class="headerlink" title="将接口转换为其他接口"></a>将接口转换为其他接口</h3><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p>
<p>鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的 Fly() 和 Walk() 方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。</p>
<p>将鸟和猪的实例创建后，被保存到 interface{} 类型的 map 中。interface{} 类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的 interface{} 变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回 false。例如下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var obj interface = new(bird)</span><br><span class="line">f, isFlyer := obj.(Flyer)</span><br></pre></td></tr></tbody></table></figure>
<p>代码中，new(bird) 产生 <code>*bird</code> 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。</p>
<p>下面是详细的代码（代码1）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义飞行动物接口</span><br><span class="line">type Flyer interface {</span><br><span class="line">    Fly()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义行走动物接口</span><br><span class="line">type Walker interface {</span><br><span class="line">    Walk()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义鸟类</span><br><span class="line">type bird struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现飞行动物接口</span><br><span class="line">func (b *bird) Fly() {</span><br><span class="line">    fmt.Println("bird: fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为鸟添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (b *bird) Walk() {</span><br><span class="line">    fmt.Println("bird: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义猪</span><br><span class="line">type pig struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为猪添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (p *pig) Walk() {</span><br><span class="line">    fmt.Println("pig: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建动物的名字到实例的映射</span><br><span class="line">    animals := map[string]interface{}{</span><br><span class="line">        "bird": new(bird),</span><br><span class="line">        "pig":  new(pig),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历映射</span><br><span class="line">    for name, obj := range animals {</span><br><span class="line"></span><br><span class="line">        // 判断对象是否为飞行动物</span><br><span class="line">        f, isFlyer := obj.(Flyer)</span><br><span class="line">        // 判断对象是否为行走动物</span><br><span class="line">        w, isWalker := obj.(Walker)</span><br><span class="line"></span><br><span class="line">        fmt.Printf("name: %s isFlyer: %v isWalker: %v\n", name, isFlyer, isWalker)</span><br><span class="line">        // 如果是飞行动物则调用飞行动物接口</span><br><span class="line">        if isFlyer {</span><br><span class="line">            f.Fly()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 如果是行走动物则调用行走动物接口</span><br><span class="line">        if isWalker {</span><br><span class="line">            w.Walk()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行定义了飞行动物的接口。</li>
<li>第 11 行定义了行走动物的接口。</li>
<li>第 16 和 30 行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。</li>
<li>第 41 行是一个 map，映射对象名字和对象实例，实例是鸟和猪。</li>
<li>第 47 行开始遍历 map，obj 为 interface{} 接口类型。</li>
<li>第 50 行中，使用类型断言获得 f，类型为 Flyer 及 isFlyer 的断言成功的判定。</li>
<li>第 52 行中，使用类型断言获得 w，类型为 Walker 及 isWalker 的断言成功的判定。</li>
<li>第 57 和 62 行，根据飞行动物和行走动物两者是否断言成功，调用其接口。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name: pig isFlyer: false isWalker: true</span><br><span class="line">pig: walk</span><br><span class="line">name: bird isFlyer: true isWalker: true</span><br><span class="line">bird: fly</span><br><span class="line">bird: walk</span><br></pre></td></tr></tbody></table></figure>
<h3 id="将接口转换为其他类型"><a href="#将接口转换为其他类型" class="headerlink" title="将接口转换为其他类型"></a>将接口转换为其他类型</h3><p>在代码 1 中，可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 <code>*pig</code> 类型，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*pig)</span><br><span class="line"></span><br><span class="line">fmt.Printf("p1=%p p2=%p", p1, p2)</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明如下：</p>
<ul>
<li>第 3 行，由于 pig 实现了 Walker 接口，因此可以被隐式转换为 Walker 接口类型保存于 a 中。</li>
<li>第 4 行，由于 a 中保存的本来就是 <code>*pig</code> 本体，因此可以转换为 <code>*pig</code> 类型。</li>
<li>第 6 行，对比发现，p1 和 p2 指针是相同的。</li>
</ul>
<p>如果尝试将上面这段代码中的 Walker 类型的 a 转换为 <code>*bird</code> 类型，将会发出运行时错误，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*bird)</span><br></pre></td></tr></tbody></table></figure>
<p>运行时报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: interface conversion: main.Walker is *main.pig, not *main.bird</span><br></pre></td></tr></tbody></table></figure>
<p>报错意思是：接口转换时，main.Walker 接口的内部保存的是 <code>*main.pig</code> ，而不是 <code>*main.bird</code> 。</p>
<p>因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p>
<p><strong>总结:</strong></p>
<p>接口和其他类型的转换可以在Go语言中自由进行，前提是已经完全实现。</p>
<p>接口断言类似于流程控制中的 if。但大量类型断言出现时，应使用更为高效的类型分支 switch 特性。</p>
<h2 id="空接口类型（interface-）"><a href="#空接口类型（interface-）" class="headerlink" title="空接口类型（interface{}）"></a>空接口类型（interface{}）</h2><p>空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。</p>
<p><strong>提示:</strong></p>
<p>空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。</p>
<p>空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。</p>
<h3 id="将值保存到空接口"><a href="#将值保存到空接口" class="headerlink" title="将值保存到空接口"></a>将值保存到空接口</h3><p>空接口的赋值如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var any interface{}</span><br><span class="line"></span><br><span class="line">any = 1</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = "hello"</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = false</span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">hello</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 1 行，声明 any 为 interface{} 类型的变量。</li>
<li>第 3 行，为 any 赋值一个整型 1。</li>
<li>第 4 行，打印 any 的值，提供给 fmt.Println 的类型依然是 interface{}。</li>
<li>第 6 行，为 any 赋值一个字符串 hello。此时 any 内部保存了一个字符串。但类型依然是 interface{}。</li>
<li>第 9 行，赋值布尔值。</li>
</ul>
<h3 id="从空接口获取值"><a href="#从空接口获取值" class="headerlink" title="从空接口获取值"></a>从空接口获取值</h3><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明a变量, 类型int, 初始值为1</span><br><span class="line">var a int = 1</span><br><span class="line"></span><br><span class="line">// 声明i变量, 类型为interface{}, 初始值为a, 此时i的值变为1</span><br><span class="line">var i interface{} = a</span><br><span class="line"></span><br><span class="line">// 声明b变量, 尝试赋值i</span><br><span class="line">var b int = i</span><br></pre></td></tr></tbody></table></figure>
<p>第8行代码编译报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot use i (type interface {}) as type int in assignment: need type assertion</span><br></pre></td></tr></tbody></table></figure>
<p>编译器告诉我们，不能将i变量视为int类型赋值给b。</p>
<p>在代码第 5 行中，将 a 的值赋值给 i 时，虽然 i 在赋值完成后的内部值为 int，但 i 还是一个 interface{} 类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。</p>
<p>为了让第 8 行的操作能够完成，编译器提示我们得使用 <code>type assertion</code> ，意思就是类型断言。</p>
<p>使用类型断言修改第 8 行代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var b int = i.(int)</span><br></pre></td></tr></tbody></table></figure>
<p>修改后，代码可以编译通过，并且 b 可以获得 i 变量保存的 a 变量的值：1。</p>
<h3 id="空接口的值比较"><a href="#空接口的值比较" class="headerlink" title="空接口的值比较"></a>空接口的值比较</h3><p>空接口在保存不同的值后，可以和其他变量值一样使用 <code>==</code> 进行比较操作。空接口的比较有以下几种特性。</p>
<p>1)类型不同的空接口间的比较结果不相同</p>
<p>保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// a保存整型</span><br><span class="line">var a interface{} = 100</span><br><span class="line"></span><br><span class="line">// b保存字符串</span><br><span class="line">var b interface{} = "hi"</span><br><span class="line"></span><br><span class="line">// 两个空接口不相等</span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>2)不能比较空接口中的动态值</p>
<p>当接口中保存有动态类型的值时，运行时将触发错误，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// c保存包含10的整型切片</span><br><span class="line">var c interface{} = []int{10}</span><br><span class="line"></span><br><span class="line">// d保存包含20的整型切片</span><br><span class="line">var d interface{} = []int{20}</span><br><span class="line"></span><br><span class="line">// 这里会发生崩溃</span><br><span class="line">fmt.Println(c == d)</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行到第8行时发生崩溃：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: runtime error: comparing uncomparable type []int</span><br></pre></td></tr></tbody></table></figure>
<p>这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。</p>
<table>
    <thead><tr><th>类  型</th><th>说  明</th></tr></thead>
    <tbody>
        <tr><th>map</th><th>宕机错误，不可比较</th></tr>
        <tr><th>切片（[]T）</th><th>宕机错误，不可比较</th></tr>
        <tr><th>通道（channel）</th><th>可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false</th></tr>
        <tr><th>数组（[容量]T）</th><th>可比较，编译期知道两个数组是否一致</th></tr>
        <tr><th>结构体</th><th>可比较，可以逐个比较结构体的值</th></tr>
         <tr><th>函数</th><th>可比较</th></tr>
    </tbody>
</table>

<h2 id="使用空接口实现可以保存任意值的字典"><a href="#使用空接口实现可以保存任意值的字典" class="headerlink" title="使用空接口实现可以保存任意值的字典"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/85.html">使用空接口实现可以保存任意值的字典</a></h2><p>空接口可以保存任何类型这个特性可以方便地用于容器的设计。下面例子使用 map 和 interface{} 实现了一个字典。字典在其他语言中的功能和 map 类似，可以将任意类型的值做成键值对保存，然后进行找回、遍历操作。详细实现过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{} // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line"></span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 遍历所有的键值，如果回调返回值为false，停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型，并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出很贵</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出很便宜</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="值设置和获取"><a href="#值设置和获取" class="headerlink" title="值设置和获取"></a>值设置和获取</h3><p>字典内部拥有一个 data 字段，其类型为 map。这个 map 的键和值都是 interface{} 类型，也就是实现任意类型关联任意类型。字典的值设置和获取通过 Set() 和 Get() 两个方法来完成，参数都是 interface{}。详细实现代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{}  // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，Dictionary 的内部实现是一个键值均为 interface{} 类型的 map，map 也具备与 Dictionary 一致的功能。</li>
<li>第 8 行，通过 map 直接获取值，如果键不存在，将返回 nil。</li>
<li>第 13 行，通过 map 设置键值。</li>
</ul>
<h3 id="遍历字段的所有键值关联数据"><a href="#遍历字段的所有键值关联数据" class="headerlink" title="遍历字段的所有键值关联数据"></a>遍历字段的所有键值关联数据</h3><p>每个容器都有遍历操作。遍历时，需要提供一个回调返回需要遍历的数据。为了方便在必要时终止遍历操作，可以将回调的返回值设置为 bool 类型，外部逻辑在回调中不需要遍历时直接返回 false 即可终止遍历。</p>
<p>Dictionary 的 Visit() 方法需要传入回调函数，回调函数的类型为 <code>func(k,v interface{}) bool</code>。每次遍历时获得的键值关联数据通过回调函数的 k 和 v 参数返回。Visit 的详细实现请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 遍历所有的键值, 如果回调返回值为false, 停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义回调，类型为 <code>func(k,v interface{}) bool</code>，意思是返回键值数据（k、v）。bool 表示遍历流程控制，返回 true 时继续遍历，返回 false 时终止遍历。</li>
<li>第 4 行，当 callback 为空时，退出遍历，避免后续代码访问空的 callback 而导致的崩溃。</li>
<li>第 8 行，遍历字典结构的 data 成员，也就是遍历 map 的所有元素。</li>
<li>第 9 行，根据 callback 的返回值，决定是否继续遍历。</li>
</ul>
<h3 id="初始化和清除"><a href="#初始化和清除" class="headerlink" title="初始化和清除"></a>初始化和清除</h3><p>字典结构包含有 map，需要在创建 Dictionary 实例时初始化 map。这个过程通过 Dictionary 的 Clear() 方法完成。在 NewDictionary 中调用 Clear() 方法避免了 map 初始化过程的代码重复问题。请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，map 没有独立的复位内部元素的操作，需要复位元素时，使用 make 创建新的实例。Go语言的垃圾回收是并行的，不用担心 map 清除的效率问题。</li>
<li>第 7 行，实例化一个 Dictionary。</li>
<li>第 11 行，在初始化时调用 Clear 进行 map 初始化操作。</li>
</ul>
<h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>字典实现完成后，需要经过一个测试过程，查看这个字典是否存在问题。</p>
<p>将一些字符串和数值组合放入到字典中，然后再从字典中根据键查询出对应的值，接着再遍历一个字典中所有的元素。详细实现过程请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型, 并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出“很贵”</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出“很便宜”</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行创建字典的实例。</li>
<li>第 7～9 行，将 3 组键值对通过字典的 Set() 方法设置到字典中。</li>
<li>第 12 行，根据字符串键查找值，将结果保存在 favorite 中。</li>
<li>第 13 行，打印 favorite 的值。</li>
<li>第 16 行，遍历字典的所有键值对。遍历的返回数据通过回调提供，key 是键，value 是值。</li>
<li>第 19 行，遍历返回的 key 和 value 的类型都是 interface{}，这里确认 value 只有 int 类型，所以将 value 转换为 int 类型判断是否大于 40。</li>
<li>第 23 和 29 行，继续遍历，返回 true</li>
<li>第 23 行，打印键。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">favorite: 36</span><br><span class="line">My Factory is expensive</span><br><span class="line">Terra Craft is cheap</span><br><span class="line">Don't Hungry is cheap</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类型分支（switch判断空接口中变量的类型）"><a href="#类型分支（switch判断空接口中变量的类型）" class="headerlink" title="类型分支（switch判断空接口中变量的类型）"></a>类型分支（switch判断空接口中变量的类型）</h2><p>type-switch 流程控制的语法或许是Go语言中最古怪的语法。 它可以被看作是类型断言的增强版。它和 switch-case 流程控制代码块有些相似。 一个 type-switch 流程控制代码块的语法如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">switch t := areaIntf.(type) {</span><br><span class="line">case *Square:</span><br><span class="line">    fmt.Printf("Type Square %T with value %v\n", t, t)</span><br><span class="line">case *Circle:</span><br><span class="line">    fmt.Printf("Type Circle %T with value %v\n", t, t)</span><br><span class="line">case nil:</span><br><span class="line">    fmt.Printf("nil value: nothing to check?\n")</span><br><span class="line">default:</span><br><span class="line">    fmt.Printf("Unexpected type %T\n", t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Type Square *main.Square with value &amp;{5}</span><br></pre></td></tr></tbody></table></figure>
<p>变量 t 得到了 areaIntf 的值和类型， 所有 case 语句中列举的类型（nil 除外）都必须实现对应的接口，如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。</p>
<p>如果跟随在某个 case 关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值 x 的（接口）类型。</p>
<h3 id="类型断言的书写格式"><a href="#类型断言的书写格式" class="headerlink" title="类型断言的书写格式"></a>类型断言的书写格式</h3><p>switch 实现类型分支时的写法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">switch 接口变量.(type) {</span><br><span class="line">    case 类型1:</span><br><span class="line">        // 变量是类型1时的处理</span><br><span class="line">    case 类型2:</span><br><span class="line">        // 变量是类型2时的处理</span><br><span class="line">    …</span><br><span class="line">    default:</span><br><span class="line">        // 变量不是所有case中列举的类型时的处理</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>接口变量：表示需要判断的接口类型的变量。</li>
<li>类型1、类型2……：表示接口变量可能具有的类型列表，满足时，会指定 case 对应的分支进行处理。</li>
</ul>
<h3 id="使用类型分支判断基本类型"><a href="#使用类型分支判断基本类型" class="headerlink" title="使用类型分支判断基本类型"></a>使用类型分支判断基本类型</h3><p>下面的例子将一个 interface{} 类型的参数传给 printType() 函数，通过 switch 判断 v 的类型，然后：打印对应类型的提示，代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printType(v interface{}) {</span><br><span class="line"></span><br><span class="line">    switch v.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(v, "is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(v, "is string")</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Println(v, "is bool")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    printType(1024)</span><br><span class="line">    printType("pig")</span><br><span class="line">    printType(true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1024 is int</span><br><span class="line">pig is string</span><br><span class="line">true is bool</span><br></pre></td></tr></tbody></table></figure>
<p>代码第 9 行中，<code>v.(type)</code> 就是类型分支的典型写法。通过这个写法，在 switch 的每个 case 中写的将是各种类型分支。</p>
<p>代码经过 switch 时，会判断 v 这个 interface{} 的具体类型从而进行类型分支跳转。</p>
<p>switch 的 default 也是可以使用的，功能和其他的 switch 一致。</p>
<h3 id="使用类型分支判断接口类型"><a href="#使用类型分支判断接口类型" class="headerlink" title="使用类型分支判断接口类型"></a>使用类型分支判断接口类型</h3><p>多个接口进行类型断言时，可以使用类型分支简化判断过程。</p>
<p>现在电子支付逐渐成为人们普遍使用的支付方式，电子支付相比现金支付具备很多优点。例如，电子支付能够刷脸支付，而现金支付容易被偷等。使用类型分支可以方便地判断一种支付方法具备哪些特性，具体请参考下面的代码。</p>
<p>电子支付和现金支付：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 电子支付方式</span><br><span class="line">type Alipay struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Alipay添加CanUseFaceID()方法, 表示电子支付方式支持刷脸</span><br><span class="line">func (a *Alipay) CanUseFaceID() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 现金支付方式</span><br><span class="line">type Cash struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Cash添加Stolen()方法, 表示现金支付方式会出现偷窃情况</span><br><span class="line">func (a *Cash) Stolen() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备刷脸特性的接口</span><br><span class="line">type CantainCanUseFaceID interface {</span><br><span class="line">    CanUseFaceID()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备被偷特性的接口</span><br><span class="line">type ContainStolen interface {</span><br><span class="line">    Stolen()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印支付方式具备的特点</span><br><span class="line">func print(payMethod interface{}) {</span><br><span class="line">    switch payMethod.(type) {</span><br><span class="line">    case CantainCanUseFaceID:  // 可以刷脸</span><br><span class="line">        fmt.Printf("%T can use faceid\n", payMethod)</span><br><span class="line">    case ContainStolen:  // 可能被偷</span><br><span class="line">        fmt.Printf("%T may be stolen\n", payMethod)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用电子支付判断</span><br><span class="line">    print(new(Alipay))</span><br><span class="line"></span><br><span class="line">    // 使用现金判断</span><br><span class="line">    print(new(Cash))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6～19 行，分别定义 Alipay 和 Cash 结构，并为它们添加具备各自特点的方法。</li>
<li>第 22～29 行，定义两种特性，即刷脸和被偷。</li>
<li>第 32 行，传入支付方式的接口。</li>
<li>第 33 行，使用类型分支进行支付方法的特性判断。</li>
<li>第 34～37 行，分别对刷脸和被偷的特性进行打印。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">*main.Alipay can use faceid</span><br><span class="line">*main.Cash may be stolen</span><br></pre></td></tr></tbody></table></figure>
<h2 id="error接口：返回错误信息"><a href="#error接口：返回错误信息" class="headerlink" title="error接口：返回错误信息"></a>error接口：返回错误信息</h2><p>错误处理在每个编程语言中都是一项重要内容，通常开发中遇到的分为异常与错误两种，Go语言中也不例外。本节我们主要来学习一下Go语言中的错误处理。</p>
<p>在C语言中通过返回 -1 或者 NULL 之类的信息来表示错误，但是对于使用者来说，如果不查看相应的 API 说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如返回 0 是成功还是失败？</p>
<p>针对这样的情况，Go语言中引入 error 接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含 error。error 处理过程类似于C语言中的错误码，可逐层返回，直到被处理。</p>
<h3 id="error-基本用法"><a href="#error-基本用法" class="headerlink" title="error 基本用法"></a>error 基本用法</h3><p>Go语言中返回的 error 类型究竟是什么呢？查看Go语言的源码就会发现 error 类型是一个非常简单的接口类型，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// The error built-in interface type is the conventional interface for</span><br><span class="line">// representing an error condition, with the nil value representing no error.</span><br><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>error 接口有一个签名为 Error() string 的方法，所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述，在使用 fmt.Println 打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。</p>
<p>一般情况下，如果函数需要返回错误，就将 error 作为多个返回值中的最后一个（但这并非是强制要求）。</p>
<p>创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, errors.New("math: square root of negative number")</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">math: square root of negative number</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中简单介绍了使用 errors.New 来返回一个错误信息，与其他语言的异常相比，Go语言的方法相对更加容易、直观。</p>
<h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>除了上面的 errors.New 用法之外，我们还可以使用 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type dualError struct {</span><br><span class="line">    Num     float64</span><br><span class="line">    problem string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (e dualError) Error() string {</span><br><span class="line">    return fmt.Sprintf("Wrong!!!,because \"%f\" is a negative number", e.Num)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, dualError{Num: f}</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Wrong!!!,because "-13.000000" is a negative number</span><br></pre></td></tr></tbody></table></figure>
<h2 id="接口内部实现"><a href="#接口内部实现" class="headerlink" title="接口内部实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5116.html">接口内部实现</a></h2><p>前几节我们介绍了接口的基本概念和用法，定义接口只需简单声明一个方法集合即可，定义新类型时不需要显式地声明要实现的接口，接口的使用也很简单。</p>
<p>那么接口的底层是如何实现的呢？如何实现动态调用的呢？接口的动态调用到底有多大的额外开销？本节我们就来深入讲解一下接口的底层实现。</p>
<p>阅读本节需要读者了解Go语言接口的基础知识和Go语言汇编基础和函数调用规约，以及对 ELF 可执行文件格式有基本了解。本节内容有点偏底层，有一定的难度，如果阅读起来有困难，可以先跳过去，有时间再慢慢读。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a></h3><p>从前面章节了解到，接口变量必须初始化才有意义，没有初始化的接口变量的默认值是 nil，没有任何意义。具体类型实例传递给接口称为接口的实例化。在接口的实例化的过程中，编译器通过特定的数据结构描述这个过程。</p>
<p>首先介绍非空接口的内部数据结构，空接口的底层更简单，放到最后介绍。非空接口的底层数据结构是 iface，代码位于Go语言安装目录的 <code>src/runtime/runtime2.go</code> 文件中。</p>
<h4 id="iface-数据结构"><a href="#iface-数据结构" class="headerlink" title="iface 数据结构"></a>iface 数据结构</h4><p>非空接口初始化的过程就是初始化一个 iface 类型的结构，示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type iface struct {</span><br><span class="line">    tab *itab                //itab 存放类型及方法指针信息</span><br><span class="line">    data unsafe.Pointer      //数据信息</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到 iface 结构很简单，有两个指针类型字段。</p>
<ul>
<li>itab：用来存放接口自身类型和绑定的实例类型及实例相关的函数指针，具体内容后面有详细介绍。</li>
<li>数据指针 data：指向接口绑定的实例的副本，接口的初始化也是一种值拷贝。</li>
</ul>
<p>data 指向具体的实例数据，如果传递给接口的是值类型，则 data 指向的是实例的副本；如果传递给接口的是指针类型，则 data 指向指针的副本。总而言之，无论接口的转换，还是函数调用，Go 遵循一样的规则——值传递。</p>
<p>接下来看一下 itab 数据结构，itab 是接口内部实现的核心和基础。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype      //接口自身的静态类型</span><br><span class="line">    _type *_type              //_type 就是接口存放的具体实例的类型（动态类型）</span><br><span class="line">    //hash 存放具体类型的 Hash 值</span><br><span class="line">    hash uint32               // copy of _type.hash. Used for type switches.</span><br><span class="line">    _   [4]byte</span><br><span class="line">    fun [1]uintptr            // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>itab 有 5 个字段：</p>
<ul>
<li>inter：是指向接口类型元信息的指针。</li>
<li>_type：是指向接口存放的具体类型元信息的指针，iface 里的 data 指针指向的是该类型的值。一个是类型信息，另一个是类型的值。</li>
<li>hash：是具体类型的 Hash 值，_type 里面也有 hash，这里冗余存放主要是为了接口断言或类型查询时快速访问。</li>
<li>fun：是一个函数指针，可以理解为 C++ 对象模型里面的虚拟函数指针，这里虽然只有一个元素，实际上指针数组的大小是可变的，编译器负责填充，运行时使用底层指针进行访问，不会受 struct 类型越界检查的约束，这些指针指向的是具体类型的方法。</li>
</ul>
<p>itab 这个数据结构是非空接口实现动态调用的基础，itab 的信息被编译器和链接器保存了下来，存放在可执行文件的只读存储段（ <code>.rodata</code> ）中。itab 存放在静态分配的存储空间中，不受 GC 的限制，其内存不会被回收。</p>
<p>接下来介绍 <code>_type</code> 数据结构，Go语言是一种强类型的语言，编译器在编译时会做严格的类型校验。所以 Go 必然为每种类型维护一个类型的元信息，这个元信息在运行和反射时都会用到，Go语言的类型元信息的通用结构是 <code>_type</code>（代码位于 <code>src/runtime/type.go</code>）， 其他类型都是以 <code>_type</code> 为内嵌宇段封装而成的结构体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">type type struct {</span><br><span class="line">    size uintptr     // 大小</span><br><span class="line">    ptrdata uintptr  //size of memory prefix holding all pointers</span><br><span class="line">    hash uint32      //类型Hash</span><br><span class="line">    tflag tflag      //类型的特征标记</span><br><span class="line">    align uint8      //_type 作为整体交量存放时的对齐字节数</span><br><span class="line">    fieldalign uint8 //当前结构字段的对齐字节数</span><br><span class="line">    kind uint8       //基础类型枚举值和反射中的 Kind 一致，kind 决定了如何解析该类型</span><br><span class="line">    alg *typeAlg     //指向一个函数指针表，该表有两个函数，一个是计算类型 Hash 函</span><br><span class="line">                     //数，另一个是比较两个类型是否相同的 equal 函数</span><br><span class="line">    //gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    //If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    //Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata *byte      //GC 相关信息</span><br><span class="line">    str nameOff       //str 用来表示类型名称字符串在编译后二进制文件中某个 section</span><br><span class="line">                      //的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">    ptrToThis typeOff //ptrToThis 用来表示类型元信息的指针在编译后二进制文件中某个</span><br><span class="line">                      //section 的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>_type</code> 包含所有类型的共同元信息，编译器和运行时可以根据该元信息解析具体类型、类型名存放位置、类型的 Hash 值等基本信息。</p>
<p>这里需要说明一下：<code>＿type</code> 里面的 nameOff 和 typeOff 最终是由链接器负责确定和填充的，它们都是一个偏移量（offset），类型的名称和类型元信息实际上存放在连接后可执行文件的某个段（section）里，这两个值是相对于段内的偏移量，运行时提供两个转换查找函数。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">//获取 _type 的 name</span><br><span class="line">func resolveNameOff(ptrInModule unsafe.Pointer , off nameOff) name {}</span><br><span class="line">//获取 _type 的副本</span><br><span class="line">func resolveTypeOff(ptrInModule unsafe.Pointer , off typeOff) *_type {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：Go语言类型元信息最初由编译器负责构建，并以表的形式存放在编译后的对象文件中，再由链接器在链接时进行段合并、符号重定向（填充某些值）。这些类型信息在接口的动态调用和反射中被运行时引用。</em></strong></p>
<p>接下来看一下接口的类型元信息的数据结构。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//描述接口的类型</span><br><span class="line">type interfacetype struct {</span><br><span class="line">    typ _type       //类型通用部分</span><br><span class="line">    pkgpath name    //接口所属包的名字信息， name 内存放的不仅有名称，还有描述信息</span><br><span class="line">    mhdr []imethod  //接口的方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//接口方法元信息</span><br><span class="line">type imethod struct {</span><br><span class="line">    name nameOff //方法名在编译后的 section 里面的偏移量</span><br><span class="line">    ityp typeOff //方法类型在编译后的 section 里面的偏移量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口调用过程分析"><a href="#接口调用过程分析" class="headerlink" title="接口调用过程分析"></a>接口调用过程分析</h3><p>前面讨论了接口内部的基本数据结构，下面就来通过跟踪接口实例化和动态调用过程，使用 Go 源码和反汇编代码相结合的方式进行研究。下面是一段非常简单的接口调用代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//iface.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Caler interface {</span><br><span class="line">    Add (a , b int) int</span><br><span class="line">    Sub (a , b int) int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Adder struct ｛id int }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int) int { return a + b }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a , b int) int { return a - b }</span><br><span class="line"></span><br><span class="line">func main () {</span><br><span class="line">    var m Caler=Adder{id: 1234}</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成汇编代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go build -gcflags= "-S - N -l" iface.go &gt;iface.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>接下来分析 main 函数的汇编代码，非关键逻辑已经去掉：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"".main STEXT size=151 args=0x0 locals=0x40</span><br><span class="line">    ...</span><br><span class="line">    0x000f 00015 (src/iface.go:16) SUBQ $64, SP</span><br><span class="line">    0x0013 00019 (src/iface.go:16) MOVQ BP, 56(SP)</span><br><span class="line">    0x0018 00024 (src/iface.go:16) LEAQ 56(SP), BP</span><br></pre></td></tr></tbody></table></figure>
<p>为 main 函数堆栈开辟空间并保存原来的 BP 指针，这是函数调用前编译器的固定动作。</p>
<p>var m Caler = Adder {id: 1234} 语句汇编代码分析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x00ld 00029 (src/iface.go:17) MOVQ    $0, ""..autotmp_1+32(SP)</span><br><span class="line">0x0026 00038 (src/iface.go:17) MOVQ    $1234, ""..autotmp_1+32(SP)</span><br></pre></td></tr></tbody></table></figure>
<p>在堆上初始化局部对象 Adder，先初始化为 0，后初始化为 1234。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x002f 00047 (src/iface.go:17) LEAQ    go.itab."".Adder,"".Caler(SB),AX</span><br><span class="line">0x0036 00054 (src/iface.go:17) MOVQ    AX, (SP)</span><br></pre></td></tr></tbody></table></figure>
<p>这两条语句非常关键，首先 LEAQ 指令是一个获取地址的指令，<code>go.itab."".Adder,"".Caler(SB)</code> 是一个全局符号引用，通过该符号能够获取接口初始化时 itab 数据结构的地址。</p>
<p>注意：这个标号在链接器链接的过程中会替换为具体的地址。我们知道 (SP) 里面存放的是指向 <code>itab(Caler,Adder)</code> 的元信息的地址，这里 (SP) 是函数调用第一个参数的位置。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x003a 00058 (src/iface.go:17) LEAQ ""..autotmp_1+32(SP), AX</span><br><span class="line">0x003f 00063 (src/iface.go:17) MOVQ AX, 8(SP)</span><br><span class="line">0x0044 00068 (src/iface.go:17) PCDATA $0, $0</span><br></pre></td></tr></tbody></table></figure>
<p>复制刚才的 Adder 类型对象的地址到 8(SP)，8(SP) 是函数调用的第二个参数位置。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x0044 00068 (src/iface.go:17) CALL    runtime.convT2I64(SB)</span><br></pre></td></tr></tbody></table></figure>
<p>runtime.convT2I64 函数是运行时接口动态调用的核心函数。runtime 中有一类这样的函数，看一下 runtime.convT2I64 的源码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {</span><br><span class="line">    t := tab._type</span><br><span class="line">    if raceenabled {</span><br><span class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I64))</span><br><span class="line">    }</span><br><span class="line">    if msanenabled {</span><br><span class="line">        msanread (elem, t.size)</span><br><span class="line">    }</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(uint64) (elem) == 0 {</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    } else {</span><br><span class="line">        x = mallocgc(8, t, false)</span><br><span class="line">        *(*uint64) (x) = *(*uint64) (elem)</span><br><span class="line">    }</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上述源码可以清楚地看出，<code>runtime.convT2I64</code> 的两个参数分别是 <code>*itab</code> 和 <code>unsafe.Pointer</code> 类型，这两个参数正是上文传递进去的两个参数值：<code>go.itab."".Adder, "".Caler(SB)</code> 和指向 Adder 对象复制的指针。</p>
<p><code>runtime.convT2I64</code> 的返回值是一个 iface 数据结构，其意义就是根据 itab 元信息和对象值复制的指针构建和初始化 iface 数据结构，iface 数据结构是实现接口动态调用的关键。至此己经完成了接口初始化的工作，即完成了 iface 数据结构的构建过程。下一步就是接口方法调用了。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x0049 00073 (src/iface.go:17) MOVQ 24(SP), AX</span><br><span class="line">0x004e 00078 (src/iface.go:17) MOVQ 16(SP), CX</span><br><span class="line">0x0053 00083 (src/iface.go:17 ) MOVQ CX, "".m+40(SP)</span><br><span class="line">0x0058 00088 (src/iface.go:17 ) MOVQ AX, "".m+48(SP)</span><br></pre></td></tr></tbody></table></figure>
<p>16(SP) 和 24(SP) 存放的是函数 runtime.convT2I64 的返回值，分别是指向 itab 和 data 的指针，将指向 itab 的指针复制到 40(SP)，将指向对象 data 的指针复制到 48(SP) 位置。</p>
<p>m.Add(10, 32) 对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x00Sd 00093 (src/iface.go:18) MOVQ "".m+40(SP), AX</span><br><span class="line">0x0062 00098 (src/iface.go:18) MOVQ 32(AX), AX</span><br><span class="line">0x0066 00102 (src/iface.go:18) MOVQ "".m+48(SP), ex</span><br><span class="line">0x006b 00107 (src/iface.go:18) MOVQ $10, 8(SP)</span><br><span class="line">0x0074 00116 (src/iface.go:18) MOVQ $32, 16(SP)</span><br><span class="line">0x007d 00125 (src/iface.go:18) MOVQ CX, (SP)</span><br><span class="line">0x0081 00129 (src/iface.go:18) PCDATA $0, $0</span><br><span class="line">0x0081 00129 (src/iface.go:18) CALL AX</span><br></pre></td></tr></tbody></table></figure>
<p>第 1 条指令是将 itab 的指针（位于 40(SP)）复制到 AX 寄存器。第 2 条指令是 AX 将 itab 的偏移 32 字节的值复制到 AX。再来看一下 itab 的数据结构：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *type</span><br><span class="line">    link *itab</span><br><span class="line">    hash uint32 //copy of _type.hash.Used for type switches.</span><br><span class="line">    bad bool    //type does not implement interface</span><br><span class="line">    inhash bool //has this itab been added to hash?</span><br><span class="line">    unused [2]byte</span><br><span class="line">    fun [1] uintptr //variable sized</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>32(AX) 正好是函数指针的位置， 即存放 <code>Adder *Add()</code> 方法指针的地址（注意：编译器将接收者为值类型的 Add 方法转换为指针的 Add 方法，编译器的这种行为是为了方便调用和优化）。</p>
<p>第 3 条指令和第 6 条指令是将对象指针作为接下来函数调用的第 1 个参数。</p>
<p>第 4 条和第 5 条指令是准备函数的第 2、第 3 个参数。</p>
<p>第 8 条指令是调用 Adder 类型的 Add 方法。</p>
<p>此函数调用时，对象的值的副本作为第 1 个参数，调用格式可以表述为 <code>func(reciver, param1, param2)</code>。</p>
<p>至此，整个接口的动态调用完成。从中可以清楚地看到，接口的动态调用分为两个阶段：</p>
<ul>
<li>第一阶段就是构建 iface 动态数据结构，这一阶段是在接口实例化的时候完成的，映射到 Go 语句就是 <code>var m Caler = Adder{id: 1234}</code>。</li>
<li>第二阶段就是通过函数指针间接调用接口绑定的实例方法的过程，映射到 Go 语句就是 <code>m.Add(10, 32)</code> 。</li>
</ul>
<p>接下来看一下 <code>go.itab. "".Adder, "".Caler(SB)</code> 这个符号在哪里？我们使用 readelf 工具来静态地分析编译后的 ELF 格式的可执行程序。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line">#go build -gcflag s= "-N -l" iface.go</span><br><span class="line">#readelf -s -W iface legrep 'itab'</span><br><span class="line">    60:000000000047b220 0 OBJECT LOCAL DEFAULT 5 runtime.itablink</span><br><span class="line">    61:000000000047b230 0 OBJECT LOCAL DEFAULT 5 runtime.eitablink</span><br><span class="line">    88:00000000004aa100 48 OBJECT GLOBAL DEFAULT 8 go.itab.main.Adder, main.Caler</span><br><span class="line">    214:00000000004aa080 40 OBJECT GLOBAL DEFAULT 8 go.itab.runtime.errorString, error</span><br><span class="line">    418:00000000004095e0 1129 FUNC GLOBAL DEFAULT 1 runtime.getitab</span><br><span class="line">    419:0000000000409a50 1665 FUNC GLOBAL DEFAULT 1 runtime.additab</span><br><span class="line">    420:000000000040a0e0 257 FUNC GLOBAL DEFAULT 1 runtime.itabsinit</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到符号表里面 <code>go.itab.main.Adder, main.Caler</code> 对应本程序里面 itab 的元信息，它被存放在第 8 个段中。我们来看一下第 8 个段是什么段？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#readelf -S -W iface |egrep '＼[8\] | I Nr'</span><br><span class="line">[Nr] Name Type Address Off Size ES Flg Lk Inf Al</span><br><span class="line">[8]. noptrdata PROGBITS 00000000004aa000 OaaOOO 000a78 00 WA 0 0 32</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到这个接口动态转换的数据元信息存放在 .noptrdata 段中，它是由链接器负责初始化的。可以进一步使用 dd 工具读取井分析其内容，这里就不再继续深入这个细节，留给感兴趣的读者继续分析。</p>
<h3 id="接口调用代价"><a href="#接口调用代价" class="headerlink" title="接口调用代价"></a>接口调用代价</h3><p>前面讨论了接口动态调用过程，这个过程有两部分多余时耗，一个是接口实例化的过程，也就是 iface 结构建立的过程，一旦实例化后，这个接口和具体类型的 itab 数据结构是可以复用的；另一个是接口的方法调用，它是一个函数指针的间接调用。</p>
<p>同时我们应考虑到接口调用是一种动态的计算后的跳转调用，这对现代的计算机 CPU 的执行很不友好，会导致 CPU 缓存失效和分支预测失败，这也有一部分的性能损失。当然最直接的办法就是对比测试，看看接口动态调用的性能损失到底有多大。</p>
<p><strong>测试用例：</strong></p>
<p>直接选用 GitHub 上的一个测试用例，稍作改写，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "testing"</span><br><span class="line">)</span><br><span class="line">type identifier interface {</span><br><span class="line">    idInline() int32</span><br><span class="line">    idNoInline() int32</span><br><span class="line">}</span><br><span class="line">type id32 struct{ id int32 }</span><br><span class="line">func (id *id32) idinline() int32 { return id.id }</span><br><span class="line">//go:noinline</span><br><span class="line">func (id *id32) idNoinline() int32 { return id.id }</span><br><span class="line">var escapeMePlease *id32</span><br><span class="line">//主要作用是强制变量内存在 heap 上分配</span><br><span class="line">//go:noinline</span><br><span class="line">func escapeToHeap(id *id32) identifier {</span><br><span class="line">    escapeMePlease = id</span><br><span class="line">    return escapeMePlease</span><br><span class="line">}</span><br><span class="line">//直接调用</span><br><span class="line">func BenchmarkMethodCall_direct(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer ()</span><br><span class="line">        for i :＝ 0; i ＜ b.N; i++ {</span><br><span class="line">            //CALL "".(*id32).idNoinline(SB)</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "".&amp;myID+40(SP), CX</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    b.Run ("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i: ＝ 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVL (DX), SI</span><br><span class="line">            //MOVL SI, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line">//接口调用</span><br><span class="line">func BenchmarkMethodCall_interface(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N ; i++ {</span><br><span class="line">            // MOVQ 32(AX), CX</span><br><span class="line">            // MOVQ "".m.data+40(SP), DX</span><br><span class="line">            // MOVQ DX, (SP)</span><br><span class="line">            // CALL CX</span><br><span class="line">            // MOVL 8(SP), AX</span><br><span class="line">            // MOVQ "".&amp;myID+48(SP), CX</span><br><span class="line">            // MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    b.Run("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVQ 24(AX), CX</span><br><span class="line">            //MOVQ "".m.data+40(SP), DX</span><br><span class="line">            //MOVQ DX, (SP)</span><br><span class="line">            //CALL CX</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "". &amp;myID+48(SP), ex</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">} //</span><br><span class="line">func main() {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>测试过程和结果：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//直接调用</span><br><span class="line">#go test -bench= 'BenchmarkMethodCall_direct/single/noinline' -cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 2.00 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.94 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 20.682s</span><br><span class="line">//接口调用</span><br><span class="line">#go test -bench='BenchmarkMethodCall_interface/single/noinline' －cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.18 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.17 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.15 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 11.930s</span><br></pre></td></tr></tbody></table></figure>
<p><strong>结果分析：</strong></p>
<p>直接调用平均时耗为 1.97ns/op，接口调用的平均时耗为 2.16ns/op, (2.16-1.97)/1.97 约等于 9.64%。可以看到测试结果符合预期，每次迭代接口要慢 0.19ns，大约有 9% 的性能损失。</p>
<p>但是要清楚这个百分比并不能真实地反映接口的效率问题，首先调用的方法是一个很简单的方法，方法的耗时占比很小，无形中放大了接口调用的耗时。如果方法里面有复杂的逻辑，则真实的性能损失远远小于9%。</p>
<p>从绝对值的角度来看更合理，那就是每次接口调用大约比直接调用慢 0.2ns ，从这个角度看，动态调用的性能损失几乎可以忽略不计。</p>
<h3 id="空接口数据结构"><a href="#空接口数据结构" class="headerlink" title="空接口数据结构"></a>空接口数据结构</h3><p>前面我们了解到空接口 interface{} 是没有任何方法集的接口，所以空接口内部不需要维护和动态内存分配相关的数据结构 itab 。空接口只关心存放的具体类型是什么，具体类型的值是什么，所以空接口的底层数据结构也很简单，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//go/src/runtime/runtime2.go</span><br><span class="line">//空接口</span><br><span class="line">type eface struct {</span><br><span class="line">    _type *_type</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从 eface 的数据结构可以看出，空接口不是真的为空，其保留了具体实例的类型和值拷贝，即便存放的具体类型是空的，空接口也不是空的。</p>
<p>由于空接口自身没有方法集，所以空接口变量实例化后的真正用途不是接口方法的动态调用。空接口在Go语言中真正的意义是支持多态，有如下几种方式使用了空接口（将空接口类型还原）：</p>
<ul>
<li>通过接口类型断言</li>
<li>通过接口类型查询</li>
<li>通过反射</li>
</ul>
<p>至此，接口内部实现原理全部讲完，大家在了解和学习接口内部实现的知识的同时，更应该学习和思考分析过程中的方法和技巧，使用该方法可以继续分析接口断言、接口查询和接口赋值的内部实现机制。</p>
<h2 id="表达式求值器"><a href="#表达式求值器" class="headerlink" title="表达式求值器"></a>表达式求值器</h2><p>在本节中，我们将创建简单算术表达式的一个求值器。我们将使用一个接口 Expr 来代表这种语言中的任意一个表达式。现在，这个接口没有任何方法，但稍后我们会逐个添加。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Expr：算术表达式</span><br><span class="line">type Expr interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>我们的表达式语言包括浮点数字面量，二元操作符 +、-、*、/，一元操作符 -x 和 +x，函数调用 pow(x,y)、sin(x) 和 sqrt(x)，变量（比如 x 和 pi），当然，还有圆括号和标准的操作符优先级。所有的值都是 float64 类型。下面是几个示例表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">(F - 32) * 5 / 9</span><br></pre></td></tr></tbody></table></figure>
<p>下面 5 种具体类型代表特定类型的表达式。Var 代表变量应用（很快我们将了解到为什么这个类型需要导岀）。literal 代表浮点数常量。unary 和 binary 类型代表有一个或者两个操作数的操作符表达式，而操作数则可以任意的 Expr。call 代表函数调用，这里限制它的 fn 字段只能是 pow、sin 和 sqrt。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Var 表示一个变量，比如 x</span><br><span class="line">type Var string</span><br><span class="line">// literal 是一个数字常量，比如 3.141</span><br><span class="line">type literal float64</span><br><span class="line">// unary 表示一元操作符表达式，比如-x</span><br><span class="line">type unary struct {</span><br><span class="line">    op rune // '+', '-' 中的一个</span><br><span class="line">    x Expr</span><br><span class="line">}</span><br><span class="line">// binary 表示二元操作符表达式，比如 x+y</span><br><span class="line">type binary struct {</span><br><span class="line">    op rune // '+', '-', '*', '/' 中的一个</span><br><span class="line">    x, y Expr</span><br><span class="line">}</span><br><span class="line">// call 表示函数调用表达式，比如 sin(x)</span><br><span class="line">type call struct {</span><br><span class="line">    fn string // one of "pow", "sin", "sqrt" 中的一个</span><br><span class="line">    args []Expr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要对包含变量的表达式进行求值，需要一个上下文 (environment) 来把变量映射到数值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Env map[Var]float64</span><br></pre></td></tr></tbody></table></figure>
<p>我们还需要为每种类型的表达式定义一个 Eval 方法来返回表达式在一个给定上下文下的值。既然每个表达式都必须提供这个方法，那么可以把它加到 Expr 接口中。这个包只导出了类型 Expr、Env 和 Var。客户端可以在不接触其他表达式类型的情况下使用这个求值器。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    // Eval 返回表达式在 env 上下文下的值</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是具体的 Eval 方法。Var 的 Eval 方法从上下文中查询结果，如果变量不存在则返回 0 literal 的 Eval 方法则直接返冋本身的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (v Var) Eval(env Env) float64 {</span><br><span class="line">    return env[v]</span><br><span class="line">}</span><br><span class="line">func (l literal) Eval(_ Env) float64 {</span><br><span class="line">    return float64(l)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>unary 和 binary 的 Eval 方法首先对它们的操作数递归求值，然后应用 op 操作。我们不把除以 0 或者无穷大当做错误（尽管它们生成的结果显然不是有穷数）。最后，call 方法先对 pow、sin 或者 sqrt 函数的参数求值，再调用 math 包中的对应函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (u unary) Eval(env Env) float64 {</span><br><span class="line">    switch u.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return +u.x.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return -u.x.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported unary operator: %q", u.op))</span><br><span class="line">}</span><br><span class="line">func (b binary) Eval(env Env) float64 {</span><br><span class="line">    switch b.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return b.x.Eval(env) + b.y.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return b.x.Eval(env) - b.y.Eval(env)</span><br><span class="line">    case '*1:</span><br><span class="line">        return b.x.Eval(env) * b.y.Eval(env)</span><br><span class="line">    case '/':</span><br><span class="line">        return b.x.Eval(env) / b.y.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported binary operator: %q", b.op))</span><br><span class="line">}</span><br><span class="line">func (c call) Eval(env Env) float64 {</span><br><span class="line">    switch c.fn {</span><br><span class="line">    case "pow":</span><br><span class="line">        return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env)</span><br><span class="line">    case "sin":</span><br><span class="line">        return math.Sin(c.args[0].Eval(erw))</span><br><span class="line">    case "sqrt":</span><br><span class="line">        return math.Sqrt(c.args[0].Eval(env))</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported function call: %s", c.fn))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>某些方法可能会失败，比如 call 表达式可能会遇到未知的函数，或者参数数量不对。也有可能用“!”或者“&lt;”这类无效的操作符构造了一个 unary 或 binary 表达式（尽管后面的 Parse 函数不会产生这样的结果）。这些错误都会导致 Eval 崩溃。</p>
<p>其他错误（比如对一个上下文中没有定义的变量求值）仅会导致返回不正确的结果。所有这些错误都可以在求值之前做检查来发现。后面的 Check 方法就负责完成这个任务，但我们先测试 Eval。</p>
<p>下面的 TestEval 函数用于测试求值器，它使用 testing 包。我们知道调用 t.Errorf 来报告错误。这个函数遍历一个表格，表格中定义了三个表达式并为每个表达式准备了不同上下文。第一个表达式用于根据圆面积 A 求半径，第二个用于计算两个变量 x 和 y 的立方和，第三个把华氏温度 F 转为摄氏温度。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func TestEval(t *testing.T) {</span><br><span class="line">    tests := []struct {</span><br><span class="line">        expr string</span><br><span class="line">        env Env</span><br><span class="line">        want string</span><br><span class="line">    }{</span><br><span class="line">        {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": -40}, "-40"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 32}, "0"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 212}, "100"},</span><br><span class="line">    }</span><br><span class="line">    var prevExpr string</span><br><span class="line">    for _, test := range tests {</span><br><span class="line">        // 仅在表达式变更时才输出</span><br><span class="line">        if test.expr != prevExpr {</span><br><span class="line">            fmt.Printf("\n%s\n", test.expr)</span><br><span class="line">            prevExpr = test.expr</span><br><span class="line">        }</span><br><span class="line">        expr, err := Parse(test.expr)</span><br><span class="line">        if err != nil {</span><br><span class="line">            t.Error(err) // 解析出错</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        got := fmt.Sprintf("%.6g", expr.Eval(test.env))</span><br><span class="line">        fmt.Printf("\t%v =&gt; %s\n", test.env, got)</span><br><span class="line">        if got != test.want {</span><br><span class="line">            t.Errorf("%s.Eval() in %v = %q, want %q\n", test.expr, test.env, got, test.want)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于表格中的每一行记录，该测试先解析表达式，在上下文中求值，再输出表达式。这里没有足够的空间来显示 Parse 函数，但可以通过 go get 来下载源码，自行查看。</p>
<p>go test 命令可用于运行包的测试：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ go test -v gopl.io/ch7/eval</span><br></pre></td></tr></tbody></table></figure>
<p>启用 -v 选项后可以看到测试的输出，通常情况下对于结果正确的测试输出就不显示了。下面就是测试中 fmt.Printf 语句输岀的内容。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">    map[A:87616 pi:3.141592653589793] =&gt; 167</span><br><span class="line"></span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">    map[x:12 y:1] =&gt; 1729</span><br><span class="line">    map[x:9 y:10] =&gt; 1729</span><br><span class="line">5 / 9 * (F - 32)</span><br><span class="line">    map[F:-40] =&gt; -40</span><br><span class="line">    map[F:32] =&gt; 0</span><br><span class="line">    map[F:212] =&gt; 100</span><br></pre></td></tr></tbody></table></figure>
<p>幸运的是，到现在为止所有的输入都是合法的，但这种幸运是不能持久的。即使在解释性语言中，通过语法检查来发现静态错误（即不用运行程序也能检测出来的错误）也是很常见的。通过分离静态检查和动态检查，我们可以更快发现错误，也可以只在运行前检查一次，而不用在表达式求值时每次都检查。</p>
<p>让我们给 Expr 方法加上另外一个方法。Check 方法用于在表达式语法树上检查静态错误。它的 vars 参数将稍后解释。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">    // Check 方法报告表达式中的错误，并把表达式中的变量加入 Vars 中</span><br><span class="line">    Check(vars map[Var]bool) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>具体的 Check 方法如下所示。literal 和 Var 的求值不可能出错，所以 Check 方法返回 nil。unary 和 binary 的方法首先检查操作符是否合法，再递归地检查操作数。类似地，call 的方法首先检查函数是否是已知的，然后检查参数个数是否正确，最后递归检查每个参数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (v Var) Check(vars map[Var]bool) error {</span><br><span class="line">    vars[v] = true</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (literal) Check(vars map[Var]bool) error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (u unary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-", u.op) {</span><br><span class="line">        return fmt.Errorf("unexpected unary op %q", u.op)</span><br><span class="line">    }</span><br><span class="line">    return u.x.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (b binary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-*/", b.op) {</span><br><span class="line">        return fmt.Errorf("unexpected binary op %q", b.op)</span><br><span class="line">    }</span><br><span class="line">    if err := b.x.Check(vars); err != nil {</span><br><span class="line">        return err</span><br><span class="line">    }</span><br><span class="line">    return b.y.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (c call) Check(vars map[Var]bool) error {</span><br><span class="line">    arity, ok := numParams[c.fn]</span><br><span class="line">    if !ok {</span><br><span class="line">        return fmt.Errorf("unknown function %q", c.fn)</span><br><span class="line">    }</span><br><span class="line">    if len(c.args) != arity {</span><br><span class="line">        return fmt.Errorf("call to %s has %d args, want %d", c.fn, len(c.args), arity)</span><br><span class="line">    }</span><br><span class="line">    for _, arg := range c.args {</span><br><span class="line">        if err := arg.Check(vars); err != nil {</span><br><span class="line">            return err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">var numParams = map[string]int{"pow",: 2, "sin": 1, "sqrt": 1}</span><br></pre></td></tr></tbody></table></figure>
<p>下面分两列展示了一些有错误的输入，以及它们触发的错误。Parse 函数（没有显示）报告了语法错误，Check 方法报告了语义错误。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">x % 2  unexpected '%'</span><br><span class="line">math.Pi unexpected '.'</span><br><span class="line">!true  unexpected '!'</span><br><span class="line">"hello" unexpected '"'</span><br><span class="line">log(10) unknown function "log"</span><br><span class="line">sqrt(1, 2) call to sqrt has 2 args, want 1</span><br></pre></td></tr></tbody></table></figure>
<p>Check 的输入参数是一个 Ver 集合，它收集在表达中发现的变量名。要让表达式能成功求值，上下文必须包含所有的这些变量。从逻辑上来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归调用的，在这种情况下使用参数更为方便。调用方在最初调用时需要提供一个空的集合。</p>
<p>既然我们可以对字符串形式的表达式进行解析、检查和求值，那么就可以构建一个 Web 应用，在运行时从客户端接收一个表达式，并绘制函数的曲面图。可以使用 vars 集合来检查表达式是一个只有两个变量 x、y 的函数（为了简单起见，还提供了半径 r，所以实际上是 3 个变量）。使用 Check 方法来拒绝掉不规范的表达式，避免了在接下来的 40000 次求值中重复检查（4 个象限中 100 x 100 的格子）。</p>
<p>下面的 parseAndCheck 函数组合了解析和检查步骤：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "gopl.io/ch7/eval"</span><br><span class="line">func parseAndCheck(s string) (eval.Expr, error) {</span><br><span class="line">    if s == "" {</span><br><span class="line">        return nil, fmt.Errorf("empty expression")</span><br><span class="line">    }</span><br><span class="line">    expr, err := eval.Parse(s)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    vars := make(map[eval.Var]bool)</span><br><span class="line">    if err := expr.Check(vars); err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    for v := range vars {</span><br><span class="line">        if v != "x" &amp;&amp; v != "y" &amp;&amp; v != "r" {</span><br><span class="line">            return nil, fmt.Errorf("undefined variable: %s", v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return expr, nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要构造完这个 Web 应用，仅需要增加下面的 plot 函数，其函数签名与 http.HandlerFunc 类似：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func plot(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    expr, err := parseAndCheck(r.Form.Get("expr"))</span><br><span class="line">    if err != nil {</span><br><span class="line">        http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    w.Header().Set("Content-Type", "image/syg+xml")</span><br><span class="line">    surface(w, func(x, y float64) float64 {</span><br><span class="line">        r := math.Hypot(x, y)   // 与(0,0)之间的距离</span><br><span class="line">        return expr.Eval(eval.Env{"x": x, "y": y, "r" : r})</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>plot 函数解析并检查 HTTP 请求中的表达式，并用它来创建一个有两个变量的匿名函数。这个匿名函数与原始曲面图绘制程序中的f有同样的签名，且能对用户提供的表达式进行求值。上下文定义了 x、y 和半径 r。</p>
<p>最后，plot 调用了 surface 函数，surface 函数来自 gop1.io/ch3/surface 中的 main 函数，略做修改，加了参数用于接受绘制函数和输出用的 io.Writer，原始版本直接使用了函数 f 和 os.Stdout。下图显示了用这个程序绘制的三张曲面图。</p>
<p>a) <code>sin(-x)*pow(1.5, -r)</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-a.gif" alt="a"></p>
<p>b) <code>pow(2, sin(y))*pow(2, sin(x))/12</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-b.gif" alt="b"></p>
<p>c) <code>sin (x*y/10)/10</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-c.gif" alt="c"></p>
<h2 id="实现Web服务器"><a href="#实现Web服务器" class="headerlink" title="实现Web服务器"></a>实现Web服务器</h2><p>Go语言里面提供了一个完善的 net/http 包，通过 net/http 包我们可以很方便的搭建一个可以运行的 Web 服务器。同时使用 net/http 包能很简单地对 Web 的路由，静态文件，模版，cookie 等数据进行设置和操作。</p>
<h3 id="Web服务器的工作方式"><a href="#Web服务器的工作方式" class="headerlink" title="Web服务器的工作方式"></a>Web服务器的工作方式</h3><p>我们平时浏览网页的时候，会打开浏览器，然后输入网址后就可以显示出想要浏览的内容。这个看似简单的过程背后却隐藏了非常复杂的操作。</p>
<p>对于普通的上网过程，系统其实是这样做的：</p>
<ul>
<li>浏览器本身是一个客户端，当在浏览器中输入 URL （网址）的时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到对应的服务器后，要求建立 TCP 连接；</li>
<li>与服务器建立连接后，浏览器会向服务器发送 HTTP Request （请求）包；</li>
<li>服务器接收到请求包之后开始处理请求包，并调用自身服务，返回 HTTP Response（响应）包；</li>
<li>客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容后断开与该服务器之间的 TCP 连接。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/webserver.gif" alt="图：用户访问一个站点的过程"></p>
<p>通过上图可以将 Web 服务器的工作原理简单地归纳为：</p>
<ul>
<li>客户机通过 TCP/IP 协议与服务器建立 TCP 连接；</li>
<li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档；</li>
<li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端；</li>
<li>客户机与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</li>
</ul>
<h3 id="搭建一个简单的-Web-服务器"><a href="#搭建一个简单的-Web-服务器" class="headerlink" title="搭建一个简单的 Web 服务器"></a>搭建一个简单的 Web 服务器</h3><p>前面简单介绍了 Web 服务器的工作原理，那么如何用Go语言搭建一个 Web 服务器呢？示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", index) // index 为向 url发送请求时，调用的函数</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 命令运行上面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure>
<p>运行之后并没有什么提示信息，但是命令行窗口会被占用（不能再输入其它命令）。这时我们在浏览器中输入 localhost:8000 可以看到下图所示的内容，则说明我们的服务器成功运行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhost.gif" alt="图：localhost:8000"></p>
<p><strong><em>提示：运行 Web 服务器会占用命令行窗口，我们可以使用 Ctrl+C 组合键来退出。</em></strong></p>
<p>上面的代码只是展示了 Web 服务器的简单应用，下面我们来完善一下，为这个服务器添加一个页面并设置访问的路由。</p>
<p>首先我们准备一个 html 文件，并命名为 index.html，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;C语言中文网&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;C语言中文网&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>然后将我们上面写的 Web 服务器的代码简单修改一下，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 在/后面加上 index ，来指定访问路径</span><br><span class="line">    http.HandleFunc("/index", index)</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    content, _ := ioutil.ReadFile("./index.html")</span><br><span class="line">    w.Write(content)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 命令运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure>
<p>运行成功后，在浏览器中输入 localhost:8000/index 就可以看到我们所添加的页面了，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhostindex.gif" alt="图：浏览 localhost:8000/index 页面"></p>
<h2 id="部署程序到Linux服务器"><a href="#部署程序到Linux服务器" class="headerlink" title="部署程序到Linux服务器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5725.html">部署程序到Linux服务器</a></h2><p>通过前面的学习相信大家对Go语言已经有了一定的了解，平时我们都是在本地进行开发调试访问的。那要怎么打包到服务器上呢？下面通过一个简单的实例来给大家介绍一下如何把我们写好的Go语言程序发布到服务 Linux 服务器上。</p>
<p>下面所示的是我们在 Windows 系统下开发的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sayHello(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", sayHello)</span><br><span class="line">    log.Println("启动成功，可以通过 localhost:9000 访问")</span><br><span class="line">    err := http.ListenAndServe(":9000", nil)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal("List 9000")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码已经写好了，现在需要编译了，由于是 window 环境编译到 linux 下运行，所有涉及到跨平台编译。</p>
<p>编译代码命令如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set GOARCH=amd64   //设置目标可执行程序操作系统构架，包括 386，amd64，arm</span><br><span class="line">set GOOS=linux           //设置可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">go build ./main.go       //打包</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：使用 Window 10 系统的小伙伴必须用 cmd 工具执行上述命令，不能使用 powershell。</em></strong></p>
<p>OK，编译完成后会生成一个 main 可执行文件，没有后缀，这时只需要把这个文件上传到你的虚拟机，直接运行就好了。</p>
<p>运行后如果出现上图的效果，就说明已经运行起来了。这时打开你的浏览器访问服务器的 IP:9000 就能看到如下图的内容了</p>
<p>好啦！就这么简单，不需要任何语言环境，像 java 程序需要在服务器安装 java，php 需要安装 Apache，PHP 等运行环境，go 统统不需要，只需要一个 linux 系统将编译好的代码扔上去就可以了。</p>
<h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5397.html">音乐播放器</a></h2><h2 id="实现有限状态机（FSM）"><a href="#实现有限状态机（FSM）" class="headerlink" title="实现有限状态机（FSM）"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5400.html">实现有限状态机（FSM）</a></h2><h2 id="二叉树数据结构的应用"><a href="#二叉树数据结构的应用" class="headerlink" title="二叉树数据结构的应用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5570.html">二叉树数据结构的应用</a></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>接口</tag>
        <tag>面向接口编程</tag>
      </tags>
  </entry>
  <entry>
    <title>go文件处理</title>
    <url>/posts/543a448f/</url>
    <content><![CDATA[<p>本章我们将带领大家深入了解一下 Go语言中的文件处理，重点在于文件而非目录或者通用的文件系统，特别是如何读写标准格式（如 XML 和 JSON 格式）的文件以及自定义的纯文本和二进制格式文件。</p>
<p>由于前面的内容已覆盖 Go语言的所有特性，现在我们可以灵活地使用 Go语言提供的所有工具。我们会充分利用这种灵活性并利用闭包来避免重复性的代码，同时在某些情况下充分利用 Go语言对面向对象的支持，特别是对为函数添加方法的支持。</p>
<h2 id="自定义数据文件"><a href="#自定义数据文件" class="headerlink" title="自定义数据文件"></a>自定义数据文件</h2><p>对一个程序非常普遍的需求包括维护内部数据结构，为数据交换提供导入导出功能，也支持使用外部工具来处理数据。</p>
<p>由于我们这里的关注重点是文件处理，因此我们纯粹只关心如何从程序内部数据结构中读取数据并将其写入标准和自定义格式的文件中，以及如何从标准和自定义格式文件中读取数据并写入程序的内部数据结构中。</p>
<p>本节中，我们会为所有的例子使用相同的数据，以便直接比较不同的文件格式。所有的代码都来自 invoicedate 程序（在 invoicedata 目录中的 invoicedata.go &gt; gob.go、inv.go、jsn.go、txt.go 和 xml.go 等文件中）。</p>
<p>该程序接受两个文件名作为命令行参数，一个用于读，另一个用于写（它们必须是不同的文件）。程序从第一个文件中读取数据（以其后缀所表示的任何格式），并将数据写入第二个文件（也是以其后缀所表示的任何格式）。</p>
<p>由 invoicedata 程序创建的文件可跨平台使用，也就是说，无论是什么格式，Windows 上创建的文件都可在 Mac OS X 以及 Linux 上读取，反之亦然。Gzip 格式压缩的文件（如 invoices.gob.gz）可以无缝读写。</p>
<p>这些数据由一个 []invoice 组成，也就是说，是一个保存了指向 Invoice 值的指针的切片。每一个发票数据都保存在一个 invoice 类型的值中，同时每一个发票数据都以 []*Item 的形式保存着 0 个或者多个项。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Invoice struct {</span><br><span class="line">    Id          int</span><br><span class="line">    Customerld  int</span><br><span class="line">    Raised      time.Time</span><br><span class="line">    Due         time.Time</span><br><span class="line">    Paid        bool</span><br><span class="line">    Note        string</span><br><span class="line">    Items       []*Item</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Item struct {</span><br><span class="line">    Id       st ring</span><br><span class="line">    Price    float64</span><br><span class="line">    Quantity int</span><br><span class="line">    Note     string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这两个结构体用于保存数据。下表给出了一些非正式的对比，展示了每种格式下读写相同的 50000 份随机发票数据所需的时间，以及以该格式所存储文件的大小。</p>
<p>计时按秒计，并向上舍入到最近的十分之一秒。我们应该把计时结果认为是无绝对单位的，因为不同硬件以及不 同负载情况下该值都不尽相同。大小一栏以千字节（KB）算，该值在所有机器上应该都是相同的。</p>
<p>对于该数据集，虽然未压缩文件的大小千差万别，但压缩文件的大小都惊人的相似。而代码的 函数不包括所有格式通用的代码（例如，那些用于压缩和解压缩以及定义结构体的代码）。</p>
<table>
    <tbody>
        <tr><th>后缀</th><th>读取</th><th>写入</th><th>大小(KiB)</th><th>读/写LOC</th><th>格式</th></tr>
        <tr><td>.gob</td><td>0.3</td><td>0.2</td><td>7948</td><td rowspan="2">21+11=32</td><td rowspan="2">Go二进制</td></tr>
        <tr><td>.gob.gz</td><td>0.5</td><td>1.5</td><td>2589</td></tr>
        <tr><td>jsn</td><td>4.5</td><td>2.2</td><td>16283</td><td rowspan="2">32+17=49</td><td rowspan="2">JSON</td></tr>
        <tr><td>.jsn.gz</td><td>4.5</td><td>3.4</td><td>2678</td></tr>
        <tr><td>.xml</td><td>6.7</td><td>1.2</td><td>18917</td><td rowspan="2">45+30=75</td><td rowspan="2">XML</td></tr>
        <tr><td>.xml.gz</td><td>6.9</td><td>2.7</td><td>2730</td></tr>
        <tr><td>..txt</td><td>1.9</td><td>1.0</td><td>12375</td><td rowspan="2">86+53=139</td><td rowspan="2">纯文本（UTF-8）</td></tr>
        <tr><td>.txt.gz</td><td>2.2</td><td>2.2</td><td>2514</td></tr>
        <tr><td>.inv</td><td>1.7</td><td>3.5</td><td>7250</td><td rowspan="2">128+87=215</td><td rowspan="2">自定义二进制</td></tr>
        <tr><td>.inv.gz</td><td>1.6</td><td>2.6</td><td>2400</td></tr>
    </tbody>
</table>

<p>这些读写时间和文件大小在我们的合理预期范围内，除了纯文本格式的读写异常快之外。这得益于 fmt 包优秀的打印和扫描函数，以及我们设计的易于解析的自定义文本格式。</p>
<p>对于 JSON 和 XML 格式，我们只简单地存储了日期部分而非存储默认的 time.Time 值（一个 ISO-8601 日期/时间字符串），通过牺牲一些速度和增加一些额外代码稍微减小了文件的大小。</p>
<p>例如，如果让JSON代码自己来处理time.Time值，它能够运行得更快，并且其代码行数与 Go语言二进制编码差不多。</p>
<p>对于二进制数据，Go语言的二进制格式是最便于使用的。它非常快且极端紧凑，所需的代码非常少，并且相对容易适应数据的变化。然而，如果我们使用的自定义类型不原生支持 gob 编码，我们必须让该类型满足 gob.Encoder 和 gob. Decoder 接口，这样会导致 gob 格式的 读写相当得慢，并且文件大小也会膨胀。</p>
<p>对于可读的数据，XML 可能是最好使用的格式，特别是作为一种数据交换格式时非常有用。与处理 JSON 格式相比，处理 XML 格式需要更多行代码。这是因为 Go [没有一个 xml.Marshaler 接口，也因为我们这里使用了并行的数据类型 （XMLInvoice 和 XMLItem）来帮助映射 XML 数据和发票数据（invoice 和 Item）。</p>
<p>使用 XML 作为外部存储格式的应用程序可能不需要并行的数据类型或者也不需要 invoicedata 程序这样的 转换，因此就有可能比 invoicedata 例子中所给出的更快，并且所需的代码也更少。</p>
<p>除了读写速度和文件大小以及代码行数之外，还有另一个问题值得考虑：格式的稳健性。例如，如果我们为 Invoice 结构体和 Item 结构体添加了一个字段，那么就必须再改变文件的格式。我们的代码适应读写新格式并继续支持读旧格式的难易程度如何？如果我们为文件格式定义版本，这样的变化就很容易被适应（会以本章一个练习的形式给岀），除了让 JSON 格式同时适应读写新旧格式稍微复杂一点之外。</p>
<p>除了 Invoice 和 Item 结构体之外，所有文件格式都共享以下常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const （</span><br><span class="line">    fileType        = "INVOICES"        //用于纯文本格式</span><br><span class="line">    magicNumber     = 0xl25D            // 用于二进制格式</span><br><span class="line">    fileVersion     = 100               //用于所有的格式</span><br><span class="line">    dataFormat      = "2006-01-02"      //必须总是使用该日期</span><br><span class="line">）</span><br></pre></td></tr></tbody></table></figure>
<p>magicNumber 用于唯一标记发票文件。fileVersion 用于标记发票文件的版本，该标记便于之后修改程序来适应数据格式的改变。dataFormat 稍后介绍，它表 示我们希望数据如何按照可读的格式进行格式化。</p>
<p>同时，我们也创建了一对接口。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type InvoiceMarshaler interface {</span><br><span class="line">    Marshallnvoices（writer io.Writer, invoices []*Invoice） error</span><br><span class="line">}</span><br><span class="line">type InvoiceUnmarshaler interface {</span><br><span class="line">    Unmarshallnvoices(reader io.Reader) ([]*Invoice, error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样做的目的是以统一的方式针对特定格式使用 reader 和 writer。例如，下列函数是 invoicedata 程序用来从一个打开的文件中读取发票数据的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func readinvoices(reader io.Reader, suffix string)([]*Invoice, error) {</span><br><span class="line">    var unmarshaler InvoicesUnmarshaler</span><br><span class="line">    switch suffix {</span><br><span class="line">        case ".gobn:</span><br><span class="line">            unmarshaler = GobMarshaler{}</span><br><span class="line">        case H.inv":</span><br><span class="line">            unmarshaler = InvMarshaler{}</span><br><span class="line">        case ,f. jsn", H. jsonn:</span><br><span class="line">            unmarshaler = JSONMarshaler{}</span><br><span class="line">        case ".txt”：</span><br><span class="line">            unmarshaler = TxtMarshaler{}</span><br><span class="line">        case ".xml":</span><br><span class="line">            unmarshaler = XMLMarshaler{}</span><br><span class="line">    }</span><br><span class="line">    if unmarshaler != nil {</span><br><span class="line">        return unmarshaler.Unmarshallnvoices(reader)</span><br><span class="line">    }</span><br><span class="line">    return nil, fmt.Errorf("unrecognized input suffix: %s", suffix)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，reader 是任何能够满足 io.Reader 接口的值，例如，一个打开的文件 ( 其类型为 <code>*os . File</code>)&gt; 一个 gzip 解码器 ( 其类型为 <code>*gzip. Reader</code>) 或者一个 string. Readero 字符串 suffix 是文件的后缀名 ( 从 <code>.gz</code> 文件中解压之后)。</p>
<p>在接下来的小节中我们将会看到 GobMarshaler 和 InvMarshaler 等自定义的类型，它们提供了 MarshmlTnvoices() 和 Unmarshallnvoices() 方法 (因此满足 InvoicesMarshaler 和 InvoicesUnmarshaler 接口)。</p>
<h2 id="JSON文件的读写操作"><a href="#JSON文件的读写操作" class="headerlink" title="JSON文件的读写操作"></a>JSON文件的读写操作</h2><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。它基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p>
<p>JSON 是一种使用 UTF-8 编码的纯文本格式，采用完全独立于语言的文本格式，由于写起来比 XML 格式方便，并且更为紧凑，同时所需的处理时间也更少，致使 JSON 格式越来越流行，特别是在通过网络连接传送数据方面。</p>
<p>开发人员可以使用 JSON 传输简单的字符串、数字、布尔值，也可以传输一个数组或者一个更复杂的复合结构。在 Web 开发领域中，JSON 被广泛应用于 Web 服务端程序和客户端之间的数据通信。</p>
<p>Go语言内建对 JSON 的支持，使用内置的 encoding/json 标准库，开发人员可以轻松使用Go程序生成和解析 JSON 格式的数据。</p>
<p>JSON 结构如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{"key1":"value1","key2":value2,"key3":["value3","value4","value5"]}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="写-JSON-文件"><a href="#写-JSON-文件" class="headerlink" title="写 JSON 文件"></a>写 JSON 文件</h3><p>使用Go语言创建一个 json 文件非常方便，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := []Website{{"Golang", "http://c.biancheng.net/golang/", []string{"http://c.biancheng.net/cplus/", "http://c.biancheng.net/linux_tutorial/"}}, {"Java", "http://c.biancheng.net/java/", []string{"http://c.biancheng.net/socket/", "http://c.biancheng.net/python/"}}}</span><br><span class="line"></span><br><span class="line">    // 创建文件</span><br><span class="line">    filePtr, err := os.Create("info.json")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer filePtr.Close()</span><br><span class="line"></span><br><span class="line">    // 创建Json编码器</span><br><span class="line">    encoder := json.NewEncoder(filePtr)</span><br><span class="line"></span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误", err.Error())</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 info.json 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        "Name":"Golang",</span><br><span class="line">        "Url":"http://c.biancheng.net/golang/",</span><br><span class="line">        "Course":[</span><br><span class="line">            "http://c.biancheng.net/golang/102/",</span><br><span class="line">            "http://c.biancheng.net/golang/concurrent/"</span><br><span class="line">        ]</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        "Name":"Java",</span><br><span class="line">        "Url":"http://c.biancheng.net/java/",</span><br><span class="line">        "Course":[</span><br><span class="line">            "http://c.biancheng.net/java/10/",</span><br><span class="line">            "http://c.biancheng.net/python/"</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读-JSON-文件"><a href="#读-JSON-文件" class="headerlink" title="读 JSON 文件"></a>读 JSON 文件</h3><p>读 JSON 数据与写 JSON 数据一样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePtr, err := os.Open("./info.json")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败 [Err:%s]", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer filePtr.Close()</span><br><span class="line">    var info []Website</span><br><span class="line">    // 创建json解码器</span><br><span class="line">    decoder := json.NewDecoder(filePtr)</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err.Error())</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">[{Golang http://c.biancheng.net/golang/ [http://c.biancheng.net/golang/102/ http://c.biancheng.net/golang/concurrent/]} {Java http://c.biancheng.net/java/ [http://c.biancheng.net/java/10/ http://c.biancheng.net/python/]}]</span><br></pre></td></tr></tbody></table></figure>
<p>顺便提一下，还有一种叫做 BSON (Binary JSON) 的格式与 JSON 非常类似，与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p>
<h2 id="XML文件的读写操作"><a href="#XML文件的读写操作" class="headerlink" title="XML文件的读写操作"></a>XML文件的读写操作</h2><p>XML（extensible Markup Language）格式被广泛用作一种数据交换格式，并且自成一种文件格式。与上一节介绍的 JSON 相比 XML 要复杂得多，而且手动写起来相对乏味得多。</p>
<p>在 JSON 还未像现在这么广泛使用时，XML 的使用相当广泛。XML 作为一种数据交换和信息传递的格式，使用还是很广泛的，现在很多开放平台接口，基本都会支持 XML 格式。</p>
<p>Go语言内置的 encoding/xml 包可以用在结构体和 XML 格式之间进行编解码，其方式跟 encoding/json 包类似。然而与 JSON 相比 XML 的编码和解码在功能上更苛刻得多，这是由于 encoding/xml 包要求结构体的字段包含格式合理的标签，而 JSON 格式却不需要。</p>
<h3 id="写-XML-文件"><a href="#写-XML-文件" class="headerlink" title="写 XML 文件"></a>写 XML 文件</h3><p>使用 encoidng/xml 包可以很方便的将 xml 数据存储到文件中，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/xml"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //实例化对象</span><br><span class="line">    info := Website{"C语言中文网", "http://c.biancheng.net/golang/", []string{"Go语言入门教程", "Golang入门教程"}}</span><br><span class="line">    f, err := os.Create("./info.xml")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line">    //序列化到文件中</span><br><span class="line">    encoder := xml.NewEncoder(f)</span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误：", err.Error())</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录生成一个 info.xml 文件，文件的内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;Website name="C语言中文网"&gt;</span><br><span class="line">    &lt;Url&gt;http://c.biancheng.net/golang/&lt;/Url&gt;</span><br><span class="line">    &lt;Course&gt;Go语言入门教程&lt;/Course&gt;</span><br><span class="line">    &lt;Course&gt;Golang入门教程&lt;/Course&gt;</span><br><span class="line">&lt;/Website&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读-XML-文件"><a href="#读-XML-文件" class="headerlink" title="读 XML 文件"></a>读 XML 文件</h3><p>读 XML 文件比写 XML 文件稍微复杂，特别是在必须处理一些我们自定义字段的时候（例如日期）。但是，如果我们使用合理的打上 XML 标签的结构体，就不会复杂。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/xml"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //打开xml文件</span><br><span class="line">    file, err := os.Open("./info.xml")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败：%v", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    info := Website{}</span><br><span class="line">    //创建 xml 解码器</span><br><span class="line">    decoder := xml.NewDecoder(file)</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("解码失败：%v", err)</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">{C语言中文网 http://c.biancheng.net/golang/ [Go语言入门教程 Golang入门教程]}</span><br></pre></td></tr></tbody></table></figure>
<p>正如写 XML 时一样，我们无需关心对所读取的 XML 数据进行转义，xml.NewDecoder.Decode() 函数会自动处理这些。</p>
<p>xml 包还支持更为复杂的标签，包括嵌套。例如标签名为 ‘xml:”Books&gt;Author”‘ 产生的是 <code>&lt;Books&gt;&lt;Author&gt;content&lt;/Author&gt;&lt;/Books&gt;</code> 这样的 XML 内容。同时除了 ‘xml:”, attr”‘ 之外，该包还支持 ‘xml:”,chardata”‘ 这样的标签表示将该字段当做字符数据来写，支持 ‘xml:”,innerxml”‘ 这样的标签表示按照字面量来写该字段，以及 ‘xml:”,comment”‘ 这样的标签表示将该字段当做 XML 注释。因此，通过使用标签化的结构体，我们可以充分利用好这些方便的编码解码函数，同时合理控制如何读写 XML 数据。</p>
<h2 id="使用Gob传输数据"><a href="#使用Gob传输数据" class="headerlink" title="使用Gob传输数据"></a>使用Gob传输数据</h2><p>为了让某个数据结构能够在网络上传输或能够保存至文件，它必须被编码然后再解码。当然已经有许多可用的编码方式了，比如 JSON、XML、Google 的 protocol buffers 等等。而现在又多了一种，由Go语言 encoding/gob 包提供的方式。</p>
<p>Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）。类似于 Python 的“pickle”和 Java 的“Serialization”。</p>
<p>Gob 和 JSON 的 pack 之类的方法一样，由发送端使用 Encoder 对数据结构进行编码。在接收端收到消息之后，接收端使用 Decoder 将序列化的数据变化成本地变量。</p>
<p>Go语言可以通过 JSON 或 Gob 来序列化 struct 对象，虽然 JSON 的序列化更为通用，但利用 Gob 编码可以实现 JSON 所不能支持的 struct 的方法序列化，利用 Gob 包序列化 struct 保存到本地也十分简单。</p>
<p>Gob 不是可外部定义、语言无关的编码方式，它的首选的是二进制格式，而不是像 JSON 或 XML 那样的文本格式。Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</p>
<p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。它和 JSON 或 XML 有什么不同呢？Gob 特定的用于纯 Go 的环境中，例如两个用Go语言写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</p>
<p>Gob 文件或流是完全自描述的，它里面包含的所有类型都有一个对应的描述，并且都是可以用Go语言解码，而不需要了解文件的内容。</p>
<p>只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作。解码客户端会继续识别以前存在的字段，并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</p>
<p>假如有下面这样一个结构体 T：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type T struct { X, Y, Z int }</span><br><span class="line">var t = T{X: 7, Y: 0, Z: 8}</span><br></pre></td></tr></tbody></table></figure>
<p>而在接收时可以用一个结构体 U 类型的变量 u 来接收这个值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type U struct { X, Y *int8 }</span><br><span class="line">var u U</span><br></pre></td></tr></tbody></table></figure>
<p>在接收时，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）和 JSON 的使用方式一样，Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()，相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode 。</p>
<h3 id="创建-gob-文件"><a href="#创建-gob-文件" class="headerlink" title="创建 gob 文件"></a>创建 gob 文件</h3><p>下面通过简单的示例程序来演示Go语言是如何创建 gob 文件的，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := map[string]string{</span><br><span class="line">        "name":    "C语言中文网",</span><br><span class="line">        "website": "http://c.biancheng.net/golang/",</span><br><span class="line">    }</span><br><span class="line">    name := "demo.gob"</span><br><span class="line">    File, _ := os.OpenFile(name, os.O_RDWR|os.O_CREATE, 0777)</span><br><span class="line">    defer File.Close()</span><br><span class="line">    enc := gob.NewEncoder(File)</span><br><span class="line">    if err := enc.Encode(info); err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成 demo.gob 文件，文件的内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0eff 8104 0102 ff82 0001 0c01 0c00 0041</span><br><span class="line">ff82 0002 046e 616d 6510 43e8 afad e8a8</span><br><span class="line">80e4 b8ad e696 87e7 bd91 0777 6562 7369</span><br><span class="line">7465 1e68 7474 703a 2f2f 632e 6269 616e</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读取-gob-文件"><a href="#读取-gob-文件" class="headerlink" title="读取 gob 文件"></a>读取 gob 文件</h3><p>读取 gob 文件与创建 gob 文件同样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var M map[string]string</span><br><span class="line">    File, _ := os.Open("demo.gob")</span><br><span class="line">    D := gob.NewDecoder(File)</span><br><span class="line">    D.Decode(&amp;M)</span><br><span class="line">    fmt.Println(M)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">map[name:C语言中文网 website:http://c.biancheng.net/golang/]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="纯文本文件的读写操作"><a href="#纯文本文件的读写操作" class="headerlink" title="纯文本文件的读写操作"></a>纯文本文件的读写操作</h2><p>Go语言提供了很多文件操作的支持，在不同场景下，有对应的处理方式，本节我们来介绍一下文本文件的读写操作。</p>
<h3 id="写纯文本文件"><a href="#写纯文本文件" class="headerlink" title="写纯文本文件"></a>写纯文本文件</h3><p>由于Go语言的 fmt 包中打印函数强大而灵活，写纯文本数据非常简单直接，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建一个新文件，写入内容</span><br><span class="line">    filePath := "./output.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("打开文件错误= %v \n", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //及时关闭</span><br><span class="line">    defer file.Close()</span><br><span class="line">    //写入内容</span><br><span class="line">    str := "http://c.biancheng.net/golang/\n" // \n\r表示换行  txt文件要看到换行效果要用 \r\n</span><br><span class="line">    //写入时，使用带缓存的 *Writer</span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        writer.WriteString(str)</span><br><span class="line">    }</span><br><span class="line">    //因为 writer 是带缓存的，因此在调用 WriterString 方法时，内容是先写入缓存的</span><br><span class="line">    //所以要调用 flush方法，将缓存的数据真正写入到文件中。</span><br><span class="line">    writer.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面代码会在当前目录下生成一个 output.txt 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读纯文本文件"><a href="#读纯文本文件" class="headerlink" title="读纯文本文件"></a>读纯文本文件</h3><p>打开并读取一个纯文本格式的数据跟写入纯文本格式数据一样简单。要解析文本来重建原始数据可能稍微复杂，这需根据格式的复杂性而定。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //打开文件</span><br><span class="line">    file, err := os.Open("./output.txt")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败 = ", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭 file 句柄，否则会有内存泄漏</span><br><span class="line">    defer file.Close()</span><br><span class="line">    //创建一个 *Reader ， 是带缓冲的</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    for {</span><br><span class="line">        str, err := reader.ReadString('\n') //读到一个换行就结束</span><br><span class="line">        if err == io.EOF {                  //io.EOF 表示文件的末尾</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print(str)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("文件读取结束...")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">文件读取结束...</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二进制文件的读写操作"><a href="#二进制文件的读写操作" class="headerlink" title="二进制文件的读写操作"></a>二进制文件的读写操作</h2><p>Go语言的二进制（gob）格式是一个自描述的二进制序列。从其内部表示来看，Go语言的二进制格式由一个 0 块或者更多块的序列组成，其中的每一块都包含一个字节数，一个由 0 个或者多个 typeId-typeSpecification 对组成的序列，以及一个 typeId-value 对。</p>
<p>如果 typeId-value 对的 typeId 是预先定义好的（例如 bool、int 和 string 等），则这些 typeId-typeSpecification 对可以省略。否则就用类型对来描述一个自定义类型（如一个自定义的结构体）。类型对和值对之间的 typeId 没有区别。</p>
<p>正如我们将看到的，我们无需了解其内部结构就可以使用 gob 格式， 因为 encoding/gob 包会在幕后为我们打理好一切底层细节。</p>
<p>Go语言中的 encoding/gob 包也提供了与 encoding/json 包一样的编码解码功能，并且容易使用。通常而言如果对肉眼可读性不做要求，gob 格式是Go语言上用于文件存储和网络传输最为方便的格式。</p>
<h3 id="写Go语言二进制文件"><a href="#写Go语言二进制文件" class="headerlink" title="写Go语言二进制文件"></a>写Go语言二进制文件</h3><p>下面通过一个简单的示例来演示一下Go语言是如何生成一个二进制文件的，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := "http://c.biancheng.net/golang/"</span><br><span class="line">    file, err := os.Create("./output.gob")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    encoder := gob.NewEncoder(file)</span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误", err.Error())</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 output.gob 文件，文件内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">210c 001e 6874 7470 3a2f 2f63 2e62 6961</span><br><span class="line">6e63 6865 6e67 2e6e 6574 2f67 6f6c 616e</span><br><span class="line">672f </span><br></pre></td></tr></tbody></table></figure>
<h3 id="读Go语言二进制文件"><a href="#读Go语言二进制文件" class="headerlink" title="读Go语言二进制文件"></a>读Go语言二进制文件</h3><p>读 gob 数据和写一样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Open("./output.gob")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    decoder := gob.NewDecoder(file)</span><br><span class="line">    info := ""</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err.Error())</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="自定义二进制文件的读写操作"><a href="#自定义二进制文件的读写操作" class="headerlink" title="自定义二进制文件的读写操作"></a>自定义二进制文件的读写操作</h2><p>虽然Go语言的 encoding/gob 包非常易用，而且使用时所需代码量也非常少，但是我们仍有可能需要创建自定义的二进制格式。自定义的二进制格式有可能做到最紧凑的数据表示，并且读写速度可以非常快。</p>
<p>不过，在实际使用中，我们发现以Go语言二进制格式的读写通常比自定义格式要快非常多，而且创建的文件也不会大很多。但如果我们必须通过满足 gob.GobEncoder 和 gob.GobDecoder 接口来处理一些不可被 gob 编码的数据，这些优势就有可能会失去。</p>
<p>在有些情况下我们可能需要与一些使用自定义二进制格式的软件交互，因此了解如何处理二进制文件就非常有用。</p>
<h3 id="写自定义二进制文件"><a href="#写自定义二进制文件" class="headerlink" title="写自定义二进制文件"></a>写自定义二进制文件</h3><p>Go语言的 encoding/binary 包中的 binary.Write() 函数使得以二进制格式写数据非常简单，函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Write(w io.Writer, order ByteOrder, data interface{}) error</span><br></pre></td></tr></tbody></table></figure>
<p>Write 函数可以将参数 data 的 binary 编码格式写入参数 w 中，参数 data 必须是定长值、定长值的切片、定长值的指针。参数 order 指定写入数据的字节序，写入结构体时，名字中有 <code>_</code> 的字段会置为 0。</p>
<p>下面通过一个简单的示例程序来演示一下 Write 函数的使用，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "encoding/binary"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Url int32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Create("output.bin")</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        info := Website{</span><br><span class="line">            int32(i),</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("文件创建失败 ", err.Error())</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        defer file.Close()</span><br><span class="line"></span><br><span class="line">        var bin_buf bytes.Buffer</span><br><span class="line">        binary.Write(&amp;bin_buf, binary.LittleEndian, info)</span><br><span class="line">        b := bin_buf.Bytes()</span><br><span class="line">        _, err = file.Write(b)</span><br><span class="line"></span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("编码失败", err.Error())</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("编码成功")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的程序会在当前目录下生成 output.bin 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0100 0000 0200 0000 0300 0000 0400 0000</span><br><span class="line">0500 0000 0600 0000 0700 0000 0800 0000</span><br><span class="line">0900 0000 0a00 0000</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读自定义二进制文件"><a href="#读自定义二进制文件" class="headerlink" title="读自定义二进制文件"></a>读自定义二进制文件</h3><p>读取自定义的二进制数据与写自定义二进制数据一样简单。我们无需解析这类数据，只需使用与写数据时相同的字节顺序将数据读进相同类型的值中。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "encoding/binary"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Url int32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Open("output.bin")</span><br><span class="line">    defer file.Close()</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    m := Website{}</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        data := readNextBytes(file, 4)</span><br><span class="line">        buffer := bytes.NewBuffer(data)</span><br><span class="line">        err = binary.Read(buffer, binary.LittleEndian, &amp;m)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("二进制文件读取失败", err)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("第", i, "个值为：", m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func readNextBytes(file *os.File, number int) []byte {</span><br><span class="line">    bytes := make([]byte, number)</span><br><span class="line"></span><br><span class="line">    _, err := file.Read(bytes)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return bytes</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">第 1 个值为: {1}</span><br><span class="line">第 2 个值为: {2}</span><br><span class="line">第 3 个值为: {3}</span><br><span class="line">第 4 个值为: {4}</span><br><span class="line">第 5 个值为: {5}</span><br><span class="line">第 6 个值为: {6}</span><br><span class="line">第 7 个值为: {7}</span><br><span class="line">第 8 个值为: {8}</span><br><span class="line">第 9 个值为: {9}</span><br><span class="line">第 10 个值为: {10}</span><br></pre></td></tr></tbody></table></figure>
<p>至此，我们完成了对自定义二进制数据的读和写操作。只要小心选择表示长度的整数符号和大小，并将该长度值写在变长值（如切片）的内容之前，那么使用二进制数据进行工作并不难。</p>
<p>Go语言对二进制文件的支持还包括随机访问。这种情况下，我们必须使用 os.OpenFile() 函数来打开文件（而非 os.Open()），并给它传入合理的权限标志和模式（例如 os.O_RDWR 表示可读写）参数。</p>
<p>然后，就可以使用 os.File.Seek() 方法来在文件中定位并读写，或者使用 os.File.ReadAt() 和 os.File.WriteAt() 方法来从特定的字节偏移中读取或者写入数据。</p>
<p>Go语言还提供了其他常用的方法，包括 os.File.Stat() 方法，它返回的 os.FileInfo 包含了文件大小、权限以及日期时间等细节信息。</p>
<h2 id="zip归档文件的读写操作"><a href="#zip归档文件的读写操作" class="headerlink" title="zip归档文件的读写操作"></a>zip归档文件的读写操作</h2><p>Go语言的标准库提供了对几种压缩格式的支持，其中包括 gzip，因此 Go 程序可以无缝地读写 <code>.gz</code> 扩展名的 gzip 压缩文件或非 <code>.gz</code> 扩展名的非压缩文件。此外标准库也提供了读和写 <code>.zip</code> 文件、<code>tar</code> 包文件（<code>.tar</code> 和 <code>.tar.gz</code>），以及读 <code>.bz2</code> 文件（即 <code>.tar</code> <code>.bz2</code> 文件）的功能。</p>
<p>本节我们将主要介绍 zip 归档文件的读写操作。</p>
<h3 id="创建-zip-归档文件"><a href="#创建-zip-归档文件" class="headerlink" title="创建 zip 归档文件"></a>创建 zip 归档文件</h3><p>Go语言提供了 archive/zip 包来操作压缩文件，下面通过一个简单的的示例演示如何使用Go语言来创建一个 zip 文件，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/zip"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个缓冲区用来保存压缩文件内容</span><br><span class="line">    buf := new(bytes.Buffer)</span><br><span class="line"></span><br><span class="line">    // 创建一个压缩文档</span><br><span class="line">    w := zip.NewWriter(buf)</span><br><span class="line"></span><br><span class="line">    // 将文件加入压缩文档</span><br><span class="line">    var files = []struct {</span><br><span class="line">        Name, Body string</span><br><span class="line">    }{</span><br><span class="line">        {"Golang.txt", "http://c.biancheng.net/golang/"},</span><br><span class="line">    }</span><br><span class="line">    for _, file := range files {</span><br><span class="line">        f, err := w.Create(file.Name)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">        _, err = f.Write([]byte(file.Body))</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 关闭压缩文档</span><br><span class="line">    err := w.Close()</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将压缩文档内容写入文件</span><br><span class="line">    f, err := os.OpenFile("file.zip", os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    buf.WriteTo(f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的文件会在当前目录下生成 file.zip 文件，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/zipfile.gif" alt="zipfile"></p>
<h3 id="读取-zip-归档文件"><a href="#读取-zip-归档文件" class="headerlink" title="读取 zip 归档文件"></a>读取 zip 归档文件</h3><p>读取一个 <code>.zip</code> 归档文件与创建一个归档文件一样简单，只是如果归档文件中包含带有路径的文件名，就必须重建目录结构。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/zip"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 打开一个zip格式文件</span><br><span class="line">    r, err := zip.OpenReader("file.zip")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf(err.Error())</span><br><span class="line">    }</span><br><span class="line">    defer r.Close()</span><br><span class="line"></span><br><span class="line">    // 迭代压缩文件中的文件，打印出文件中的内容</span><br><span class="line">    for _, f := range r.File {</span><br><span class="line">        fmt.Printf("文件名: %s\n", f.Name)</span><br><span class="line">        rc, err := f.Open()</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf(err.Error())</span><br><span class="line">        }</span><br><span class="line">        _, err = io.CopyN(os.Stdout, rc, int64(f.UncompressedSize64))</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf(err.Error())</span><br><span class="line">        }</span><br><span class="line">        rc.Close()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">文件名: Golang.txt</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="tar归档文件的读写操作"><a href="#tar归档文件的读写操作" class="headerlink" title="tar归档文件的读写操作"></a>tar归档文件的读写操作</h2><p>接下来介绍一下 tar 归档文件的创建及读取。</p>
<h3 id="创建-tar-归档文件"><a href="#创建-tar-归档文件" class="headerlink" title="创建 tar 归档文件"></a>创建 tar 归档文件</h3><p>tar 是一种打包格式，但不对文件进行压缩，所以打包后的文档一般远远大于 zip 和 tar.gz，因为不需要压缩的原因，所以打包的速度是非常快的，打包时 CPU 占用率也很低。</p>
<p>tar 的目的在于方便文件的管理，比如在我们的生活中，有很多小物品分散在房间的各个角落，为了方便整洁可以将这些零散的物品整理进一个箱子中，而 tar 的功能就类似这样。</p>
<p>创建 tar 归档文件与创建 .zip 归档文件非常类似，主要不同点在于我们将所有数据都写入相同的 writer 中，并且在写入文件的数据之前必须写入完整的头部，而非仅仅是一个文件名。</p>
<p>tar 打包实现原理如下：</p>
<ul>
<li>创建一个文件 x.tar，然后向 x.tar 写入 tar 头部信息；</li>
<li>打开要被 tar 的文件，向 x.tar 写入头部信息，然后向 x.tar 写入文件信息；</li>
<li>当有多个文件需要被 tar 时，重复第二步直到所有文件都被写入到 x.tar 中；</li>
<li>关闭 x.tar，完成打包。</li>
</ul>
<p>下面通过示例程序简单演示一下Go语言 tar 打包的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/tar"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := os.Create("./output.tar") //创建一个 tar 文件</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line"></span><br><span class="line">    tw := tar.NewWriter(f)</span><br><span class="line">    defer tw.Close()</span><br><span class="line"></span><br><span class="line">    fileinfo, err := os.Stat("./main.exe") //获取文件相关信息</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    hdr, err := tar.FileInfoHeader(fileinfo, "")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = tw.WriteHeader(hdr) //写入头文件信息</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    f1, err := os.Open("./main.exe")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    m, err := io.Copy(tw, f1) //将main.exe文件中的信息写入压缩包中</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 output.tar 文件，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/trafile.gif" alt="trafile"></p>
<h3 id="解压-tar-归档文件"><a href="#解压-tar-归档文件" class="headerlink" title="解压 tar 归档文件"></a>解压 tar 归档文件</h3><p>解压 tar 归档文件比创建 tar 归档文档稍微简单些。首先需要将其打开，然后从这个 tar 头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据即可。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/tar"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := os.Open("output.tar")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line">    r := tar.NewReader(f)</span><br><span class="line">    for hdr, err := r.Next(); err != io.EOF; hdr, err = r.Next() {</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fileinfo := hdr.FileInfo()</span><br><span class="line">        fmt.Println(fileinfo.Name())</span><br><span class="line">        f, err := os.Create("123" + fileinfo.Name())</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">        defer f.Close()</span><br><span class="line">        _, err = io.Copy(f, r)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的程序会将 tar 包的文件解压到当前目录中，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/4-20011Q42I5302.gif" alt="tarfile1"></p>
<p>至此，我们完成了对压缩和归档文件及常规文件处理的介绍。Go语言使用 io.Reader、io.ReadCloser、io.Writer 和 io.WriteCloser 等接口处理文件的方式让开发者可以使用相同的编码模式来读写文件或者其他流（如网络流或者甚至是字符串），从而大大降低了难度。</p>
<h2 id="使用buffer读取文件"><a href="#使用buffer读取文件" class="headerlink" title="使用buffer读取文件"></a>使用buffer读取文件</h2><p>buffer 是缓冲器的意思，Go语言要实现缓冲读取需要使用到 bufio 包。bufio 包本身包装了 io.Reader 和 io.Writer 对象，同时创建了另外的 Reader 和 Writer 对象，因此对于文本 I/O 来说，bufio 包提供了一定的便利性。</p>
<p>buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p>
<h3 id="使用-bufio-包写入文件"><a href="#使用-bufio-包写入文件" class="headerlink" title="使用 bufio 包写入文件"></a>使用 bufio 包写入文件</h3><p>bufio 和 io 包中有很多操作都是相似的，唯一不同的地方是 bufio 提供了一些缓冲的操作，如果对文件 I/O 操作比较频繁的，使用 bufio 包能够提高一定的性能。</p>
<p>在 bufio 包中，有一个 Writer 结构体，而其相关的方法支持一些写入操作，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//Writer 是一个空的结构体，一般需要使用 NewWriter 或者 NewWriterSize 来初始化一个结构体对象</span><br><span class="line">type Writer struct {</span><br><span class="line">        // contains filtered or unexported fields</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//NewWriterSize 和 NewWriter 函数</span><br><span class="line">//返回默认缓冲大小的 Writer 对象(默认是4096)</span><br><span class="line">func NewWriter(w io.Writer) *Writer</span><br><span class="line"></span><br><span class="line">//指定缓冲大小创建一个 Writer 对象</span><br><span class="line">func NewWriterSize(w io.Writer, size int) *Writer</span><br><span class="line"></span><br><span class="line">//Writer 对象相关的写入数据的方法</span><br><span class="line"></span><br><span class="line">//把 p 中的内容写入 buffer，返回写入的字节数和错误信息。如果 nn &lt; len(p)，返回错误信息中会包含为什么写入的数据比较短</span><br><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br><span class="line">//将 buffer 中的数据写入 io.Writer</span><br><span class="line">func (b *Writer) Flush() error</span><br><span class="line"></span><br><span class="line">//以下三个方法可以直接写入到文件中</span><br><span class="line">//写入单个字节</span><br><span class="line">func (b *Writer) WriteByte(c byte) error</span><br><span class="line">//写入单个 Unicode 指针返回写入字节数错误信息</span><br><span class="line">func (b *Writer) WriteRune(r rune) (size int, err error)</span><br><span class="line">//写入字符串并返回写入字节数和错误信息</span><br><span class="line">func (b *Writer) WriteString(s string) (int, error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    name := "demo.txt"</span><br><span class="line">    content := "http://c.biancheng.net/golang/"</span><br><span class="line"></span><br><span class="line">    fileObj, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    defer fileObj.Close()</span><br><span class="line">    writeObj := bufio.NewWriterSize(fileObj, 4096)</span><br><span class="line"></span><br><span class="line">    //使用 Write 方法,需要使用 Writer 对象的 Flush 方法将 buffer 中的数据刷到磁盘</span><br><span class="line">    buf := []byte(content)</span><br><span class="line">    if _, err := writeObj.Write(buf); err == nil {</span><br><span class="line">        if err := writeObj.Flush(); err != nil {</span><br><span class="line">            panic(err)</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("数据写入成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录之下生成 demo.txt 文件，并将 <code>“http://c.biancheng.net/golang/”</code> 写入到该文件中。</p>
<h3 id="使用-bufio-包读取文件"><a href="#使用-bufio-包读取文件" class="headerlink" title="使用 bufio 包读取文件"></a>使用 bufio 包读取文件</h3><p>使用 bufio 包读取文件也非常方便，我们先来看下 bufio 包的相关的 Reader 函数方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//首先定义了一个用来缓冲 io.Reader 对象的结构体，同时该结构体拥有以下相关的方法</span><br><span class="line">type Reader struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//NewReader 函数用来返回一个默认大小 buffer 的 Reader 对象（默认大小是 4096） 等同于 NewReaderSize(rd,4096)</span><br><span class="line">func NewReader(rd io.Reader) *Reader</span><br><span class="line"></span><br><span class="line">//该函数返回一个指定大小 buffer（size 最小为 16）的 Reader 对象，如果 io.Reader 参数已经是一个足够大的 Reader，它将返回该 Reader</span><br><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br><span class="line"></span><br><span class="line">//该方法返回从当前 buffer 中能被读到的字节数</span><br><span class="line">func (b *Reader) Buffered() int</span><br><span class="line"></span><br><span class="line">//Discard 方法跳过后续的 n 个字节的数据，返回跳过的字节数。如果 0 &lt;= n &lt;= b.Buffered()，该方法将不会从 io.Reader 中成功读取数据</span><br><span class="line">func (b *Reader) Discard(n int) (discarded int, err error)</span><br><span class="line"></span><br><span class="line">//Peekf 方法返回缓存的一个切片，该切片只包含缓存中的前 n 个字节的数据</span><br><span class="line">func (b *Reader) Peek(n int) ([]byte, error)</span><br><span class="line"></span><br><span class="line">//把 Reader 缓存对象中的数据读入到 []byte 类型的 p 中，并返回读取的字节数。读取成功，err 将返回空值</span><br><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br><span class="line"></span><br><span class="line">//返回单个字节，如果没有数据返回 err</span><br><span class="line">func (b *Reader) ReadByte() (byte, error)</span><br><span class="line"></span><br><span class="line">//该方法在 b 中读取 delimz 之前的所有数据，返回的切片是已读出的数据的引用，切片中的数据在下一次的读取操作之前是有效的。如果未找到 delim，将返回查找结果并返回 nil 空值。因为缓存的数据可能被下一次的读写操作修改，因此一般使用 ReadBytes 或者 ReadString，他们返回的都是数据拷贝</span><br><span class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span><br><span class="line"></span><br><span class="line">//功能同 ReadSlice，返回数据的拷贝</span><br><span class="line">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</span><br><span class="line"></span><br><span class="line">//功能同 ReadBytes，返回字符串</span><br><span class="line">func (b *Reader) ReadString(delim byte) (string, error)</span><br><span class="line"></span><br><span class="line">//该方法是一个低水平的读取方式，一般建议使用 ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner 来代替。ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片，用于读取一行数据，不包括行尾标记（\n 或 \r\n）</span><br><span class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span><br><span class="line"></span><br><span class="line">//读取单个 UTF-8 字符并返回一个 rune 和字节大小</span><br><span class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fileObj, err := os.Open("demo.txt")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败：", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer fileObj.Close()</span><br><span class="line">    //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空</span><br><span class="line">    reader := bufio.NewReader(fileObj)</span><br><span class="line">    buf := make([]byte, 1024)</span><br><span class="line">    //读取 Reader 对象中的内容到 []byte 类型的 buf 中</span><br><span class="line">    info, err := reader.Read(buf)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("读取的字节数:" + strconv.Itoa(info))</span><br><span class="line">    //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉</span><br><span class="line">    fmt.Println("读取的文件内容:", string(buf))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">读取的字节数:30</span><br><span class="line">读取的文件内容: http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="并发目录遍历"><a href="#并发目录遍历" class="headerlink" title="并发目录遍历"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5406.html">并发目录遍历</a></h2><p>我们将构建一个程序，根据命令行指定的输入，报告一个或多个目录的磁盘使用情况，类似于 UNIX 的du命令。该程序大多数工作是由下面的 walkDir 函数完成，它使用 dirents 辅助函数来枚举目录中的条目，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树，并在 filesizes 上发送每个已找到文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ioutil.ReadDir 函数返回一个 os.FileInfo 类型的 slice，针对单个文件同样的信息可以通过调用 os.Stat 函数来返回。对每一个子目录，walkDir 递归调用它自己，对于每一个文件，walkDir 发送一条消息到 fileSizes 通道，消息的内容为文件所占用的字节数。</p>
<p>程序的完整代码如下所示，代码中 main 函数使用两个 goroutine，后台 goroutine 调用 walkDir 遍历命令行上指定的每一个目录，最后关闭 fileSizes 通道；主 goroutine 计算从通道中接收的文件的大小的和，最后输出总数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    flag.Parse()</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    go func() {</span><br><span class="line">        for _, root := range roots {</span><br><span class="line">            walkDir(root, fileSizes)</span><br><span class="line">        }</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">    for size := range fileSizes {</span><br><span class="line">        nfiles++</span><br><span class="line">        nbytes += size</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在输出结果前，程序等待较长时间：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go D:/code</span><br><span class="line">18681 files  0.5 GB</span><br></pre></td></tr></tbody></table></figure>
<p>如果程序可以通知它的进度，将会更友好，但是仅把 printDiskUsage 调用移动到循环内部会使它输出数千行结果，所以这里对上面的程序进行一些调整，在有 <code>-v</code> 标识的时候周期性的输出当前目录的总和，如果只想看到最终的结果省略 <code>-v</code> 即可。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var verbose = flag.Bool("v", false, "显示详细进度")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // ...启动后台 goroutine...</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    flag.Parse()</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line">    // 遍历文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    go func() {</span><br><span class="line">        for _, root := range roots {</span><br><span class="line">            walkDir(root, fileSizes)</span><br><span class="line">        }</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line">    // 定期打印结果</span><br><span class="line">    var tick &lt;-chan time.Time</span><br><span class="line">    if *verbose {</span><br><span class="line">        tick = time.Tick(500 * time.Millisecond)</span><br><span class="line">    }</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">loop:</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case size, ok := &lt;-fileSizes:</span><br><span class="line">            if !ok {</span><br><span class="line">                break loop // fileSizes 关闭</span><br><span class="line">            }</span><br><span class="line">            nfiles++</span><br><span class="line">            nbytes += size</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            printDiskUsage(nfiles, nbytes)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes) // 最终总数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为这个程序没有使用 range 循环，所以第一个 select 情况必须显式判断 fileSizes 通道是否已经关闭，使用两个返回值的形式进行接收操作。如果通道已经关闭，程序退出循环。标签化的 break 语句将跳出 select 和 for 循环的逻辑。没有标签的 break 只能跳出 select 的逻辑，导致循环的下一次迭代。</p>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go -v D:\</span><br><span class="line">296077 files  57.9 GB</span><br><span class="line">302142 files  58.0 GB</span><br><span class="line">306669 files  58.1 GB</span><br><span class="line">314725 files  58.2 GB</span><br><span class="line">320050 files  58.3 GB</span><br><span class="line">341713 files  58.6 GB</span><br><span class="line">346102 files  64.2 GB</span><br></pre></td></tr></tbody></table></figure>
<p>此程序的弊端也很明显，它依然会耗费太长的时间。</p>
<p>所以，下面为每一个 walkDir 的调用创建一个新的 goroutine。它使用 sync.WaitGroup 来为当前存活的 walkDir 调用计数，一个 goroutine 在计数器减为 0 的时候关闭 fileSizes 通道。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var verbose = flag.Bool("v", false, "显示详细进度")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // ...确定根目录...</span><br><span class="line">    flag.Parse()</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line">    // 并行遍历每一个文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    var n sync.WaitGroup</span><br><span class="line">    for _, root := range roots {</span><br><span class="line">        n.Add(1)</span><br><span class="line">        go walkDir(root, &amp;n, fileSizes)</span><br><span class="line">    }</span><br><span class="line">    go func() {</span><br><span class="line">        n.Wait()</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line">    // 定期打印结果</span><br><span class="line">    var tick &lt;-chan time.Time</span><br><span class="line">    if *verbose {</span><br><span class="line">        tick = time.Tick(500 * time.Millisecond)</span><br><span class="line">    }</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">loop:</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case size, ok := &lt;-fileSizes:</span><br><span class="line">            if !ok {</span><br><span class="line">                break loop // fileSizes 关闭</span><br><span class="line">            }</span><br><span class="line">            nfiles++</span><br><span class="line">            nbytes += size</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            printDiskUsage(nfiles, nbytes)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes) // 最终总数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) {</span><br><span class="line">    defer n.Done()</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            n.Add(1)</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            go walkDir(subdir, n, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// sema是一个用于限制目录并发数的计数信号量</span><br><span class="line">var sema = make(chan struct{}, 20)</span><br><span class="line"></span><br><span class="line">// dirents返回directory目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    sema &lt;- struct{}{}        // 获取令牌</span><br><span class="line">    defer func() { &lt;-sema }() // 释放令牌</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>尽管系统与系统之间有很多的不同，但是这个版本的速度比前一个版本快几倍。</p>
<h2 id="从INI配置文件中读取需要的值"><a href="#从INI配置文件中读取需要的值" class="headerlink" title="从INI配置文件中读取需要的值"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5407.html">从INI配置文件中读取需要的值</a></h2><p>INI 文件是 Initialization File 的缩写，即初始化文件，是 Windows 的系统配置文件所采用的存储格式，统管 Windows 的各项配置。INI 文件格式由节（section）和键（key）构成，一般用于操作系统、虚幻游戏引擎、GIT 版本管理中，这种配置文件的文件扩展名为.ini。</p>
<p>下面是从 GIT 版本管理的配置文件中截取的一部分内容，展示 INI 文件的样式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line"></span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">hideDotFiles = dotGitOnly</span><br><span class="line">[remote "origin"]</span><br><span class="line">url = https://github.com/davyxu/cellnet</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></tbody></table></figure>
<h3 id="INI-文件的格式"><a href="#INI-文件的格式" class="headerlink" title="INI 文件的格式"></a>INI 文件的格式</h3><p>INI 文件由多行文本组成，整个配置由 <code>[ ]</code> 拆分为多个“段”（section）。每个段中又以 <code>＝</code> 分割为“键”和“值”。</p>
<p>INI 文件以 <code>;</code> 置于行首视为注释，注释后将不会被处理和识别，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[sectionl]</span><br><span class="line">key1=value1</span><br><span class="line">;key2=value2</span><br><span class="line">[section2]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="从-INI-文件中取值的函数"><a href="#从-INI-文件中取值的函数" class="headerlink" title="从 INI 文件中取值的函数"></a>从 INI 文件中取值的函数</h3><p>熟悉了 INI 文件的格式后，下面我们创建一个 example.ini 文件，并将从 GIT 版本管理配置文件中截取的一部分内容复制到该文件中。</p>
<p>准备好 example.ini 文件后，下面我们开始尝试读取该 INI 文件，并从文件中获取需要的数据，完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 根据文件名，段名，键名获取ini的值</span><br><span class="line">func getValue(filename, expectSection, expectKey string) string {</span><br><span class="line">    // 打开文件</span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    // 文件找不到，返回空</span><br><span class="line">    if err != nil {</span><br><span class="line">        return ""</span><br><span class="line">    }</span><br><span class="line">    // 在函数结束时，关闭文件</span><br><span class="line">    defer file.Close()</span><br><span class="line">    // 使用读取器读取文件</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    // 当前读取的段的名字</span><br><span class="line">    var sectionName string</span><br><span class="line">    for {</span><br><span class="line">        // 读取文件的一行</span><br><span class="line">        linestr, err := reader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        // 切掉行的左右两边的空白字符</span><br><span class="line">        linestr = strings.TrimSpace(linestr)</span><br><span class="line">        // 忽略空行</span><br><span class="line">        if linestr == "" {</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        // 忽略注释</span><br><span class="line">        if linestr[0] == ';' {</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        // 行首和尾巴分别是方括号的，说明是段标记的起止符</span><br><span class="line">        if linestr[0] == '[' &amp;&amp; linestr[len(linestr)-1] == ']' {</span><br><span class="line">            // 将段名取出</span><br><span class="line">            sectionName = linestr[1 : len(linestr)-1]</span><br><span class="line">            // 这个段是希望读取的</span><br><span class="line">        } else if sectionName == expectSection {</span><br><span class="line">            // 切开等号分割的键值对</span><br><span class="line">            pair := strings.Split(linestr, "=")</span><br><span class="line">            // 保证切开只有1个等号分割的简直情况</span><br><span class="line">            if len(pair) == 2 {</span><br><span class="line">                // 去掉键的多余空白字符</span><br><span class="line">                key := strings.TrimSpace(pair[0])</span><br><span class="line">                // 是期望的键</span><br><span class="line">                if key == expectKey {</span><br><span class="line">                    // 返回去掉空白字符的值</span><br><span class="line">                    return strings.TrimSpace(pair[1])</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return ""</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(getValue("example.ini", "remote \"origin\"", "fetch"))</span><br><span class="line">    fmt.Println(getValue("example.ini", "core", "hideDotFiles"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本例并不是将整个 INI 文件读取保存后再获取需要的字段数据并返回，这里使用 getValue() 函数，每次从指定文件中找到需要的段（Section）及键（Key）对应的值。</p>
<p>getValue() 函数的声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func getValue(filename, expectSection, expectKey string) string</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明如下。</p>
<ul>
<li>filename：INI 文件的文件名。</li>
<li>expectSection：期望读取的段。</li>
<li>expectKey：期望读取段中的键。</li>
</ul>
<p>getValue() 函数的实际使用例子参考代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    fmt.Println(getValue("example.ini", "remote \"origin\"", "fetch"))</span><br><span class="line">    fmt.Println(getValue("example.ini", "core", "hideDotFiles"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的示例程序，输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">dotGitOnly</span><br></pre></td></tr></tbody></table></figure>
<p>输出内容中“+refs/heads/<em>:refs/remotes/origin/</em>”表示 INI 文件中 <code>[remote "origin"]</code> 的 “fetch” 键对应的值；dotGitOnly 表示 INI 文件中 <code>[core]</code> 中键名为 “hideDotFiles” 的值。</p>
<p><strong>注意 main 函数的第 2 行中，由于段名中包含双引号，所以使用\进行转义。</strong></p>
<p>getValue() 函数的逻辑由 4 部分组成：即读取文件、读取行文本、读取段和读取键值组成。接下来分步骤了解 getValue() 函数的详细处理过程。</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>Go语言的 OS 包中提供了文件打开函数 os.Open()，文件读取完成后需要及时关闭，否则文件会发生占用，系统无法释放缓冲资源。参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 打开文件</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">// 文件找不到，返回空</span><br><span class="line">if err != nil {</span><br><span class="line">    return ""</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在函数结束时，关闭文件</span><br><span class="line">defer file.Close()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，filename 是由 getValue() 函数参数提供的 INI 的文件名。使用 os.Open() 函数打开文件，如果成功打开，会返回文件句柄，同时返回打开文件时可能发生的错误：err。</li>
<li>第 5 行，如果文件打开错误，err 将不为 nil，此时 getValue() 函数返回一个空的字符串，表示无法从给定的 INI 文件中获取到需要的值。</li>
<li>第 10 行，使用 defer 延迟执行函数，defer 并不会在这一行执行，而是延迟在任何一个 getValue() 函数的返回点，也就是函数退出的地方执行。调用 file.Close() 函数后，打开的文件就会被关闭并释放系统资源。</li>
</ul>
<p>INI 文件已经打开了，接下来就可以开始读取 INI 的数据了。</p>
<h3 id="读取行文本"><a href="#读取行文本" class="headerlink" title="读取行文本"></a>读取行文本</h3><p>INI 文件的格式是由多行文本组成，因此需要构造一个循环，不断地读取 INI 文件的所有行。Go语言总是将文件以二进制格式打开，通过不同的读取方式对二进制文件进行操作。Go语言对二进制读取有专门的代码，bufio 包即可以方便地以比较常见的方式读取二进制文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 使用读取器读取文件</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">// 当前读取的段的名字</span><br><span class="line">var sectionName string</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    // 读取文件的一行</span><br><span class="line">    linestr, err := reader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 切掉行的左右两边的空白字符</span><br><span class="line">    linestr = strings.TrimSpace(linestr)</span><br><span class="line"></span><br><span class="line">    // 忽略空行</span><br><span class="line">    if linestr == "" {</span><br><span class="line">        continue</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 忽略注释</span><br><span class="line">    if linestr[0] == ';' {</span><br><span class="line">        continue</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //读取段和键值的代码</span><br><span class="line">    //...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，使用 bufio 包提供的 NewReader() 函数，传入文件并构造一个读取器。</li>
<li>第 5 行，提前声明段的名字字符串，方便后面的段和键值读取。</li>
<li>第 7 行，构建一个读取循环，不断地读取文件中的每一行。</li>
<li>第 10 行，使用 reader.ReadString() 从文件中读取字符串，直到碰到\n，也就是行结束。这个函数返回读取到的行字符串（包括\n）和可能的读取错误 err，例如文件读取完毕。</li>
<li>第 16 行，每一行的文本可能会在标识符两边混杂有空格、回车符、换行符等不可见的空白字符，使用 strings.TrimSpace() 可以去掉这些空白字符。</li>
<li>第 19 行，可能存在空行的情况，继续读取下一行，忽略空行。</li>
<li>第 24 行，当行首的字符为;分号时，表示这一行是注释行，忽略一整行的读取。</li>
</ul>
<p>读取 INI 文本文件时，需要注意各种异常情况。文本中的空白符就是经常容易忽略的部分，空白符在调试时完全不可见，需要打印出字符的 ASCII 码才能辨别。</p>
<p>抛开各种异常情况拿到了每行的行文本 linestr 后，就可以方便地读取 INI 文件的段和键值了。</p>
<h3 id="读取段"><a href="#读取段" class="headerlink" title="读取段"></a>读取段</h3><p>行字符串 linestr 已经去除了空白字符串，段的起止符又以 <code>[</code> 开头，以 <code>]</code> 结尾，因此可以直接判断行首和行尾的字符串匹配段的起止符匹配时读取的是段，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sectionvalue.gif" alt="sectionvalue"></p>
<p>此时，段只是一个标识，而无任何内容，因此需要将段的名字取出保存在 sectionName（己在之前的代码中定义）中，待读取段后面的键值对时使用。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 行首和尾巴分别是方括号的，说明是段标记的起止符</span><br><span class="line">if linestr[0] == '[' &amp;&amp; linestr[len(linestr)-1] == ']' {</span><br><span class="line"></span><br><span class="line">    // 将段名取出</span><br><span class="line">    sectionName = linestr[1 : len(linestr)-1]</span><br><span class="line"></span><br><span class="line">    // 这个段是希望读取的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，<code>linestr[0]</code> 表示行首的字符，<code>len(linestr)-1</code> 取出字符串的最后一个字符索引随后取出行尾的字符。根据两个字符串是否匹配方括号，断定当前行是否为段。</li>
<li>第 5 行，linestr 两边的 <code>[</code> 和 <code>]</code> 去掉，取出中间的段名保存在 sectionName 中，留着后面的代码用。</li>
</ul>
<h3 id="读取键值"><a href="#读取键值" class="headerlink" title="读取键值"></a>读取键值</h3><p>这里代码紧接着前面的代码。当前行不是段时（不以 <code>[</code> 开头），那么行内容一定是键值对。别忘记此时 getValue() 的参数对段有匹配要求。找到能匹配段的键值对后，开始对键值对进行解析，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">else if sectionName == expectSection {</span><br><span class="line"></span><br><span class="line">    // 切开等号分割的键值对</span><br><span class="line">    pair := strings.Split(linestr, "=")</span><br><span class="line"></span><br><span class="line">    // 保证切开只有1个等号分割的简直情况</span><br><span class="line">    if len(pair) == 2 {</span><br><span class="line"></span><br><span class="line">        // 去掉键的多余空白字符</span><br><span class="line">        key := strings.TrimSpace(pair[0])</span><br><span class="line"></span><br><span class="line">        // 是期望的键</span><br><span class="line">        if key == expectKey {</span><br><span class="line"></span><br><span class="line">            // 返回去掉空白字符的值</span><br><span class="line">            return strings.TrimSpace(pair[1])</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，当前的段匹配期望的段时，进行后面的解析。</li>
<li>第 4 行，对行内容（linestr）通过 <code>strings.Split()</code> 函数进行切割，INI 的键值对使用 <code>=</code> 分割，分割后 <code>strings.Split()</code> 函数会返回字符串切片，其类型为  <code>[]string</code> 。这里只考虑一个=的情况，因此被分割后 <code>strings.Split()</code> 函数返回的字符串切片有 2 个元素。</li>
<li>第 7 行，只考虑切割出 2 个元素的情况。其他情况会被忽略， 键值如没有 <code>=</code> 、行中多余一个 <code>=</code> 等情况。</li>
<li>第 10 行，<code>pair[0]</code> 表示 <code>=</code> 左边的键。使用 <code>strings.TrimSpace()</code> 函数去掉空白符，如下图所示。</li>
<li>第 13 行，键值对切割出后，还需要判断键是否为期望的键。</li>
<li>第 16 行，匹配期望的键时，将 <code>pair[1]</code> 中保存的键对应的值经过去掉空白字符处理后作为函数返回值返回。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/inivalue.gif" alt="图：lNI 的键值解析"></p>
<h2 id="文件的写入、追加、读取、复制操作"><a href="#文件的写入、追加、读取、复制操作" class="headerlink" title="文件的写入、追加、读取、复制操作"></a>文件的写入、追加、读取、复制操作</h2><p>Go语言的 os 包下有一个 OpenFile 函数，其原型如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的。</p>
<p>下面列举了一些常用的 flag 文件处理参数：</p>
<ul>
<li>O_RDONLY：只读模式打开文件；</li>
<li>O_WRONLY：只写模式打开文件；</li>
<li>O_RDWR：读写模式打开文件；</li>
<li>O_APPEND：写操作时将数据附加到文件尾部（追加）；</li>
<li>O_CREATE：如果不存在将创建一个新文件；</li>
<li>O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；</li>
<li>O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；</li>
<li>O_TRUNC：如果可能，在打开时清空文件。</li>
</ul>
<p>【示例 1】：创建一个新文件 golang.txt，并在其中写入 5 句 <code>“http://c.biancheng.net/golang/”</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建一个新文件，写入内容 5 句 “http://c.biancheng.net/golang/”</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("http://c.biancheng.net/golang/ \n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后会在指定目录下生成一个 golang.txt 文件，打开该文件如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext.gif" alt="golangtext"></p>
<p>【示例 2】：打开一个存在的文件，在原来的内容追加内容“C语言中文网”</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("C语言中文网 \r\n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后，打开 golang.txt 文件发现内容追加成功，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext1.gif" alt="golangtext1"></p>
<p>【示例 3】：打开一个存在的文件，将原来的内容读出来，显示在终端，并且追加 5 句“Hello，C语言中文网”。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //读原来文件的内容，并且显示在终端</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    for {</span><br><span class="line">        str, err := reader.ReadString('\n')</span><br><span class="line">        if err == io.EOF {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print(str)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("Hello，C语言中文网。 \r\n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后，会在控制台打印出文件的内容，并在文件中追加指定的内容，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext2.gif" alt="golangtext2"></p>
<p>【示例 4】：编写一个程序，将一个文件的内容复制到另外一个文件（注：这两个文件都已存在）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file1Path := "e:/code/golang.txt"</span><br><span class="line">    file2Path := "e:/code/other.txt"</span><br><span class="line">    data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败=%v\n", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    err = ioutil.WriteFile(file2Path, data, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败=%v\n", err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功后，发现内容已经复制成功，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext3.gif" alt="golangtext3"></p>
<h2 id="文件锁操作"><a href="#文件锁操作" class="headerlink" title="文件锁操作"></a>文件锁操作</h2><p>我们使用Go语言开发一些程序的时候，往往出现多个进程同时操作同一份文件的情况，这很容易导致文件中的数据混乱。这时我们就需要采用一些手段来平衡这些冲突，文件锁（flock）应运而生，下面我们就来介绍一下。</p>
<p>对于 flock，最常见的例子就是 Nginx，进程运行起来后就会把当前的 PID 写入这个文件，当然如果这个文件已经存在了，也就是前一个进程还没有退出，那么 Nginx 就不会重新启动，所以 flock 还可以用来检测进程是否存在。</p>
<p>flock 是对于整个文件的建议性锁。也就是说，如果一个进程在一个文件（inode）上放了锁，其它进程是可以知道的（建议性锁不强求进程遵守）。最棒的一点是，它的第一个参数是文件描述符，在此文件描述符关闭时，锁会自动释放。而当进程终止时，所有的文件描述符均会被关闭。所以很多时候就不用考虑类似原子锁解锁的事情。</p>
<p>在具体介绍前，先上代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "sync"</span><br><span class="line">    "syscall"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//文件锁</span><br><span class="line">type FileLock struct {</span><br><span class="line">    dir string</span><br><span class="line">    f   *os.File</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func New(dir string) *FileLock {</span><br><span class="line">    return &amp;FileLock{</span><br><span class="line">        dir: dir,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//加锁</span><br><span class="line">func (l *FileLock) Lock() error {</span><br><span class="line">    f, err := os.Open(l.dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return err</span><br><span class="line">    }</span><br><span class="line">    l.f = f</span><br><span class="line">    err = syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return fmt.Errorf("cannot flock directory %s - %s", l.dir, err)</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//释放锁</span><br><span class="line">func (l *FileLock) Unlock() error {</span><br><span class="line">    defer l.f.Close()</span><br><span class="line">    return syscall.Flock(int(l.f.Fd()), syscall.LOCK_UN)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test_file_path, _ := os.Getwd()</span><br><span class="line">    locked_file := test_file_path</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup{}</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(num int) {</span><br><span class="line">            flock := New(locked_file)</span><br><span class="line">            err := flock.Lock()</span><br><span class="line">            if err != nil {</span><br><span class="line">                wg.Done()</span><br><span class="line">                fmt.Println(err.Error())</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            fmt.Printf("output : %d\n", num)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Windows 系统下运行上面的代码会出现下面的错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">undefined: syscall.Flock</span><br><span class="line">undefined: syscall.LOCK_EX</span><br><span class="line">undefined: syscall.LOCK_NB</span><br><span class="line">undefined: syscall.Flock</span><br><span class="line">undefined: syscall.LOCK_UN</span><br></pre></td></tr></tbody></table></figure>
<p>这是因为 Windows 系统不支持 pid 锁，所以我们需要在 Linux 或 Mac 系统下才能正常运行上面的程序。</p>
<p>上面代码中演示了同时启动 10 个 goroutinue，但在程序运行过程中，只有一个 goroutine 能获得文件锁（flock）。其它的 goroutinue 在获取不到 flock 后，会抛出异常的信息。这样即可达到同一文件在指定的周期内只允许一个进程访问的效果。</p>
<p>代码中文件锁的具体调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)</span><br></pre></td></tr></tbody></table></figure>
<p>我们采用了 syscall.LOCK_EX、syscall.LOCK_NB，这是什么意思呢？</p>
<p>flock 属于建议性锁，不具备强制性。一个进程使用 flock 将文件锁住，另一个进程可以直接操作正在被锁的文件，修改文件中的数据，原因在于 flock 只是用于检测文件是否被加锁，针对文件已经被加锁，另一个进程写入数据的情况，内核不会阻止这个进程的写入操作，也就是建议性锁的内核处理策略。</p>
<p>flock 主要三种操作类型：</p>
<ul>
<li>LOCK_SH：共享锁，多个进程可以使用同一把锁，常被用作读共享锁；</li>
<li>LOCK_EX：排他锁，同时只允许一个进程使用，常被用作写锁；</li>
<li>LOCK_UN：释放锁。</li>
</ul>
<p>进程使用 flock 尝试锁文件时，如果文件已经被其他进程锁住，进程会被阻塞直到锁被释放掉，或者在调用 flock 的时候，采用 LOCK_NB 参数。在尝试锁住该文件的时候，发现已经被其他服务锁住，会返回错误，错误码为 EWOULDBLOCK。</p>
<p>flock 锁的释放非常具有特色，即可调用 LOCK_UN 参数来释放文件锁，也可以通过关闭 fd 的方式来释放文件锁（flock 的第一个参数是 fd），意味着 flock 会随着进程的关闭而被自动释放掉。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go 文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title>go反射（reflect），Golang反射（reflect）</title>
    <url>/posts/b3ea2e2d/</url>
    <content><![CDATA[<p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p><strong>其它语言中的反射:</strong></p>
<p>C/C++ 语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。Java、C# 等语言都支持完整的反射功能。</p>
<p>Lua、JavaScript 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。</p>
<p>Go 程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p>
<p>Go语言提供了 reflect 包来访问程序的反射信息。</p>
<h3 id="reflect-包"><a href="#reflect-包" class="headerlink" title="reflect 包"></a>reflect 包</h3><p>Go语言中的反射是由 reflect 包提供支持的，它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。</p>
<h3 id="反射的类型对象（reflect-Type）"><a href="#反射的类型对象（reflect-Type）" class="headerlink" title="反射的类型对象（reflect.Type）"></a>反射的类型对象（reflect.Type）</h3><p>在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a int</span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int  int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，定义一个 int 类型的变量。</li>
<li>第 10 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。</li>
<li>第 11 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。</li>
</ul>
<h3 id="反射的类型（Type）与种类（Kind）"><a href="#反射的类型（Type）与种类（Kind）" class="headerlink" title="反射的类型（Type）与种类（Kind）"></a>反射的类型（Type）与种类（Kind）</h3><p>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<p><strong>1)反射种类（Kind）的定义:</strong></p>
<p>Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<p><strong>2)从类型对象中获取类型名称和种类：</strong></p>
<p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>下面的代码中会对常量和结构体进行类型信息获取。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个Enum类型</span><br><span class="line">type Enum int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Zero Enum = 0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">    // 获取Zero常量的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(Zero)</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cat struct</span><br><span class="line">Enum int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 17 行，声明结构体类型 cat。</li>
<li>第 20 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。</li>
<li>第 22 行，输出 cat 的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。</li>
<li>第 24 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。</li>
<li>第 26 行，输出 Zero 对应的类型对象的类型名和种类。</li>
</ul>
<h3 id="指针与指针指向的元素"><a href="#指针与指针指向的元素" class="headerlink" title="指针与指针指向的元素"></a>指针与指针指向的元素</h3><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个 <code>*</code> 操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := &amp;cat{}</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("name:'%v' kind:'%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">    // 取类型的元素</span><br><span class="line">    typeOfCat = typeOfCat.Elem()</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name:'' kind:'ptr'</span><br><span class="line">element name: 'cat', element kind: 'struct'</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，创建了 cat 结构体的实例，ins 是一个 <code>*cat</code> 类型的指针变量。</li>
<li>第 15 行，对指针变量获取反射类型信息。</li>
<li>第 17 行，输出指针变量的类型名称和种类。Go语言的反射中对所有指针变量的种类都是 Ptr，但需要注意的是，指针变量的类型名称是空，不是 *cat。</li>
<li>第 19 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。</li>
<li>第 21 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。</li>
</ul>
<h3 id="使用反射获取结构体的成员类型"><a href="#使用反射获取结构体的成员类型" class="headerlink" title="使用反射获取结构体的成员类型"></a>使用反射获取结构体的成员类型</h3><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。</p>
<p>与成员获取相关的 reflect.Type 的方法如下表所示。</p>
<table>
    <caption>结构体成员访问的方法列表</caption>
    <thead><tr><th>方法</th><th>说明</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)StructField</td><td>根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)(StructField,bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息，没有找到时bool返回false，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)StructField</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)(StructField,bool)</td><td>根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<p><strong>1)结构体字段类型</strong></p>
<p>reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（StructTag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。</p>
<p>StructField 的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type StructField struct {</span><br><span class="line">    Name string          // 字段名</span><br><span class="line">    PkgPath string       // 字段路径</span><br><span class="line">    Type      Type       // 字段反射类型对象</span><br><span class="line">    Tag       StructTag  // 字段的结构体标签</span><br><span class="line">    Offset    uintptr    // 字段在结构体中的相对偏移</span><br><span class="line">    Index     []int      // Type.FieldByIndex中的返回的索引值</span><br><span class="line">    Anonymous bool       // 是否为匿名字段</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字段说明如下：</p>
<ul>
<li>Name：为字段名称。</li>
<li>PkgPath：字段在结构体中的路径。</li>
<li>Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。</li>
<li>Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。</li>
<li>Index：FieldByIndex 中的索引顺序。</li>
<li>Anonymous：表示该字段是否为匿名字段。</li>
</ul>
<p><strong>2)获取成员反射信息</strong></p>
<p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<p>反射访问结构体成员类型及信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        // 带有结构体tag的字段</span><br><span class="line">        Type int `json:"type" id:"100"`</span><br><span class="line">    }</span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := cat{Name: "mimi", Type: 1}</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line">    // 遍历结构体所有成员</span><br><span class="line">    for i := 0; i &lt; typeOfCat.NumField(); i++ {</span><br><span class="line">        // 获取每个成员的结构体字段类型</span><br><span class="line">        fieldType := typeOfCat.Field(i)</span><br><span class="line">        // 输出成员名和tag</span><br><span class="line">        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)</span><br><span class="line">    }</span><br><span class="line">    // 通过字段名, 找到字段类型信息</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line">        // 从tag中取出需要的tag</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name: Name  tag: ''</span><br><span class="line">name: Type  tag: 'json:"type" id:"100"'</span><br><span class="line">type 100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，声明了带有两个成员的 cat 结构体。</li>
<li>第 13 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以 ` 开始和结尾的字符串。这个字符串在Go语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。</li>
<li>第 16 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。</li>
<li>第 18 行，获取实例的反射类型对象。</li>
<li>第 20 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。</li>
<li>第 22 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。</li>
<li>第 24 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是 StructField 结构体。</li>
<li>第 27 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，catType 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。</li>
<li>第 29 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。</li>
</ul>
<h3 id="结构体标签（Struct-Tag）"><a href="#结构体标签（Struct-Tag）" class="headerlink" title="结构体标签（Struct Tag）"></a>结构体标签（Struct Tag）</h3><p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。</p>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<p><strong>1)结构体标签的格式:</strong></p>
<p>Tag 在结构体字段后方书写的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">`key1:"value1" key2:"value2"`</span><br></pre></td></tr></tbody></table></figure>
<p>结构体标签由一个或多个键值对组成；键与值使用冒号分隔，值用双引号括起来；键值对之间使用一个空格分隔。</p>
<p><strong>2)从结构体标签中获取值：</strong></p>
<p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：<br>— <code>func (tag StructTag) Get(key string) string</code>：根据 Tag 中的键获取对应的值，例如 `key1:”value1” key2:”value2”` 的 Tag 中，可以传入“key1”获得“value1”。</p>
<ul>
<li><code>func (tag StructTag) Lookup(key string) (value string, ok bool)</code> ：根据 Tag 中的键，查询值是否存在。</li>
</ul>
<p><strong>3) 结构体标签格式错误导致的问题：</strong></p>
<p>编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        Type int `json: "type" id:"100"`</span><br><span class="line">    }</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会输出一个空字符串，并不会输出期望的 type。</p>
<p>代码第 11 行中，在 json: 和 “type” 之间增加了一个空格，这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。这个错误在开发中非常容易被疏忽，造成难以察觉的错误。所以将第 12 行代码修改为下面的样子，则可以正常打印。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type cat struct {</span><br><span class="line">    Name string</span><br><span class="line">    Type int `json:"type" id:"100"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type</span><br></pre></td></tr></tbody></table></figure>
<h2 id="反射规则浅析"><a href="#反射规则浅析" class="headerlink" title="反射规则浅析"></a>反射规则浅析</h2><p>反射是众多编程语言中的一个非常实用的功能，它是一种能够自描述、自控制的应用，Go语言也对反射提供了友好的支持。</p>
<p>Go语言中使用反射可以在编译时不知道类型的情况下更新变量，在运行时查看值、调用方法以及直接对他们的布局进行操作。</p>
<p>由于反射是建立在类型系统（type system）上的，所以我们先来复习一下Go语言中的类型。</p>
<h3 id="Go语言中的类型"><a href="#Go语言中的类型" class="headerlink" title="Go语言中的类型"></a>Go语言中的类型</h3><p>Go语言是一门静态类型的语言，每个变量都有一个静态类型，类型在编译的时候确定下来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">var i int</span><br><span class="line">var j MyInt</span><br></pre></td></tr></tbody></table></figure>
<p>变量 i 的类型是 int，变量 j 的类型是 MyInt，虽然它们有着相同的基本类型，但静态类型却不一样，在没有类型转换的情况下，它们之间无法互相赋值。</p>
<p>接口是一个重要的类型，它意味着一个确定的方法集合，一个接口变量可以存储任何实现了接口的方法的具体值（除了接口本身），例如 io.Reader 和 io.Writer：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Reader is the interface that wraps the basic Read method.</span><br><span class="line">type Reader interface {</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Writer is the interface that wraps the basic Write method.</span><br><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个类型声明实现了 Reader（或 Writer）方法，那么它便实现了 io.Reader（或 io.Writer），这意味着一个 io.Reader 的变量可以持有任何一个实现了 Read 方法的的类型的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = new(bytes.Buffer)</span><br><span class="line">// and so on</span><br></pre></td></tr></tbody></table></figure>
<p>必须要弄清楚的一点是，不管变量 r 中的具体值是什么，r 的类型永远是 io.Reader，由于Go语言是静态类型的，r 的静态类型就是 io.Reader。</p>
<p>在接口类型中有一个极为重要的例子——空接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>它表示了一个空的方法集，一切值都可以满足它，因为它们都有零值或方法。</p>
<p>有人说Go语言的接口是动态类型，这是错误的，它们都是静态类型，虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。我们必须精确地了解这些，因为反射与接口是密切相关的。</p>
<p>关于接口我们就介绍到这里，下面我们看看Go语言的反射三定律。</p>
<h3 id="反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”"><a href="#反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”" class="headerlink" title="反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”"></a>反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”</h3><p><strong>注：这里反射类型指 reflect.Type 和 reflect.Value。</strong></p>
<p>从使用方法上来讲，反射提供了一种机制，允许程序在运行时检查接口变量内部存储的 (value, type) 对。</p>
<p>在最开始，我们先了解下 reflect 包的两种类型 Type 和 Value，这两种类型使访问接口内的数据成为可能，它们对应两个简单的方法，分别是 reflect.TypeOf 和 reflect.ValueOf，分别用来读取接口变量的 reflect.Type 和 reflect.Value 部分。</p>
<p>当然，从 reflect.Value 也很容易获取到 reflect.Type，目前我们先将它们分开。</p>
<p>首先，我们下看 reflect.TypeOf：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    fmt.Println("type:", reflect.TypeOf(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type: float64</span><br></pre></td></tr></tbody></table></figure>
<p>大家可能会疑惑，为什么没看到接口？这段代码看起来只是把一个 float64 类型的变量 x 传递给 reflect.TypeOf 并没有传递接口。其实在 reflect.TypeOf 的函数签名里包含一个空接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// TypeOf returns the reflection Type of the value in the interface{}.</span><br><span class="line">func TypeOf(i interface{}) Type</span><br></pre></td></tr></tbody></table></figure>
<p>我们调用 reflect.TypeOf(x) 时，x 被存储在一个空接口变量中被传递过去，然后 reflect.TypeOf 对空接口变量进行拆解，恢复其类型信息。</p>
<p>函数 reflect.ValueOf 也会对底层的值进行恢复：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    fmt.Println("value:", reflect.ValueOf(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">value: 3.4</span><br></pre></td></tr></tbody></table></figure>
<p>类型 reflect.Type 和 reflect.Value 都有很多方法，我们可以检查和使用它们，这里我们举几个例子。</p>
<p>类型 reflect.Value 有一个方法 Type()，它会返回一个 reflect.Type 类型的对象。</p>
<p>Type 和 Value 都有一个名为 Kind 的方法，它会返回一个常量，表示底层数据的类型，常见值有：Uint、Float64、Slice 等。</p>
<p>Value 类型也有一些类似于 Int、Float 的方法，用来提取底层的数据：<br>Int 方法用来提取 int64<br>Float 方法用来提取 float64，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("type:", v.Type())</span><br><span class="line">    fmt.Println("kind is float64:", v.Kind() == reflect.Float64)</span><br><span class="line">    fmt.Println("value:", v.Float())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type: float64</span><br><span class="line">kind is float64: true</span><br><span class="line">value: 3.4</span><br></pre></td></tr></tbody></table></figure>
<p>还有一些用来修改数据的方法，比如 SetInt、SetFloat。在介绍它们之前，我们要先理解“可修改性”（settability），这一特性会在下面进行详细说明。</p>
<p>反射库提供了很多值得列出来单独讨论的属性，下面就来介绍一下。</p>
<p>首先是介绍下 Value 的 getter 和 setter 方法，为了保证 API 的精简，这两个方法操作的是某一组类型范围最大的那个。比如，处理任何含符号整型数，都使用 int64，也就是说 Value 类型的 Int 方法返回值为 int64 类型，SetInt 方法接收的参数类型也是 int64 类型。实际使用时，可能需要转化为实际的类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x uint8 = 'x'</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("type:", v.Type())                            // uint8.</span><br><span class="line">    fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.</span><br><span class="line">    x = uint8(v.Uint())                                       // v.Uint returns a uint64.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type: uint8</span><br><span class="line">kind is uint8: true</span><br></pre></td></tr></tbody></table></figure>
<p>其次，反射对象的 Kind 方法描述的是基础类型，而不是静态类型。如果一个反射对象包含了用户定义类型的值，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var x MyInt = 7</span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，虽然变量 v 的静态类型是 MyInt，而不是 int，但 Kind 方法仍然会返回 reflect.Int。换句话说 Kind 方法不会像 Type 方法一样区分 MyInt 和 int。</p>
<h3 id="反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”"><a href="#反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”" class="headerlink" title="反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”"></a>反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”</h3><p>和物理学中的反射类似，Go语言中的反射也能创造自己反面类型的对象。</p>
<p>根据一个 reflect.Value 类型的变量，我们可以使用 Interface 方法恢复其接口类型的值。事实上，这个方法会把 type 和 value 信息打包并填充到一个接口变量中，然后返回。</p>
<p>其函数声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Interface returns v's value as an interface{}.</span><br><span class="line">func (v Value) Interface() interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>然后，我们可以通过断言，恢复底层的具体值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">y := v.Interface().(float64) // y will have type float64.</span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></tbody></table></figure>
<p>上面这段代码会打印出一个 float64 类型的值，也就是反射类型变量 v 所代表的值。</p>
<p>事实上，我们可以更好地利用这一特性，标准库中的 fmt.Println 和 fmt.Printf 等函数都接收空接口变量作为参数，fmt 包内部会对接口变量进行拆包，因此 fmt 包的打印函数在打印 reflect.Value 类型变量的数据时，只需要把 Interface 方法的结果传给格式化打印程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(v.Interface())</span><br></pre></td></tr></tbody></table></figure>
<p>为什么不直接使用 fmt.Println(v)？因为 v 的类型是 reflect.Value，我们需要的是它的具体值，由于值的类型是 float64，我们也可以用浮点格式化打印它：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Printf("value is %7.1e\n", v.Interface())</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.4e+00</span><br></pre></td></tr></tbody></table></figure>
<p>同样，这次也不需要对 v.Interface() 的结果进行类型断言，空接口值内部包含了具体值的类型信息，Printf 函数会恢复类型信息。</p>
<p>简单来说 Interface 方法和 ValueOf 函数作用恰好相反，唯一一点是，返回值的静态类型是 interface{}。</p>
<p>Go的反射机制可以将“接口类型的变量”转换为“反射类型的对象”，然后再将“反射类型对象”转换过去。</p>
<h3 id="反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”"><a href="#反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”" class="headerlink" title="反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”"></a>反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”</h3><p>这条定律很微妙，也很容易让人迷惑，但是如果从第一条定律开始看，应该比较容易理解。</p>
<p>下面这段代码虽然不能正常工作，但是非常值得研究：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(7.1) // Error: will panic</span><br></pre></td></tr></tbody></table></figure>
<p>如果运行这段代码，它会抛出一个奇怪的异常：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>这里问题不在于值 <code>7.1</code> 不能被寻址，而是因为变量 v 是“不可写的”，“可写性”是反射类型变量的一个属性，但不是所有的反射类型变量都拥有这个属性。</p>
<p>我们可以通过 CanSet 方法检查一个 reflect.Value 类型变量的“可写性”，对于上面的例子，可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("settability of v:", v.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">settability of v: false</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个不具有“可写性”的 Value 类型变量，调用 Set 方法会报出错误。</p>
<p>首先我们要弄清楚什么是“可写性”，“可写性”有些类似于寻址能力，但是更严格，它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。“可写性”最终是由一个反射对象是否存储了原始值而决定的。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></tbody></table></figure>
<p>这里我们传递给 reflect.ValueOf 函数的是变量 x 的一个拷贝，而非 x 本身，想象一下如果下面这行代码能够成功执行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">v.SetFloat(7.1)</span><br></pre></td></tr></tbody></table></figure>
<p>如果这行代码能够成功执行，它不会更新 x，虽然看起来变量 v 是根据 x 创建的，相反它会更新 x 存在于反射对象 v 内部的一个拷贝，而变量 x 本身完全不受影响。这会造成迷惑，并且没有任何意义，所以是不合法的。“可写性”就是为了避免这个问题而设计的。</p>
<p>这看起来很诡异，事实上并非如此，而且类似的情况很常见。考虑下面这行代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">f(x)</span><br></pre></td></tr></tbody></table></figure>
<p>代码中，我们把变量 x 的一个拷贝传递给函数，因此不期望它会改变 x 的值。如果期望函数 f 能够修改变量 x，我们必须传递 x 的地址（即指向 x 的指针）给函数 f，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">f(&amp;x)</span><br></pre></td></tr></tbody></table></figure>
<p>反射的工作机制与此相同，如果想通过反射修改变量 x，就要把想要修改的变量的指针传递给反射库。</p>
<p>首先，像通常一样初始化变量 x，然后创建一个指向它的反射对象，命名为 p：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    fmt.Println("type of p:", p.Type())</span><br><span class="line">    fmt.Println("settability of p:", p.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type of p: *float64</span><br><span class="line">settability of p: false</span><br></pre></td></tr></tbody></table></figure>
<p>反射对象 p 是不可写的，但是我们也不像修改 p，事实上我们要修改的是 *p。为了得到 p 指向的数据，可以调用 Value 类型的 Elem 方法。Elem 方法能够对指针进行“解引用”，然后将结果存储到反射 Value 类型对象 v 中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    v := p.Elem()</span><br><span class="line">    fmt.Println("settability of v:", v.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">settability of v: true</span><br></pre></td></tr></tbody></table></figure>
<p>由于变量 v 代表 x， 因此我们可以使用 v.SetFloat 修改 x 的值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    v := p.Elem()</span><br><span class="line">    v.SetFloat(7.1)</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">7.1</span><br><span class="line">7.1</span><br></pre></td></tr></tbody></table></figure>
<p>反射不太容易理解，reflect.Type 和 reflect.Value 会混淆正在执行的程序，但是它做的事情正是编程语言做的事情。只需要记住：只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们一般使用反射修改结构体的字段，只要有结构体的指针，我们就可以修改它的字段。</p>
<p>下面是一个解析结构体变量 t 的例子，用结构体的地址创建反射变量，再修改它。然后我们对它的类型设置了 typeOfT，并用调用简单的方法迭代字段。</p>
<p>需要注意的是，我们从结构体的类型中提取了字段的名字，但每个字段本身是正常的 reflect.Value 对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type T struct {</span><br><span class="line">        A int</span><br><span class="line">        B string</span><br><span class="line">    }</span><br><span class="line">    t := T{23, "skidoo"}</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT := s.Type()</span><br><span class="line">    for i := 0; i &lt; s.NumField(); i++ {</span><br><span class="line">        f := s.Field(i)</span><br><span class="line">        fmt.Printf("%d: %s %s = %v\n", i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0: A int = 23</span><br><span class="line">1: B string = skidoo</span><br></pre></td></tr></tbody></table></figure>
<p>T 字段名之所以大写，是因为结构体中只有可导出的字段是“可设置”的。</p>
<p>因为 s 包含了一个可设置的反射对象，我们可以修改结构体字段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type T struct {</span><br><span class="line">        A int</span><br><span class="line">        B string</span><br><span class="line">    }</span><br><span class="line">    t := T{23, "skidoo"}</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    s.Field(0).SetInt(77)</span><br><span class="line">    s.Field(1).SetString("Sunset Strip")</span><br><span class="line">    fmt.Println("t is now", t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">t is now {77 Sunset Strip}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们修改了程序让 s 由 t（而不是 &amp;t）创建，程序就会在调用 SetInt 和 SetString 的地方失败，因为 t 的字段是不可设置的。</p>
<h3 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h3><p>反射规则可以总结为如下几条：</p>
<ul>
<li>反射可以将“接口类型变量”转换为“反射类型对象”；</li>
<li>反射可以将“反射类型对象”转换为“接口类型变量”；</li>
<li>如果要修改“反射类型对象”，其值必须是“可写的”。</li>
</ul>
<h2 id="反射——性能和灵活性的双刃剑"><a href="#反射——性能和灵活性的双刃剑" class="headerlink" title="反射——性能和灵活性的双刃剑"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/127.html">反射——性能和灵活性的双刃剑</a></h2><p>现在的一些流行设计思想需要建立在反射基础上，如控制反转（Inversion Of Control，IOC）和依赖注入（Dependency Injection，DI）。Go语言中非常有名的 Web 框架 martini（<code>https://github.com/go-martini/martini</code>）就是通过依赖注入技术进行中间件的实现，例如使用 martini 框架搭建的 http 的服务器如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/go-martini/martini"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    m := martini.Classic()</span><br><span class="line">    m.Get("/", func() string {</span><br><span class="line">        return "Hello world!"</span><br><span class="line">    })</span><br><span class="line">    m.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 7 行，响应路径 <code>/</code> 的代码使用一个闭包实现。如果希望获得 Go语言中提供的请求和响应接口，可以直接修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m.Get("/", func(res http.ResponseWriter, req *http.Request) string {</span><br><span class="line">    // 响应处理代码……</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>martini 的底层会自动通过识别 Get 获得的闭包参数情况，通过动态反射调用这个函数并传入需要的参数。martini 的设计广受好评，但同时也有人指出，其运行效率较低。其中最主要的因素是大量使用了反射。</p>
<p>虽然一般情况下，I/O 的延迟远远大于反射代码所造成的延迟。但是，更低的响应速度和更低的 CPU 占用依然是 Web 服务器追求的目标。因此，反射在带来灵活性的同时，也带上了性能低下的桎梏。</p>
<p>要用好反射这把双刃剑，就需要详细了解反射的性能。下面的一些基准测试从多方面对比了原生调用和反射调用的区别。</p>
<h3 id="1-结构体成员赋值对比"><a href="#1-结构体成员赋值对比" class="headerlink" title="1)结构体成员赋值对比"></a>1)结构体成员赋值对比</h3><p>反射经常被使用在结构体上，因此结构体的成员访问性能就成为了关注的重点。下面例子中使用一个被实例化的结构体，访问它的成员，然后使用 Go语言的基准化测试可以迅速测试出结果。</p>
<p>反射性能测试的完整代码位于./src/chapter12/reflecttest/reflect_test.go，下面是对各个部分的详细说明。</p>
<p>原生结构体的赋值过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个结构体, 拥有一个字段</span><br><span class="line">type data struct {</span><br><span class="line">    Hp int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkNativeAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    // 实例化结构体</span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    // 停止基准测试的计时器</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    // 重置基准测试计时器数据</span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    // 重新启动基准测试计时器</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    // 根据基准测试数据进行循环测试</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 结构体成员赋值测试</span><br><span class="line">        v.Hp = 3</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明一个普通结构体，拥有一个成员变量。</li>
<li>第 6 行，使用基准化测试的入口。</li>
<li>第 9 行，实例化 data 结构体，并给 Hp 成员赋值。</li>
<li>第 12～17 行，由于测试的重点必须放在赋值上，因此需要极大程度地降低其他代码的干扰，于是在赋值完成后，将基准测试的计时器复位并重新开始。</li>
<li>第 20 行，将基准测试提供的测试数量用于循环中。</li>
<li>第 23 行，测试的核心代码：结构体赋值。</li>
</ul>
<p>接下来的代码分析使用反射访问结构体成员并赋值的过程。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func BenchmarkReflectAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    // 取出结构体指针的反射值对象并取其元素</span><br><span class="line">    vv := reflect.ValueOf(&amp;v).Elem()</span><br><span class="line"></span><br><span class="line">    // 根据名字取结构体成员</span><br><span class="line">    f := vv.FieldByName("Hp")</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 反射测试设置成员值性能</span><br><span class="line">        f.SetInt(3)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，取v的地址并转为反射值对象。此时值对象里的类型为 *data，使用值的 Elem() 方法取元素，获得 data 的反射值对象。</li>
<li>第 9 行，使用 FieldByName() 根据名字取出成员的反射值对象。</li>
<li>第 11～13 行，重置基准测试计时器。</li>
<li>第 18 行，使用反射值对象的 SetInt() 方法，给 data 结构的Hp字段设置数值 3。</li>
</ul>
<p>这段代码中使用了反射值对象的 SetInt() 方法，这个方法的源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (v Value) SetInt(x int64) {</span><br><span class="line">    v.mustBeAssignable()</span><br><span class="line">    switch k := v.kind(); k {</span><br><span class="line">    default:</span><br><span class="line">        panic(&amp;ValueError{"reflect.Value.SetInt", v.kind()})</span><br><span class="line">    case Int:</span><br><span class="line">        *(*int)(v.ptr) = int(x)</span><br><span class="line">    case Int8:</span><br><span class="line">        *(*int8)(v.ptr) = int8(x)</span><br><span class="line">    case Int16:</span><br><span class="line">        *(*int16)(v.ptr) = int16(x)</span><br><span class="line">    case Int32:</span><br><span class="line">        *(*int32)(v.ptr) = int32(x)</span><br><span class="line">    case Int64:</span><br><span class="line">        *(*int64)(v.ptr) = x</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现，整个设置过程都是指针转换及赋值，没有遍历及内存操作等相对耗时的算法。</p>
<h3 id="2-结构体成员搜索并赋值对比"><a href="#2-结构体成员搜索并赋值对比" class="headerlink" title="2)结构体成员搜索并赋值对比"></a>2)结构体成员搜索并赋值对比</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func BenchmarkReflectFindFieldAndAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    vv := reflect.ValueOf(&amp;v).Elem()</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 测试结构体成员的查找和设置成员的性能</span><br><span class="line">        vv.FieldByName("Hp").SetInt(3)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码将反射值对象的 FieldByName() 方法与 SetInt() 方法放在循环里进行检测，主要对比测试 FieldByName() 方法对性能的影响。FieldByName() 方法源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (v Value) FieldByName(name string) Value {</span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    if f, ok := v.typ.FieldByName(name); ok {</span><br><span class="line">        return v.FieldByIndex(f.Index)</span><br><span class="line">    }</span><br><span class="line">    return Value{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>底层代码说明如下：</p>
<ul>
<li>第 3 行，通过名字查询类型对象，这里有一次遍历过程。</li>
<li>第 4 行，找到类型对象后，使用 FieldByIndex() 继续在值中查找，这里又是一次遍历。</li>
</ul>
<p>经过底层代码分析得出，随着结构体字段数量和相对位置的变化，FieldByName() 方法比较严重的低效率问题。</p>
<h3 id="3-调用函数对比"><a href="#3-调用函数对比" class="headerlink" title="3)调用函数对比"></a>3)调用函数对比</h3><p>反射的函数调用，也是使用反射中容易忽视的性能点，下面展示对普通函数的调用过程。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 一个普通函数</span><br><span class="line">func foo(v int) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkNativeCall(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        // 原生函数调用</span><br><span class="line">        foo(0)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkReflectCall(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    // 取函数的反射值对象</span><br><span class="line">    v := reflect.ValueOf(foo)</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        // 反射调用函数</span><br><span class="line">        v.Call([]reflect.Value{reflect.ValueOf(2)})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，一个普通的只有一个参数的函数。</li>
<li>第 10 行，对原生函数调用的性能测试。</li>
<li>第 17 行，根据函数名取出反射值对象。</li>
<li>第 25 行，使用 reflect.ValueOf(2) 将 2 构造为反射值对象，因为反射函数调用的参数必须全是反射值对象，再使用 []reflect.Value 构造多个参数列表传给反射值对象的 Call() 方法进行调用。</li>
</ul>
<p>反射函数调用的参数构造过程非常复杂，构建很多对象会造成很大的内存回收负担。Call() 方法内部就更为复杂，需要将参数列表的每个值从 reflect.Value 类型转换为内存。调用完毕后，还要将函数返回值重新转换为 reflect.Value 类型返回。因此，反射调用函数的性能堪忧。</p>
<h3 id="4-基准测试结果对比"><a href="#4-基准测试结果对比" class="headerlink" title="4)基准测试结果对比"></a>4)基准测试结果对比</h3><p>测试结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ go test -v -bench=.</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkNativeAssign-4                        2000000000               0.32 ns/op</span><br><span class="line">BenchmarkReflectAssign-4                       300000000               4.42 ns/op</span><br><span class="line">BenchmarkReflectFindFieldAndAssign-4           20000000               91.6 ns/op</span><br><span class="line">BenchmarkNativeCall-4                          2000000000               0.33 ns/op</span><br><span class="line">BenchmarkReflectCall-4                         10000000               163 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>
<p>结果分析如下：</p>
<ul>
<li>第 4 行，原生的结构体成员赋值，每一步操作耗时 0.32 纳秒，这是参考基准。</li>
<li>第 5 行，使用反射的结构体成员赋值，操作耗时 4.42 纳秒，比原生赋值多消耗 13 倍的性能。</li>
<li>第 6 行，反射查找结构体成员且反射赋值，操作耗时 91.6 纳秒，扣除反射结构体成员赋值的 4.42 纳秒还富余，性能大概是原生的 272 倍。这个测试结果与代码分析结果很接近。SetInt 的性能可以接受，但 FieldByName() 的性能就非常低。</li>
<li>第 7 行，原生函数调用，性能与原生访问结构体成员接近。</li>
<li>第 8 行，反射函数调用，性能差到“爆棚”，花费了 163 纳秒，操作耗时比原生多消耗 494 倍。</li>
</ul>
<p>经过基准测试结果的数值分析及对比，最终得出以下结论：</p>
<ul>
<li>能使用原生代码时，尽量避免反射操作。</li>
<li>提前缓冲反射值对象，对性能有很大的帮助。</li>
<li>避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。</li>
</ul>
<h2 id="reflect-TypeOf-和reflect-Type（通过反射获取类型信息）"><a href="#reflect-TypeOf-和reflect-Type（通过反射获取类型信息）" class="headerlink" title="reflect.TypeOf()和reflect.Type（通过反射获取类型信息）"></a>reflect.TypeOf()和reflect.Type（通过反射获取类型信息）</h2><p>在 Go语言中通过调用 reflect.TypeOf 函数，我们可以从一个任何非接口类型的值创建一个 reflect.Type 值。reflect.Type 值表示着此非接口值的类型。通过此值，我们可以得到很多此非接口类型的信息。当然，我们也可以将一个接口值传递给一个 reflect.TypeOf 函数调用，但是此调用将返回一个表示着此接口值的动态类型的 reflect.Type 值。</p>
<p>实际上，reflect.TypeOf 函数的唯一参数的类型为 interface{}，reflect.TypeOf 函数将总是返回一个表示着此唯一接口参数值的动态类型的 reflect.Type 值。</p>
<p>那如何得到一个表示着某个接口类型的 reflect.Type 值呢？我们必须通过下面将要介绍的一些间接途径来达到这一目的。</p>
<p>类型 reflect.Type 为一个接口类型，它指定了若干方法（<code>https://golang.google.cn/pkg/reflect/#Type</code>）。 通过这些方法，我们能够观察到一个 reflect.Type 值所表示的 Go类型的各种信息。这些方法中的有的适用于所有种类（<code>https://golang.google.cn/pkg/reflect/#Kind</code>）的类型，有的只适用于一种或几种类型。通过不合适的 reflect.Type 属主值调用某个方法将在运行时产生一个恐慌。</p>
<p>使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。下面通过例子来理解获取类型对象的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line"></span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int  int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，定义一个 int 类型的变量。</li>
<li>第 12 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。</li>
<li>第 14 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。</li>
</ul>
<h3 id="理解反射的类型（Type）与种类（Kind）"><a href="#理解反射的类型（Type）与种类（Kind）" class="headerlink" title="理解反射的类型（Type）与种类（Kind）"></a>理解反射的类型（Type）与种类（Kind）</h3><p>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<p><strong>1) 反射种类（Kind）的定义：</strong></p>
<p>Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。</p>
<p>type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<p><strong>2)从类型对象中获取类型名称和种类的例子:</strong></p>
<p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。</p>
<p>类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>下面的代码中会对常量和结构体进行类型信息获取。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个Enum类型</span><br><span class="line">type Enum int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Zero Enum = 0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">    // 获取Zero常量的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(Zero)</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cat struct</span><br><span class="line">Enum int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 18 行，声明结构体类型 cat。</li>
<li>第 22 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。</li>
<li>第 25 行，输出cat的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。</li>
<li>第 28 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。</li>
<li>第 31 行，输出 Zero 对应的类型对象的类型名和种类。</li>
</ul>
<h2 id="reflect-Elem-——通过反射获取指针指向的元素类型"><a href="#reflect-Elem-——通过反射获取指针指向的元素类型" class="headerlink" title="reflect.Elem()——通过反射获取指针指向的元素类型"></a>reflect.Elem()——通过反射获取指针指向的元素类型</h2><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个 <code>*</code> 操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := &amp;cat{}</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("name:'%v' kind:'%v'\n",typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">    // 取类型的元素</span><br><span class="line">    typeOfCat = typeOfCat.Elem()</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name: ''  kind: 'ptr'</span><br><span class="line">element name: 'cat', element kind: 'struct'</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 15 行，创建了cat结构体的实例，ins 是一个 <code>*cat</code> 类型的指针变量。</li>
<li>第 18 行，对指针变量获取反射类型信息。</li>
<li>第 21 行，输出指针变量的类型名称和种类。Go 语言的反射中对所有指针变量的种类都是 Ptr，但注意，指针变量的类型名称是空，不是 <code>*cat</code> 。</li>
<li>第 24 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。</li>
<li>第 27 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。</li>
</ul>
<h2 id="通过反射获取结构体的成员类型"><a href="#通过反射获取结构体的成员类型" class="headerlink" title="通过反射获取结构体的成员类型"></a>通过反射获取结构体的成员类型</h2><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的 NumField() 和 Field() 方法获得结构体成员的详细信息。与成员获取相关的 reflect.Type 的方法如下表所示。</p>
<table>
    <caption>结构体成员访问的方法列表</caption>
    <thead><tr><th>方法</th><th>说明</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)StructField</td><td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)(StructField,bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时&nbsp;bool返回false，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)StructField</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)&nbsp;(StructField,bool)</td><td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<h3 id="结构体字段类型"><a href="#结构体字段类型" class="headerlink" title="结构体字段类型"></a>结构体字段类型</h3><p>reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（Struct Tag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。StructField 的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type StructField struct {</span><br><span class="line">    Name string          // 字段名</span><br><span class="line">    PkgPath string       // 字段路径</span><br><span class="line">    Type      Type       // 字段反射类型对象</span><br><span class="line">    Tag       StructTag  // 字段的结构体标签</span><br><span class="line">    Offset    uintptr    // 字段在结构体中的相对偏移</span><br><span class="line">    Index     []int      // Type.FieldByIndex中的返回的索引值</span><br><span class="line">    Anonymous bool       // 是否为匿名字段</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字段说明如下。</p>
<ul>
<li>Name：为字段名称。</li>
<li>PkgPath：字段在结构体中的路径。</li>
<li>Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。</li>
<li>Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。</li>
<li>Index：FieldByIndex 中的索引顺序。</li>
<li>Anonymous：表示该字段是否为匿名字段。</li>
</ul>
<h3 id="获取成员反射信息"><a href="#获取成员反射信息" class="headerlink" title="获取成员反射信息"></a>获取成员反射信息</h3><p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<p>反射访问结构体成员类型及信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line"></span><br><span class="line">        // 带有结构体tag的字段</span><br><span class="line">        Type int `json:"type" id:"100"`</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := cat{Name: "mimi", Type: 1}</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line"></span><br><span class="line">    // 遍历结构体所有成员</span><br><span class="line">    for i := 0; i &lt; typeOfCat.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // 获取每个成员的结构体字段类型</span><br><span class="line">        fieldType := typeOfCat.Field(i)</span><br><span class="line"></span><br><span class="line">        // 输出成员名和tag</span><br><span class="line">        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通过字段名, 找到字段类型信息</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line"></span><br><span class="line">        // 从tag中取出需要的tag</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name: Name  tag: ''</span><br><span class="line">name: Type  tag: 'json:"type" id:"100"'</span><br><span class="line">type 100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明了带有两个成员的 cat 结构体。</li>
<li>第 15 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以`开始和结尾的字符串。这个字符串在 Go 语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。</li>
<li>第 19 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。</li>
<li>第 22 行，获取实例的反射类型对象。</li>
<li>第 25 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。</li>
<li>第 28 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。</li>
<li>第 31 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是StructField 结构体。</li>
<li>第 35 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，cat Type 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。</li>
<li>第 38 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。</li>
</ul>
<h2 id="结构体标签-Struct-Tag"><a href="#结构体标签-Struct-Tag" class="headerlink" title="结构体标签 Struct Tag"></a>结构体标签 Struct Tag</h2><p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。</p>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<p><strong>提示:</strong></p>
<p>结构体标签（Struct Tag）类似于 C# 中的特性（Attribute）。C# 允许在类、字段、方法等前面添加 Attribute，然后在反射系统中可以获取到这个属性系统。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[Conditional("DEBUG")]</span><br><span class="line">public static void Message(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg)；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h3><p>Tag 在结构体字段后方书写的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">`key1:"value1" key2:"value2"`</span><br></pre></td></tr></tbody></table></figure>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</p>
<h3 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h3><p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：</p>
<ul>
<li><code>func(tag StructTag)Get(key string)string</code></li>
<li>根据 Tag 中的键获取对应的值，例如 `key1:”value1”key2:”value2”` 的 Tag 中，可以传入“key1”获得“value1”。</li>
<li><code>func(tag StructTag)Lookup(key string)(value string,ok bool)</code></li>
<li>根据 Tag 中的键，查询值是否存在。</li>
</ul>
<h3 id="结构体标签格式错误导致的问题"><a href="#结构体标签格式错误导致的问题" class="headerlink" title="结构体标签格式错误导致的问题"></a>结构体标签格式错误导致的问题</h3><p>编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，参见下面这个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        Type int `json: "type" id:"100"`</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line"></span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line"></span><br><span class="line">        fmt.Println(catType.Tag.Get("json"))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出空字符串，并不会输出期望的 type。</p>
<p>第 12 行中，在json:和”type”之间增加了一个空格。这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。</p>
<p>这个错误在开发中非常容易被疏忽，造成难以察觉的错误。</p>
<h2 id="reflect-ValueOf-和reflect-Value（通过反射获取值信息）"><a href="#reflect-ValueOf-和reflect-Value（通过反射获取值信息）" class="headerlink" title="reflect.ValueOf()和reflect.Value（通过反射获取值信息）"></a>reflect.ValueOf()和reflect.Value（通过反射获取值信息）</h2><p>当我们将一个接口值传递给一个 reflect.ValueOf 函数调用时，此调用返回的是代表着此接口值的动态值的一个 reflect.Value 值。我们必须通过间接的途径获得一个代表一个接口值的 reflect.Value 值。</p>
<p>reflect.Value 类型有很多方法（<code>https://golang.google.cn/pkg/reflect/</code>）。我们可以调用这些方法来观察和操纵一个 reflect.Value 属主值表示的 Go 值。这些方法中的有些适用于所有种类类型的值，有些只适用于一种或几种类型的值。</p>
<p>通过不合适的 reflect.Value 属主值调用某个方法将在运行时产生一个恐慌。请阅读 reflect 代码库中各个方法的文档来获取如何正确地使用这些方法。</p>
<p>一个 reflect.Value 值的 CanSet 方法将返回此 reflect.Value 值代表的 Go 值是否可以被修改（可以被赋值）。如果一个 Go 值可以被修改，则我们可以调用对应的 reflect.Value 值的 Set 方法来修改此 Go 值。注意：reflect.ValueOf 函数直接返回的 reflect.Value 值都是不可修改的。</p>
<p>反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用 reflect.Value 获取和设置变量的值。</p>
<h3 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h3><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></tbody></table></figure>
<p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p>
<h3 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h3><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p>
<p><strong>1)从反射值对象（reflect.Value）中获取值的方法:</strong></p>
<p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p>
<table>
    <caption>反射值获取原始值的方法</caption>
    <thead><tr><th>方法名</th><th>说&nbsp;明</th></tr></thead>
    <tbody>
        <tr><td>Interface()interface{}</td><td>将值以interface{}&nbsp;类型返回，可以通过类型断言转换为指定类型</td></tr>
        <tr><td>Int()int64</td><td>将值以int类型返回，所有有符号整型均可以此方式返回</td></tr>
        <tr><td>Uint()uint64</td><td>将值以uint类型返回，所有无符号整型均可以此方式返回</td></tr>
        <tr><td>Float()float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr>
        <tr><td>Bool()bool</td><td>将值以bool类型返回</td></tr>
        <tr><td>Bytes()[]bytes</td><td>将值以字节数组[]bytes类型返回</td></tr>
        <tr><td>String()string</td><td>将值以字符串类型返回</td></tr>
    </tbody>
</table>

<p><strong>2)从反射值对象（reflect.Value）中获取值的例子:</strong></p>
<p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象</span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line"></span><br><span class="line">    // 获取interface{}类型的值, 通过类型断言转换</span><br><span class="line">    var getA int = valueOfA.Interface().(int)</span><br><span class="line"></span><br><span class="line">    // 获取64位的值, 强制类型转换为int类型</span><br><span class="line">    var getA2 int = int(valueOfA.Int())</span><br><span class="line"></span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1024 1024</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明一个变量，类型为 int，设置初值为 1024。</li>
<li>第 14 行，获取变量 a 的反射值对象，类型为 reflect.Value，这个过程和 reflect.TypeOf() 类似。</li>
<li>第 17 行，将 valueOfA 反射值对象以 interface{} 类型取出，通过类型断言转换为 int 类型并赋值给 getA。</li>
<li>第 20 行，将 valueOfA 反射值对象通过 Int 方法，以 int64 类型取出，通过强制类型转换，转换为原本的 int 类型。</li>
</ul>
<h2 id="通过反射访问结构体成员的值"><a href="#通过反射访问结构体成员的值" class="headerlink" title="通过反射访问结构体成员的值"></a>通过反射访问结构体成员的值</h2><p>反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。</p>
<table>
    <caption>反射值对象的成员访问方法</caption>
    <thead><tr><th>方&nbsp;法</th><th>备&nbsp;注</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)Value</td><td>根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)Value</td><td>根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)Value</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的值。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)Value</td><td>根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<p>下面代码构造一个结构体包含不同类型的成员。通过 reflect.Value 提供的成员访问函数，可以获得结构体值的各种数据。</p>
<p>反射访问结构体成员值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义结构体</span><br><span class="line">type dummy struct {</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line"></span><br><span class="line">    // 嵌入字段</span><br><span class="line">    float32</span><br><span class="line">    bool</span><br><span class="line"></span><br><span class="line">    next *dummy</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 值包装结构体</span><br><span class="line">    d := reflect.ValueOf(dummy{</span><br><span class="line">            next: &amp;dummy{},</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 获取字段数量</span><br><span class="line">    fmt.Println("NumField", d.NumField())</span><br><span class="line"></span><br><span class="line">    // 获取索引为2的字段(float32字段)</span><br><span class="line">    floatField := d.Field(2)</span><br><span class="line"></span><br><span class="line">    // 输出字段类型</span><br><span class="line">    fmt.Println("Field", floatField.Type())</span><br><span class="line"></span><br><span class="line">    // 根据名字查找字段</span><br><span class="line">    fmt.Println("FieldByName(\"b\").Type", d.FieldByName("b").Type())</span><br><span class="line"></span><br><span class="line">    // 根据索引查找值中, next字段的int字段的值</span><br><span class="line">    fmt.Println("FieldByIndex([]int{4, 0}).Type()", d.FieldByIndex([]int{4, 0}).Type())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，定义结构体，结构体的每个字段的类型都不一样。</li>
<li>第 24 行，实例化结构体并包装为 reflect.Value 类型，成员中包含一个  <code>*dummy</code> 的实例。</li>
<li>第 29 行，获取结构体的字段数量。</li>
<li>第 32 和 35 行，获取索引为2的字段值（float32 字段），并且打印类型。</li>
<li>第 38 行，根据b字符串，查找到 b 字段的类型。</li>
<li>第 41 行，[]int{4,0} 中的 4 表示，在 dummy 结构中索引值为 4 的成员，也就是 next。next 的类型为 dummy，也是一个结构体，因此使用 []int{4,0} 中的 0 继续在 next 值的基础上索引，结构为 dummy 中索引值为 0 的 a 字段，类型为 int。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">NumField 5</span><br><span class="line">Field float32</span><br><span class="line">FieldByName("b").Type string</span><br><span class="line">FieldByIndex([]int{4, 0}).Type() int</span><br></pre></td></tr></tbody></table></figure>
<h2 id="IsNil-和IsValid-——判断反射值的空和有效性"><a href="#IsNil-和IsValid-——判断反射值的空和有效性" class="headerlink" title="IsNil()和IsValid()——判断反射值的空和有效性"></a>IsNil()和IsValid()——判断反射值的空和有效性</h2><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p>
<table>
    <caption>反射值对象的零值和有效性判断方法</caption>
    <thead><tr><th>方&nbsp;法</th><th>说&nbsp;明</th></tr></thead>
    <tbody>
        <tr><td>IsNil()bool</td><td colspan="2">返回值是否为nil。如果值类型不是通道（channel）、函数、接口、map、指针或切片时发生panic，类似于语言层的<code style="font-size: 14px;">v==nil</code>操作</td></tr>
        <tr><td>IsValid()&nbsp;bool</td><td>判断值是否有效。&nbsp;当值本身非法时，返回false，例如reflect Value不包含任何值，值为nil等。</td></tr>
    </tbody>
</table>

<p>下面的例子将会对各种方式的空指针进行 IsNil() 和 IsValid() 的返回值判定检测。同时对结构体成员及方法查找 map 键值对的返回值进行 IsValid() 判定，参考下面的代码。</p>
<p>反射值对象的零值和有效性判断：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // *int的空指针</span><br><span class="line">    var a *int</span><br><span class="line">    fmt.Println("var a *int:", reflect.ValueOf(a).IsNil())</span><br><span class="line"></span><br><span class="line">    // nil值</span><br><span class="line">    fmt.Println("nil:", reflect.ValueOf(nil).IsValid())</span><br><span class="line"></span><br><span class="line">    // *int类型的空指针</span><br><span class="line">    fmt.Println("(*int)(nil):", reflect.ValueOf((*int)(nil)).Elem().IsValid())</span><br><span class="line"></span><br><span class="line">    // 实例化一个结构体</span><br><span class="line">    s := struct{}{}</span><br><span class="line"></span><br><span class="line">    // 尝试从结构体中查找一个不存在的字段</span><br><span class="line">    fmt.Println("不存在的结构体成员:", reflect.ValueOf(s).FieldByName("").IsValid())</span><br><span class="line"></span><br><span class="line">    // 尝试从结构体中查找一个不存在的方法</span><br><span class="line">    fmt.Println("不存在的结构体方法:", reflect.ValueOf(s).MethodByName("").IsValid())</span><br><span class="line"></span><br><span class="line">    // 实例化一个map</span><br><span class="line">    m := map[int]int{}</span><br><span class="line"></span><br><span class="line">    // 尝试从map中查找一个不存在的键</span><br><span class="line">    fmt.Println("不存在的键：", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a *int: true</span><br><span class="line">nil: false</span><br><span class="line">(*int)(nil): false</span><br><span class="line">不存在的结构体成员: false</span><br><span class="line">不存在的结构体方法: false</span><br><span class="line">不存在的键： false</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明一个 <code>*int</code> 类型的指针，初始值为 nil。</li>
<li>第 12 行，将变量 a 包装为 reflect.Value 并且判断是否为空，此时变量 a 为空指针，因此返回 true。</li>
<li>第 15 行，对 nil 进行 IsValid() 判定（有效性判定），返回 false。</li>
<li>第 18 行，<code>(*int)(nil)</code> 的含义是将 nil 转换为 <code>*int</code>，也就是 <code>*int</code> 类型的空指针。此行将 nil 转换为 <code>*int</code> 类型，并取指针指向元素。由于 nil 不指向任何元素，<code>*int</code> 类型的 nil 也不能指向任何元素，值不是有效的。因此这个反射值使用 Isvalid() 判断时返回 false。</li>
<li>第 21 行，实例化一个结构体。</li>
<li>第 24 行，通过 FieldByName 查找 s 结构体中一个空字符串的成员，如成员不存在，IsValid() 返回 false。</li>
<li>第 27 行，通过 MethodByName 查找 s 结构体中一个空字符串的方法，如方法不存在，IsValid() 返回 false。</li>
<li>第 30 行，实例化一个 map，这种写法与 make 方式创建的 map 等效。</li>
<li>第 33 行，MapIndex() 方法能根据给定的 reflect.Value 类型的值查找 map，并且返回查找到的结果。</li>
</ul>
<p>IsNil() 常被用于判断指针是否为空；IsValid() 常被用于判定返回值是否有效</p>
<h2 id="通过反射修改变量的值"><a href="#通过反射修改变量的值" class="headerlink" title="通过反射修改变量的值"></a>通过反射修改变量的值</h2><p>Go语言中类似 x、x.f[1] 和 <code>*p</code> 形式的表达式都可以表示变量，但是其它如 <code>x + 1</code> 和 f(2) 则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。</p>
<p>对于 reflect.Values 也有类似的区别。有一些 reflect.Values 是可取地址的；其它一些则不可以。考虑以下的声明语句：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">x := 2 // value type variable?</span><br><span class="line">a := reflect.ValueOf(2) // 2 int no</span><br><span class="line">b := reflect.ValueOf(x) // 2 int no</span><br><span class="line">c := reflect.ValueOf(&amp;x) // &amp;x *int no</span><br><span class="line">d := c.Elem() // 2 int yes (x)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的 Value。</p>
<p>我们可以通过调用 reflect.Value 的 CanAddr 方法来判断其是否可以被取地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fmt.Println(a.CanAddr()) // "false"</span><br><span class="line">fmt.Println(b.CanAddr()) // "false"</span><br><span class="line">fmt.Println(c.CanAddr()) // "false"</span><br><span class="line">fmt.Println(d.CanAddr()) // "true"</span><br></pre></td></tr></tbody></table></figure>
<p>每当我们通过指针间接地获取的 reflect.Value 都是可取地址的，即使开始的是一个不可取地址的 Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice 的索引表达式 e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。</p>
<p>以此类推，reflect.ValueOf(e).Index(i) 对于的值也是可取地址的，即使原始的 reflect.ValueOf(e) 不支持也没有关系。</p>
<p>使用 reflect.Value 对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。</p>
<h3 id="判定及获取元素的相关方法"><a href="#判定及获取元素的相关方法" class="headerlink" title="判定及获取元素的相关方法"></a>判定及获取元素的相关方法</h3><p>使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。</p>
<table>
    <caption>反射值对象的判定及获取元素的方法</caption>
    <thead><tr><th>方法名</th><th>备&nbsp;注</th></tr></thead>
    <tbody>
        <tr><td>Elem()Value</td><td>取值指向的元素值，类似于语言层<code style="font-size: 14px;">*</code>操作。当值类型不是指针或接口时发生宕机，空指针时返回nil的Value</td></tr>
        <tr><td>Addr()Value</td><td>对可寻址的值返回其地址，类似于语言层<code style="font-size: 14px;">&amp;</code>操作。当值不可寻址时发生宕机</td></tr>
        <tr><td>CanAddr()bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet()&nbsp;bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr>
    </tbody>
</table>

<h3 id="值修改相关方法"><a href="#值修改相关方法" class="headerlink" title="值修改相关方法"></a>值修改相关方法</h3><p>使用 reflect.Value 修改值的相关方法如下表所示。</p>
<table border="1">
    <caption>反射值对象修改值的方法</caption>
    <thead><tr><th>Set(x Value)</th><th>将值设置为传入的反射值对象的值</th></tr></thead>
    <tbody>
        <tr><td>Setlnt(x int64)</td><td>使用int64设置值。当值的类型不是int、int8、int16、&nbsp;int32、int64时会发生宕机</td></tr>
        <tr><td>SetUint(x uint64)</td><td>使用uint64设置值。当值的类型不是uint、uint8、uint16、uint32、uint64时会发生宕机</td></tr>
        <tr><td>SetFloat(x float64)</td><td>使用float64设置值。当值的类型不是float32、float64时会发生宕机</td></tr>
        <tr><td>SetBool(x bool)</td><td>使用bool设置值。当值的类型不是bod时会发生宕机</td></tr>
        <tr><td>SetBytes(x[]byte)</td><td>设置字节数组[]bytes值。当值的类型不是[]byte时会发生宕机</td></tr>
        <tr><td>SetString(x string)</td><td>设置字符串值。当值的类型不是string时会发生宕机</td></tr>
    </tbody>
</table>

<p>以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。</p>
<p>在已知值的类型时，应尽量使用值对应类型的反射设置值。</p>
<h3 id="值可修改条件之一：可被寻址"><a href="#值可修改条件之一：可被寻址" class="headerlink" title="值可修改条件之一：可被寻址"></a>值可修改条件之一：可被寻址</h3><p>通过反射修改变量值的前提条件之一：这个值必须可以被寻址。简单地说就是这个变量必须能被修改。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象</span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line"></span><br><span class="line">    // 尝试将a修改为1(此处会发生崩溃)</span><br><span class="line">    valueOfA.SetInt(1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序运行崩溃，打印错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>报错意思是：SetInt 正在使用一个不能被寻址的值。从 reflect.ValueOf 传入的是 a 的值，而不是 a 的地址，这个 reflect.Value 当然是不能被寻址的。将代码修改一下，重新运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象(a的地址)</span><br><span class="line">    valueOfA := reflect.ValueOf(&amp;a)</span><br><span class="line"></span><br><span class="line">    // 取出a地址的元素(a的值)</span><br><span class="line">    valueOfA = valueOfA.Elem()</span><br><span class="line"></span><br><span class="line">    // 修改a的值为1</span><br><span class="line">    valueOfA.SetInt(1)</span><br><span class="line"></span><br><span class="line">    // 打印a的值</span><br><span class="line">    fmt.Println(valueOfA.Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对代码的分析：</p>
<ul>
<li>第 14 行中，将变量 a 取值后传给 reflect.ValueOf()。此时 reflect.ValueOf() 返回的 valueOfA 持有变量 a 的地址。</li>
<li>第 17 行中，使用 reflect.Value 类型的 Elem() 方法获取 a 地址的元素，也就是 a 的值。reflect.Value 的 Elem() 方法返回的值类型也是 reflect.Value。</li>
<li>第 20 行，此时 valueOfA 表示的是 a 的值且可以寻址。使用 SetInt() 方法设置值时不再发生崩溃。</li>
<li>第 23 行，正确打印修改的值。</li>
</ul>
<p><strong>提示：</strong></p>
<p>当 reflect.Value 不可寻址时，使用 Addr() 方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的 Addr() 方法类似于语言层的&amp;操作；Elem() 方法类似于语言层的*操作，但并不代表这些方法与语言层操作等效。</p>
<h3 id="值可修改条件之一：被导出"><a href="#值可修改条件之一：被导出" class="headerlink" title="值可修改条件之一：被导出"></a>值可修改条件之一：被导出</h3><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type dog struct {</span><br><span class="line">            legCount int</span><br><span class="line">    }</span><br><span class="line">    // 获取dog实例的反射值对象</span><br><span class="line">    valueOfDog := reflect.ValueOf(dog{})</span><br><span class="line"></span><br><span class="line">    // 获取legCount字段的值</span><br><span class="line">    vLegCount := valueOfDog.FieldByName("legCount")</span><br><span class="line"></span><br><span class="line">    // 尝试设置legCount的值(这里会发生崩溃)</span><br><span class="line">    vLegCount.SetInt(4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序发生崩溃，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span><br></pre></td></tr></tbody></table></figure>
<p>报错的意思是：SetInt() 使用的值来自于一个未导出的字段。</p>
<p>为了能修改这个值，需要将该字段导出。将 dog 中的 legCount 的成员首字母大写，导出 LegCount 让反射可以访问，修改后的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type dog struct {</span><br><span class="line">    LegCount int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">vLegCount := valueOfDog.FieldByName("LegCount")</span><br></pre></td></tr></tbody></table></figure>
<p>再次运行程序，发现仍然报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>这个错误表示第 13 行构造的 valueOfDog 这个结构体实例不能被寻址，因此其字段也不能被修改。修改代码，取结构体的指针，再通过 reflect.Value 的 Elem() 方法取到值的反射值对象。修改后的完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type dog struct {</span><br><span class="line">            LegCount int</span><br><span class="line">    }</span><br><span class="line">    // 获取dog实例地址的反射值对象</span><br><span class="line">    valueOfDog := reflect.ValueOf(&amp;dog{})</span><br><span class="line"></span><br><span class="line">    // 取出dog实例地址的元素</span><br><span class="line">    valueOfDog = valueOfDog.Elem()</span><br><span class="line"></span><br><span class="line">    // 获取legCount字段的值</span><br><span class="line">    vLegCount := valueOfDog.FieldByName("LegCount")</span><br><span class="line"></span><br><span class="line">    // 尝试设置legCount的值(这里会发生崩溃)</span><br><span class="line">    vLegCount.SetInt(4)</span><br><span class="line"></span><br><span class="line">    fmt.Println(vLegCount.Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，将 LegCount 首字母大写导出该字段。</li>
<li>第 14 行，获取 dog 实例指针的反射值对象。</li>
<li>第 17 行，取 dog 实例的指针元素，也就是 dog 的实例。</li>
<li>第 20 行，取 dog 结构体中 LegCount 字段的成员值。</li>
<li>第 23 行，修改该成员值。</li>
<li>第 25 行，打印该成员值。</li>
</ul>
<p>值的修改从表面意义上叫可寻址，换一种说法就是值必须“可被设置”。那么，想修改变量值，一般的步骤是：</p>
<ul>
<li>取这个变量的地址或者这个变量所在的结构体已经是指针类型。</li>
<li>使用 reflect.ValueOf 进行值包装。</li>
<li>通过 Value.Elem() 获得指针值指向的元素值对象（Value），因为值对象（Value）内部对象为指针时，使用 set 设置时会报出宕机错误。</li>
<li>使用 Value.Set 设置值。</li>
</ul>
<h2 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h2><p>当已知 reflect.Type 时，可以动态地创建这个类型的实例，实例的类型为指针。例如 reflect.Type 的类型为 int 时，创建 int 的指针，即 <code>*int</code>，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line"></span><br><span class="line">    // 取变量a的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 根据反射类型对象创建类型实例</span><br><span class="line">    aIns := reflect.New(typeOfA)</span><br><span class="line"></span><br><span class="line">    // 输出Value的类型和种类</span><br><span class="line">    fmt.Println(aIns.Type(), aIns.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">*int ptr</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，获取变量 a 的反射类型对象。</li>
<li>第 16 行，使用 reflect.New() 函数传入变量 a 的反射类型对象，创建这个类型的实例值，值以 reflect.Value 类型返回。这步操作等效于：new(int)，因此返回的是 <code>*int</code> 类型的实例。</li>
<li>第 19 行，打印 aIns 的类型为 <code>*int</code> ，种类为指针。</li>
</ul>
<h2 id="通过反射调用函数"><a href="#通过反射调用函数" class="headerlink" title="通过反射调用函数"></a>通过反射调用函数</h2><p>如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将参数使用反射值对象的切片 []reflect.Value 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。</p>
<p>下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。</p>
<p>反射调用函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 普通函数</span><br><span class="line">func add(a, b int) int {</span><br><span class="line"></span><br><span class="line">    return a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将函数包装为反射值对象</span><br><span class="line">    funcValue := reflect.ValueOf(add)</span><br><span class="line"></span><br><span class="line">    // 构造函数参数, 传入两个整型值</span><br><span class="line">    paramList := []reflect.Value{reflect.ValueOf(10), reflect.ValueOf(20)}</span><br><span class="line"></span><br><span class="line">    // 反射调用函数</span><br><span class="line">    retList := funcValue.Call(paramList)</span><br><span class="line"></span><br><span class="line">    // 获取第一个返回值, 取整数值</span><br><span class="line">    fmt.Println(retList[0].Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9～12 行，定义一个普通的加法函数。</li>
<li>第 17 行，将 add 函数包装为反射值对象。</li>
<li>第 20 行，将 10 和 20 两个整型值使用 reflect.ValueOf 包装为 reflect.Value，再将反射值对象的切片 []reflect.Value 作为函数的参数。</li>
<li>第 23 行，使用 funcValue 函数值对象的 Call() 方法，传入参数列表 paramList 调用 add() 函数。</li>
<li>第 26 行，调用成功后，通过 retList[0] 取返回值的第一个参数，使用 Int 取返回值的整数值。</li>
</ul>
<p><strong>提示：</strong></p>
<p>反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。</p>
<h2 id="inject库：依赖注入"><a href="#inject库：依赖注入" class="headerlink" title="inject库：依赖注入"></a>inject库：依赖注入</h2><p>在介绍 inject 之前我们先来简单介绍一下“依赖注入”和“控制反转”这两个概念。</p>
<p>正常情况下，对函数或方法的调用是我们的主动直接行为，在调用某个函数之前我们需要清楚地知道被调函数的名称是什么，参数有哪些类型等等。</p>
<p>所谓的控制反转就是将这种主动行为变成间接的行为，我们不用直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为称作“控制反转”，库和框架能很好的解释控制反转的概念。</p>
<p>依赖注入是实现控制反转的一种方法，如果说控制反转是一种设计思想，那么依赖注入就是这种思想的一种实现，通过注入参数或实例的方式实现控制反转。如果没有特殊说明，我们可以认为依赖注入和控制反转是一个东西。</p>
<p>控制反转的价值在于解耦，有了控制反转就不需要将代码写死，可以让控制反转的的框架代码读取配置，动态的构建对象，这一点在 Java 的 Spring 框架中体现的尤为突出。</p>
<h3 id="inject-实践"><a href="#inject-实践" class="headerlink" title="inject 实践"></a>inject 实践</h3><p>inject 是依赖注入的Go语言实现，它能在运行时注入参数，调用方法，是 Martini 框架（Go语言中著名的 Web 框架）的基础核心。</p>
<p>在介绍具体实现之前，先来想一个问题，如何通过一个字符串类型的函数名来调用函数？Go语言没有 Java 中的 Class.forName 方法可以通过类名直接构造对象，所以这种方法是行不通的，能想到的方法就是使用 map 实现一个字符串到函数的映射，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func fl() {</span><br><span class="line">    println ("fl")</span><br><span class="line">}</span><br><span class="line">func f2 () {</span><br><span class="line">    println ("f2")</span><br><span class="line">}</span><br><span class="line">funcs := make(map[string] func ())</span><br><span class="line">funcs ["fl"] = fl</span><br><span class="line">funcs ["f2"] = fl</span><br><span class="line">funcs ["fl"]()</span><br><span class="line">funcs ["f2"]()</span><br></pre></td></tr></tbody></table></figure>
<p>但是这有个缺陷，就是 map 的 Value 类型被写成 func()，不同参数和返回值的类型的函数并不能通用。将 map 的 Value 定义为 interface{} 空接口类型即可以解决该问题，但需要借助类型断言或反射来实现，通过类型断言实现等于又绕回去了，反射是一种可行的办法。</p>
<p>inject 包借助反射实现函数的注入调用，下面通过一个示例来看一下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S1 interface{}</span><br><span class="line">type S2 interface{}</span><br><span class="line"></span><br><span class="line">func Format(name string, company S1, level S2, age int) {</span><br><span class="line">    fmt.Printf("name ＝ %s, company=%s, level=%s, age ＝ %d!\n", name, company, level, age)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    //控制实例的创建</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    //实参注入</span><br><span class="line">    inj.Map("tom")</span><br><span class="line">    inj.MapTo("tencent", (*S1)(nil))</span><br><span class="line">    inj.MapTo("T4", (*S2)(nil))</span><br><span class="line">    inj.Map(23)</span><br><span class="line">    //函数反转调用</span><br><span class="line">    inj.Invoke(Format)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name ＝ tom, company=tencent, level=T4, age ＝ 23!</span><br></pre></td></tr></tbody></table></figure>
<p>可见 inject 提供了一种注入参数调用函数的通用功能，inject.New() 相当于创建了一个控制实例，由其来实现对函数的注入调用。inject 包不但提供了对函数的注入，还实现了对 struct 类型的注入，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S1 interface{}</span><br><span class="line">type S2 interface{}</span><br><span class="line">type Staff struct {</span><br><span class="line">    Name    string `inject`</span><br><span class="line">    Company S1     `inject`</span><br><span class="line">    Level   S2     `inject`</span><br><span class="line">    Age     int    `inject`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建被注入实例</span><br><span class="line">    s := Staff{}</span><br><span class="line">    //控制实例的创建</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    //初始化注入值</span><br><span class="line">    inj.Map("tom")</span><br><span class="line">    inj.MapTo("tencent", (*S1)(nil))</span><br><span class="line">    inj.MapTo("T4", (*S2)(nil))</span><br><span class="line">    inj.Map(23)</span><br><span class="line">    //实现对 struct 注入</span><br><span class="line">    inj.Apply(&amp;s)</span><br><span class="line">    //打印结果</span><br><span class="line">    fmt.Printf("s ＝ %v\n", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s ＝ {tom tencent T4 23}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到 inject 提供了一种对结构类型的通用注入方法。至此，我们仅仅从宏观层面了解 iniect 能做什么，下面从源码实现角度来分析 inject。</p>
<h3 id="inject-原理分析"><a href="#inject-原理分析" class="headerlink" title="inject 原理分析"></a>inject 原理分析</h3><p>inject 包中只有 2 个文件，一个是 inject.go 文件和一个 inject_test.go 文件，这里我们只需要关注 inject.go 文件即可。</p>
<p>inject.go 短小精悍，包括注释和空行在内才 157 行代码，代码中定义了 4 个接口，包括一个父接口和三个子接口，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Injector interface {</span><br><span class="line">    Applicator</span><br><span class="line">    Invoker</span><br><span class="line">    TypeMapper</span><br><span class="line">    SetParent(Injector)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Applicator interface {</span><br><span class="line">    Apply(interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Invoker interface {</span><br><span class="line">    Invoke(interface{}) ([]reflect.Value, error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type TypeMapper interface {</span><br><span class="line">    Map(interface{}) TypeMapper</span><br><span class="line">    MapTo(interface{}, interface{}) TypeMapper</span><br><span class="line">    Get(reflect.Type) reflect.Value</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Injector 接口是 Applicator、Invoker、TypeMapper 接口的父接口，所以实现了 Injector 接口的类型，也必然实现了 Applicator、Invoker 和 TypeMapper 接口：</p>
<ul>
<li>Applicator 接口只规定了 Apply 成员，它用于注入 struct。</li>
<li>Invoker 接口只规定了 Invoke 成员，它用于执行被调用者。</li>
<li>TypeMapper 接口规定了三个成员，Map 和 MapTo 都用于注入参数，但它们有不同的用法，Get 用于调用时获取被注入的参数。</li>
</ul>
<p>另外 Injector 还规定了 SetParent 行为，它用于设置父 Injector，其实它相当于查找继承。也即通过 Get 方法在获取被注入参数时会一直追溯到 parent，这是个递归过程，直到查找到参数或为 nil 终止。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type injector struct {</span><br><span class="line">    values map[reflect.Type]reflect.Value</span><br><span class="line">    parent Injector</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func InterfaceOf(value interface{}) reflect.Type {</span><br><span class="line">    t := reflect.TypeOf(value)</span><br><span class="line"></span><br><span class="line">    for t.Kind() == reflect.Ptr {</span><br><span class="line">        t = t.Elem()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if t.Kind() != reflect.Interface {</span><br><span class="line">        panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func New() Injector {</span><br><span class="line">    return &amp;injector{</span><br><span class="line">        values: make(map[reflect.Type]reflect.Value),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>injector 是 inject 包中唯一定义的 struct，所有的操作都是基于 injector struct 来进行的，它有两个成员 values 和 parent。values 用于保存注入的参数，是一个用 reflect.Type 当键、reflect.Value 为值的 map，理解这点将有助于理解 Map 和 MapTo。</p>
<p>New 方法用于初始化 injector struct，并返回一个指向 injector struct 的指针，但是这个返回值被 Injector 接口包装了。</p>
<p>InterfaceOf 方法虽然只有几句实现代码，但它是 Injector 的核心。InterfaceOf 方法的参数必须是一个接口类型的指针，如果不是则引发 panic。InterfaceOf 方法的返回类型是 reflect.Type，大家应该还记得 injector 的成员 values 就是一个 reflect.Type 类型当键的 map。这个方法的作用其实只是获取参数的类型，而不关心它的值。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(inject.InterfaceOf((*interface{})(nil)))</span><br><span class="line">    fmt.Println(inject.InterfaceOf((*SpecialString)(nil)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">interface {}</span><br><span class="line">main.SpecialString</span><br></pre></td></tr></tbody></table></figure>
<p>InterfaceOf 方法就是用来得到参数类型，而不关心它具体存储的是什么值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (i *injector) Map(val interface{}) TypeMapper {</span><br><span class="line">    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {</span><br><span class="line">    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) Get(t reflect.Type) reflect.Value {</span><br><span class="line">    val := i.values[t]</span><br><span class="line">    if !val.IsValid() &amp;&amp; i.parent != nil {</span><br><span class="line">        val = i.parent.Get(t)</span><br><span class="line">    }</span><br><span class="line">    return val</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) SetParent(parent Injector) {</span><br><span class="line">    i.parent = parent</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Map 和 MapTo 方法都用于注入参数，保存于 injector 的成员 values 中。这两个方法的功能完全相同，唯一的区别就是 Map 方法用参数值本身的类型当键，而 MapTo 方法有一个额外的参数可以指定特定的类型当键。但是 MapTo 方法的第二个参数 ifacePtr 必须是接口指针类型，因为最终 ifacePtr 会作为 InterfaceOf 方法的参数。</p>
<p>为什么需要有 MapTo 方法？因为注入的参数是存储在一个以类型为键的 map 中，可想而知，当一个函数中有一个以上的参数的类型是一样时，后执行 Map 进行注入的参数将会覆盖前一个通过 Map 注入的参数。</p>
<p>SetParent 方法用于给某个 Injector 指定父 Injector。Get 方法通过 reflect.Type 从 injector 的 values 成员中取出对应的值，它可能会检查是否设置了 parent，直到找到或返回无效的值，最后 Get 方法的返回值会经过 IsValid 方法的校验。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("C语言中文网")</span><br><span class="line">    inj.MapTo("Golang", (*SpecialString)(nil))</span><br><span class="line">    inj.Map(20)</span><br><span class="line">    fmt.Println("字符串是否有效？", inj.Get(reflect.TypeOf("Go语言入门教程")).IsValid())</span><br><span class="line">    fmt.Println("特殊字符串是否有效？", inj.Get(inject.InterfaceOf((*SpecialString)(nil))).IsValid())</span><br><span class="line">    fmt.Println("int 是否有效？", inj.Get(reflect.TypeOf(18)).IsValid())</span><br><span class="line">    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map([]byte("test"))</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">字符串是否有效？ true</span><br><span class="line">特殊字符串是否有效？ true</span><br><span class="line">int 是否有效？ true</span><br><span class="line">[]byte 是否有效？ false</span><br><span class="line">[]byte 是否有效？ true</span><br></pre></td></tr></tbody></table></figure>
<p>通过以上例子应该知道 SetParent 是什么样的行为，是不是很像面向对象中的查找链？</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {</span><br><span class="line">    t := reflect.TypeOf(f)</span><br><span class="line"></span><br><span class="line">    var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func</span><br><span class="line">    for i := 0; i &lt; t.NumIn(); i++ {</span><br><span class="line">        argType := t.In(i)</span><br><span class="line">        val := inj.Get(argType)</span><br><span class="line">        if !val.IsValid() {</span><br><span class="line">            return nil, fmt.Errorf("Value not found for type %v", argType)</span><br><span class="line">        }</span><br><span class="line">        in[i] = val</span><br><span class="line">    }</span><br><span class="line">    return reflect.ValueOf(f).Call(in), nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Invoke 方法用于动态执行函数，当然执行前可以通过 Map 或 MapTo 来注入参数，因为通过 Invoke 执行的函数会取出已注入的参数，然后通过 reflect 包中的 Call 方法来调用。Invoke 接收的参数 f 是一个接口类型，但是 f 的底层类型必须为 func，否则会 panic。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func Say(name string, gender SpecialString, age int) {</span><br><span class="line">    fmt.Printf("My name is %s, gender is %s, age is %d!\n", name, gender, age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("张三")</span><br><span class="line">    inj.MapTo("男", (*SpecialString)(nil))</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map(25)</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    inj.Invoke(Say)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">My name is 张三, gender is 男, age is 25!</span><br></pre></td></tr></tbody></table></figure>
<p>上面的例子如果没有定义 SpecialString 接口作为 gender 参数的类型，而把 name 和 gender 都定义为 string 类型，那么 gender 会覆盖 name 的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (inj *injector) Apply(val interface{}) error {</span><br><span class="line">    v := reflect.ValueOf(val)</span><br><span class="line"></span><br><span class="line">    for v.Kind() == reflect.Ptr {</span><br><span class="line">        v = v.Elem()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if v.Kind() != reflect.Struct {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; v.NumField(); i++ {</span><br><span class="line">        f := v.Field(i)</span><br><span class="line">        structField := t.Field(i)</span><br><span class="line">        if f.CanSet() &amp;&amp; structField.Tag == "inject" {</span><br><span class="line">            ft := f.Type()</span><br><span class="line">            v := inj.Get(ft)</span><br><span class="line">            if !v.IsValid() {</span><br><span class="line">                return fmt.Errorf("Value not found for type %v", ft)</span><br><span class="line">            }</span><br><span class="line">            f.Set(v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Apply 方法是用于对 struct 的字段进行注入，参数为指向底层类型为结构体的指针。可注入的前提是：字段必须是导出的（也即字段名以大写字母开头），并且此字段的 tag 设置为 `inject`。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">type TestStruct struct {</span><br><span class="line">    Name   string `inject`</span><br><span class="line">    Nick   []byte</span><br><span class="line">    Gender SpecialString `inject`</span><br><span class="line">    uid    int           `inject`</span><br><span class="line">    Age    int           `inject`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    s := TestStruct{}</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("张三")</span><br><span class="line">    inj.MapTo("男", (*SpecialString)(nil))</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map(26)</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    inj.Apply(&amp;s)</span><br><span class="line">    fmt.Println("s.Name =", s.Name)</span><br><span class="line">    fmt.Println("s.Gender =", s.Gender)</span><br><span class="line">    fmt.Println("s.Age =", s.Age)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s.Name = 张三</span><br><span class="line">s.Gender = 男</span><br><span class="line">s.Age = 26</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go 反射</tag>
        <tag>go reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 包</title>
    <url>/posts/bd026676/</url>
    <content><![CDATA[<p>Go 语言的源码复用建立在包（package）基础之上。Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，必须同样以包的方式进行引用，本章内容将详细讲解如何导出包的内容及如何导入其他包。</p>
<p>Go 语言的包与文件夹一一对应，所有与包相关的操作，必须依赖于工作目录（GOPATH）。</p>
<h2 id="包的基本概念"><a href="#包的基本概念" class="headerlink" title="包的基本概念"></a>包的基本概念</h2><p>Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。</p>
<p>任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是 <code>package pacakgeName</code> 语句，通过该语句声明自己所在的包。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。</p>
<p>包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在 <code>GOPATH/src/a/b/</code> 下定义一个包 <code>c</code> 。在包 c 的源码中只需声明为 <code>package c</code>，而不是声明为<code>package a/b/c</code>，但是在导入 c 包时，需要带上路径，例如 <code>import "a/b/c"</code>。</p>
<p>包的习惯用法：</p>
<ul>
<li>包名一般是小写的，使用一个简短且有意义的名称。</li>
<li>包名一般要和所在的目录同名，也可以不同，包名中不能包含 <code>-</code> 等特殊符号。</li>
<li>包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到 <code>GOPATH/src/github.com/userName/projectName</code> 目录下。</li>
<li>包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。</li>
<li>一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</li>
</ul>
<h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "包的路径"</span><br></pre></td></tr></tbody></table></figure>
<p>注意事项：</p>
<ul>
<li>import 导入语句通常放在源码文件开头包声明语句的下面；</li>
<li>导入的包名需要使用双引号包裹起来；</li>
<li>包名是从 <code>GOPATH/src/</code> 后开始计算的，使用 <code>/</code> 进行路径分隔。</li>
</ul>
<p>包的导入有两种写法，分别是单行导入和多行导入。</p>
<h4 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h4><p>单行导入的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "包 1 的路径"</span><br><span class="line">import "包 2 的路径"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h4><p>多行导入的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    "包 1 的路径"</span><br><span class="line">    "包 2 的路径"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="包的导入路径"><a href="#包的导入路径" class="headerlink" title="包的导入路径"></a>包的导入路径</h3><p>包的引用路径有两种写法，分别是全路径导入和相对路径导入。</p>
<h4 id="全路径导入"><a href="#全路径导入" class="headerlink" title="全路径导入"></a>全路径导入</h4><p>包的绝对路径就是 <code>GOROOT/src/</code> 或 <code>GOPATH/src/</code> 后面包的存放路径，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "lab/test"</span><br><span class="line">import "database/sql/driver"</span><br><span class="line">import "database/sql"</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码的含义如下：</p>
<ul>
<li>test 包是自定义的包，其源码位于GOPATH/src/lab/test 目录下；</li>
<li>driver 包的源码位于GOROOT/src/database/sql/driver 目录下；</li>
<li>sql 包的源码位于GOROOT/src/database/sql 目录下。</li>
</ul>
<h4 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h4><p>相对路径只能用于导入 <code>GOPATH</code> 下的包，标准包的导入只能使用全路径导入。</p>
<p>例如包 a 的所在路径是 <code>GOPATH/src/lab/a</code> ，包 b 的所在路径为 <code>GOPATH/src/lab/b</code>，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 相对路径导入</span><br><span class="line">import "../a"</span><br></pre></td></tr></tbody></table></figure>
<p>当然了，也可以使用上面的全路径导入，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 全路径导入</span><br><span class="line">import "lab/a"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="包的引用格式"><a href="#包的引用格式" class="headerlink" title="包的引用格式"></a>包的引用格式</h4><p>包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。</p>
<p><strong>1) 标准引用格式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>此时可以用 <code>fmt.</code> 作为前缀来使用 fmt 包中的方法，这是常用的一种方式。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 自定义别名引用格式</strong></p>
<p>在导入包的时候，我们还可以为导入的包设置别名，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import F "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>其中 F 就是 fmt 包的别名，使用时我们可以使用 <code>F.</code> 来代替标准引用格式的fmt.来作为前缀使用 fmt 包中的方法。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import F "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    F.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 省略引用格式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import . "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>这种格式相当于把 fmt 包直接合并到当前程序中，在使用 fmt 包内的方法是可以不用加前缀 <code>fmt.</code> ，直接引用。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import . "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //不需要加前缀 fmt.</span><br><span class="line">    Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) 匿名引用格式</strong></p>
<p>在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import _ "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p>
<p>使用标准格式引用包，但是代码中却没有使用包，编译器会报错。如果包中有 init 初始化函数，则通过import _ “包的路径” 这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。</p>
<p>示例代码如下：</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    _ "database/sql"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。</li>
<li>包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。</li>
<li>包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。</li>
</ul>
<h3 id="包加载"><a href="#包加载" class="headerlink" title="包加载"></a>包加载</h3><p>通过前面一系列的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gomaininit.gif" alt="图：Go 包的初始化"></p>
<p>Go语言包的初始化有如下特点：</p>
<ul>
<li>包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。</li>
<li>Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。</li>
<li>单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 init 函数。</li>
</ul>
<h2 id="封装简介及实现细节"><a href="#封装简介及实现细节" class="headerlink" title="封装简介及实现细节"></a>封装简介及实现细节</h2><p>在Go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只能通过被授权的方法，才能对字段进行操作。</p>
<p>封装的好处：</p>
<ul>
<li>隐藏实现细节；</li>
<li>可以对数据进行验证，保证数据安全合理。</li>
</ul>
<p>如何体现封装：</p>
<ul>
<li>对结构体中的属性进行封装；</li>
<li>通过方法，包，实现封装。</li>
</ul>
<p>封装的实现步骤：</p>
<ul>
<li>将结构体、字段的首字母小写；</li>
<li>给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；</li>
<li>提供一个首字母大写的 Set 方法（类似其它语言的 public），用于对属性判断并赋值；</li>
<li>提供一个首字母大写的 Get 方法（类似其它语言的 public），用于获取属性的值。</li>
</ul>
<p>【示例】对于员工，不能随便查看年龄，工资等隐私，并对输入的年龄进行合理的验证。代码结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package model</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type person struct {</span><br><span class="line">	Name string</span><br><span class="line">	age int   //其它包不能直接访问..</span><br><span class="line">	sal float64</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//写一个工厂模式的函数，相当于构造函数</span><br><span class="line">func NewPerson(name string) *person {</span><br><span class="line">	return &amp;person{</span><br><span class="line">		Name : name,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span><br><span class="line">func (p *person) SetAge(age int) {</span><br><span class="line">	if age &gt;0 &amp;&amp; age &lt;150 {</span><br><span class="line">		p.age = age</span><br><span class="line">	} else {</span><br><span class="line">		fmt.Println("年龄范围不正确..")</span><br><span class="line">		//给程序员给一个默认值</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) GetAge() int {</span><br><span class="line">	return p.age</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) SetSal(sal float64) {</span><br><span class="line">	if sal &gt;= 3000 &amp;&amp; sal &lt;= 30000 {</span><br><span class="line">		p.sal = sal</span><br><span class="line">	} else {</span><br><span class="line">		fmt.Println("薪水范围不正确..")</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) GetSal() float64 {</span><br><span class="line">	return p.sal</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>main.go 中的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line"></span><br><span class="line">	"../model"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  {</span><br><span class="line">	p := model.NewPerson("smith")</span><br><span class="line">	p.SetAge(18)</span><br><span class="line">	p.SetSal(5000)</span><br><span class="line">	fmt.Println(p)</span><br><span class="line">	fmt.Println(p.Name, " age =", p.GetAge(), " sal = ", p.GetSal())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&amp;{smith 18 5000}</span><br><span class="line">smith  age = 18  sal =  5000</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## GOPATH详解（Go语言工作目录）</span><br><span class="line"></span><br><span class="line">GOPATH 是 Go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录。</span><br><span class="line"></span><br><span class="line">工作目录是一个工程开发的相对参考目录，好比当你要在公司编写一套服务器代码，你的工位所包含的桌面、计算机及椅子就是你的工作区。工作区的概念与工作目录的概念也是类似的。如果不使用工作目录的概念，在多人开发时，每个人有一套自己的目录结构，读取配置文件的位置不统一，输出的二进制运行文件也不统一，这样会导致开发的标准不统一，影响开发效率。</span><br><span class="line"></span><br><span class="line">GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。</span><br><span class="line"></span><br><span class="line">**提示**</span><br><span class="line"></span><br><span class="line">C、C++、Java、C# 及其他语言发展到后期，都拥有自己的 IDE（集成开发环境），并且工程（Project）、解决方案（Solution）和工作区（Workspace）等概念将源码和资源组织了起来，方便编译和输出。</span><br><span class="line"></span><br><span class="line">### 使用命令行查看GOPATH信息</span><br><span class="line"></span><br><span class="line">在《安装Go语言开发包》一节中我们已经介绍过 Go语言的安装方法。在安装过 Go 开发包的操作系统中，可以使用命令行查看 Go 开发包的环境变量配置信息，这些配置信息里可以查看到当前的 GOPATH 路径设置情况。在命令行中运行go env后，命令行将提示以下信息：</span><br><span class="line"></span><br><span class="line">```示例代码</span><br><span class="line">D:\go_workspace\chebada-go-proxy\src\chebada.com\app\main&gt;go env</span><br><span class="line">set GO111MODULE=</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">set GOBIN=</span><br><span class="line">set GOCACHE=D:\MyConfiguration\dqc13215\AppData\Local\go-build</span><br><span class="line">set GOENV=D:\MyConfiguration\dqc13215\AppData\Roaming\go\env</span><br><span class="line">set GOEXE=.exe</span><br><span class="line">set GOFLAGS=</span><br><span class="line">set GOHOSTARCH=amd64</span><br><span class="line">set GOHOSTOS=windows</span><br><span class="line">set GOINSECURE=</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOOS=windows</span><br><span class="line">set GOPATH=D:\go_workspace</span><br><span class="line">set GOPRIVATE=</span><br><span class="line">set GOPROXY=https://goproxy.cn,direct</span><br><span class="line">set GOROOT=C:\Go</span><br><span class="line">set GOSUMDB=sum.golang.org</span><br><span class="line">set GOTMPDIR=</span><br><span class="line">set GOTOOLDIR=C:\Go\pkg\tool\windows_amd64</span><br><span class="line">set GCCGO=gccgo</span><br><span class="line">set AR=ar</span><br><span class="line">set CC=gcc</span><br><span class="line">set CXX=g++</span><br><span class="line">set CGO_ENABLED=1</span><br><span class="line">set GOMOD=D:\go_workspace\chebada-go-proxy\go.mod</span><br><span class="line">set CGO_CFLAGS=-g -O2</span><br><span class="line">set CGO_CPPFLAGS=</span><br><span class="line">set CGO_CXXFLAGS=-g -O2</span><br><span class="line">set CGO_FFLAGS=-g -O2</span><br><span class="line">set CGO_LDFLAGS=-g -O2</span><br><span class="line">set PKG_CONFIG=pkg-config</span><br><span class="line">set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=D:\MyConfiguration\dqc13215\AppData\Local\Temp\go-build678842734=/tmp/go-build -gno-record-gcc-switches</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>命令行说明如下：</p>
<ul>
<li>第 1 行，执行 go env 指令，将输出当前 Go 开发包的环境变量状态。</li>
<li>第 3 行，GOARCH 表示目标处理器架构。</li>
<li>第 4 行，GOBIN 表示编译器和链接器的安装位置。</li>
<li>第 14 行，GOOS 表示目标操作系统。</li>
<li>第 15 行，GOPATH 表示当前工作目录。</li>
<li>第 18 行，GOROOT 表示 Go 开发包的安装目录。</li>
</ul>
<p>从命令行输出中，可以看到 GOPATH 设定的路径为：<code>D:\go_workspace</code> 。</p>
<p>在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。</p>
<table>
    <thead><tr><th>平  台</th><th>GOPATH 默认值</th><th>举  例</th></tr></thead>
    <tbody>
        <tr><th>Windows 平台</th><th>%USERPROFILE%/go</th><th>C:\Users\用户名\go</th></tr>
         <tr><th>Unix 平台</th><th>$HOME/go</th><th>/home/用户名/go</th></tr>
    </tbody>
</table>

<h3 id="使用GOPATH的工程结构"><a href="#使用GOPATH的工程结构" class="headerlink" title="使用GOPATH的工程结构"></a>使用GOPATH的工程结构</h3><p>在 GOPATH 指定的工作目录下，代码总是会保存在 <code>$GOPATH/src</code> 目录下。在工程经过 <code>go build</code> 、<code>go install</code> 或 <code>go get</code> 等指令后，会将产生的二进制可执行文件放在 <code>$GOPATH/bin</code> 目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p>如果需要将整个源码添加到版本管理工具<code>（Version Control System，VCS）</code>中时，只需要添加 <code>$GOPATH/src</code> 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</p>
<h4 id="设置和使用GOPATH"><a href="#设置和使用GOPATH" class="headerlink" title="设置和使用GOPATH"></a>设置和使用GOPATH</h4><p>本节以 Linux 为演示平台，为大家演示使用 GOPATH 的方法。</p>
<p><strong>1) 设置当前目录为GOPATH</strong></p>
<p>选择一个目录，在目录中的命令行中执行下面的指令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br></pre></td></tr></tbody></table></figure>
<p>该指令中的 pwd 将输出当前的目录，使用反引号 ` 将 pwd 指令括起来表示命令行替换，也就是说，使用 `pwd` 将获得 pwd 返回的当前目录的值。例如，假设你的当前目录是“/home/davy/go”，那么使用 `pwd` 将获得返回值“/home/davy/go”。</p>
<p>使用 export 指令可以将当前目录的值设置到环境变量 GOPATH中。</p>
<p><strong>2) 建立GOPATH中的源码目录</strong></p>
<p>使用下面的指令创建 GOPATH 中的 src 目录，在 src 目录下还有一个 hello 目录，该目录用于保存源码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p src/hello</span><br></pre></td></tr></tbody></table></figure>
<p>mkdir 指令的 -p 可以连续创建一个路径。</p>
<p><strong>3) 添加main.go源码文件</strong></p>
<p>使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 <code>$GOPATH/src/hello</code> 目录下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main(){</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) 编译源码并运行</strong></p>
<p>此时我们已经设定了 GOPATH，因此在 Go语言中可以通过 GOPATH 找到工程的位置。</p>
<p>在命令行中执行如下指令编译源码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go install hello</span><br></pre></td></tr></tbody></table></figure>
<p>编译完成的可执行文件会保存在 <code>$GOPATH/bin</code> 目录下。</p>
<p>在 bin 目录中执行 <code>./hello</code>，命令行输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在多项目工程中使用GOPATH"><a href="#在多项目工程中使用GOPATH" class="headerlink" title="在多项目工程中使用GOPATH"></a>在多项目工程中使用GOPATH</h3><p>在很多与 Go语言相关的书籍、文章中描述的 GOPATH 都是通过修改系统全局的环境变量来实现的。然而，根据笔者多年的 Go语言使用和实践经验及周边朋友、同事的反馈，这种设置全局 GOPATH 的方法可能会导致当前项目错误引用了其他目录的 Go 源码文件从而造成编译输出错误的版本或编译报出一些无法理解的错误提示。</p>
<p>比如说，将某项目代码保存在 <code>/home/davy/projectA</code> 目录下，将该目录设置为 GOPATH。随着开发进行，需要再次获取一份工程项目的源码，此时源码保存在 <code>/home/davy/projectB</code> 目录下，如果此时需要编译 projectB 目录的项目，但开发者忘记设置 GOPATH 而直接使用命令行编译，则当前的 GOPATH 指向的是 <code>/home/davy/projectA</code> 目录，而不是开发者编译时期望的 projectB 目录。编译完成后，开发者就会将错误的工程版本发布到外网。</p>
<p>因此，建议大家无论是使用命令行或者使用集成开发环境编译 Go 源码时，GOPATH 跟随项目设定。在 Jetbrains 公司的 GoLand 集成开发环境（IDE）中的 GOPATH 设置分为全局 GOPATH 和项目 GOPATH，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gopathproject.png" alt="图：全局和项目GOPATH"></p>
<p>图中的 Global GOPATH 代表全局 GOPATH，一般来源于系统环境变量中的 GOPATH；Project GOPATH 代表项目所使用的 GOPATH，该设置会被保存在工作目录的 <code>.idea</code> 目录下，不会被设置到环境变量的 GOPATH 中，但会在编译时使用到这个目录。建议在开发时只填写项目 GOPATH，每一个项目尽量只设置一个 GOPATH，不使用多个 GOPATH 和全局的 GOPATH。</p>
<p><strong>提示</strong></p>
<p>Visual Studio 早期在设计时，允许 C++ 语言在全局拥有一个包含路径。当一个工程多个版本的编译，或者两个项目混杂有不同的共享全局包含时，会发生难以察觉的错误。在新版本 Visual Studio 中已经废除了这种全局包含的路径设计，并建议开发者将包含目录与项目关联。</p>
<p>Go语言中的 GOPATH 也是一种类似全局包含的设计，因此鉴于 Visual Studio 在设计上的失误，建议开发者不要设置全局的 GOPATH，而是随项目设置 GOPATH。</p>
<h2 id="常用内置包简介"><a href="#常用内置包简介" class="headerlink" title="常用内置包简介"></a>常用内置包简介</h2><p>标准的Go语言代码库中包含了大量的包，并且在安装 Go 的时候多数会自动安装到系统中。我们可以在 <code>$GOROOT/src/pkg</code> 目录中查看这些包。下面简单介绍一些我们开发中常用的包。</p>
<h3 id="1-fmt"><a href="#1-fmt" class="headerlink" title="1) fmt"></a>1) fmt</h3><p>fmt 包实现了格式化的标准输入输出，这与C语言中的 printf 和 scanf 类似。其中的 fmt.Printf() 和 fmt.Println() 是开发者使用最为频繁的函数。</p>
<p>格式化短语派生于C语言，一些短语（%- 序列）是这样使用：</p>
<ul>
<li>%v：默认格式的值。当打印结构时，加号（%+v）会增加字段名；</li>
<li>%#v：Go样式的值表达；</li>
<li>%T：带有类型的 Go 样式的值表达。</li>
</ul>
<h3 id="2-io"><a href="#2-io" class="headerlink" title="2) io"></a>2) io</h3><p>这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。</p>
<h3 id="3-bufio"><a href="#3-bufio" class="headerlink" title="3) bufio"></a>3) bufio</h3><p>bufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。</p>
<p>在 bufio 各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行。当发起一次读写操作时，会首先尝试从缓冲区获取数据，只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。</p>
<h3 id="4-sort"><a href="#4-sort" class="headerlink" title="4) sort"></a>4) sort</h3><p>sort 包提供了用于对切片和用户定义的集合进行排序的功能。</p>
<h3 id="5-strconv"><a href="#5-strconv" class="headerlink" title="5) strconv"></a>5) strconv</h3><p>strconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。</p>
<h3 id="6-os"><a href="#6-os" class="headerlink" title="6) os"></a>6) os</h3><p>os 包提供了不依赖平台的操作系统函数接口，设计像 Unix 风格，但错误处理是 go 风格，当 os 包使用时，如果失败后返回错误类型而不是错误数量。</p>
<h3 id="7-sync"><a href="#7-sync" class="headerlink" title="7) sync"></a>7) sync</h3><p>sync 包实现多线程中锁机制以及其他同步互斥机制。</p>
<h3 id="8-flag"><a href="#8-flag" class="headerlink" title="8) flag"></a>8) flag</h3><p>flag 包提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。</p>
<h3 id="9-encoding-json"><a href="#9-encoding-json" class="headerlink" title="9) encoding/json"></a>9) encoding/json</h3><p>JSON 目前广泛用做网络程序中的通信格式。encoding/json 包提供了对 JSON 的基本支持，比如从一个对象序列化为 JSON 字符串，或者从 JSON 字符串反序列化出一个具体的对象等。</p>
<h3 id="10-html-template"><a href="#10-html-template" class="headerlink" title="10) html/template"></a>10) html/template</h3><p>主要实现了 web 开发中生成 html 的 template 的一些函数。</p>
<h3 id="11-net-http"><a href="#11-net-http" class="headerlink" title="11) net/http"></a>11) net/http</h3><p>net/http 包提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。</p>
<p>通过 net/http 包，只需要数行代码，即可实现一个爬虫或者一个 Web 服务器，这在传统语言中是无法想象的。</p>
<h3 id="12-reflect"><a href="#12-reflect" class="headerlink" title="12) reflect"></a>12) reflect</h3><p>reflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。</p>
<h3 id="13-os-exec"><a href="#13-os-exec" class="headerlink" title="13) os/exec"></a>13) os/exec</h3><p>os/exec 包提供了执行自定义 linux 命令的相关实现。</p>
<h3 id="14-strings"><a href="#14-strings" class="headerlink" title="14) strings"></a>14) strings</h3><p>strings 包主要是处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。</p>
<p>strings 包与 bytes 包的函数接口功能基本一致。</p>
<h3 id="15-bytes"><a href="#15-bytes" class="headerlink" title="15) bytes"></a>15) bytes</h3><p>bytes 包提供了对字节切片进行读写操作的一系列函数。字节切片处理的函数比较多，分为基本处理函数、比较函数、后缀检查函数、索引函数、分割函数、大小写处理函数和子切片处理函数等。</p>
<h3 id="16-log"><a href="#16-log" class="headerlink" title="16) log"></a>16) log</h3><p>log 包主要用于在程序中输出日志。</p>
<p>log 包中提供了三类日志输出接口，Print、Fatal 和 Panic。</p>
<ul>
<li>Print 是普通输出；</li>
<li>Fatal 是在执行完 Print 后，执行 os.Exit(1)；</li>
<li>Panic 是在执行完 Print 后调用 panic() 方法。</li>
</ul>
<h2 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h2><p>包是Go语言中代码组成和代码编译的主要方式。关于包的基本信息我们已经在前面介绍过了，本节我们主要来介绍一下如何自定义一个包并使用它。</p>
<p>到目前为止，我们所使用的例子都是以一个包的形式存在的，比如 main 包。在Go语言里，允许我们将同一个包的代码分隔成多个独立的源码文件来单独保存，只需要将这些文件放在同一个目录下即可。</p>
<p>我们创建的自定义的包需要将其放在 GOPATH 的 src 目录下（也可以是 src 目录下的某个子目录），而且两个不同的包不能放在同一目录下，这样会引起编译错误。</p>
<p>一个包中可以有任意多个文件，文件的名字也没有任何规定（但后缀必须是 .go），这里我们假设包名就是 .go 的文件名（如果一个包有多个 .go 文件，则其中会有一个 .go 文件的文件名和包名相同）。</p>
<p>下面通过示例来演示一下如何创建一个名为 demo 的自定义包，并在 main 包中使用自定义包 demo 中的方法。</p>
<p>首先，在 GOPATH 下的 src 目录中新建一个 demo 文件夹 ，并在 demo 文件夹下创建 demo.go 文件，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/demopackage.gif" alt="图：demo 文件夹"></p>
<p>demo.go 文件的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func PrintStr() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后，在 GOPATH 下的 src 目录中新建一个 main 文件夹，并在 main 文件夹下创建 mian.go 文件，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gopackagemain.gif" alt="图：main 文件夹"></p>
<p>main.go 文件的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "demo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    demo.PrintStr()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">C语言中文网</span><br></pre></td></tr></tbody></table></figure>
<p>对引用自定义包需要注意以下几点：</p>
<ul>
<li>如果项目的目录不在 GOPATH 环境变量中，则需要把项目移到 GOPATH 所在的目录中，或者将项目所在的目录设置到 GOPATH 环境变量中，否则无法完成编译；</li>
<li>使用 import 语句导入包时，使用的是包所属文件夹的名称；</li>
<li>包中的函数名第一个字母要大写，否则无法在外部调用；</li>
<li>自定义包的包名不必与其所在文件夹的名称保持一致，但为了便于维护，建议保持一致；</li>
<li>调用自定义包时使用 包名 . 函数名 的方式，如上例：demo.PrintStr()。</li>
</ul>
<h2 id="package（创建包）"><a href="#package（创建包）" class="headerlink" title="package（创建包）"></a>package（创建包）</h2><p>包（package）是多个 Go 源码的集合，是一种高级的代码复用方案，像 fmt、os、io 等这样具有常用功能的内置包在 Go语言中有 150 个以上，它们被称为标准库，大部分（一些底层的除外）内置于 Go 本身。</p>
<p>包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></tbody></table></figure>
<p>包的特性如下：</p>
<ul>
<li>一个目录下的同级文件归属一个包。</li>
<li>包名可以与其目录不同名。</li>
<li>包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。</li>
</ul>
<p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p>
<p>每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以避免在我们使用它们的时候减少和其它部分名字的冲突。</p>
<p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包 API 的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p>
<p>当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。</p>
<ul>
<li>第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件。</li>
</ul>
<h2 id="导出包中的标识符——让外部访问包的类型和值"><a href="#导出包中的标识符——让外部访问包的类型和值" class="headerlink" title="导出包中的标识符——让外部访问包的类型和值"></a>导出包中的标识符——让外部访问包的类型和值</h2><p>在 Go语言中，如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。</p>
<h3 id="导出包内标识符"><a href="#导出包内标识符" class="headerlink" title="导出包内标识符"></a>导出包内标识符</h3><p>下面代码中包含一系列未导出标识符，它们的首字母都为小写，这些标识符可以在包内自由使用，但是包外无法访问它们，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package mypkg</span><br><span class="line"></span><br><span class="line">var myVar = 100</span><br><span class="line"></span><br><span class="line">const myConst = "hello"</span><br><span class="line"></span><br><span class="line">type myStruct struct {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将 myStruct 和 myConst 首字母大写，导出这些标识符，修改后代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package mypkg</span><br><span class="line"></span><br><span class="line">var myVar = 100</span><br><span class="line"></span><br><span class="line">const MyConst = "hello"</span><br><span class="line"></span><br><span class="line">type MyStruct struct {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时，MyConst 和 MyStruct 可以被外部访问，而 myVar 由于首字母是小写，因此只能在 mypkg 包内使用，不能被外部包引用。</p>
<h3 id="导出结构体及接口成员"><a href="#导出结构体及接口成员" class="headerlink" title="导出结构体及接口成员"></a>导出结构体及接口成员</h3><p>在被导出的结构体或接口中，如果它们的字段或方法首字母是大写，外部可以访问这些字段和方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type MyStruct struct {</span><br><span class="line"></span><br><span class="line">    // 包外可以访问的字段</span><br><span class="line">    ExportedField int</span><br><span class="line"></span><br><span class="line">    // 仅限包内访问的字段</span><br><span class="line">    privateField int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type MyInterface interface {</span><br><span class="line"></span><br><span class="line">    // 包外可以访问的方法</span><br><span class="line">    ExportedMethod()</span><br><span class="line"></span><br><span class="line">    // 仅限包内访问的方法</span><br><span class="line">    privateMethod()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在代码中，MyStruct 的 ExportedField 和 MyInterface 的 ExportedMethod() 可以被包外访问。</p>
<h2 id="import导入包——在代码中使用其他的代码"><a href="#import导入包——在代码中使用其他的代码" class="headerlink" title="import导入包——在代码中使用其他的代码"></a>import导入包——在代码中使用其他的代码</h2><p>可以在一个 Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用 <code>/</code> 进行路径分隔。</p>
<h3 id="默认导入的写法"><a href="#默认导入的写法" class="headerlink" title="默认导入的写法"></a>默认导入的写法</h3><p>导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的。</p>
<p><strong>1) 单行导入</strong></p>
<p>单行导入格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "包1"</span><br><span class="line">import "包2"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 多行导入</strong></p>
<p>当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import(</span><br><span class="line">    "包1"</span><br><span class="line">    "包2"</span><br><span class="line">    …</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>参考代码例子来理解 import 的机制。</p>
<p>代码的目录层次如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    └── chapter08</span><br><span class="line">        └── importadd</span><br><span class="line">            ├── main.go</span><br><span class="line">            └── mylib</span><br><span class="line">                └── add.go</span><br></pre></td></tr></tbody></table></figure>
<p>加函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package mylib</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int {</span><br><span class="line">    return a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 3 行中的 Add() 函数以大写 A 开头，表示将 Add() 函数导出供包外使用。当首字母小写时，为包内使用，包外无法引用到。</p>
<p>add.go 在 mylib 文件夹下，习惯上将文件夹的命名与包名一致，命名为 mylib 包。</p>
<p>导入包</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/importadd/mylib"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(mylib.Add(1, 2))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，导入 chapter08/importadd/mylib 包。</li>
<li>第 9 行，使用 mylib 作为包名，并引用 Add() 函数调用。</li>
</ul>
<p>在命令行中运行下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPATH=/home/davy/golangbook/code</span><br><span class="line">go install chapter08/importadd</span><br><span class="line">$GOPATH/bin/importadd</span><br></pre></td></tr></tbody></table></figure>
<p>命令说明如下：</p>
<ul>
<li>第 1 行，根据你的 GOPATH 不同，设置 GOPATH。</li>
<li>第 2 行，使用 <code>go install</code> 指令编译并安装 chapter08/code8-1 到 GOPATH 的 bin 目录下。</li>
<li>第 3 行，执行 GOPATH 的 bin 目录下的可执行文件 code8-1。</li>
</ul>
<p>运行代码，输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt 和 goimports 工具都可以将不同分组导入的包独立排序。）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "html/template"</span><br><span class="line">    "os"</span><br><span class="line"></span><br><span class="line">    "golang.org/x/net/html"</span><br><span class="line">    "golang.org/x/net/ipv4"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入包后自定义引用的包名"><a href="#导入包后自定义引用的包名" class="headerlink" title="导入包后自定义引用的包名"></a>导入包后自定义引用的包名</h3><p>如果我们想同时导入两个有着名字相同的包，例如 math/rand 包和 crypto/rand 包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    "crypto/rand"</span><br><span class="line">    mrand "math/rand" // 将名称替换为mrand避免冲突</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。</p>
<p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为 path 的变量，那么我们可以将”path”标准包重命名为 pathpkg。</p>
<p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</p>
<h3 id="匿名导入包——只导入包但不使用包内类型和数值"><a href="#匿名导入包——只导入包但不使用包内类型和数值" class="headerlink" title="匿名导入包——只导入包但不使用包内类型和数值"></a>匿名导入包——只导入包但不使用包内类型和数值</h3><p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "path/to/package"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，path/to/package 表示要导入的包名，下画线 <code>_</code> 表示匿名导入包。</p>
<p>匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。</p>
<h3 id="包在程序启动前的初始化入口：init"><a href="#包在程序启动前的初始化入口：init" class="headerlink" title="包在程序启动前的初始化入口：init"></a>包在程序启动前的初始化入口：init</h3><p>在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。</p>
<p>例如，为了提高数学库计算三角函数的执行效率，可以在程序启动时，将三角函数的值提前在内存中建成索引表，外部程序通过查表的方式迅速获得三角函数的值。但是三角函数索引表的初始化函数的调用不希望由每一个外部使用三角函数的开发者调用，如果在三角函数的包内有一个机制可以告诉三角函数包程序何时启动，那么就可以解决初始化的问题。</p>
<p>Go 语言为以上问题提供了一个非常方便的特性：init() 函数。</p>
<p>init() 函数的特性如下：</p>
<ul>
<li>每个源码可以使用 1 个 init() 函数。</li>
<li>init() 函数会在程序执行前（main() 函数执行前）被自动调用。</li>
<li>调用顺序为 main() 中引用的包，以深度优先顺序初始化。</li>
</ul>
<p>例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">C.init→B.init→A.init→main</span><br></pre></td></tr></tbody></table></figure>
<p>说明：</p>
<ul>
<li>同一个包中的多个 init() 函数的调用顺序不可预期。</li>
<li>init() 函数不能被其他函数调用。</li>
</ul>
<h3 id="理解包导入后的init-函数初始化顺序"><a href="#理解包导入后的init-函数初始化顺序" class="headerlink" title="理解包导入后的init()函数初始化顺序"></a>理解包导入后的init()函数初始化顺序</h3><p>Go 语言包会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p>
<p>在运行时，被最后导入的包会最先初始化并调用 init() 函数。</p>
<p>通过下面的代码理解包的初始化顺序。</p>
<p>包导入初始化顺序入口（…/chapter08/pkginit/main.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "chapter08/code8-2/pkg1"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    pkg1.ExecPkg1()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，导入 pkg1 包。</li>
<li>第 7 行，调用 pkg1 包的 ExecPkg1() 函数。</li>
</ul>
<p>包导入初始化顺序pkg1（…/chapter08/pkginit/pkg1/pkg1.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package pkg1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/code8-2/pkg2"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func ExecPkg1() {</span><br><span class="line"></span><br><span class="line">    fmt.Println("ExecPkg1")</span><br><span class="line"></span><br><span class="line">    pkg2.ExecPkg2()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">    fmt.Println("pkg1 init")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，导入 pkg2 包。</li>
<li>第 8 行，声明 ExecPkg1() 函数。</li>
<li>第 12 行，调用 pkg2 包的 ExecPkg2() 函数。</li>
<li>第 15 行，在 pkg1 包初始化时，打印 pkg1 init。</li>
</ul>
<p>包导入初始化顺序pkg2（…/chapter08/pkginit/pkg2/pkg2.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package pkg2</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func ExecPkg2() {</span><br><span class="line">    fmt.Println("ExecPkg2")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">    fmt.Println("pkg2 init")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行，声明 ExecPkg2() 函数。</li>
<li>第 10 行，在 pkg2 包初始化时，打印 pkg2 init。</li>
</ul>
<p>执行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">pkg2 init</span><br><span class="line">pkg1 init</span><br><span class="line">ExecPkg1</span><br><span class="line">ExecPkg2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="工厂模式自动注册——管理多个包的结构体"><a href="#工厂模式自动注册——管理多个包的结构体" class="headerlink" title="工厂模式自动注册——管理多个包的结构体"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/92.html">工厂模式自动注册——管理多个包的结构体</a></h2><p>本例利用包的 init 特性，将 cls1 和 cls2 两个包注册到工厂，使用字符串创建这两个注册好的结构实例。</p>
<p>完整代码的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    └── chapter08</span><br><span class="line">        └── clsfactory</span><br><span class="line">            ├── main.go</span><br><span class="line">            └── base</span><br><span class="line">                └── factory.go</span><br><span class="line">            └── cls1</span><br><span class="line">                └── reg.go</span><br><span class="line">            └── cls2</span><br><span class="line">                └── reg.go</span><br></pre></td></tr></tbody></table></figure>
<p>类工厂（具体文件：…/chapter08/clsfactory/base/factory.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package base</span><br><span class="line"></span><br><span class="line">// 类接口</span><br><span class="line">type Class interface {</span><br><span class="line">	Do()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	// 保存注册好的工厂信息</span><br><span class="line">	factoryByName = make(map[string]func() Class)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 注册一个类生成工厂</span><br><span class="line">func Register(name string, factory func() Class) {</span><br><span class="line">	factoryByName[name] = factory</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据名称创建对应的类</span><br><span class="line">func Create(name string) Class {</span><br><span class="line">	if f, ok := factoryByName[name]; ok {</span><br><span class="line">		return f()</span><br><span class="line">	} else {</span><br><span class="line">		panic("name not found")</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个包叫base，负责处理注册和使用工厂的基础代码，该包不会引用任何外部的包。</p>
<p>以下是对代码的说明：</p>
<ul>
<li>第 4 行定义了“产品”：类。</li>
<li>第 10 行使用了一个 map 保存注册的工厂信息。</li>
<li>第 14 行提供给工厂方注册使用，所谓的“工厂”，就是一个定义为 <code>func() Class</code> 的普通函数，调用此函数，创建一个类实例，实现的工厂内部结构体会实现 Class 接口。</li>
<li>第 19 行定义通过名字创建类实例的函数，该函数会在注册好后调用。</li>
<li>第 20 行在已经注册的信息中查找名字对应的工厂函数，找到后，在第 21 行调用并返回接口。</li>
<li>第 23 行是如果创建的名字没有找到时，报错。</li>
</ul>
<p>类1及注册代码（具体文件：…/chapter08/clsfactory/cls1/reg.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package cls1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> "../base"</span><br><span class="line"> "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义类1</span><br><span class="line">type Class1 struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Class接口</span><br><span class="line">func (c *Class1) Do() {</span><br><span class="line">	fmt.Println("Class1")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	// 在启动时注册类1工厂</span><br><span class="line">	base.Register("Class1", func() base.Class {</span><br><span class="line">		return new(Class1)</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码展示了Class1的工厂及产品定义过程。</p>
<ul>
<li>第 9～15 行定义 Class1 结构，该结构实现了 base 中的 Class 接口。</li>
<li>第 20 行，Class1 结构的实例化过程叫 Class1 的工厂，使用 <code>base.Register()</code> 函数在 init() 函数被调用时与一个字符串关联，这样，方便以后通过名字重新调用该函数并创建实例。</li>
</ul>
<p>类2及注册代码（具体文件：…/chapter08/clsfactory/cls2/reg.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package cls2</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"../base"</span><br><span class="line">	"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义类2</span><br><span class="line">type Class2 struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Class接口</span><br><span class="line">func (c *Class2) Do() {</span><br><span class="line">	fmt.Println("Class2")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	// 在启动时注册类2工厂</span><br><span class="line">	base.Register("Class2", func() base.Class {</span><br><span class="line">		return new(Class2)</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Class2 的注册与 Class1 的定义和注册过程类似。</p>
<p>类工程主流程（具体文件：…/chapter08/clsfactory/main.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/clsfactory/base"</span><br><span class="line">    _ "chapter08/clsfactory/cls1"  // 匿名引用cls1包, 自动注册</span><br><span class="line">    _ "chapter08/clsfactory/cls2"  // 匿名引用cls2包, 自动注册</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 根据字符串动态创建一个Class1实例</span><br><span class="line">    c1 := base.Create("Class1")</span><br><span class="line">    c1.Do()</span><br><span class="line"></span><br><span class="line">    // 根据字符串动态创建一个Class2实例</span><br><span class="line">    c2 := base.Create("Class2")</span><br><span class="line">    c2.Do()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对代码的说明：</p>
<ul>
<li>第 5 和第 6 行使用匿名引用方法导入了 cls1 和 cls2 两个包。在 main() 函数调用前，这两个包的 init() 函数会被自动调用，从而自动注册 Class1 和 Class2。</li>
<li>第 12 和第 16 行，通过 base.Create() 方法查找字符串对应的类注册信息，调用工厂方法进行实例创建。</li>
<li>第 13 和第 17 行，调用类的方法。</li>
</ul>
<p>执行下面的指令进行编译：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPATH=/home/davy/golangbook/code</span><br><span class="line">go install chapter08/clsfactory</span><br><span class="line">$GOPATH/bin/clsfactory</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Class1</span><br><span class="line">Class2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="单例模式简述"><a href="#单例模式简述" class="headerlink" title="单例模式简述"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5720.html">单例模式简述</a></h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>的重要性不用多说，也是面试时常常会被问到的问题。对于设计模式，更多的则是仁者见仁智者见智，要在实际工作中不断的积累，再进行深度的思考，才能逐渐形成的一种思维。</p>
<p>单例模式也叫单子模式，是常用的模式之一，在它的核心结构中只包含一个被称为单例的特殊类，能够保证系统运行中一个类只创建一个实例，本节我们就来介绍一下Go语言中的单例模式。</p>
<h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><p>Go语言实现单例模式的有四种方式，分别是懒汉式、饿汉式、双重检查和 sync.Once。</p>
<p>懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建；饿汉式则是在系统初始化的时候就已经把对象创建好了，需要用的时候直接拿过来用就好了。</p>
<p>不管那种模式最终目的只有一个，就是只实例化一次，只允许一个实例存在。</p>
<p>下面就来分别介绍一下这四种实现方式：</p>
<p><strong>1) 懒汉式——非线程安全</strong></p>
<p>非线程安全，指的是在多线程下可能会创建多次对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//使用结构体代替类</span><br><span class="line"></span><br><span class="line">type Tool struct {</span><br><span class="line">    values int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//建立私有变量</span><br><span class="line">var instance *Tool</span><br><span class="line"></span><br><span class="line">//获取单例对象的方法，引用传递返回</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    if instance == nil {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    }</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在非线程安全的基本上，利用 Sync.Mutex 进行加锁保证线程安全，但由于每次调用该方法都进行了加锁操作，在性能上不是很高效。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//锁对象</span><br><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">//加锁保证线程安全</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    defer lock.Unlock()</span><br><span class="line">    if instance == nil {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 饿汉式</strong></p>
<p>直接创建好对象，不需要判断为空，同时也是线程安全，唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p>
<p>Go语言饿汉式可以使用 init 函数，也可以使用全局变量。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type cfg struct {</span><br><span class="line">}</span><br><span class="line">var cfg *cfg</span><br><span class="line">func init()  {</span><br><span class="line">   cfg = new(cfg)</span><br><span class="line">}</span><br><span class="line">// NewConfig 提供获取实例的方法</span><br><span class="line">func NewConfig() *cfg {</span><br><span class="line">   return cfg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type config struct {  </span><br><span class="line">}</span><br><span class="line">//全局变量</span><br><span class="line">var cfg *config = new(config)</span><br><span class="line">// NewConfig 提供获取实例的方法</span><br><span class="line">func NewConfig() *config {</span><br><span class="line">   return cfg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 双重检查</strong></p>
<p>在懒汉式（线程安全）的基础上再进行优化，减少加锁的操作，保证线程安全的同时不影响性能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//锁对象</span><br><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">//第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后，获取对象就不用加锁了。</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    if instance == nil {</span><br><span class="line">        lock.Lock()</span><br><span class="line">        if instance == nil {</span><br><span class="line">            instance = new(Tool)</span><br><span class="line">        }</span><br><span class="line">        lock.Unlock()</span><br><span class="line">    }</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) sync.Once</strong></p>
<p>通过 sync.Once 来确保创建对象的方法只执行一次</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    once.Do(func() {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    })</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sync.Once 内部本质上也是双重检查的方式，但在写法上会比自己写双重检查更简洁，以下是 Once 的源码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (o *Once) Do(f func()) {</span><br><span class="line">　　//判断是否执行过该方法，如果执行过则不执行</span><br><span class="line">    if atomic.LoadUint32(&amp;o.done) == 1 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    // Slow-path.</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    defer o.m.Unlock()</span><br><span class="line">　　//进行加锁，再做一次判断，如果没有执行，则进行标志已经执行并调用该方法</span><br><span class="line">    if o.done == 0 {</span><br><span class="line">        defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">        f()</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="sync包与锁：限制线程对变量的访问"><a href="#sync包与锁：限制线程对变量的访问" class="headerlink" title="sync包与锁：限制线程对变量的访问"></a>sync包与锁：限制线程对变量的访问</h2><p>Go语言中 sync 包里提供了互斥锁 Mutex 和读写锁 RWMutex 用于处理并发过程中可能出现同时两个或多个协程（或线程）读或写同一个变量的情况。</p>
<h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>锁是 sync 包中的核心，它主要有两个方法，分别是加锁（Lock）和解锁（Unlock）。</p>
<p>在并发的情况下，多个线程或协程同时其修改一个变量，使用锁能保证在某一时间内，只有一个协程或线程修改这一变量。</p>
<p>不使用锁时，在并发的情况下可能无法得到想要的结果，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var a = 0</span><br><span class="line">    for i := 0; i &lt; 1000; i++ {</span><br><span class="line">        go func(idx int) {</span><br><span class="line">            a += 1</span><br><span class="line">            fmt.Println(a)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从理论上来说，上面的程序会将 a 的值依次递增输出，然而实际结果却是下面这样子的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">537</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">538</span><br><span class="line">999</span><br><span class="line">1000</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出 a 的值并不是按顺序递增输出的，这是为什么呢？</p>
<p>协程的执行顺序大致如下所示：</p>
<ul>
<li>从寄存器读取 a 的值；</li>
<li>然后做加法运算；</li>
<li>最后写到寄存器。</li>
</ul>
<p>按照上面的顺序，假如有一个协程取得 a 的值为 3，然后执行加法运算，此时又有一个协程对 a 进行取值，得到的值同样是 3，最终两个协程的返回结果是相同的。</p>
<p>而锁的概念就是，当一个协程正在处理 a 时将 a 锁定，其它协程需要等待该协程处理完成并将 a 解锁后才能再进行操作，也就是说同时处理 a 的协程只能有一个，从而避免上面示例中的情况出现。</p>
<h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>上面的示例中出现的问题怎么解决呢？加一个互斥锁 Mutex 就可以了。那什么是互斥锁呢 ？互斥锁中其有两个方法可以调用，如下所示</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (m *Mutex) Lock()</span><br><span class="line">func (m *Mutex) Unlock()</span><br></pre></td></tr></tbody></table></figure>
<p>将上面的代码略作修改，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a = 0</span><br><span class="line">    var lock sync.Mutex</span><br><span class="line">    for i := 0; i &lt; 1000; i++ {</span><br><span class="line">        go func(idx int) {</span><br><span class="line">            lock.Lock()</span><br><span class="line">            defer lock.Unlock()</span><br><span class="line">            a += 1</span><br><span class="line">            fmt.Printf("goroutine %d, a=%d\n", idx, a)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    // 等待 1s 结束主程序</span><br><span class="line">    // 确保所有协程执行完</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">goroutine 995, a=996</span><br><span class="line">goroutine 996, a=997</span><br><span class="line">goroutine 997, a=998</span><br><span class="line">goroutine 998, a=999</span><br><span class="line">goroutine 999, a=1000</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁（重新争抢对互斥锁的锁定），示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    ch := make(chan struct{}, 2)</span><br><span class="line">    var l sync.Mutex</span><br><span class="line">    go func() {</span><br><span class="line">        l.Lock()</span><br><span class="line">        defer l.Unlock()</span><br><span class="line">        fmt.Println("goroutine1: 我会锁定大概 2s")</span><br><span class="line">        time.Sleep(time.Second * 2)</span><br><span class="line">        fmt.Println("goroutine1: 我解锁了，你们去抢吧")</span><br><span class="line">        ch &lt;- struct{}{}</span><br><span class="line">    }()</span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("goroutine2: 等待解锁")</span><br><span class="line">        l.Lock()</span><br><span class="line">        defer l.Unlock()</span><br><span class="line">        fmt.Println("goroutine2: 欧耶，我也解锁了")</span><br><span class="line">        ch &lt;- struct{}{}</span><br><span class="line">    }()</span><br><span class="line">    // 等待 goroutine 执行结束</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        &lt;-ch</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">goroutine1: 我会锁定大概 2s</span><br><span class="line">goroutine2: 等待解锁</span><br><span class="line">goroutine1: 我解锁了，你们去抢吧</span><br><span class="line">goroutine2: 欧耶，我也解锁了</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁有如下四个方法：</p>
<ul>
<li>写操作的锁定和解锁分别是 <code>func (*RWMutex) Lock</code> 和 <code>func (*RWMutex) Unlock</code> ；</li>
<li>读操作的锁定和解锁分别是 <code>func (*RWMutex) Rlock</code> 和 <code>func (*RWMutex) RUnlock</code> 。</li>
</ul>
<p>读写锁的区别在于：</p>
<ul>
<li>当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；</li>
<li>当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；</li>
<li>当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。</li>
</ul>
<p>所以说这里的读锁定（RLock）目的其实是告诉写锁定，有很多协程或者进程正在读取数据，写操作需要等它们读（读解锁）完才能进行写（写锁定）。</p>
<p>我们可以将其总结为如下三条：</p>
<ul>
<li>同时只能有一个 goroutine 能够获得写锁定；</li>
<li>同时可以有任意多个 gorouinte 获得读锁定；</li>
<li>同时只能存在写锁定或读锁定（读和写互斥）。</li>
</ul>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/rand"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line">var count int</span><br><span class="line">var rw sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    ch := make(chan struct{}, 10)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        go read(i, ch)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        go write(i, ch)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        &lt;-ch</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func read(n int, ch chan struct{}) {</span><br><span class="line">    rw.RLock()</span><br><span class="line">    fmt.Printf("goroutine %d 进入读操作...\n", n)</span><br><span class="line">    v := count</span><br><span class="line">    fmt.Printf("goroutine %d 读取结束，值为：%d\n", n, v)</span><br><span class="line">    rw.RUnlock()</span><br><span class="line">    ch &lt;- struct{}{}</span><br><span class="line">}</span><br><span class="line">func write(n int, ch chan struct{}) {</span><br><span class="line">    rw.Lock()</span><br><span class="line">    fmt.Printf("goroutine %d 进入写操作...\n", n)</span><br><span class="line">    v := rand.Intn(1000)</span><br><span class="line">    count = v</span><br><span class="line">    fmt.Printf("goroutine %d 写入结束，新值为：%d\n", n, v)</span><br><span class="line">    rw.Unlock()</span><br><span class="line">    ch &lt;- struct{}{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">goroutine 0 进入读操作...</span><br><span class="line">goroutine 0 读取结束，值为：0</span><br><span class="line">goroutine 3 进入读操作...</span><br><span class="line">goroutine 1 进入读操作...</span><br><span class="line">goroutine 3 读取结束，值为：0</span><br><span class="line">goroutine 1 读取结束，值为：0</span><br><span class="line">goroutine 4 进入写操作...</span><br><span class="line">goroutine 4 写入结束，新值为：81</span><br><span class="line">goroutine 4 进入读操作...</span><br><span class="line">goroutine 4 读取结束，值为：81</span><br><span class="line">goroutine 2 进入读操作...</span><br><span class="line">goroutine 2 读取结束，值为：81</span><br><span class="line">goroutine 0 进入写操作...</span><br><span class="line">goroutine 0 写入结束，新值为：887</span><br><span class="line">goroutine 1 进入写操作...</span><br><span class="line">goroutine 1 写入结束，新值为：847</span><br><span class="line">goroutine 2 进入写操作...</span><br><span class="line">goroutine 2 写入结束，新值为：59</span><br><span class="line">goroutine 3 进入写操作...</span><br><span class="line">goroutine 3 写入结束，新值为：81</span><br></pre></td></tr></tbody></table></figure>
<p>下面再来看两个示例。</p>
<p>【示例 1】多个读操作同时读取一个变量时，虽然加了锁，但是读操作是不受影响的。（读和写是互斥的，读和读不互斥）</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">var m *sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    m = new(sync.RWMutex)</span><br><span class="line">    // 多个同时读</span><br><span class="line">    go read(1)</span><br><span class="line">    go read(2)</span><br><span class="line">    time.Sleep(2*time.Second)</span><br><span class="line">}</span><br><span class="line">func read(i int) {</span><br><span class="line">    println(i,"read start")</span><br><span class="line">    m.RLock()</span><br><span class="line">    println(i,"reading")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.RUnlock()</span><br><span class="line">    println(i,"read over")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 read start</span><br><span class="line">1 reading</span><br><span class="line">2 read start</span><br><span class="line">2 reading</span><br><span class="line">1 read over</span><br><span class="line">2 read over</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】由于读写互斥，所以写操作开始的时候，读操作必须要等写操作进行完才能继续，不然读操作只能继续等待。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">var m *sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    m = new(sync.RWMutex)</span><br><span class="line">    // 写的时候啥也不能干</span><br><span class="line">    go write(1)</span><br><span class="line">    go read(2)</span><br><span class="line">    go write(3)</span><br><span class="line">    time.Sleep(2*time.Second)</span><br><span class="line">}</span><br><span class="line">func read(i int) {</span><br><span class="line">    println(i,"read start")</span><br><span class="line">    m.RLock()</span><br><span class="line">    println(i,"reading")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.RUnlock()</span><br><span class="line">    println(i,"read over")</span><br><span class="line">}</span><br><span class="line">func write(i int) {</span><br><span class="line">    println(i,"write start")</span><br><span class="line">    m.Lock()</span><br><span class="line">    println(i,"writing")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.Unlock()</span><br><span class="line">    println(i,"write over")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 write start</span><br><span class="line">3 write start</span><br><span class="line">1 writing</span><br><span class="line">2 read start</span><br><span class="line">1 write over</span><br><span class="line">2 reading</span><br></pre></td></tr></tbody></table></figure>
<h2 id="big包：对整数的高精度计算"><a href="#big包：对整数的高精度计算" class="headerlink" title="big包：对整数的高精度计算"></a>big包：对整数的高精度计算</h2><p>实际开发中，对于超出 int64 或者 uint64 类型的大数进行计算时，如果对精度没有要求，使用 float32 或者 float64 就可以胜任，但如果对精度有严格要求的时候，我们就不能使用浮点数了，因为浮点数在内存中只能被近似的表示。</p>
<p>Go语言中 <code>math/big</code> 包实现了大数字的多精度计算，支持 Int（有符号整数）、Rat（有理数）和 Float（浮点数）等数字类型。</p>
<p>这些类型可以实现任意位数的数字，只要内存足够大，但缺点是需要更大的内存和处理开销，这使得它们使用起来要比内置的数字类型慢很多。</p>
<p>在 <code>math/big</code> 包中，Int 类型定义如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// An Int represents a signed multi-precision integer.</span><br><span class="line">// The zero value for an Int represents the value 0.</span><br><span class="line">type Int struct {</span><br><span class="line">    neg bool // sign</span><br><span class="line">    abs nat  // absolute value of the integer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成 Int 类型的方法为 NewInt()，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// NewInt allocates and returns a new Int set to x.</span><br><span class="line">func NewInt(x int64) *Int {</span><br><span class="line">    return new(Int).SetInt64(x)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：NewInt() 函数只对 int64 有效，其他类型必须先转成 int64 才行。</em></strong></p>
<p>Go语言中还提供了许多 Set 函数，可以方便的把其他类型的整形存入 Int ，因此，我们可以先 new(int) 然后再调用 Set 函数，Set 函数有如下几种：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// SetInt64 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) SetInt64(x int64) *Int {</span><br><span class="line">    neg := false</span><br><span class="line">    if x &lt; 0 {</span><br><span class="line">        neg = true</span><br><span class="line">        x = -x</span><br><span class="line">    }</span><br><span class="line">    z.abs = z.abs.setUint64(uint64(x))</span><br><span class="line">    z.neg = neg</span><br><span class="line">    return z</span><br><span class="line">}</span><br><span class="line">​</span><br><span class="line">// SetUint64 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) SetUint64(x uint64) *Int {</span><br><span class="line">    z.abs = z.abs.setUint64(x)</span><br><span class="line">    z.neg = false</span><br><span class="line">    return z</span><br><span class="line">}</span><br><span class="line">​</span><br><span class="line">// Set 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) Set(x *Int) *Int {</span><br><span class="line">    if z != x {</span><br><span class="line">        z.abs = z.abs.set(x.abs)</span><br><span class="line">        z.neg = x.neg</span><br><span class="line">    }</span><br><span class="line">    return z</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    big1 := new(big.Int).SetUint64(uint64(1000))</span><br><span class="line">    fmt.Println("big1 is: ", big1)</span><br><span class="line"></span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println("big2 is: ", big2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">big1 is:  1000</span><br><span class="line">big2 is:  1000</span><br></pre></td></tr></tbody></table></figure>
<p>除了上述的 Set 函数，<code>math/big</code> 包中还提供了一个 SetString() 函数，可以指定进制数，比如二进制、十进制或者十六进制等！</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// SetString sets z to the value of s, interpreted in the given base,</span><br><span class="line">// and returns z and a boolean indicating success. The entire string</span><br><span class="line">// (not just a prefix) must be valid for success. If SetString fails,</span><br><span class="line">// the value of z is undefined but the returned value is nil.</span><br><span class="line">//</span><br><span class="line">// The base argument must be 0 or a value between 2 and MaxBase. If the base</span><br><span class="line">// is 0, the string prefix determines the actual conversion base. A prefix of</span><br><span class="line">// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a</span><br><span class="line">// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.</span><br><span class="line">//</span><br><span class="line">func (z *Int) SetString(s string, base int) (*Int, bool) {</span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    if _, _, err := z.scan(r, base); err != nil {</span><br><span class="line">        return nil, false</span><br><span class="line">    }</span><br><span class="line">    // entire string must have been consumed</span><br><span class="line">    if _, err := r.ReadByte(); err != io.EOF {</span><br><span class="line">        return nil, false</span><br><span class="line">    }</span><br><span class="line">    return z, true // err == io.EOF =&gt; scan consumed all of s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    big1, _ := new(big.Int).SetString("1000", 10)</span><br><span class="line">    fmt.Println("big1 is: ", big1)</span><br><span class="line"></span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println("big2 is: ", big2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">big1 is:  1000</span><br><span class="line">big2 is:  1000</span><br></pre></td></tr></tbody></table></figure>
<p>因为Go语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。</p>
<p>Add 方法的定义如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (z *Int) Add(x, y *Int) *Int</span><br></pre></td></tr></tbody></table></figure>
<p>该方法会将 z 转换为 x + y 并返回 z。</p>
<p>【示例】计算第 1000 位的斐波那契数列</p>
<p>【示例】计算第 1000 位的斐波那契数列。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const LIM = 1000 //求第1000位的斐波那契数列</span><br><span class="line"></span><br><span class="line">var fibs [LIM]*big.Int //使用数组保存计算出来的数列的指针</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result := big.NewInt(0)</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 0; i &lt; LIM; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i+1, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("执行完成，所耗时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func fibonacci(n int) (res *big.Int) {</span><br><span class="line">    if n &lt;= 1 {</span><br><span class="line">        res = big.NewInt(1)</span><br><span class="line">    } else {</span><br><span class="line">        temp := new(big.Int)</span><br><span class="line">        res = temp.Add(fibs[n-1], fibs[n-2])</span><br><span class="line">    }</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">...</span><br><span class="line">数列第 997 位: 10261062362033262336604926729245222132668558120602124277764622905699407982546711488272859468887457959087733119242564077850743657661180827326798539177758919828135114407499369796465649524266755391104990099120377</span><br><span class="line">数列第 998 位: 16602747662452097049541800472897701834948051198384828062358553091918573717701170201065510185595898605104094736918879278462233015981029522997836311232618760539199036765399799926731433239718860373345088375054249</span><br><span class="line">数列第 999 位: 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564191827856161443356312976673642210350324634850410377680367334151172899169723197082763985615764450078474174626</span><br><span class="line">数列第 1000 位: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</span><br><span class="line">执行完成，所耗时间为: 6.945ms</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用图像包制作GIF动画"><a href="#使用图像包制作GIF动画" class="headerlink" title="使用图像包制作GIF动画"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4785.html">使用图像包制作GIF动画</a></h2><p>本节将通过示例来介绍一下Go语言标准库中图像包的使用，并使用这些图像包来创建一系列的位图图像，然后将位图序列编码为 GIF 动画。</p>
<p>下面的图像叫作利萨茹图形，它类似于 20 世纪 60 年代科幻片中出现的一种纤维状视觉效果，利萨茹图形是由在互相垂直的方向上的两个频率成简单整数比的简谐振动所合成的规则的、稳定的曲线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/lisharugif.gif" alt="图：四种利萨茹图形"></p>
<p>上图中所示的图像看似复杂，利用Go语言标准库中的图像包可以很轻松的实现，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/gif"</span><br><span class="line">    "io"</span><br><span class="line">    "math"</span><br><span class="line">    "math/rand"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var palette = []color.Color{color.White, color.Black} //调色板</span><br><span class="line">const (</span><br><span class="line">    whiteIndex = 0</span><br><span class="line">    blackIndex = 1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">    lissajous(os.Stdout)</span><br><span class="line">}</span><br><span class="line">func lissajous(out io.Writer) {</span><br><span class="line">    const (</span><br><span class="line">        cycles  = 5     //完整的x振荡器变化的个数</span><br><span class="line">        res     = 0.001 //角度分辨率</span><br><span class="line">        size    = 100   //图像画布包含[-size. .+size]</span><br><span class="line">        nframes = 64    //动画中的帧数</span><br><span class="line">        delay   = 8     //以10ms为单位的帧间延迟</span><br><span class="line">    )</span><br><span class="line">    freq := rand.Float64() * 3.0 //y 振荡器的相对频率</span><br><span class="line">    anim := gif.GIF{LoopCount: nframes}</span><br><span class="line">    phase := 0.0</span><br><span class="line">    for i := 0; i &lt; nframes; i++ {</span><br><span class="line">        rect := image.Rect(0, 0, 2*size+1, 2*size+1)</span><br><span class="line">        img := image.NewPaletted(rect, palette)</span><br><span class="line">        for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">            x := math.Sin(t)</span><br><span class="line">            y := math.Sin(t*freq + phase)</span><br><span class="line">            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)</span><br><span class="line">        }</span><br><span class="line">        phase += 0.1</span><br><span class="line">        anim.Delay = append(anim.Delay, delay)</span><br><span class="line">        anim.Image = append(anim.Image, img)</span><br><span class="line">    }</span><br><span class="line">    gif.EncodeAll(out, &amp;anim)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，lissajous 函数内部包含两层嵌套的 for 循环，外层循环会循环 64 次，每一次都会生成一个单独的动画帧，即生成一个只有黑色和白色，且大小为 201*201 的图片。</p>
<p>而 lissajous 函数的内层循环则设置了两个偏振值 x 和 y，x 轴偏振使用 sin 函数，y 轴偏振也是正弦波，但其相对 x 轴的偏振是一个 0~3 的随机值。初始偏振值是一个零值，随着动画的每一帧逐渐增加，循环会一直跑到 x 轴完成五次完整的循环，每一步它都会调用 SetColorIndex 来把 (x, y) 点来染成黑色。</p>
<p>想要成功的生成 gif 图像需要我们先使用go build 命令将代码编译为可执行文件，然后在 CMD（命令行工具）中运行所生成的可执行文件，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">main.exe &gt;1.gif</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>&gt;</code> 在这里用来指定生成图像的文件名，<code>1.gif</code> 为文件名。</p>
<p>执行成功后就可以在当前目录下找到生成的 gif 文件了，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/lisharu.gif" alt="图：利萨如图形"></p>
<h2 id="正则表达式：regexp包"><a href="#正则表达式：regexp包" class="headerlink" title="正则表达式：regexp包"></a>正则表达式：regexp包</h2><p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活，按照它的语法规则，根据需求构造出的正则表达式能够从原始文本中筛选出几乎任何你想要得到的字符组合。</p>
<p>Go语言通过 regexp 包为正则表达式提供了官方支持，其采用 RE2 语法，除了 <code>\c</code> 、<code>\C</code> 外，Go语言和 Perl、Python 等语言的正则基本一致。</p>
<h3 id="正则表达式语法规则"><a href="#正则表达式语法规则" class="headerlink" title="正则表达式语法规则"></a>正则表达式语法规则</h3><p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）构成的文字序列，可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>下面的表格中列举了构成正则表达式的一些语法规则及其含义。</p>
<p><strong>1) 字符</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>一般字符</td><td>匹配自身</td><td>abc</td><td>abc</td></tr>
    <tr><td>.</td><td>匹配任意除换行符"\n"外的字符，在 DOTALL 模式中也能匹配换行符</td><td>a.c</td><td>abc</td></tr>
    <tr><td>\</td><td>转义字符，使后一个字符改变原来的意思；<br>如果字符串中有字符 * 需要匹配，可以使用 \* 或者字符集［*]。</td><td>a\.c<br>a\\c</td><td>a.c<br>a\c</td></tr>
    <tr><td>[...]</td><td>字符集（字符类），对应的位置可以是字符集中任意字符。<br>字符集中的字符可以逐个列出，也可以给出范围，如 [abc] 或 [a-c]，<br>第一个字符如果是 ^ 则表示取反，如 [^abc] 表示除了abc之外的其他字符。</td><td>a[bcd]e</td><td>abe 或 ace 或 ade</td></tr>
    <tr><td>\d</td><td>数字：[0-9]</td><td>a\dc</td><td>a1c</td></tr>
    <tr><td>\D</td><td>非数字：[^\d]</td><td>a\Dc</td><td>abc</td></tr>
    <tr><td>\s</td><td>空白字符：[&lt;空格&gt;\t\r\n\f\v]</td><td>a\sc</td><td>a c</td></tr>
    <tr><td>\S</td><td>非空白字符：[^\s]</td><td>a\Sc</td><td>abc</td></tr>
    <tr><td>\w</td><td>单词字符：[A-Za-z0-9]</td><td>a\wc</td><td>abc</td></tr>
    <tr><td>\W</td><td>非单词字符：[^\w]</td><td>a\Wc</td><td>a c</td></tr>
  </tbody>
</table>

<p><strong>2) 数量词（用在字符或 (…) 之后）</strong></p>
<table>  
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>*</td><td>匹配前一个字符0或无限次</td><td>abc*</td><td>ab或abccc</td></tr>
    <tr><td>+</td><td>匹配前一个字符1次或无限次</td><td>abc+</td><td>abc或abccc</td></tr>
    <tr><td>?</td><td>匹配前一个字符0次或1次</td><td>abc?</td><td>ab或abc</td></tr>
    <tr><td>{m}</td><td>匹配前一个字符m次</td><td>ab{2}c</td><td>abbc</td></tr>
    <tr><td>{m,n}</td><td>匹配前一个字符m至n次，m和n可以省略，若省略m，则匹配0至n次；<br>若省略n，则匹配m至无限次</td><td>ab{1,2}c</td><td>abc或abbc</td></tr>
  </tbody>
</table>

<p><strong>3) 边界匹配</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>^</td><td>匹配字符串开头，在多行模式中匹配每一行的开头</td><td>^abc</td><td>abc</td></tr>
    <tr><td>$</td><td>匹配字符串末尾，在多行模式中匹配每一行的末尾</td><td>abc$</td><td>abc</td></tr>
    <tr><td>\A</td><td>仅匹配字符串开头</td><td>\Aabc</td><td>abc</td></tr>
    <tr><td>\Z</td><td>仅匹配字符串末尾</td><td>abc\Z</td><td>abc</td></tr>
    <tr><td>\b</td><td>匹配\w和\W之间</td><td>a\b!bc</td><td>a!bc</td></tr>
    <tr><td>\B</td><td>[^\b]</td><td>a\Bbc</td><td>abc</td></tr>
  </tbody>
</table>

<p><strong>4) 逻辑、分组</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>|</td><td>|代表左右表达式任意匹配一个，优先匹配左边的表达式</td><td>abc|def</td><td>abc或def</td></tr>
    <tr><td>(...)</td><td>括起来的表达式将作为分组，分组将作为一个整体，可以后接数量词</td><td>(abc){2}</td><td>abcabc</td></tr>
    <tr><td>(?P&lt;name&gt;...)</td><td>分组，功能与(...)相同，但会指定一个额外的别名</td><td>(?P&lt;id&gt;abc){2}</td><td>abcabc</td></tr>
    <tr><td>\&lt;number&gt;</td><td>引用编号为&lt;number&gt;的分组匹配到的字符串</td><td>(\d)abc\1</td><td>1abe1或5abc5</td></tr>
    <tr><td>(?P=name)</td><td>引用别名为&lt;name&gt;的分组匹配到的字符串</td><td>(?P&lt;id&gt;\d)abc(?P=id)</td><td>1abe1或&nbsp;5abc5</td></tr>
  </tbody>
</table>

<p><strong>5) 特殊构造（不作为分组）</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>(?:...)</td><td>(…)的不分组版本，用于使用"|"或后接数量词</td><td>(?:abc){2}</td><td>abcabc</td></tr>
    <tr><td>(?iLmsux)</td><td>iLmsux中的每个字符代表一种匹配模式，只能用在正则表达式的开头，可选多个</td><td>(?i)abc</td><td>AbC</td></tr>
    <tr><td>(?#...)</td><td>#后的内容将作为注释被忽略。</td><td>abc(?#comment)123&nbsp;</td><td>abc123</td></tr>
    <tr><td>(?=...)</td><td>之后的字符串内容需要匹配表达式才能成功匹配</td><td>a(?=\d)</td><td>后面是数字的a</td></tr>
    <tr><td>(?!...)</td><td>之后的字符串内容需要不匹配表达式才能成功匹配</td><td>a(?!\d)</td><td>后面不是数字的a</td></tr>
    <tr><td>(?&lt;=...)</td><td>之前的字符串内容需要匹配表达式才能成功匹配</td><td>(?&lt;=\d)a</td><td>前面是数字的a</td></tr>
    <tr><td>(?&lt;!...)</td><td>之前的字符串内容需要不匹配表达式才能成功匹配</td><td>(?&lt;!\d)a</td><td>前面不是数字的a</td></tr>
  </tbody>
</table>

<h3 id="Regexp-包的使用"><a href="#Regexp-包的使用" class="headerlink" title="Regexp 包的使用"></a>Regexp 包的使用</h3><p>下面通过几个示例来演示一下 regexp 包的使用。</p>
<p>【示例 1】匹配指定类型的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a.c`)</span><br><span class="line">    if reg1 == nil {</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">result1 =  [[abc] [azc] [a7c] [aac] [a9c]]　　</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】匹配 a 和 c 中间包含一个数字的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a[0-9]c`)</span><br><span class="line"></span><br><span class="line">    if reg1 == nil { //解释失败，返回nil</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">result1 =  [[a7c] [a9c]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 3】使用 \d 来匹配 a 和 c 中间包含一个数字的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a\dc`)</span><br><span class="line"></span><br><span class="line">    if reg1 == nil { //解释失败，返回nil</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">result1 =  [[a7c] [a9c]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 4】匹配字符串中的小数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "43.14 567 agsdg 1.23 7. 8.9 1sdljgl 6.66 7.8   "</span><br><span class="line"></span><br><span class="line">    //解释正则表达式</span><br><span class="line">    reg := regexp.MustCompile(`\d+\.\d+`)</span><br><span class="line"></span><br><span class="line">    if reg == nil {</span><br><span class="line">        fmt.Println("MustCompile err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //提取关键信息</span><br><span class="line">    //result := reg.FindAllString(buf, -1)</span><br><span class="line">    result := reg.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result = ", result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">result =  [[43.14] [1.23] [8.9] [6.66] [7.8]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 5】匹配 div 标签中的内容。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 原生字符串</span><br><span class="line">    buf := `</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-CN"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;C语言中文网 | Go语言入门教程&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;Go语言简介&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言基本语法</span><br><span class="line">    Go语言变量的声明</span><br><span class="line">    Go语言教程简明版</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言容器&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言函数&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">    `</span><br><span class="line"></span><br><span class="line">    //解释正则表达式</span><br><span class="line">    reg := regexp.MustCompile(`&lt;div&gt;(?s:(.*?))&lt;/div&gt;`)</span><br><span class="line">    if reg == nil {</span><br><span class="line">        fmt.Println("MustCompile err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //提取关键信息</span><br><span class="line">    result := reg.FindAllStringSubmatch(buf, -1)</span><br><span class="line"></span><br><span class="line">    //过滤&lt;&gt;&lt;/&gt;</span><br><span class="line">    for _, text := range result {</span><br><span class="line">        fmt.Println("text[1] = ", text[1])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">text[1] =  Go语言简介</span><br><span class="line">text[1] =  Go语言基本语法</span><br><span class="line">    Go语言变量的声明</span><br><span class="line">    Go语言教程简明版</span><br><span class="line"></span><br><span class="line">text[1] =  Go语言容器</span><br><span class="line">text[1] =  Go语言函数</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 6】通过 Compile 方法返回一个 Regexp 对象，实现匹配，查找，替换相关的功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //目标字符串</span><br><span class="line">    searchIn := "John: 2578.34 William: 4567.23 Steve: 5632.18"</span><br><span class="line">    pat := "[0-9]+.[0-9]+"          //正则</span><br><span class="line"></span><br><span class="line">    f := func(s string) string{</span><br><span class="line">        v, _ := strconv.ParseFloat(s, 32)</span><br><span class="line">        return strconv.FormatFloat(v * 2, 'f', 2, 32)</span><br><span class="line">    }</span><br><span class="line">    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok {</span><br><span class="line">        fmt.Println("Match Found!")</span><br><span class="line">    }</span><br><span class="line">    re, _ := regexp.Compile(pat)</span><br><span class="line">    //将匹配到的部分替换为 "##.#"</span><br><span class="line">    str := re.ReplaceAllString(searchIn, "##.#")</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">    //参数为函数时</span><br><span class="line">    str2 := re.ReplaceAllStringFunc(searchIn, f)</span><br><span class="line">    fmt.Println(str2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Match Found!</span><br><span class="line">John: ##.# William: ##.# Steve: ##.#</span><br><span class="line">John: 5156.68 William: 9134.46 Steve: 11264.36</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中 Compile 方法可以解析并返回一个正则表达式，如果成功返回，则说明该正则表达式正确可用于匹配文本。</p>
<p>另外我们也可以使用 MustCompile 方法，它也可以像 Compile 方法一样检验正则的有效性，但是当正则不合法时程序将 panic。</p>
<h2 id="time包：时间和日期"><a href="#time包：时间和日期" class="headerlink" title="time包：时间和日期"></a>time包：时间和日期</h2><p>时间和日期是我们开发中经常会用到的，Go语言中的 time 包提供了时间显示和测量等所用的函数，本节我们就来介绍一下 time 包的基本用法。</p>
<h3 id="time-包简介"><a href="#time-包简介" class="headerlink" title="time 包简介"></a>time 包简介</h3><p>时间一般包含时间值和时区，可以从Go语言中 time 包的源码中看出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ype Time struct {</span><br><span class="line">    // wall and ext encode the wall time seconds, wall time nanoseconds,</span><br><span class="line">    // and optional monotonic clock reading in nanoseconds.</span><br><span class="line">    //</span><br><span class="line">    // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</span><br><span class="line">    // a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</span><br><span class="line">    // The nanoseconds field is in the range [0, 999999999].</span><br><span class="line">    // If the hasMonotonic bit is 0, then the 33-bit field must be zero</span><br><span class="line">    // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</span><br><span class="line">    // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</span><br><span class="line">    // unsigned wall seconds since Jan 1 year 1885, and ext holds a</span><br><span class="line">    // signed 64-bit monotonic clock reading, nanoseconds since process start.</span><br><span class="line">    wall uint64</span><br><span class="line">    ext  int64</span><br><span class="line">    // loc specifies the Location that should be used to</span><br><span class="line">    // determine the minute, hour, month, day, and year</span><br><span class="line">    // that correspond to this Time.</span><br><span class="line">    // The nil location means UTC.</span><br><span class="line">    // All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span><br><span class="line">    loc *Location</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中：</p>
<ul>
<li>wall：表示距离公元 1 年 1 月 1 日 00:00:00UTC 的秒数；</li>
<li>ext：表示纳秒；</li>
<li>loc：代表时区，主要处理偏移量，不同的时区，对应的时间不一样。</li>
</ul>
<p><strong>如何正确表示时间呢？</strong></p>
<p>公认最准确的计算应该是使用“原子震荡周期”所计算的物理时钟了（Atomic Clock, 也被称为原子钟），这也被定义为标准时间（International Atomic Time）。</p>
<p>而我们常常看见的 UTC（Universal Time Coordinated，世界协调时间）就是利用这种 Atomic Clock 为基准所定义出来的正确时间。UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UTC + 时区差 ＝ 本地时间</span><br></pre></td></tr></tbody></table></figure>
<p>国内一般使用的是北京时间，与 UTC 的时间关系如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">UTC + 8 个小时 = 北京时间</span><br></pre></td></tr></tbody></table></figure>
<p>在Go语言的 time 包里面有两个时区变量，如下：</p>
<ul>
<li>time.UTC：UTC 时间</li>
<li>time.Local：本地时间</li>
</ul>
<p>同时，Go语言还提供了 LoadLocation 方法和 FixedZone 方法来获取时区变量，如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FixedZone(name string, offset int) *Location</span><br></pre></td></tr></tbody></table></figure>
<p>其中，name 为时区名称，offset 是与 UTC 之前的时差。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">LoadLocation(name string) (*Location, error)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间的获取"><a href="#时间的获取" class="headerlink" title="时间的获取"></a>时间的获取</h3><p><strong>1) 获取当前时间</strong></p>
<p>我们可以通过 time.Now() 函数来获取当前的时间对象，然后通过事件对象来获取当前的时间信息。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now() //获取当前时间</span><br><span class="line">    fmt.Printf("current time:%v\n", now)</span><br><span class="line">    year := now.Year()     //年</span><br><span class="line">    month := now.Month()   //月</span><br><span class="line">    day := now.Day()       //日</span><br><span class="line">    hour := now.Hour()     //小时</span><br><span class="line">    minute := now.Minute() //分钟</span><br><span class="line">    second := now.Second() //秒</span><br><span class="line">    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">current time:2020-10-23 16:30:41.4278273 +0800 CST m=+0.008019701</span><br><span class="line">2020-10-23 16:30:41</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 获取时间戳</strong></p>
<p>时间戳是自 <code>1970 年 1 月 1 日（08:00:00GMT）</code> 至当前时间的总毫秒数，它也被称为 Unix 时间戳（UnixTimestamp）。</p>
<p>基于时间对象获取时间戳的示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()            //获取当前时间</span><br><span class="line">    timestamp1 := now.Unix()     //时间戳</span><br><span class="line">    timestamp2 := now.UnixNano() //纳秒时间戳</span><br><span class="line">    fmt.Printf("现在的时间戳：%v\n", timestamp1)</span><br><span class="line">    fmt.Printf("现在的纳秒时间戳：%v\n", timestamp2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">现在的时间戳：1603441948</span><br><span class="line">现在的纳秒时间戳：1603441948527541800</span><br></pre></td></tr></tbody></table></figure>
<p>使用 time.Unix() 函数可以将时间戳转为时间格式，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()                  //获取当前时间</span><br><span class="line">    timestamp := now.Unix()            //时间戳</span><br><span class="line">    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式</span><br><span class="line">    fmt.Println(timeObj)</span><br><span class="line">    year := timeObj.Year()     //年</span><br><span class="line">    month := timeObj.Month()   //月</span><br><span class="line">    day := timeObj.Day()       //日</span><br><span class="line">    hour := timeObj.Hour()     //小时</span><br><span class="line">    minute := timeObj.Minute() //分钟</span><br><span class="line">    second := timeObj.Second() //秒</span><br><span class="line">    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020-10-23 16:35:53 +0800 CST</span><br><span class="line">2020-10-23 16:35:53</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 获取当前是星期几</strong></p>
<p>time 包中的 Weekday 函数能够返回某个时间点所对应是一周中的周几，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //时间戳</span><br><span class="line">    t := time.Now()</span><br><span class="line">    fmt.Println(t.Weekday().String())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Friday</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间操作函数"><a href="#时间操作函数" class="headerlink" title="时间操作函数"></a>时间操作函数</h3><p><strong>1) Add</strong></p>
<p>我们在日常的开发过程中可能会遇到要求某个时间 + 时间间隔之类的需求，Go语言中的 Add 方法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (t Time) Add(d Duration) Time</span><br></pre></td></tr></tbody></table></figure>
<p>Add 函数可以返回时间点 t + 时间间隔 d 的值。</p>
<p>【示例】求一个小时之后的时间：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()</span><br><span class="line">    later := now.Add(time.Hour) // 当前时间加1小时后的时间</span><br><span class="line">    fmt.Println(later)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020-10-23 17:39:37.5959762 +0800 CST m=+3600.007976201</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) Sub</strong></p>
<p>求两个时间之间的差值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (t Time) Sub(u Time) Duration</span><br></pre></td></tr></tbody></table></figure>
<p>返回一个时间段 t - u 的值。如果结果超出了 Duration 可以表示的最大值或最小值，将返回最大值或最小值，要获取时间点 t - d（d 为 Duration），可以使用 t.Add(-d)。</p>
<p><strong>3) Equal</strong></p>
<p>判断两个时间是否相同：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (t Time) Equal(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>Equal 函数会考虑时区的影响，因此不同时区标准的时间也可以正确比较，Equal 方法和用 t==u 不同，Equal 方法还会比较地点和时区信息。</p>
<p><strong>4) Before</strong></p>
<p>判断一个时间点是否在另一个时间点之前：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (t Time) Before(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>如果 t 代表的时间点在 u 之前，则返回真，否则返回假。</p>
<p><strong>5) After</strong></p>
<p>判断一个时间点是否在另一个时间点之后：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (t Time) After(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>如果 t 代表的时间点在 u 之后，则返回真，否则返回假。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>使用 time.Tick(时间间隔) 可以设置定时器，定时器的本质上是一个通道（channel），示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器</span><br><span class="line">    for i := range ticker {</span><br><span class="line">        fmt.Println(i) //每秒都会执行的任务</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020-10-23 16:45:40.0277348 +0800 CST m=+1.037966301</span><br><span class="line">2020-10-23 16:45:41.0269758 +0800 CST m=+2.037200801</span><br><span class="line">2020-10-23 16:45:42.0281504 +0800 CST m=+3.038368801</span><br><span class="line">2020-10-23 16:45:43.0272063 +0800 CST m=+4.037418201</span><br><span class="line">2020-10-23 16:45:44.0275883 +0800 CST m=+5.037793601</span><br><span class="line">2020-10-23 16:45:45.0271711 +0800 CST m=+6.037369801</span><br><span class="line">2020-10-23 16:45:46.027105 +0800 CST m=+7.037297201</span><br><span class="line">2020-10-23 16:45:47.0268987 +0800 CST m=+8.037084301</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>时间类型有一个自带的 Format 方法进行格式化，需要注意的是Go语言中格式化时间模板不是常见的 <code>Y-m-d H:M:S</code> 而是使用Go语言的诞生时间 <code>2006 年 1 月 2 号 15 点 04 分 05 秒</code> 。</p>
<p><strong><em>提示：如果想将时间格式化为 12 小时格式，需指定 PM。</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()</span><br><span class="line">    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span><br><span class="line">    // 24小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))</span><br><span class="line">    // 12小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02 15:04"))</span><br><span class="line">    fmt.Println(now.Format("15:04 2006/01/02"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020-10-23 16:49:07.304 Fri Oct</span><br><span class="line">2020-10-23 04:49:07.304 PM Fri Oct</span><br><span class="line">2020/10/23 16:49</span><br><span class="line">16:49 2020/10/23</span><br><span class="line">2020/10/23</span><br></pre></td></tr></tbody></table></figure>
<h3 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h3><p>Parse 函数可以解析一个格式化的时间字符串并返回它代表的时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Parse(layout, value string) (Time, error)</span><br></pre></td></tr></tbody></table></figure>
<p>与 Parse 函数类似的还有 ParseInLocation 函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseInLocation(layout, value string, loc *Location) (Time, error)</span><br></pre></td></tr></tbody></table></figure>
<p>ParseInLocation 与 Parse 函数类似，但有两个重要的不同之处：</p>
<ul>
<li>第一，当缺少时区信息时，Parse 将时间解释为 UTC 时间，而 ParseInLocation 将返回值的 Location 设置为 loc；</li>
<li>第二，当时间字符串提供了时区偏移量信息时，Parse 会尝试去匹配本地时区，而 ParseInLocation 会去匹配 loc。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var layout string = "2006-01-02 15:04:05"</span><br><span class="line">    var timeStr string = "2020-10-23 16:52:12"</span><br><span class="line"></span><br><span class="line">    timeObj1, _ := time.Parse(layout, timeStr)</span><br><span class="line">    fmt.Println(timeObj1)</span><br><span class="line"></span><br><span class="line">    timeObj2, _ := time.ParseInLocation(layout, timeStr, time.Local)</span><br><span class="line">    fmt.Println(timeObj2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020-10-23 16:52:12 +0000 UTC</span><br><span class="line">2020-10-23 16:52:12 +0800 CST</span><br></pre></td></tr></tbody></table></figure>
<h2 id="os包用法简述"><a href="#os包用法简述" class="headerlink" title="os包用法简述"></a>os包用法简述</h2><p>Go语言的 os 包中提供了操作系统函数的接口，是一个比较重要的包。顾名思义，os 包的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。</p>
<h3 id="os-包中的常用函数"><a href="#os-包中的常用函数" class="headerlink" title="os 包中的常用函数"></a>os 包中的常用函数</h3><p><strong>1) Hostname</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>Hostname 函数会返回内核提供的主机名。</p>
<p><strong>2) Environ</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) Getenv</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></tbody></table></figure>
<p>Getenv 函数会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。</p>
<p><strong>4) Setenv</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></tbody></table></figure>
<p>Setenv 函数可以设置名为 key 的环境变量，如果出错会返回该错误。</p>
<p><strong>5) Exit</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></tbody></table></figure>
<p>Exit 函数可以让当前程序以给出的状态码 code 退出。一般来说，状态码 0 表示成功，非 0 表示出错。程序会立刻终止，并且 defer 的函数不会被执行。</p>
<p><strong>6) Getuid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getuid 函数可以返回调用者的用户 ID。</p>
<p><strong>7) Getgid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getgid 函数可以返回调用者的组 ID。</p>
<p><strong>8) Getpid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getpid 函数可以返回调用者所在进程的进程 ID。</p>
<p><strong>9) Getwd</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Getwd() (dir string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>Getwd 函数可以返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd 会返回其中一个。</p>
<p><strong>10) Mkdir</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Mkdir(name string, perm FileMode) error</span><br></pre></td></tr></tbody></table></figure>
<p>Mkdir 函数可以使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 底层类型的错误。</p>
<p><strong>11) MkdirAll</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func MkdirAll(path string, perm FileMode) error</span><br></pre></td></tr></tbody></table></figure>
<p>MkdirAll 函数可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。权限位 perm 会应用在每一个被该函数创建的目录上。如果 path 指定了一个已经存在的目录，MkdirAll 不做任何操作并返回 nil。</p>
<p><strong>12) Remove</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Remove(name string) error</span><br></pre></td></tr></tbody></table></figure>
<p>Remove 函数会删除 name 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 底层类型的错误。</p>
<p>RemoveAll 函数跟 Remove 用法一样，区别是会递归的删除所有子目录和文件。</p>
<p>在 os 包下，有 exec，signal，user 三个子包，下面来分别介绍一下。</p>
<h3 id="os-exec-执行外部命令"><a href="#os-exec-执行外部命令" class="headerlink" title="os/exec 执行外部命令"></a>os/exec 执行外部命令</h3><p>exec 包可以执行外部命令，它包装了 os.StartProcess 函数以便更容易的修正输入和输出，使用管道连接 I/O，以及作其它的一些调整。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func LookPath(file string) (string, error)</span><br></pre></td></tr></tbody></table></figure>
<p>在环境变量 PATH 指定的目录中搜索可执行文件，如果 file 中有斜杠，则只在当前目录搜索。返回完整路径或者相对于当前目录的一个相对路径。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os/exec"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := exec.LookPath("main")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main.exe</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os-user-获取当前用户信息"><a href="#os-user-获取当前用户信息" class="headerlink" title="os/user 获取当前用户信息"></a>os/user 获取当前用户信息</h3><p>可以通过 os/user 包中的 Current() 函数来获取当前用户信息，该函数会返回一个 User 结构体，结构体中的 Username、Uid、HomeDir、Gid 分别表示当前用户的名称、用户 id、用户主目录和用户所属组 id，函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Current() (*User, error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "os/user"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    u, _ := user.Current()</span><br><span class="line">    log.Println("用户名：", u.Username)</span><br><span class="line">    log.Println("用户id", u.Uid)</span><br><span class="line">    log.Println("用户主目录：", u.HomeDir)</span><br><span class="line">    log.Println("主组id：", u.Gid)</span><br><span class="line"></span><br><span class="line">    // 用户所在的所有的组的id</span><br><span class="line">    s, _ := u.GroupIds()</span><br><span class="line">    log.Println("用户所在的所有组：", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2020/10/23 17:10:55 用户名： TCENT\dqc13215</span><br><span class="line">2020/10/23 17:10:55 用户id S-1-5-21-1244066353-432844205-2039415564-35519</span><br><span class="line">2020/10/23 17:10:55 用户主目录： D:\MyConfiguration\dqc13215</span><br><span class="line">2020/10/23 17:10:55 主组id： S-1-5-21-1244066353-432844205-2039415564-513</span><br><span class="line">2020/10/23 17:10:55 用户所在的所有组： [S-1-5-32-544 S-1-5-32-545 S-1-5-21-1244066353-432844205-2039415564-513]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os-signal-信号处理"><a href="#os-signal-信号处理" class="headerlink" title="os/signal 信号处理"></a>os/signal 信号处理</h3><p>一个运行良好的程序在退出（正常退出或者强制退出，如 Ctrl+C，kill 等）时是可以执行一段清理代码的，将收尾工作做完后再真正退出。一般采用系统 Signal 来通知系统退出，如 kill pid，在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。</p>
<p>Go语言中对信号的处理主要使用 os/signal 包中的两个方法，一个是 Notify 方法用来监听收到的信号，一个是 stop 方法用来取消监听。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，第一个参数表示接收信号的 channel，第二个及后面的参数表示设置要监听的信号，如果不设置表示监听所有的信号。</p>
<p>【示例 1】使用 Notify 方法来监听收到的信号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "os/signal"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := make(chan os.Signal, 0)</span><br><span class="line">    signal.Notify(c)</span><br><span class="line">  </span><br><span class="line">    // Block until a signal is received.</span><br><span class="line">    s := &lt;-c</span><br><span class="line">    fmt.Println("Got signal:", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行该程序，然后在 CMD 窗口中通过 Ctrl+C 来结束该程序，便会得到输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Got signal: interrupt</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】使用 stop 方法来取消监听：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "os/signal"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := make(chan os.Signal, 0)</span><br><span class="line">    signal.Notify(c)</span><br><span class="line"></span><br><span class="line">    signal.Stop(c) //不允许继续往c中存入内容</span><br><span class="line">    s := &lt;-c       //c无内容，此处阻塞，所以不会执行下面的语句，也就没有输出</span><br><span class="line">    fmt.Println("Got signal:", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为使用 Stop 方法取消了 Notify 方法的监听，所以运行程序没有输出结果。</p>
<h2 id="flag包：命令行参数解析"><a href="#flag包：命令行参数解析" class="headerlink" title="flag包：命令行参数解析"></a>flag包：命令行参数解析</h2><p>在编写命令行程序（工具、server）时，我们有时需要对命令参数进行解析，各种编程语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。在Go语言中的 flag 包中，提供了命令行参数解析的功能。</p>
<p>下面我们就来看一下 flag 包可以做什么，它具有什么样的能力。</p>
<p>这里介绍几个概念：</p>
<ul>
<li>命令行参数（或参数）：是指运行程序时提供的参数；</li>
<li>已定义命令行参数：是指程序中通过 flag.Type 这种形式定义了的参数；</li>
<li>非 flag（non-flag）命令行参数（或保留的命令行参数）：可以简单理解为 flag 包不能解析的参数。</li>
</ul>
<h3 id="flag-包概述"><a href="#flag-包概述" class="headerlink" title="flag 包概述"></a>flag 包概述</h3><p>Go语言内置的 flag 包实现了命令行参数的解析，flag 包使得开发命令行工具更为简单。若要使用 flag 包，首先需要使用 import 关键字导入 flag 包，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "flag"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="flag-参数类型"><a href="#flag-参数类型" class="headerlink" title="flag 参数类型"></a>flag 参数类型</h3><p>flag 包支持的命令行参数类型有 bool、int、int64、uint、uint64、float、float64、string、duration，如下表所示：</p>
<table>
  <thead><tr><th>flag参数</th><th>有效值</th></tr></thead>
  <tbody>
    <tr><td>字符串flag</td><td>合法字符串</td></tr>
    <tr><td>整数flag</td><td>1234、0664、0x1234等类型，也可以是负数</td></tr>
    <tr><td>浮点数flag</td><td>合法浮点数</td></tr>
    <tr><td>bool类型flag</td><td>1、0、t、f、T、F、true、false、TRUE、FALSE、True、False</td></tr>
    <tr><td>时间段flag</td><td>任何合法的时间段字符串，如“300ms”、“-1.5h”、“2h45m”，<br>合法的单位有“ns”、“us”、“µs”、“ms”、“s”、“m”、“h”</td></tr>
  </tbody>
</table>

<h3 id="flag-包基本使用"><a href="#flag-包基本使用" class="headerlink" title="flag 包基本使用"></a>flag 包基本使用</h3><p>有以下两种常用的定义命令行 flag 参数的方法：</p>
<p><strong>1) flag.Type()</strong></p>
<p>基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">flag.Type(flag 名, 默认值, 帮助信息) *Type</span><br></pre></td></tr></tbody></table></figure>
<p>Type 可以是 Int、String、Bool 等，返回值为一个相应类型的指针，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name := flag.String("name", "张三", "姓名")</span><br><span class="line">age := flag.Int("age", 18, "年龄")</span><br><span class="line">married := flag.Bool("married", false, "婚否")</span><br><span class="line">delay := flag.Duration("d", 0, "时间间隔")</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，此时 name、age、married、delay 均为对应类型的指针。</p>
<p><strong>2) flag.TypeVar()</strong></p>
<p>基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">flag.TypeVar(Type 指针, flag 名, 默认值, 帮助信息)</span><br></pre></td></tr></tbody></table></figure>
<p>TypeVar 可以是 IntVar、StringVar、BoolVar 等，其功能为将 flag 绑定到一个变量上，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">var married bool</span><br><span class="line">var delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, "name", "张三", "姓名")</span><br><span class="line">flag.IntVar(&amp;age, "age", 18, "年龄")</span><br><span class="line">flag.BoolVar(&amp;married, "married", false, "婚否")</span><br><span class="line">flag.DurationVar(&amp;delay, "d", 0, "时间间隔")</span><br></pre></td></tr></tbody></table></figure>
<h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h3><p>通过以上两种方法定义好命令行 flag 参数后，需要通过调用 flag.Parse() 来对命令行参数进行解析。</p>
<p>支持的命令行参数格式有以下几种：</p>
<ul>
<li>-flag：只支持 bool 类型；</li>
<li>-flag=x；</li>
<li>-flag x：只支持非 bool 类型。</li>
</ul>
<p>其中，布尔类型的参数必须使用等号的方式指定。</p>
<p>flag 包的其他函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">flag.Args()  //返回命令行参数后的其他参数，以 []string 类型</span><br><span class="line">flag.NArg()  //返回命令行参数后的其他参数个数</span><br><span class="line">flag.NFlag() //返回使用的命令行参数个数</span><br></pre></td></tr></tbody></table></figure>
<p>结合上面的介绍知识，我们来看一个实例，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Input_pstrName = flag.String("name", "gerry", "input ur name")</span><br><span class="line">var Input_piAge = flag.Int("age", 20, "input ur age")</span><br><span class="line">var Input_flagvar int</span><br><span class="line"></span><br><span class="line">func Init() {</span><br><span class="line">    flag.IntVar(&amp;Input_flagvar, "flagname", 1234, "help message for flagname")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    Init()</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // After parsing, the arguments after the flag are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1</span><br><span class="line">    // Args returns the non-flag command-line arguments</span><br><span class="line">    // NArg is the number of arguments remaining after flags have been processed</span><br><span class="line">    fmt.Printf("args=%s, num=%d\n", flag.Args(), flag.NArg())</span><br><span class="line">    for i := 0; i != flag.NArg(); i++ {</span><br><span class="line">        fmt.Printf("arg[%d]=%s\n", i, flag.Arg(i))</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    fmt.Println("name=", *Input_pstrName)</span><br><span class="line">    fmt.Println("age=", *Input_piAge)</span><br><span class="line">    fmt.Println("flagname=", Input_flagvar)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run flagmain.go -name "dqc13215" -age=30 -flagname=999</span><br><span class="line">args=[], num=0</span><br><span class="line">name= dqc13215</span><br><span class="line">age= 30</span><br><span class="line">flagname= 999</span><br></pre></td></tr></tbody></table></figure>
<h3 id="自定义-Value"><a href="#自定义-Value" class="headerlink" title="自定义 Value"></a>自定义 Value</h3><p>另外，我们还可以创建自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针类型），这时候可以通过如下方式定义该 flag：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">flag.Var(&amp;flagVal, "name", "help message for flagname")</span><br></pre></td></tr></tbody></table></figure>
<p>【示例】解析喜欢的编程语言，并直接解析到 slice 中，我们可以定义如下 sliceValue 类型，然后实现 Value 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义一个类型，用于增加该类型方法</span><br><span class="line">type sliceValue []string</span><br><span class="line"></span><br><span class="line">//new一个存放命令行参数值的slice</span><br><span class="line">func newSliceValue(vals []string, p *[]string) *sliceValue {</span><br><span class="line">    *p = vals</span><br><span class="line">    return (*sliceValue)(p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Value接口：</span><br><span class="line">type Value interface {</span><br><span class="line">    String() string</span><br><span class="line">    Set(string) error</span><br><span class="line">}</span><br><span class="line">实现flag包中的Value接口，将命令行接收到的值用,分隔存到slice里</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">func (s *sliceValue) Set(val string) error {</span><br><span class="line">    *s = sliceValue(strings.Split(val, ","))</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//flag为slice的默认值default is me,和return返回值没有关系</span><br><span class="line">func (s *sliceValue) String() string {</span><br><span class="line">    *s = sliceValue(strings.Split("default is me", ","))</span><br><span class="line">    return "It's none of my business"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">可执行文件名 -slice="java,go"  最后将输出[java,go]</span><br><span class="line">可执行文件名 最后将输出[default is me]</span><br><span class="line">*/</span><br><span class="line">func main(){</span><br><span class="line">    var languages []string</span><br><span class="line">    flag.Var(newSliceValue([]string{}, &amp;languages), "slice", "I like programming `languages`")</span><br><span class="line">    flag.Parse()</span><br><span class="line">    //打印结果slice接收到的值</span><br><span class="line">    fmt.Println(languages)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>-slice go,php</code> 这样的形式传递参数，languages 得到的就是 <code>[go, php]</code>，如果不加 <code>-slice</code> 参数则打印默认值 <code>[default is me]</code> ，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go -slice go,php,java</span><br><span class="line">[go php java]</span><br></pre></td></tr></tbody></table></figure>
<p>flag 中对 Duration 这种非基本类型的支持，使用的就是类似这样的方式，即同样实现了 Value 接口。</p>
<h2 id="go-mod包依赖管理工具使用详解"><a href="#go-mod包依赖管理工具使用详解" class="headerlink" title="go mod包依赖管理工具使用详解"></a>go mod包依赖管理工具使用详解</h2><p>最早的时候，Go语言所依赖的所有的第三方库都放在 GOPATH 这个目录下面，这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p>
<p>go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。</p>
<p>Modules 官方定义为：</p>
<p><strong>Modules 是相关 Go 包的集合，是源代码交换和版本控制的单元。Go语言命令直接支持使用 Modules，包括记录和解析对其他模块的依赖性，Modules 替换旧的基于 GOPATH 的方法，来指定使用哪些源文件。</strong></p>
<h3 id="如何使用-Modules"><a href="#如何使用-Modules" class="headerlink" title="如何使用 Modules"></a>如何使用 Modules</h3><p>1) 首先需要把 golang 升级到 1.11 版本以上。<br>2) 设置 GO111MODULE。</p>
<h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。</p>
<ul>
<li>GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包；</li>
<li>GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod下载依赖；</li>
<li>GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。</li>
</ul>
<p>Windows 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set GO111MODULE=on 或者 set GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或者 Linux 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GO111MODULE=on 或者 export GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>常用的go mod命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>    
    <tr><td>go mod download</td><td>下载依赖包到本地（默认为GOPATH/pkg/mod目录）</td></tr>
    <tr><td>go mod edit</td><td>编辑go.mod文件</td></tr>
    <tr><td>go mod graph</td><td>打印模块依赖图</td></tr>
    <tr><td>go mod init</td><td>初始化当前文件夹，创建go.mod文件</td></tr>
    <tr><td>go mod tidy</td><td>增加缺少的包，删除无用的包</td></tr>
    <tr><td>go mod vendor</td><td>将依赖复制到vendor目录下</td></tr>
    <tr><td>go mod verify</td><td>校验依赖</td></tr>
    <tr><td>go mod why</td><td>解释为什么需要依赖</td></tr>
  </tbody>
</table>

<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过go get命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。</p>
<p>目前公开的代理服务器的地址有：</p>
<ul>
<li>goproxy.io；</li>
<li>goproxy.cn：（推荐）由国内的七牛云提供。</li>
</ul>
<p>Windows 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或 Linux 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言在 1.13 版本之后 GOPROXY 默认值为 <a target="_blank" rel="noopener" href="https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将">https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将</a> GOPROXY 设置为国内的 goproxy.cn。</p>
<p><strong>使用go get命令下载指定版本的依赖包</strong></p>
<ul>
<li>执行 <code>go get</code> 命令，在下载依赖包的同时还可以指定依赖包的版本。</li>
<li>运行 <code>go get -u</code> 命令会将项目中的包升级到最新的次要版本或者修订版本；</li>
<li>运行 <code>go get -u=patch</code> 命令会将项目中的包升级到最新的修订版本；</li>
<li>运行 <code>go get [包名]@[版本号]</code> 命令会下载对应包的指定版本或者将对应包升级到指定的版本。</li>
</ul>
<p><strong>提示：<code>go get [包名]@[版本号]</code> 命令中版本号可以是 x.y.z 的形式，例如 <code>go get foo@v1.2.3</code> ，也可以是 git 上的分支或 tag，例如 <code>go get foo@master</code> ，还可以是 git 提交时的哈希值，例如 <code>go get foo@e3702bed2。</code></strong></p>
<h3 id="如何在项目中使用"><a href="#如何在项目中使用" class="headerlink" title="如何在项目中使用"></a>如何在项目中使用</h3><p>【示例 1】创建一个新项目：</p>
<p>1) 在 GOPATH 目录之外新建一个目录，并使用go mod init初始化生成 go.mod 文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\chebada.com&gt;go mod init chebada.com</span><br><span class="line">go: creating new go.mod: module chebada.com</span><br></pre></td></tr></tbody></table></figure>
<p>go.mod 文件一旦创建后，它的内容将会被 <code>go toolchain</code> 全面掌控，<code>go toolchain</code> 会在各类命令执行时，比如 <code>go get</code> 、<code>go build</code> 、<code>go mod</code> 等修改和维护 <code>go.mod</code> 文件。</p>
<p>go.mod 提供了 module、require、replace 和 exclude 四个命令：</p>
<ul>
<li>module 语句指定包的名字（路径）；</li>
<li>require 语句指定的依赖项模块；</li>
<li>replace 语句可以替换依赖项模块；</li>
<li>exclude 语句可以忽略依赖项模块。</li>
</ul>
<p>初始化生成的 go.mod 文件如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module chebada.com</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></tbody></table></figure>
<p>2)添加依赖。</p>
<p>新建一个 main.go 文件，写入以下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", func(c echo.Context) error {</span><br><span class="line">        return c.String(http.StatusOK, "Hello, World!")</span><br><span class="line">    })</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行 <code>go run main.go</code> 运行代码会发现 <code>go mod</code> 会自动查找依赖自动下载：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\chebada.com\main&gt;go run echomain.go</span><br><span class="line">go: finding module for package github.com/labstack/echo</span><br><span class="line">go: downloading github.com/labstack/echo v1.4.4</span><br><span class="line">go: downloading github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: found github.com/labstack/echo in github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: finding module for package github.com/labstack/gommon/color</span><br><span class="line">go: finding module for package github.com/labstack/gommon/log</span><br><span class="line">go: finding module for package golang.org/x/crypto/acme/autocert</span><br><span class="line">go: downloading github.com/labstack/gommon v0.3.0</span><br><span class="line">go: downloading golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897</span><br><span class="line">go: found github.com/labstack/gommon/color in github.com/labstack/gommon v0.3.0</span><br><span class="line">go: found golang.org/x/crypto/acme/autocert in golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897</span><br><span class="line">go: downloading github.com/valyala/fasttemplate v1.0.1</span><br><span class="line">go: downloading golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3</span><br><span class="line">go: downloading github.com/mattn/go-colorable v0.1.2</span><br><span class="line">go: downloading github.com/mattn/go-isatty v0.0.9</span><br><span class="line">go: downloading github.com/valyala/bytebufferpool v1.0.0</span><br><span class="line">go: downloading golang.org/x/text v0.3.0</span><br><span class="line"></span><br><span class="line">   ____    __</span><br><span class="line">  / __/___/ /  ___</span><br><span class="line"> / _// __/ _ \/ _ \</span><br><span class="line">/___/\__/_//_/\___/ v3.3.10-dev</span><br><span class="line">High performance, minimalist Go web framework</span><br><span class="line">https://echo.labstack.com</span><br><span class="line">____________________________________O/_______</span><br><span class="line">                                    O\</span><br><span class="line">⇨ http server started on [::]:1323</span><br></pre></td></tr></tbody></table></figure>
<p>现在查看 go.mod 内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module chebada.com</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">    github.com/labstack/gommon v0.3.0 // indirect</span><br><span class="line">    golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897 // indirect</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><code>go module</code> 安装 package 的原则是先拉取最新的 <code>release tag</code>，若无 tag 则拉取最新的 commit，详见 <a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/Modules">Modules</a> 官方介绍。</p>
<p>go 会自动生成一个 go.sum 文件来记录 dependency tree：</p>
<p>go 会自动生成一个 go.sum 文件来记录 dependency tree：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.com/labstack/echo v1.4.4 h1:1bEiBNeGSUKxcPDGfZ/7IgdhJJZx8wV/pICJh4W2NJI=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=</span><br><span class="line">github.com/labstack/gommon v0.3.0 h1:JEeO0bvc78PKdyHxloTKiF8BD5iGrH8T6MSeGvSgob0=</span><br><span class="line">github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=</span><br><span class="line">github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行脚本 <code>go run main.go</code> 发现跳过了检查并安装依赖的步骤。</p>
<p>可以使用命令 <code>go list -m -u all</code> 来检查可以升级的 package，使用 <code>go get -u need-upgrade-package</code> 升级后会将新的依赖版本更新到 go.mod , 也可以使用 <code>go get -u</code> 升级所有依赖。</p>
<p>【示例 2】改造现有项目。</p>
<p>项目目录结构为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">├─ main.go</span><br><span class="line">│</span><br><span class="line">└─ api</span><br><span class="line">      └─ apis.go</span><br></pre></td></tr></tbody></table></figure>
<p>main.go 源码为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    api "./api"  // 这里使用的是相对路径</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", api.HelloWorld)</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>api/apis.go 源码为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package api</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line"></span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func HelloWorld(c echo.Context) error {</span><br><span class="line">    return c.JSON(http.StatusOK, "hello world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>1)使用 <code>go mod init ***</code> 初始化 go.mod。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go mod init hello</span><br><span class="line">go: creating new go.mod: module hello</span><br></pre></td></tr></tbody></table></figure>
<p>2)运行go run main.go。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">build _/D_/code/src/api: cannot find module for path _/D_/code/src/api</span><br></pre></td></tr></tbody></table></figure>
<p>首先还是会查找并下载安装依赖，然后运行脚本 main.go，这里会抛出一个错误：</p>
<p>build <em>/D</em>/code/src/api: cannot find module for path <em>/D</em>/code/src/api</p>
<p>但是 go.mod 已经更新：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module hello</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">    github.com/labstack/gommon v0.3.0 // indirect</span><br><span class="line">    golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413 // indirect</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>那为什么会抛出这个错误呢？</p>
<p>这是因为 main.go 中使用 <code>internal package</code> 的方法跟以前已经不同了，由于 <code>go.mod</code> 会扫描同工作目录下所有 package 并且变更引入方法，必须将 hello 当成路径的前缀，也就是需要写成 <code>import hello/api</code>，以往 <code>GOPATH/dep</code> 模式允许的 <code>import ./api</code> 已经失效</p>
<p>3)更新旧的 package import 方式。</p>
<p>所以 main.go 需要改写成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    api "hello/api" // 这里使用的是相对路径</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", api.HelloWorld)</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示：在 Go语言 1.11 版本下使用 <code>go mod</code> 时可能会遇到 <code>go build github.com/valyala/fasttemplate: module requires go 1.12</code> 这种错误，遇到类似这种需要升级到 1.12 的问题，直接升级到Go语言1.12 版本以上就好了。</em></strong></p>
<p>4)到这里就和新创建一个项目没什么区别了。</p>
<p>由于某些已知的原因，并不是所有的 package 都能成功下载，比如：<code>golang.org</code> 下的包。</p>
<p>modules 可以通过在 go.mod 文件中使用 replace 指令替换成 github 上对应的库，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Go语言生成二维码"><a href="#Go语言生成二维码" class="headerlink" title="Go语言生成二维码"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5713.html">Go语言生成二维码</a></h2><p>二维码作为一种快速的输入手段越来越流行，支付，添加好友，买东西，扫个二维码即可，可以说二维码已经深深地融入了我们的生活中。那么二维码是如何制作生成的呢？我们如何制作自己的二维码呢？</p>
<h3 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h3><p>二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，但其长度没有记载数据，而二维条码的长度、宽度均记载着数据。</p>
<p>二维条码有一维条码没有的“定位点”和“容错机制”，容错机制在即使没有辨识到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。</p>
<h3 id="使用Go语言生成二维码图片"><a href="#使用Go语言生成二维码图片" class="headerlink" title="使用Go语言生成二维码图片"></a>使用Go语言生成二维码图片</h3><p>使用Go语言编程时，生成任意内容的二维码是非常方便的，因为我们有 <code>go-qrcode</code> 这个库。该库的源代码托管在 github 上，大家可以从 <a target="_blank" rel="noopener" href="https://github.com/skip2/go-qrcode">github</a> 上下载并使用这个库。</p>
<p>go-qrcode 的使用很简单，假如要为我们的官网 <a target="_blank" rel="noopener" href="http://c.biancheng.net/">http://c.biancheng.net/</a> 生成一张 256*256 的图片，可以使用如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/skip2/go-qrcode"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    qrcode.WriteFile("http://c.biancheng.net/",qrcode.Medium,256,"./golang_qrcode.png")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样我们运行代码的时候，就在当前目录下，生成一张 256*256 的二维码，扫描后就可以自动跳转到我们的官网，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/qrcode.gif" alt="图：二维码"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func WriteFile(content string, level RecoveryLevel, size int, filename string) error</span><br></pre></td></tr></tbody></table></figure>
<p>WriteFile 函数的原型定义如上，它有几个参数，大概意思如下：</p>
<ul>
<li>content 表示要生成二维码的内容，可以是任意字符串；</li>
<li>level 表示二维码的容错级别，取值有 Low、Medium、High、Highest；</li>
<li>size 表示生成图片的 width 和 height，像素单位；</li>
<li>filename 表示生成的文件名路径；</li>
<li>RecoveryLevel 类型其实是个 int，它的定义和常量如下：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type RecoveryLevel int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    // Level L: 7% error recovery.</span><br><span class="line">    Low RecoveryLevel = iota</span><br><span class="line"></span><br><span class="line">    // Level M: 15% error recovery. Good default choice.</span><br><span class="line">    Medium</span><br><span class="line"></span><br><span class="line">    // Level Q: 25% error recovery.</span><br><span class="line">    High</span><br><span class="line"></span><br><span class="line">    // Level H: 30% error recovery.</span><br><span class="line">    Highest</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>RecoveryLevel 越高，二维码的容错能力越好。</p>
<h3 id="生成二维码图片字节"><a href="#生成二维码图片字节" class="headerlink" title="生成二维码图片字节"></a>生成二维码图片字节</h3><p>有时候我们不想直接生成一个 PNG 文件存储，我们想对 PNG 图片做一些处理，比如缩放了，旋转了，或者网络传输了等，基于此，我们可以使用 Encode 函数，生成一个 PNG 图片的字节流，这样我们就可以进行各种处理了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Encode(content string, level RecoveryLevel, size int) ([]byte, error)</span><br></pre></td></tr></tbody></table></figure>
<p>用法和 WriteFile 函数差不多，只不过返回的是一个 []byte 字节数组，这样我们就可以对这个字节数组进行处理了。</p>
<h3 id="自定义二维码"><a href="#自定义二维码" class="headerlink" title="自定义二维码"></a>自定义二维码</h3><p>除了以上两种快捷方式，go-qrcode 库还为我们提供了对二维码的自定义方式，比如我们可以自定义二维码的前景色和背景色等。qrcode.New 函数可以返回一个 <em>QRCode，我们可以对 </em>QRCode 设置，实现对二维码的自定义。</p>
<p>比如我们设置背景色为绿色，前景色为白色的二维码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "github.com/skip2/go-qrcode"</span><br><span class="line">    "image/color"</span><br><span class="line">    "log"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    qr,err:=qrcode.New("http://c.biancheng.net/",qrcode.Medium)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    } else {</span><br><span class="line">        qr.BackgroundColor = color.RGBA{50,205,50,255}</span><br><span class="line">        qr.ForegroundColor = color.White</span><br><span class="line">        qr.WriteFile(256,"./golang_qrcode.png")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>指定 *QRCode 的 BackgroundColor 和 ForegroundColor 即可，然后调用 WriteFile 方法生成这个二维码文件，如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/qrcode2.gif" alt="图：二维码"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func New(content string, level RecoveryLevel) (*QRCode, error)</span><br><span class="line">// A QRCode represents a valid encoded QRCode.</span><br><span class="line">type QRCode struct {</span><br><span class="line">    // Original content encoded.</span><br><span class="line">    Content string</span><br><span class="line">    // QR Code type.</span><br><span class="line">    Level         RecoveryLevel</span><br><span class="line">    VersionNumber int</span><br><span class="line">    // User settable drawing options.</span><br><span class="line">    ForegroundColor color.Color</span><br><span class="line">    BackgroundColor color.Color</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上 QRCode 的这些字段都是可以设置的，这样我们就可以灵活自定义二维码了。</p>
<p><strong>小结：二维码是一种流行的输入技术手段，不光 Go 可以生成，其他语言也可以生成，并且生成的二维码是标准的，都可以扫描和识别，比如 Java 可以通过  <code>https://github.com/kenglxn/QRGen</code> 库来生成。</strong></p>
<h2 id="Context上下文"><a href="#Context上下文" class="headerlink" title="Context上下文"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5714.html">Context上下文</a></h2><p>Context 在 Go1.7 之后就加入到了Go语言标准库中，准确说它是 Goroutine 的上下文，包含 Goroutine 的运行状态、环境、现场等信息。</p>
<p>随着 Context 包的引入，标准库中很多接口因此加上了 Context 参数，例如 <code>database/sql</code> 包，Context 几乎成为了并发控制和超时控制的标准做法。</p>
<h3 id="什么是-Context"><a href="#什么是-Context" class="headerlink" title="什么是 Context"></a>什么是 Context</h3><p>Context 也叫作“上下文”，是一个比较抽象的概念，一般理解为程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元则指的是 Goroutine。</p>
<p>每个 Goroutine 在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个 Context 变量中，传递给要执行的 Goroutine 中。</p>
<p>在网络编程下，当接收到一个网络请求 Request，在处理 Request 时，我们可能需要开启不同的 Goroutine 来获取数据与逻辑处理，即一个请求 Request，会在多个 Goroutine 中处理。而这些 Goroutine 可能需要共享 Request 的一些信息，同时当 Request 被取消或者超时的时候，所有从这个 Request 创建的所有 Goroutine 也应该被结束。</p>
<h3 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h3><p>Context 包的核心就是 Context 接口，其定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Context interface {</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line">    Done() &lt;-chan struct{}</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key interface{}) interface{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>Deadline 方法需要返回当前 Context 被取消的时间，也就是完成工作的截止时间（deadline）；</li>
<li>Done 方法需要返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个Channel；</li>
<li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值：<ul>
<li>如果当前 Context 被取消就会返回 Canceled 错误；</li>
<li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li>
</ul>
</li>
<li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法仅用于传递跨 API 和进程间跟请求域的数据。</li>
</ul>
<h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>Go语言内置两个函数：Background() 和 TODO()，这两个函数分别返回一个实现了 Context 接口的 background 和 todo。</p>
<p>Background() 主要用于 main 函数、初始化以及测试代码中，作为 Context 这个树结构的最顶层的 Context，也就是根 Context。</p>
<p>TODO()，它目前还不知道具体的使用场景，在不知道该使用什么 Context 的时候，可以使用这个。</p>
<p>background 和 todo 本质上都是 emptyCtx 结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的 Context。</p>
<h3 id="With-系列函数"><a href="#With-系列函数" class="headerlink" title="With 系列函数"></a>With 系列函数</h3><p>此外，Context 包中还定义了四个 With 系列函数。</p>
<h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>WithCancel 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithCancel 返回带有新 Done 通道的父节点的副本，当调用返回的 cancel 函数或当关闭父上下文的 Done 通道时，将关闭返回上下文的 Done 通道，无论先发生什么情况。</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    gen := func(ctx context.Context) &lt;-chan int {</span><br><span class="line">        dst := make(chan int)</span><br><span class="line">        n := 1</span><br><span class="line">        go func() {</span><br><span class="line">            for {</span><br><span class="line">                select {</span><br><span class="line">                case &lt;-ctx.Done():</span><br><span class="line">                    return // return结束该goroutine，防止泄露</span><br><span class="line">                case dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">        return dst</span><br><span class="line">    }</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    defer cancel() // 当我们取完需要的整数后调用cancel</span><br><span class="line">    for n := range gen(ctx) {</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        if n == 5 {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，gen 函数在单独的 Goroutine 中生成整数并将它们发送到返回的通道，gen 的调用者在使用生成的整数之后需要取消上下文，以免 gen 启动的内部 Goroutine 发生泄漏。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p>WithDeadline 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithDeadline 函数会返回父上下文的副本，并将 deadline 调整为不迟于 d。如果父上下文的 deadline 已经早于 d，则 WithDeadline(parent, d) 在语义上等同于父上下文。当截止日过期时，当调用返回的 cancel 函数时，或者当父上下文的 Done 通道关闭时，返回上下文的 Done 通道将被关闭，以最先发生的情况为准。</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    d := time.Now().Add(50 * time.Millisecond)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span><br><span class="line">    // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    select {</span><br><span class="line">    case &lt;-time.After(1 * time.Second):</span><br><span class="line">        fmt.Println("overslept")</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">context deadline exceeded</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，定义了一个 50 毫秒之后过期的 deadline，然后我们调用 context.WithDeadline(context.Background(), d) 得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个 select 让主程序陷入等待，等待 1 秒后打印 overslept 退出或者等待 ctx 过期后退出。因为 ctx 50 秒后就过期，所以 ctx.Done() 会先接收到值，然后打印 ctx.Err() 取消原因。</p>
<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>WithTimeout 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithTimeout 函数返回 WithDeadline(parent, time.Now().Add(timeout))。</p>
<p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 传递带有超时的上下文</span><br><span class="line">    // 告诉阻塞函数在超时结束后应该放弃其工作。</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    select {</span><br><span class="line">    case &lt;-time.After(1 * time.Second):</span><br><span class="line">        fmt.Println("overslept")</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err()) // 终端输出"context deadline exceeded"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">context deadline exceeded</span><br></pre></td></tr></tbody></table></figure>
<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p>WithValue 函数能够将请求作用域的数据与 Context 对象建立关系。函数声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func WithValue(parent Context, key, val interface{}) Context</span><br></pre></td></tr></tbody></table></figure>
<p>WithValue 函数接收 context 并返回派生的 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，函数应接收签名中的那些值，使其显式化。</p>
<p>所提供的键必须是可比较的，并且不应该是 string 类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue 的用户应该为键定义自己的类型，为了避免在分配给接口 <code>{ }</code> 时进行分配，上下文键通常具有具体类型 <code>struct{}</code> 。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type favContextKey string // 定义一个key类型</span><br><span class="line">    // f:一个从上下文中根据key取value的函数</span><br><span class="line">    f := func(ctx context.Context, k favContextKey) {</span><br><span class="line">        if v := ctx.Value(k); v != nil {</span><br><span class="line">            fmt.Println("found value:", v)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("key not found:", k)</span><br><span class="line">    }</span><br><span class="line">    k := favContextKey("language")</span><br><span class="line">    // 创建一个携带key为k，value为"Go"的上下文</span><br><span class="line">    ctx := context.WithValue(context.Background(), k, "Go")</span><br><span class="line">    f(ctx, k)</span><br><span class="line">    f(ctx, favContextKey("color"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">found value: Go</span><br><span class="line">key not found: color</span><br></pre></td></tr></tbody></table></figure>
<p>使用 Context 的注意事项：</p>
<ul>
<li>不要把 Context 放在结构体中，要以参数的方式显示传递；</li>
<li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数；</li>
<li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO；</li>
<li>Context 的 Value 相关方法应该传递请求域的必要数据，不应该用于传递可选参数；</li>
<li>Context 是线程安全的，可以放心的在多个 Goroutine 中传递。</li>
</ul>
<p><strong>总结:</strong></p>
<p>Go语言中的 Context 的主要作用还是在多个 Goroutine 或者模块之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费，虽然传值也是它的功能之一，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，不能将请求的所有参数都使用 Context 进行传递，这是一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>
<h2 id="客户信息管理系统"><a href="#客户信息管理系统" class="headerlink" title="客户信息管理系统"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5716.html">客户信息管理系统</a></h2><p>实现一个基于文本界面的客户关系管理软件，该软件可以实现对客户的插入、修改和删除，并且可以打印客户信息明细表。</p>
<p>软件由一下三个模块组成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/customermanager.gif" alt="客户关系管理软件"></p>
<p>项目结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/customerarch.gif" alt="项目结构"></p>
<p>在 costumer.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package model</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明一个Customer结构体，表示一个客户信息</span><br><span class="line">type Customer struct {</span><br><span class="line">    Id int</span><br><span class="line">    Name string</span><br><span class="line">    Gender string</span><br><span class="line">    Age int</span><br><span class="line">    Phone string</span><br><span class="line">    Email string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//使用工厂模式，返回一个Customer的实例</span><br><span class="line">func NewCustomer(id int, name string, gender string, age int, phone string, email string ) Customer {</span><br><span class="line">    return Customer{</span><br><span class="line">        Id : id,</span><br><span class="line">        Name : name,</span><br><span class="line">        Gender : gender,</span><br><span class="line">        Age : age,</span><br><span class="line">        Phone : phone,</span><br><span class="line">        Email : email,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//第二种创建Customer实例方法，不带id</span><br><span class="line">func NewCustomer2(name string, gender string,</span><br><span class="line">    age int, phone string, email string ) Customer {</span><br><span class="line">    return Customer{</span><br><span class="line">        Name : name,</span><br><span class="line">        Gender : gender,</span><br><span class="line">        Age : age,</span><br><span class="line">        Phone : phone,</span><br><span class="line">        Email : email,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//返回用户的信息,格式化的字符串</span><br><span class="line">func (this Customer) GetInfo()  string {</span><br><span class="line">    info := fmt.Sprintf("%v\t %v\t %v\t %v\t %v\t %v\t", this.Id,</span><br><span class="line">        this.Name, this.Gender,this.Age, this.Phone, this.Email)</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 costumerService.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package service</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "../model"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//该CustomerService， 完成对Customer的操作,包括</span><br><span class="line">//增删改查</span><br><span class="line">type CustomerService struct {</span><br><span class="line">    customers []model.Customer</span><br><span class="line">    //声明一个字段，表示当前切片含有多少个客户</span><br><span class="line">    //该字段后面，还可以作为新客户的id+1</span><br><span class="line">    customerNum int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//编写一个方法，可以返回 *CustomerService</span><br><span class="line">func NewCustomerService() *CustomerService {</span><br><span class="line">    //为了能够看到有客户在切片中，我们初始化一个客户</span><br><span class="line">    customerService := &amp;CustomerService{}</span><br><span class="line">    customerService.customerNum = 1</span><br><span class="line">    customer := model.NewCustomer(1, "张三", "男", 20, "010-56253825", "zs@sohu.com")</span><br><span class="line">    customerService.customers = append(customerService.customers, customer)</span><br><span class="line">    return customerService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//返回客户切片</span><br><span class="line">func (this *CustomerService) List() []model.Customer {</span><br><span class="line">    return this.customers</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//添加客户到customers切片</span><br><span class="line">func (this *CustomerService) Add(customer model.Customer) bool {</span><br><span class="line">    //我们确定一个分配id的规则,就是添加的顺序</span><br><span class="line">    this.customerNum++</span><br><span class="line">    customer.Id = this.customerNum</span><br><span class="line">    this.customers = append(this.customers, customer)</span><br><span class="line">    return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//根据id删除客户(从切片中删除)</span><br><span class="line">func (this *CustomerService) Delete(id int) bool {</span><br><span class="line">    index := this.FindById(id)</span><br><span class="line">    //如果index == -1, 说明没有这个客户</span><br><span class="line">    if index == -1 {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    //如何从切片中删除一个元素</span><br><span class="line">    this.customers = append(this.customers[:index], this.customers[index+1:]...)</span><br><span class="line">    return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//根据id查找客户在切片中对应下标,如果没有该客户，返回-1</span><br><span class="line">func (this *CustomerService) FindById(id int)  int {</span><br><span class="line">    index := -1</span><br><span class="line">    //遍历this.customers 切片</span><br><span class="line">    for i := 0; i &lt; len(this.customers); i++ {</span><br><span class="line">        if this.customers[i].Id == id {</span><br><span class="line">            //找到</span><br><span class="line">            index = i</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return index</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 costumerView.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "../model"</span><br><span class="line">    "../service"</span><br><span class="line">)</span><br><span class="line">type customerView struct {</span><br><span class="line">    //定义必要字段</span><br><span class="line">    key string //接收用户输入...</span><br><span class="line">    loop bool  //表示是否循环的显示主菜单</span><br><span class="line">    //增加一个字段customerService</span><br><span class="line">    customerService *service.CustomerService</span><br><span class="line">}</span><br><span class="line">//显示所有的客户信息</span><br><span class="line">func (this *customerView) list() {</span><br><span class="line">    //首先，获取到当前所有的客户信息(在切片中)</span><br><span class="line">    customers := this.customerService.List()</span><br><span class="line">    //显示</span><br><span class="line">    fmt.Println("---------------------------客户列表---------------------------")</span><br><span class="line">    fmt.Println("编号\t姓名\t性别\t年龄\t电话\t邮箱")</span><br><span class="line">    for i := 0; i &lt; len(customers); i++ {</span><br><span class="line">        //fmt.Println(customers[i].Id,"\t", customers[i].Name...)</span><br><span class="line">        fmt.Println(customers[i].GetInfo())</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf("\n-------------------------客户列表完成-------------------------\n\n")</span><br><span class="line">}</span><br><span class="line">//得到用户的输入，信息构建新的客户，并完成添加</span><br><span class="line">func (this *customerView) add() {</span><br><span class="line">    fmt.Println("---------------------添加客户---------------------")</span><br><span class="line">    fmt.Print("姓名:")</span><br><span class="line">    name := ""</span><br><span class="line">    fmt.Scanln(&amp;name)</span><br><span class="line">    fmt.Print("性别:")</span><br><span class="line">    gender := ""</span><br><span class="line">    fmt.Scanln(&amp;gender)</span><br><span class="line">    fmt.Print("年龄:")</span><br><span class="line">    age := 0</span><br><span class="line">    fmt.Scanln(&amp;age)</span><br><span class="line">    fmt.Print("电话:")</span><br><span class="line">    phone := ""</span><br><span class="line">    fmt.Scanln(&amp;phone)</span><br><span class="line">    fmt.Print("邮箱:")</span><br><span class="line">    email := ""</span><br><span class="line">    fmt.Scanln(&amp;email)</span><br><span class="line">    //构建一个新的Customer实例</span><br><span class="line">    //注意: id号，没有让用户输入，id是唯一的，需要系统分配</span><br><span class="line">    customer := model.NewCustomer2(name, gender, age, phone, email)</span><br><span class="line">    //调用</span><br><span class="line">    if this.customerService.Add(customer) {</span><br><span class="line">        fmt.Println("---------------------添加完成---------------------")</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("---------------------添加失败---------------------")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//得到用户的输入id，删除该id对应的客户</span><br><span class="line">func (this *customerView) delete() {</span><br><span class="line">    fmt.Println("---------------------删除客户---------------------")</span><br><span class="line">    fmt.Print("请选择待删除客户编号(-1退出)：")</span><br><span class="line">    id := -1</span><br><span class="line">    fmt.Scanln(&amp;id)</span><br><span class="line">    if id == -1 {</span><br><span class="line">        return //放弃删除操作</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("确认是否删除(Y/N)：")</span><br><span class="line">    //这里同学们可以加入一个循环判断，直到用户输入 y 或者 n,才退出..</span><br><span class="line">    choice := ""</span><br><span class="line">    fmt.Scanln(&amp;choice)</span><br><span class="line">    if choice == "y" || choice == "Y" {</span><br><span class="line">        //调用customerService 的 Delete方法</span><br><span class="line">        if this.customerService.Delete(id) {</span><br><span class="line">            fmt.Println("---------------------删除完成---------------------")</span><br><span class="line">        } else {</span><br><span class="line">            fmt.Println("---------------------删除失败，输入的id号不存在----")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//退出软件</span><br><span class="line">func (this *customerView) exit() {</span><br><span class="line">    fmt.Print("确认是否退出(Y/N)：")</span><br><span class="line">    for {</span><br><span class="line">        fmt.Scanln(&amp;this.key)</span><br><span class="line">        if this.key == "Y" || this.key == "y" || this.key == "N" || this.key == "n" {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print("你的输入有误，确认是否退出(Y/N)：")</span><br><span class="line">    }</span><br><span class="line">    if this.key == "Y" || this.key == "y" {</span><br><span class="line">        this.loop = false</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//显示主菜单</span><br><span class="line">func (this *customerView) mainMenu() {</span><br><span class="line">    for {</span><br><span class="line">        fmt.Println("-----------------客户信息管理软件-----------------")</span><br><span class="line">        fmt.Println("                 1 添 加 客 户")</span><br><span class="line">        fmt.Println("                 2 修 改 客 户")</span><br><span class="line">        fmt.Println("                 3 删 除 客 户")</span><br><span class="line">        fmt.Println("                 4 客 户 列 表")</span><br><span class="line">        fmt.Println("                 5 退       出")</span><br><span class="line">        fmt.Print("请选择(1-5)：")</span><br><span class="line">        fmt.Scanln(&amp;this.key)</span><br><span class="line">        switch this.key {</span><br><span class="line">            case "1" :</span><br><span class="line">                this.add()</span><br><span class="line">            case "2" :</span><br><span class="line">                fmt.Println("修 改 客 户")</span><br><span class="line">            case "3" :</span><br><span class="line">                this.delete()</span><br><span class="line">            case "4" :</span><br><span class="line">                this.list()</span><br><span class="line">            case "5" :</span><br><span class="line">                this.exit()</span><br><span class="line">            default :</span><br><span class="line">                fmt.Println("你的输入有误，请重新输入...")</span><br><span class="line">        }</span><br><span class="line">        if !this.loop {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("已退出了客户关系管理系统...")</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    //在main函数中，创建一个customerView,并运行显示主菜单..</span><br><span class="line">    customerView := customerView{</span><br><span class="line">        key : "",</span><br><span class="line">        loop : true,</span><br><span class="line">    }</span><br><span class="line">    //这里完成对customerView结构体的customerService字段的初始化</span><br><span class="line">    customerView.customerService = service.NewCustomerService()</span><br><span class="line">    //显示主菜单..</span><br><span class="line">    customerView.mainMenu()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\code\demo\view&gt;go run customerView.go</span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：1</span><br><span class="line">---------------------添加客户---------------------</span><br><span class="line">姓名:李四</span><br><span class="line">性别:男</span><br><span class="line">年龄:22</span><br><span class="line">电话:15611112222</span><br><span class="line">邮箱:lisi@qq.com</span><br><span class="line">---------------------添加完成---------------------</span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：4</span><br><span class="line">---------------------------客户列表---------------------------</span><br><span class="line">编号    姓名    性别    年龄    电话    邮箱</span><br><span class="line">1        张三    男      20      010-56253825    zs@sohu.com</span><br><span class="line">2        李四    男      22      15611112222     lisi@qq.com</span><br><span class="line"></span><br><span class="line">-------------------------客户列表完成-------------------------</span><br><span class="line"></span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：</span><br></pre></td></tr></tbody></table></figure>
<h2 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h2><p>电子邮件在日常工作中有很大用途，凡项目或任务，有邮件来往可避免扯皮背锅。而在一些自动化的应用场合，也使用得广泛，特别是系统监控方面，如果在资源使用达到警戒线之前自动发邮件通知运维人员，能消除隐患于前期，而不至于临时临急去做善后方案。</p>
<p>对于多人协合（不管是不是异地）场合，邮件也有用武之地，当有代码或文档更新时，自动发邮件通知项目成员或领导，提醒各方人员知晓并及时更新。</p>
<p>说到发邮件，不得不提用程序的方式实现。下面就来为大家介绍一下怎么使用Go语言来实现发送电子邮件。Go语言拥有大量的库，非常方便使用。</p>
<p>Go语言使用 gomail 包来发送邮箱，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "strings"</span><br><span class="line">    "github.com/go-gomail/gomail"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type EmailParam struct {</span><br><span class="line">    // ServerHost 邮箱服务器地址，如腾讯邮箱为smtp.qq.com</span><br><span class="line">    ServerHost string</span><br><span class="line"></span><br><span class="line">    // ServerPort 邮箱服务器端口，如腾讯邮箱为465</span><br><span class="line">    ServerPort int</span><br><span class="line"></span><br><span class="line">    // FromEmail　发件人邮箱地址</span><br><span class="line">    FromEmail string</span><br><span class="line"></span><br><span class="line">    // FromPasswd 发件人邮箱密码（注意，这里是明文形式），TODO：如果设置成密文？</span><br><span class="line">    FromPasswd string</span><br><span class="line"></span><br><span class="line">    // Toers 接收者邮件，如有多个，则以英文逗号(“,”)隔开，不能为空</span><br><span class="line">    Toers string</span><br><span class="line"></span><br><span class="line">    // CCers 抄送者邮件，如有多个，则以英文逗号(“,”)隔开，可以为空</span><br><span class="line">    CCers string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 全局变量，因为发件人账号、密码，需要在发送时才指定</span><br><span class="line">// 注意，由于是小写，外面的包无法使用</span><br><span class="line">var serverHost, fromEmail, fromPasswd string</span><br><span class="line">var serverPort int</span><br><span class="line">var m *gomail.Message</span><br><span class="line"></span><br><span class="line">func InitEmail(ep *EmailParam) {</span><br><span class="line">    toers := []string{}</span><br><span class="line">    serverHost = ep.ServerHost</span><br><span class="line">    serverPort = ep.ServerPort</span><br><span class="line">    fromEmail = ep.FromEmail</span><br><span class="line">    fromPasswd = ep.FromPasswd</span><br><span class="line"></span><br><span class="line">    m = gomail.NewMessage()</span><br><span class="line">    if len(ep.Toers) == 0 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for _, tmp := range strings.Split(ep.Toers, ",") {</span><br><span class="line">        toers = append(toers, strings.TrimSpace(tmp))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 收件人可以有多个，故用此方式</span><br><span class="line">    m.SetHeader("To", toers...)</span><br><span class="line"></span><br><span class="line">    //抄送列表</span><br><span class="line">    if len(ep.CCers) != 0 {</span><br><span class="line">        for _, tmp := range strings.Split(ep.CCers, ",") {</span><br><span class="line">            toers = append(toers, strings.TrimSpace(tmp))</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        m.SetHeader("Cc", toers...)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 发件人</span><br><span class="line">    // 第三个参数为发件人别名，如"李大锤"，可以为空（此时则为邮箱名称）</span><br><span class="line">    m.SetAddressHeader("From", fromEmail, "")  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// SendEmail body支持html格式字符串</span><br><span class="line">func SendEmail(subject, body string) {</span><br><span class="line"></span><br><span class="line">    // 主题</span><br><span class="line">    m.SetHeader("Subject", subject)</span><br><span class="line"></span><br><span class="line">    // 正文</span><br><span class="line">    m.SetBody("text/html", body)</span><br><span class="line">    d := gomail.NewPlainDialer(serverHost, serverPort, fromEmail, fromPasswd)</span><br><span class="line"></span><br><span class="line">    // 发送</span><br><span class="line">    err := d.DialAndSend(m)</span><br><span class="line">    if err != nil {</span><br><span class="line">        panic(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    serverHost := "smtp.qq.com"</span><br><span class="line">    serverPort := 465</span><br><span class="line">    fromEmail := "xxxxxxx@qq.com"</span><br><span class="line"></span><br><span class="line">    //发件人邮箱</span><br><span class="line">    fromPasswd := "xumkkzfscmxxxxxx"</span><br><span class="line"></span><br><span class="line">    //授权码</span><br><span class="line">    myToers := "xxxxxxx@qq.com"</span><br><span class="line"></span><br><span class="line">    // 收件人邮箱，逗号隔开</span><br><span class="line">    myCCers := "" //"readchy@163.com"</span><br><span class="line"></span><br><span class="line">    subject := "这是主题"</span><br><span class="line">    body := `这是正文&lt;br&gt;</span><br><span class="line">    Hello &lt;a href = "http://c.biancheng.net/"&gt;C语言中文网&lt;/a&gt;`</span><br><span class="line"></span><br><span class="line">    // 结构体赋值</span><br><span class="line">    myEmail := &amp;EmailParam {</span><br><span class="line">        ServerHost: serverHost,</span><br><span class="line">        ServerPort: serverPort,</span><br><span class="line">        FromEmail:  fromEmail,</span><br><span class="line">        FromPasswd: fromPasswd,</span><br><span class="line">        Toers:      myToers,</span><br><span class="line">        CCers:      myCCers,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    InitEmail(myEmail)</span><br><span class="line">    SendEmail(subject, body)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用自定义客户端发放邮件需要以下两个要素:</p>
<ul>
<li><p>1) 发送方的邮箱必须开启 stmt 和 pop3 通道，以 qq 邮箱为例，登陆 qq 邮箱 -&gt; 设置 -&gt; 账户 -&gt; 开启 pop3 和 stmt 服务</p>
</li>
<li><p>2) 开启后会获得该账户的授权码，如果忘记也可以重新生成。</p>
</li>
</ul>
<h2 id="Pingo-插件化开发"><a href="#Pingo-插件化开发" class="headerlink" title="Pingo 插件化开发"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5718.html">Pingo 插件化开发</a></h2><p>Pingo 是一个用来为Go语言程序编写插件的简单独立库，因为 Go 本身是静态链接的，因此所有插件都以外部进程方式存在。Pingo 旨在简化标准 RPC 包，支持 TCP 和 Unix 套接字作为通讯协议。当前还不支持远程插件，如果有需要，远程插件很快会提供。</p>
<p>使用 Pingo 创建一个插件非常简单，首先新建目录，如 “plugins/hello-world” ，然后在该目录下编写 main.go：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建新的二进制文件</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/dullgiulio/pingo"</span><br><span class="line"></span><br><span class="line">// 创建要导出的对象</span><br><span class="line">type MyPlugin struct{}</span><br><span class="line"></span><br><span class="line">// 导出的方法，带有rpc签名</span><br><span class="line">func (p *MyPlugin) SayHello(name string, msg *string) error {</span><br><span class="line">    *msg = "Hello, " + name</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    plugin := &amp;MyPlugin{}</span><br><span class="line"></span><br><span class="line">    // 注册要导出的对象</span><br><span class="line">    pingo.Register(plugin)</span><br><span class="line">    // 运行主程序</span><br><span class="line">    pingo.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go build</code> 命令编译并生成可执行文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd plugins/hello-world</span><br><span class="line">go build</span><br></pre></td></tr></tbody></table></figure>
<p>接下来就可以调用该插件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "github.com/dullgiulio/pingo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 从创建的可执行文件中创建一个新插件。通过 TCP 连接到它</span><br><span class="line">    p := pingo.NewPlugin("tcp", "plugins/hello-world/hello-world")</span><br><span class="line"></span><br><span class="line">    // 启动插件</span><br><span class="line">    p.Start()</span><br><span class="line"></span><br><span class="line">    // 使用完插件后停止它</span><br><span class="line">    defer p.Stop()</span><br><span class="line"></span><br><span class="line">    var resp string</span><br><span class="line"></span><br><span class="line">    // 从先前创建的对象调用函数</span><br><span class="line">    if err := p.Call("MyPlugin.SayHello", "Go developer", &amp;resp); err != nil {</span><br><span class="line">        log.Print(err)</span><br><span class="line">    } else {</span><br><span class="line">        log.Print(resp)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\chebada.com\main&gt;go run pingomain.go</span><br><span class="line">2020/10/24 14:22:57 Hello, Go dqc13215~!</span><br></pre></td></tr></tbody></table></figure>
<h2 id="定时器实现原理及作用"><a href="#定时器实现原理及作用" class="headerlink" title="定时器实现原理及作用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5723.html">定时器实现原理及作用</a></h2><p>对于任何一个正在运行的应用，如何获取准确的绝对时间都非常重要，但是在一个分布式系统中我们很难保证各个节点上绝对时间的一致性，哪怕通过 NTP 这种标准的对时协议也只能把时间的误差控制在毫秒级，所以相对时间在一个分布式系统中显得更为重要，在接下来的讲解中我们将会介绍一下Go语言中的定时器以及它在并发编程中起到什么样的作用。</p>
<p>绝对时间一定不会是完全准确的，它对于一个运行中的分布式系统其实没有太多指导意义，但是由于相对时间的计算不依赖于外部的系统，所以它的计算可以做的比较准确，首先介绍一下Go语言中用于计算相对时间的定时器的实现原理。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>timer 就是Go语言定时器的内部表示，每一个 timer 其实都存储在堆中，tb 就是用于存储当前定时器的桶，而 i 是当前定时器在堆中的索引，我们可以通过这两个变量找到当前定时器在堆中的位置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type timer struct {</span><br><span class="line">    tb *timersBucket</span><br><span class="line">    i  int</span><br><span class="line"></span><br><span class="line">    when   int64</span><br><span class="line">    period int64</span><br><span class="line">    f      func(interface{}, uintptr)</span><br><span class="line">    arg    interface{}</span><br><span class="line">    seq    uintptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>when 表示当前定时器（Timer）被唤醒的时间，而 period 表示两次被唤醒的间隔，每当定时器被唤醒时都会调用 f(args, now) 函数并传入 args 和当前时间作为参数。</p>
<p>然而这里的 timer 作为一个私有结构体其实只是定时器的运行时表示，time 包对外暴露的定时器使用了如下所示的结构体：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Timer struct {</span><br><span class="line">    C &lt;-chan Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Timer 定时器必须通过 NewTimer 或者 AfterFunc 函数进行创建，其中的 runtimeTimer 其实就是上面介绍的 timer 结构体，当定时器失效时，失效的时间就会被发送给当前定时器持有的 Channel C，订阅管道中消息的 Goroutine 就会收到当前定时器失效的时间。</p>
<p>在 time 包中，除了 timer 和 Timer 两个分别用于表示运行时定时器和对外暴露的 API 之外，timersBucket 这个用于存储定时器的结构体也非常重要，它会存储一个处理器上的全部定时器，不过如果当前机器的核数超过了 64 核，也就是机器上的处理器 P 的个数超过了 64 个，多个处理器上的定时器就可能存储在同一个桶中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type timersBucket struct {</span><br><span class="line">    lock         mutex</span><br><span class="line">    gp           *g</span><br><span class="line">    created      bool</span><br><span class="line">    sleeping     bool</span><br><span class="line">    rescheduling bool</span><br><span class="line">    sleepUntil   int64</span><br><span class="line">    waitnote     note</span><br><span class="line">    t            []*timer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每一个 timersBucket 中的 t 就是用于存储定时器指针的切片，每一个运行的Go语言程序都会在内存中存储着 64 个桶，这些桶中都存储定时器的信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timersBucket.gif" alt="GOLANG TIMER BUCKET"></p>
<p>每一个桶持有的 timer 切片其实都是一个最小堆，这个最小堆会按照 timer 应该触发的时间对它们进行排序，最小堆最上面的定时器就是最近需要被唤醒的 timer，下面来介绍下定时器的创建和触发过程。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>既然我们已经介绍了定时器的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，接下来我们就可以开始分析它的常见操作以及工作原理了，在这一节中我们将介绍定时器的创建、触发、time.Sleep 与定时器的关系以及计时器 Ticker 的实现原理。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>time 包对外提供了两种创建定时器的方法，第一种方法就是 NewTimer 接口，这个接口会创建一个用于通知触发时间的 Channel、调用 startTimer 方法并返回一个创建指向 Timer 结构体的指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewTimer(d Duration) *Timer {</span><br><span class="line">    c := make(chan Time, 1)</span><br><span class="line">    t := &amp;Timer{</span><br><span class="line">        C: c,</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when: when(d),</span><br><span class="line">            f:    sendTime,</span><br><span class="line">            arg:  c,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另一个用于创建 Timer 的方法 AfterFunc 其实也提供了非常相似的结构，与 NewTimer 方法不同的是该方法没有创建一个用于通知触发时间的 Channel，它只会在定时器到期时调用传入的方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func AfterFunc(d Duration, f func()) *Timer {</span><br><span class="line">    t := &amp;Timer{</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when: when(d),</span><br><span class="line">            f:    goFunc,</span><br><span class="line">            arg:  f,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>startTimer 基本上就是创建定时器的入口了，所有定时器的创建和重启基本上都需要调用该函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func startTimer(t *timer) {</span><br><span class="line">    addtimer(t)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func addtimer(t *timer) {</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    tb.addtimerLocked(t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>它会调用 addtimer 函数，这个函数总共做了两件事情，首先通过 assignBucket 方法为当前定时器选择一个 timersBucket 桶，我们会根据当前 Goroutine 所在处理器 P 的 id 选择一个合适的桶，随后调用 addtimerLocked 方法将当前定时器加入桶中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func (tb *timersBucket) addtimerLocked(t *timer) bool {</span><br><span class="line">    t.i = len(tb.t)</span><br><span class="line">    tb.t = append(tb.t, t)</span><br><span class="line">    if !siftupTimer(tb.t, t.i) {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    if t.i == 0 {</span><br><span class="line">        if tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when {</span><br><span class="line">            tb.sleeping = false</span><br><span class="line">            notewakeup(&amp;tb.waitnote)</span><br><span class="line">        }</span><br><span class="line">        if tb.rescheduling {</span><br><span class="line">            tb.rescheduling = false</span><br><span class="line">            goready(tb.gp, 0)</span><br><span class="line">        }</span><br><span class="line">        if !tb.created {</span><br><span class="line">            tb.created = true</span><br><span class="line">            go timerproc(tb)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addtimerLocked 会先将最新加入的定时器加到队列的末尾，随后调用 siftupTimer 将当前定时器与四叉树（或者四叉堆）中的父节点进行比较，保证父节点的到期时间一定小于子节点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerQuadtree.gif" alt="timerQuadtree"></p>
<p>这个四叉树只能保证父节点的到期时间小于子节点，这对于我们来说其实也足够了，因为我们只关心即将被触发的计数器，如果当前定时器是第一个被加入四叉树的定时器，我们还会通过 go timerproc(tb) 启动一个 Goroutine 用于处理当前树中的定时器，这也是处理定时器的核心方法。</p>
<h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>定时器的触发都是由 timerproc 中的一个双层 for 循环控制的，外层的 for 循环主要负责对当前 Goroutine 进行控制，它不仅会负责锁的获取和释放，还会在合适的时机触发当前 Goroutine 的休眠：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func timerproc(tb *timersBucket) {</span><br><span class="line">    tb.gp = getg()</span><br><span class="line">    for {</span><br><span class="line">        tb.sleeping = false</span><br><span class="line">        now := nanotime()</span><br><span class="line">        delta := int64(-1)</span><br><span class="line">        // inner loop</span><br><span class="line">        if delta &lt; 0 {</span><br><span class="line">            tb.rescheduling = true</span><br><span class="line">            goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, 1)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        tb.sleeping = true</span><br><span class="line">        tb.sleepUntil = now + delta</span><br><span class="line">        noteclear(&amp;tb.waitnote)</span><br><span class="line">        notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果距离下一个定时器被唤醒的时间小于 0，当前的 timerproc 就会将 rescheduling 标记设置成 true 并立刻陷入休眠，这其实也意味着当前 timerproc 中不包含任何待处理的定时器，当我们再向该 timerBucket 加入定时器时就会重新唤醒 timerproc Goroutine。</p>
<p>在其他情况下，也就是下一次计数器的响应时间是 now + delta 时，timerproc 中的外层循环会通过 notesleepg 将当前 Goroutine 陷入休眠。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func notetsleepg(n *note, ns int64) bool {</span><br><span class="line">    gp := getg()</span><br><span class="line">    if gp == gp.m.g0 {</span><br><span class="line">        throw("notetsleepg on g0")</span><br><span class="line">    }</span><br><span class="line">    semacreate(gp.m)</span><br><span class="line">    entersyscallblock()</span><br><span class="line">    ok := notetsleep_internal(n, ns, nil, 0)</span><br><span class="line">    exitsyscall()</span><br><span class="line">    return ok</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该函数会先获取当前的 Goroutine 并在当前的 CPU 上创建一个信号量，随后在 entersyscallblock 和 exitsyscall 之间执行系统调用让当前的 Goroutine 陷入休眠并在 ns 纳秒后返回。</p>
<p>内部循环的主要作用就是触发已经到期的定时器，在这个内部循环中，我们会按照以下的流程对当前桶中的定时器进行处理：</p>
<ul>
<li>如果桶中不包含任何定时器就会直接返回并陷入休眠等待定时器加入当前桶；</li>
<li>如果四叉树最上面的定时器还没有到期会通过 notetsleepg 方法陷入休眠等待最近定时器的到期；</li>
<li>如果四叉树最上面的定时器已经到期；</li>
<li>当定时器的 period &gt; 0 就会设置下一次会触发定时器的时间并将当前定时器向下移动到对应的位置；</li>
<li>当定时器的 period &lt;= 0 就会将当前定时器从四叉树中移除；</li>
<li>在每次循环的最后都会从定时器中取出定时器中的函数、参数和序列号并调用函数触发该计数器；</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for {</span><br><span class="line">    if len(tb.t) == 0 {</span><br><span class="line">        delta = -1</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">    t := tb.t[0]</span><br><span class="line">    delta = t.when - now</span><br><span class="line">    if delta &gt; 0 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">    ok := true</span><br><span class="line">    if t.period &gt; 0 {</span><br><span class="line">        t.when += t.period * (1 + -delta/t.period)</span><br><span class="line">        if !siftdownTimer(tb.t, 0) {</span><br><span class="line">            ok = false</span><br><span class="line">        }</span><br><span class="line">    } else {</span><br><span class="line">        last := len(tb.t) - 1</span><br><span class="line">        if last &gt; 0 {</span><br><span class="line">            tb.t[0] = tb.t[last]</span><br><span class="line">            tb.t[0].i = 0</span><br><span class="line">        }</span><br><span class="line">        tb.t[last] = nil</span><br><span class="line">        tb.t = tb.t[:last]</span><br><span class="line">        if last &gt; 0 {</span><br><span class="line">            if !siftdownTimer(tb.t, 0) {</span><br><span class="line">                ok = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        t.i = -1 // mark as removed</span><br><span class="line">    }</span><br><span class="line">    f := t.f</span><br><span class="line">    arg := t.arg</span><br><span class="line">    seq := t.seq</span><br><span class="line">    f(arg, seq)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 NewTimer 创建的定时器，传入的函数时 sendTime，它会将当前时间发送到定时器持有的 Channel 中，而使用 AfterFunc 创建的定时器，在内层循环中调用的函数就会是调用方传入的函数了。</p>
<h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><p>如果你使用过一段时间的Go语言，一定在项目中使用过 time 包中的 Sleep 方法让当前的 Goroutine 陷入休眠以等待某些条件的完成或者触发一些定时任务，time.Sleep 就是通过如下所示的 timeSleep 方法完成的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func timeSleep(ns int64) {</span><br><span class="line">    if ns &lt;= 0 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    gp := getg()</span><br><span class="line">    t := gp.timer</span><br><span class="line">    if t == nil {</span><br><span class="line">        t = new(timer)</span><br><span class="line">        gp.timer = t</span><br><span class="line">    }</span><br><span class="line">    *t = timer{}</span><br><span class="line">    t.when = nanotime() + ns</span><br><span class="line">    t.f = goroutineReady</span><br><span class="line">    t.arg = gp</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    if !tb.addtimerLocked(t) {</span><br><span class="line">        unlock(&amp;tb.lock)</span><br><span class="line">        badTimer()</span><br><span class="line">    }</span><br><span class="line">    goparkunlock(&amp;tb.lock, waitReasonSleep, traceEvGoSleep, 2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>timeSleep 会创建一个新的 timer 结构体，在初始化的过程中我们会传入当前 Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数 goroutineReady，随后会调用 goparkunlock 将当前 Goroutine 陷入休眠状态，当定时器到期时也会调用 goroutineReady 方法唤醒当前的 Goroutine：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func goroutineReady(arg interface{}, seq uintptr) {</span><br><span class="line">    goready(arg.(*g), 0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>time.Sleep 方法其实只是创建了一个会在到期时唤醒当前 Goroutine 的定时器并通过 goparkunlock 将当前的协程陷入休眠状态等待定时器触发的唤醒。</p>
<h4 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h4><p>除了只用于一次的定时器（Timer）之外，Go语言的 time 包中还提供了用于多次通知的 Ticker 计时器，计时器中包含了一个用于接受通知的 Channel 和一个定时器，这两个字段共同组成了用于连续多次触发事件的计时器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Ticker struct {</span><br><span class="line">    C &lt;-chan Time // The channel on which the ticks are delivered.</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>想要在Go语言中创建一个计时器只有两种方法，一种是使用 NewTicker 方法显示地创建 Ticker 计时器指针，另一种可以直接通过 Tick 方法获取一个会定期发送消息的 Channel：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewTicker(d Duration) *Ticker {</span><br><span class="line">    if d &lt;= 0 {</span><br><span class="line">        panic(errors.New("non-positive interval for NewTicker"))</span><br><span class="line">    }</span><br><span class="line">    c := make(chan Time, 1)</span><br><span class="line">    t := &amp;Ticker{</span><br><span class="line">        C: c,</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when:   when(d),</span><br><span class="line">            period: int64(d),</span><br><span class="line">            f:      sendTime,</span><br><span class="line">            arg:    c,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Tick(d Duration) &lt;-chan Time {</span><br><span class="line">    if d &lt;= 0 {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return NewTicker(d).C</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Tick 其实也只是对 NewTicker 的简单封装，从实现上我们就能看出来它其实就是调用了 NewTicker 获取了计时器并返回了计时器中 Channel，两个创建计时器的方法的实现都并不复杂而且费容易理解，所以在这里也就不详细展开介绍了。</p>
<p>需要注意的是每一个 NewTicker 方法开启的计时器都需要在不需要使用时调用 Stop 进行关闭，如果不显示调用 Stop 方法，创建的计时器就没有办法被垃圾回收，而通过 Tick 创建的计时器由于只对外提供了 Channel，所以是一定没有办法关闭的，我们一定要谨慎使用这一接口创建计时器。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>定时器在内部使用四叉树的方式进行实现和存储，当我们在生产环境中使用定时器进行毫秒级别的计时时，在高并发的场景下会有比较明显的性能问题，我们可以通过实验测试一下定时器在高并发时的性能，假设我们有以下的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func runTimers(count int) {</span><br><span class="line">    durationCh := make(chan time.Duration, count)</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup{}</span><br><span class="line">    wg.Add(count)</span><br><span class="line">    for i := 0; i &lt; count; i++ {</span><br><span class="line">        go func() {</span><br><span class="line">            startedAt := time.Now()</span><br><span class="line">            time.AfterFunc(10*time.Millisecond, func() {</span><br><span class="line">                defer wg.Done()</span><br><span class="line">                durationCh &lt;- time.Since(startedAt)</span><br><span class="line">            })</span><br><span class="line">        }()</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    close(durationCh)</span><br><span class="line"></span><br><span class="line">    durations := []time.Duration{}</span><br><span class="line">    totalDuration := 0 * time.Millisecond</span><br><span class="line">    for duration := range durationCh {</span><br><span class="line">        durations = append(durations, duration)</span><br><span class="line">        totalDuration += duration</span><br><span class="line">    }</span><br><span class="line">    averageDuration := totalDuration / time.Duration(count)</span><br><span class="line">    sort.Slice(durations, func(i, j int) bool {</span><br><span class="line">        return durations[i] &lt; durations[j]</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Printf("run %v timers with average=%v, pct50=%v, pct99=%v\n", count, averageDuration, durations[count/2], durations[int(float64(count)*0.99)])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：由于机器和性能的不同，多次运行测试可能会有不一样的结果。</strong></p>
<p>这段代码开了 N 个 Goroutine 并在每一个 Goroutine 中运行一个定时器，我们会在定时器到期时将开始计时到定时器到期所用的时间加入 Channel 并用于之后的统计，在函数的最后我们会计算出 N 个 Goroutine 中定时器到期时间的平均数、50 分位数和 99 分位数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ go test ./... -v</span><br><span class="line">=== RUN   TestTimers</span><br><span class="line">run 1000 timers with average=10.367111ms, pct50=10.234219ms, pct99=10.913219ms</span><br><span class="line">run 2000 timers with average=10.431598ms, pct50=10.37367ms, pct99=11.025823ms</span><br><span class="line">run 5000 timers with average=11.873773ms, pct50=11.986249ms, pct99=12.673725ms</span><br><span class="line">run 10000 timers with average=11.954716ms, pct50=12.313613ms, pct99=13.507858ms</span><br><span class="line">run 20000 timers with average=11.456237ms, pct50=10.625529ms, pct99=25.246254ms</span><br><span class="line">run 50000 timers with average=21.223818ms, pct50=14.792982ms, pct99=34.250143ms</span><br><span class="line">run 100000 timers with average=36.010924ms, pct50=31.794761ms, pct99=128.089527ms</span><br><span class="line">run 500000 timers with average=176.676498ms, pct50=138.238588ms, pct99=676.967558ms</span><br><span class="line">--- PASS: TestTimers (1.21s)</span><br></pre></td></tr></tbody></table></figure>
<p>我们将上述代码输出的结果绘制成如下图所示的折线图，其中横轴是并行定时器的个数，纵轴表示定时器从开始到触发时间的差值，三个不同的线分别表示时间的平均值、50 分位数和 99 分位数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerbranch.gif" alt="timerbranch"></p>
<p>虽然测试的数据可能有一些误差，但是从图中我们也能得出一些跟定时器性能和现象有关的结论：</p>
<ul>
<li>定时器触发的时间一定会晚于创建时传入的时间，假设定时器需要等待 10ms 触发，那它触发的时间一定是晚于 10ms 的；</li>
<li>当并发的定时器数量达到 5000 时，定时器的平均误差达到了 ~18%，99 分位数上的误差达到了 ~26%；</li>
<li>并发定时器的数量超过 5000 之后，定时器的误差就变得非常明显，不能有效、准确地完成计时任务；</li>
</ul>
<p>这其实也是因为定时器从开始到触发的时间间隔非常短，当我们将计时的时间改到 100ms 时就会发现性能问题有比较明显的改善：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerbranch2.gif" alt="timerbranch2"></p>
<p>哪怕并行运行了 10w 个定时器，99 分位数的误差也只有 ~12%，我们其实能够发现Go语言标准库中的定时器在计时时间较短并且并发较高时有着非常明显的问题，所以在一些性能非常敏感的基础服务中使用定时器一定要非常注意，它可能达不到我们预期的效果。</p>
<p>不过哪怕我们不主动使用定时器，而是使用 context.WithDeadline 这种方法，由于它底层也会使用定时器实现，所以仍然会受到影响。</p>
<h3 id="定时器总结"><a href="#定时器总结" class="headerlink" title="定时器总结"></a>定时器总结</h3><p>Go语言的定时器在并发编程起到了非常重要的作用，它能够为我们提供比较准确的相对时间，基于它的功能，标准库中还提供了计时器、休眠等接口能够帮助我们在Go语言程序中更好地处理过期和超时等问题。</p>
<p>标准库中的定时器在大多数情况下是能够正常工作并且高效完成任务的，但是在遇到极端情况或者性能敏感场景时，它可能没有办法胜任，而在 10ms 的这个粒度下，目前也没有找到能够使用的定时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>包</tag>
        <tag>package</tag>
        <tag>gopath</tag>
      </tags>
  </entry>
  <entry>
    <title>go 并发，Golang并发</title>
    <url>/posts/eae873a8/</url>
    <content><![CDATA[<p>并发指在同一时间内可以执行多个任务。并发编程含义比较广泛，包含多线程编程、多进程编程及分布式程序等。本章讲解的并发含义属于多线程编程。</p>
<p>Go 语言通过编译器运行时（runtime），从语言上支持了并发的特性。Go 语言的并发通过 goroutine 特性完成。goroutine 类似于线程，但是可以根据需要创建多个 goroutine 并发工作。goroutine 是由 Go 语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>Go 语言还提供 channel 在多个 goroutine 间进行通信。goroutine 和 channel 是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。本章中，将详细为大家讲解 goroutine 和 channel 及相关特性。</p>
<h2 id="并发简述（并发的优势）"><a href="#并发简述（并发的优势）" class="headerlink" title="并发简述（并发的优势）"></a>并发简述（并发的优势）</h2><p>有人把Go语言比作 21 世纪的C语言，第一是因为Go语言设计简单，第二则是因为 21 世纪最重要的就是并发程序设计，而 Go 从语言层面就支持并发。同时实现了自动垃圾回收机制。</p>
<p>Go语言的并发机制运用起来非常简便，在启动并发的方式上直接添加了语言级的关键字就可以实现，和其他编程语言相比更加轻量。</p>
<p>下面来介绍几个概念：</p>
<p><strong>进程/线程:</strong></p>
<p>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
<p>一个进程可以创建和撤销多个线程，同一个进程中的多个线程之间可以并发执行。</p>
<p><strong>并发/并行:</strong></p>
<p>多线程程序在单核心的 cpu 上运行，称为并发；多线程程序在多核心的 cpu 上运行，称为并行。</p>
<p>并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。</p>
<p><strong>协程/线程:</strong></p>
<p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。</p>
<p>线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>
<p>优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。使用Go语言开发服务器程序时，就需要对它的并发机制有深入的了解。</p>
<h3 id="Goroutine-介绍"><a href="#Goroutine-介绍" class="headerlink" title="Goroutine 介绍"></a>Goroutine 介绍</h3><p>goroutine 是一种非常轻量级的实现，可在单个进程里执行成千上万的并发任务，它是Go语言并发设计的核心。</p>
<p>说到底 goroutine 其实就是线程，但是它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，而且Go语言内部也实现了 goroutine 之间的内存共享。</p>
<p>使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。</p>
<p>goroutine 的用法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//go 关键字放在方法调用前新建一个 goroutine 并执行方法体</span><br><span class="line">go GetThingDone(param1, param2);</span><br><span class="line"></span><br><span class="line">//新建一个匿名方法并执行</span><br><span class="line">go func(param1, param2) {</span><br><span class="line">}(val1, val2)</span><br><span class="line"></span><br><span class="line">//直接新建一个 goroutine 并在 goroutine 中执行代码块</span><br><span class="line">go {</span><br><span class="line">    //do someting...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 goroutine 在多核 cpu 环境下是并行的，如果代码块在多个 goroutine 中执行，那么我们就实现了代码的并行。</p>
<p>如果需要了解程序的执行情况，怎么拿到并行的结果呢？需要配合使用channel进行。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel 是Go语言在语言级别提供的 goroutine 间的通信方式。我们可以使用 channel 在两个或多个 goroutine 之间传递消息。</p>
<p>channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go语言对于网络方面也有非常完善的支持。</p>
<p>channel 是类型相关的，也就是说，一个 channel 只能传递一种类型的值，这个类型需要在声明 channel 时指定。如果对 Unix 管道有所了解的话，就不难理解 channel，可以将其认为是一种类型安全的管道。</p>
<p>定义一个 channel 时，也需要定义发送到 channel 的值的类型，注意，必须使用 make 创建 channel，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ci := make(chan int)</span><br><span class="line">cs := make(chan string)</span><br><span class="line">cf := make(chan interface{})</span><br></pre></td></tr></tbody></table></figure>
<p>回到在 Windows 和 Linux 出现之前的古老年代，在开发程序时并没有并发的概念，因为命令式程序设计语言是以串行为基础的，程序会顺序执行每一条指令，整个程序只有一个执行上下文，即一个调用栈，一个堆。</p>
<p>并发则意味着程序在运行时有多个执行上下文，对应着多个调用栈。我们知道每一个进程在运行时，都有自己的调用栈和堆，有一个完整的上下文，而操作系统在调度进程的时候，会保存被调度进程的上下文环境，等该进程获得时间片后，再恢复该进程的上下文到系统中。</p>
<p>从整个操作系统层面来说，多个进程是可以并发的，那么并发的价值何在？下面我们先看以下几种场景。</p>
<p>1) 一方面我们需要灵敏响应的图形用户界面，一方面程序还需要执行大量的运算或者 IO 密集操作，而我们需要让界面响应与运算同时执行。</p>
<p>2) 当我们的 Web 服务器面对大量用户请求时，需要有更多的“Web 服务器工作单元”来分别响应用户。</p>
<p>3) 我们的事务处于分布式环境上，相同的工作单元在不同的计算机上处理着被分片的数据，计算机的 CPU 从单内核（core）向多内核发展，而我们的程序都是串行的，计算机硬件的能力没有得到发挥。</p>
<p>4) 我们的程序因为 IO 操作被阻塞，整个程序处于停滞状态，其他 IO 无关的任务无法执行。</p>
<p>从以上几个例子可以看到，串行程序在很多场景下无法满足我们的要求。下面我们归纳了并发程序的几条优点，让大家认识到并发势在必行：</p>
<ul>
<li>并发能更客观地表现问题模型；</li>
<li>并发可以充分利用 CPU 核心的优势，提高程序的执行效率；</li>
<li>并发能充分利用 CPU 与其他硬件设备固有的异步性。</li>
</ul>
<h2 id="goroutine（轻量级线程）"><a href="#goroutine（轻量级线程）" class="headerlink" title="goroutine（轻量级线程）"></a>goroutine（轻量级线程）</h2><p>在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。</p>
<p>虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go语言中被称为 goroutine。</p>
<p>goroutine 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。</p>
<p>Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。</p>
<h3 id="使用普通函数创建-goroutine"><a href="#使用普通函数创建-goroutine" class="headerlink" title="使用普通函数创建 goroutine"></a>使用普通函数创建 goroutine</h3><p>Go 程序中使用 go 关键字为一个函数创建一个 goroutine。一个函数可以被创建多个 goroutine，一个 goroutine 必定对应一个函数。</p>
<p><strong>1) 格式</strong></p>
<p>为一个普通函数创建 goroutine 的写法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go 函数名( 参数列表 )</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数名：要调用的函数名。</li>
<li>参数列表：调用函数需要传入的参数。</li>
</ul>
<p>使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。</p>
<p>如果需要在 goroutine 中返回数据，请使用后面介绍的通道（channel）特性，通过通道把数据从 goroutine 中作为返回值传出。</p>
<p><strong>2) 例子</strong></p>
<p>使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func running() {</span><br><span class="line"></span><br><span class="line">    var times int</span><br><span class="line">    // 构建一个无限循环</span><br><span class="line">    for {</span><br><span class="line">        times++</span><br><span class="line">        fmt.Println("tick", times)</span><br><span class="line"></span><br><span class="line">        // 延时1秒</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 并发执行程序</span><br><span class="line">    go running()</span><br><span class="line"></span><br><span class="line">    // 接受命令行输入, 不做任何事情</span><br><span class="line">    var input string</span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>命令行输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">tick 1</span><br><span class="line">tick 2</span><br><span class="line">tick 3</span><br><span class="line">tick 4</span><br><span class="line">tick 5</span><br></pre></td></tr></tbody></table></figure>
<p>代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。</p>
<p>代码说明如下：</p>
<ul>
<li>第 12 行，使用 for 形成一个无限循环。</li>
<li>第 13 行，times 变量在循环中不断自增。</li>
<li>第 14 行，输出 times 变量的值。</li>
<li>第 17 行，使用 time.Sleep 暂停 1 秒后继续循环。</li>
<li>第 25 行，使用 go 关键字让 running() 函数并发运行。</li>
<li>第 29 行，接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。</li>
</ul>
<p>这段代码的执行顺序如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goroutineexec.jpg" alt="图：并发运行图"></p>
<p>这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。</p>
<h3 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a>使用匿名函数创建goroutine</h3><p>go 关键字后也可以为匿名函数或闭包启动 goroutine。</p>
<p><strong>1) 使用匿名函数创建goroutine的格式</strong></p>
<p>使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go func( 参数列表 ){</span><br><span class="line">    函数体</span><br><span class="line">}( 调用参数列表 )</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>参数列表：函数体内的参数变量列表。</li>
<li>函数体：匿名函数的代码。</li>
<li>调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。</li>
</ul>
<p><strong>2) 使用匿名函数创建goroutine的例子</strong></p>
<p>在 main() 函数中创建一个匿名函数并为匿名函数启动 goroutine。匿名函数没有参数。代码将并行执行定时打印计数的效果。参见下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    go func() {</span><br><span class="line"></span><br><span class="line">        var times int</span><br><span class="line"></span><br><span class="line">        for {</span><br><span class="line">            times++</span><br><span class="line">            fmt.Println("tick", times)</span><br><span class="line"></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    var input string</span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，go 后面接匿名函数启动 goroutine。</li>
<li>第 12～19 行的逻辑与前面程序的 running() 函数一致。</li>
<li>第 21 行的括号的功能是调用匿名函数的参数列表。由于第 10 行的匿名函数没有参数，因此第 21 行的参数列表也是空的。</li>
</ul>
<p><strong>提示</strong></p>
<p>所有 goroutine 在 main() 函数结束时会一同结束。</p>
<p>goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。</p>
<p>终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。虽然可以用 golang.org/x/net/context 包进行 goroutine 生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。</p>
<p>截止 Go 1.9 版本，暂时没有标准接口获取 goroutine 的 ID。</p>
<h2 id="并发通信"><a href="#并发通信" class="headerlink" title="并发通信"></a>并发通信</h2><p>关键字 go 的引入使得在Go语言中并发编程变得简单而优雅，但我们同时也应该意识到并发编程的原生复杂性，并时刻对并发中容易出现的问题保持警惕。</p>
<p>事实上，不管是什么平台，什么编程语言，不管在哪，并发都是一个大话题。并发编程的难度在于协调，而协调就要通过交流，从这个角度看来，并发单元间的通信是最大的问题。</p>
<p>在工程上，有两种最常见的并发通信模型：共享数据和消息。</p>
<p>共享数据是指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。被共享的数据可能有多种形式，比如内存数据块、磁盘文件、网络数据等。在实际工程应用中最常见的无疑是内存了，也就是常说的共享内存。</p>
<p>先看看我们在C语言中通常是怎么处理线程间数据共享的，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void *count();</span><br><span class="line">pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">int counter = 0;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int rc1, rc2;</span><br><span class="line">    pthread_t thread1, thread2;</span><br><span class="line">    /* 创建线程，每个线程独立执行函数functionC */</span><br><span class="line">    if((rc1 = pthread_create(&amp;thread1, NULL, &amp;count, NULL)))</span><br><span class="line">    {</span><br><span class="line">        printf("Thread creation failed: %d\n", rc1);</span><br><span class="line">    }</span><br><span class="line">    if((rc2 = pthread_create(&amp;thread2, NULL, &amp;count, NULL)))</span><br><span class="line">    {</span><br><span class="line">        printf("Thread creation failed: %d\n", rc2);</span><br><span class="line">    }</span><br><span class="line">    /* 等待所有线程执行完毕 */</span><br><span class="line">    pthread_join( thread1, NULL);</span><br><span class="line">    pthread_join( thread2, NULL);</span><br><span class="line">    exit(0);</span><br><span class="line">}</span><br><span class="line">void *count()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock( &amp;mutex1 );</span><br><span class="line">    counter++;</span><br><span class="line">    printf("Counter value: %d\n",counter);</span><br><span class="line">    pthread_mutex_unlock( &amp;mutex1 );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们尝试将这段C语言代码直接翻译为Go语言代码，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line">var counter int = 0</span><br><span class="line">func Count(lock *sync.Mutex) {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    counter++</span><br><span class="line">    fmt.Println(counter)</span><br><span class="line">    lock.Unlock()</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    lock := &amp;sync.Mutex{}</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        go Count(lock)</span><br><span class="line">    }</span><br><span class="line">    for {</span><br><span class="line">        lock.Lock()</span><br><span class="line">        c := counter</span><br><span class="line">        lock.Unlock()</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        if c &gt;= 10 {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子中，我们在 10 个 goroutine 中共享了变量 counter。每个 goroutine 执行完成后，会将 counter 的值加 1。因为 10 个 goroutine 是并发执行的，所以我们还引入了锁，也就是代码中的 lock 变量。每次对 n 的操作，都要先将锁锁住，操作完成后，再将锁打开。</p>
<p>在 main 函数中，使用 for 循环来不断检查 counter 的值（同样需要加锁）。当其值达到 10 时，说明所有 goroutine 都执行完毕了，这时主函数返回，程序退出。</p>
<p>事情好像开始变得糟糕了。实现一个如此简单的功能，却写出如此臃肿而且难以理解的代码。想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多 C/C++ 开发者正在经历的，其实 Java 和 C# 开发者也好不到哪里去。</p>
<p>Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享内存作为通信方式。</p>
<p>消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。这有点类似于进程的概念，每个进程不会被其他进程打扰，它只做好自己的工作就可以了。不同进程间靠消息来通信，它们不会共享内存。</p>
<p>Go语言提供的消息通信机制被称为 channel，关于 channel 的介绍将在后续的学习中为大家讲解。</p>
<h2 id="竞争状态简述"><a href="#竞争状态简述" class="headerlink" title="竞争状态简述"></a>竞争状态简述</h2><p>有并发，就有资源竞争，如果两个或者多个 goroutine 在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写时，就会处于相互竞争的状态，这就是并发中的资源竞争。</p>
<p>并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。</p>
<p>下面的代码中就会出现竞争状态：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line">var (</span><br><span class="line">    count int32</span><br><span class="line">    wg    sync.WaitGroup</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go incCount()</span><br><span class="line">    go incCount()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">}</span><br><span class="line">func incCount() {</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        value := count</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        value++</span><br><span class="line">        count = value</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这是一个资源竞争的例子，大家可以将程序多运行几次，会发现结果可能是 2，也可以是 3，还可能是 4。这是因为 count 变量没有任何同步保护，所以两个 goroutine 都会对其进行读写，会导致对已经计算好的结果被覆盖，以至于产生错误结果。</p>
<p>代码中的 <code>runtime.Gosched()</code> 是让当前 goroutine 暂停的意思，退回执行队列，让其他等待的 goroutine 运行，目的是为了使资源竞争的结果更明显。</p>
<p>下面我们来分析一下程序的运行过程，将两个 goroutine 分别假设为 g1 和 g2：</p>
<ul>
<li>g1 读取到 count 的值为 0；</li>
<li>然后 g1 暂停了，切换到 g2 运行，g2 读取到 count 的值也为 0；</li>
<li>g2 暂停，切换到 g1，g1 对 count+1，count 的值变为 1；</li>
<li>g1 暂停，切换到 g2，g2 刚刚已经获取到值 0，对其 +1，最后赋值给 count，其结果还是 1；</li>
<li>可以看出 g1 对 count+1 的结果被 g2 给覆盖了，两个 goroutine 都 +1 而结果还是 1。</li>
</ul>
<p>通过上面的分析可以看出，之所以出现上面的问题，是因为两个 goroutine 相互覆盖结果。</p>
<p>所以我们对于同一个资源的读写必须是原子化的，也就是说，同一时间只能允许有一个 goroutine 对共享资源进行读写操作。</p>
<p>共享资源竞争的问题，非常复杂，并且难以察觉，好在 Go 为我们提供了一个工具帮助我们检查，这个就是 <code>go build -race</code> 命令。在项目目录下执行这个命令，生成一个可以执行文件，然后再运行这个可执行文件，就可以看到打印出的检测信息。</p>
<p>在 <code>go build</code> 命令中多加了一个 <code>-race</code> 标志，这样生成的可执行程序就自带了检测资源竞争的功能，运行生成的可执行文件，效果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at 0x000000619cbc by goroutine 8:</span><br><span class="line">  main.incCount()</span><br><span class="line">      D:/code/src/main.go:25 +0x80</span><br><span class="line"></span><br><span class="line">Previous write at 0x000000619cbc by goroutine 7:</span><br><span class="line">  main.incCount()</span><br><span class="line">      D:/code/src/main.go:28 +0x9f</span><br><span class="line"></span><br><span class="line">Goroutine 8 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      D:/code/src/main.go:17 +0x7e</span><br><span class="line"></span><br><span class="line">Goroutine 7 (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      D:/code/src/main.go:16 +0x66</span><br><span class="line">==================</span><br><span class="line">4</span><br><span class="line">Found 1 data race(s)</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出 <code>goroutine 8</code> 在代码 25 行读取共享资源 <code>value := count</code> ，而这时 <code>goroutine 7</code> 在代码 28 行修改共享资源 <code>count = value</code> ，而这两个 goroutine 都是从 main 函数的 16、17 行通过 go 关键字启动的。</p>
<h3 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a>锁住共享资源</h3><p>Go语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。atomic 和 sync 包里的一些函数就可以对共享的资源进行加锁操作。</p>
<p><strong>原子函数</strong></p>
<p>原子函数能够以很底层的加锁机制来同步访问整型变量和指针，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">    "sync/atomic"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    counter int64</span><br><span class="line">    wg      sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go incCounter(1)</span><br><span class="line">    go incCounter(2)</span><br><span class="line"></span><br><span class="line">    wg.Wait() //等待goroutine结束</span><br><span class="line">    fmt.Println(counter)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func incCounter(id int) {</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for count := 0; count &lt; 2; count++ {</span><br><span class="line">        atomic.AddInt64(&amp;counter, 1) //安全的对counter加1</span><br><span class="line"></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中使用了 atmoic 包的 AddInt64 函数，这个函数会同步整型值的加法，方法是强制同一时刻只能有一个 gorountie 运行并完成这个加法操作。当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理。</p>
<p>另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。下面是代码就使用了 LoadInt64 和 StoreInt64 函数来创建一个同步标志，这个标志可以向程序里多个 goroutine 通知某个特殊状态。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "sync/atomic"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    shutdown int64</span><br><span class="line">    wg       sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wg.Add(2)</span><br><span class="line"></span><br><span class="line">    go doWork("A")</span><br><span class="line">    go doWork("B")</span><br><span class="line"></span><br><span class="line">    time.Sleep(1 * time.Second)</span><br><span class="line">    fmt.Println("Shutdown Now")</span><br><span class="line">    atomic.StoreInt64(&amp;shutdown, 1)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func doWork(name string) {</span><br><span class="line">    defer wg.Done()</span><br><span class="line"></span><br><span class="line">    for {</span><br><span class="line">        fmt.Printf("Doing %s Work\n", name)</span><br><span class="line">        time.Sleep(250 * time.Millisecond)</span><br><span class="line"></span><br><span class="line">        if atomic.LoadInt64(&amp;shutdown) == 1 {</span><br><span class="line">            fmt.Printf("Shutting %s Down\n", name)</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中 main 函数使用 StoreInt64 函数来安全地修改 shutdown 变量的值。如果哪个 doWork goroutine 试图在 main 函数调用 StoreInt64 的同时调用 LoadInt64 函数，那么原子函数会将这些调用互相同步，保证这些操作都是安全的，不会进入竞争状态。</p>
<p><strong>互斥锁</strong></p>
<p>另一种同步访问共享资源的方式是使用互斥锁，互斥锁这个名字来自互斥的概念。互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界代码。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    counter int64</span><br><span class="line">    wg      sync.WaitGroup</span><br><span class="line">    mutex   sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wg.Add(2)</span><br><span class="line"></span><br><span class="line">    go incCounter(1)</span><br><span class="line">    go incCounter(2)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(counter)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func incCounter(id int) {</span><br><span class="line">    defer wg.Done()</span><br><span class="line"></span><br><span class="line">    for count := 0; count &lt; 2; count++ {</span><br><span class="line">        //同一时刻只允许一个goroutine进入这个临界区</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        {</span><br><span class="line">            value := counter</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">            value++</span><br><span class="line">            counter = value</span><br><span class="line">        }</span><br><span class="line">        mutex.Unlock() //释放锁，允许其他正在等待的goroutine进入临界区</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同一时刻只有一个 goroutine 可以进入临界区。之后直到调用 Unlock 函数之后，其他 goroutine 才能进去临界区。当调用 runtime.Gosched 函数强制将当前 goroutine 退出当前线程后，调度器会再次分配这个 goroutine 继续运行。</p>
<h2 id="GOMAXPROCS（调整并发的运行性能）"><a href="#GOMAXPROCS（调整并发的运行性能）" class="headerlink" title="GOMAXPROCS（调整并发的运行性能）"></a>GOMAXPROCS（调整并发的运行性能）</h2><p>在 Go语言程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 <code>runtime.GOMAXPROCS()</code> 函数做到，格式为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br></pre></td></tr></tbody></table></figure>
<p>这里的逻辑CPU数量可以有如下几种数值：</p>
<ul>
<li>&lt;1：不修改任何数值。</li>
<li>=1：单核心执行。</li>
<li><blockquote>
<p>1：多核并发执行。</p>
</blockquote>
</li>
</ul>
<p>一般情况下，可以使用 <code>runtime.NumCPU()</code> 查询 CPU 数量，并使用 <code>runtime.GOMAXPROCS()</code> 函数进行设置，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></tbody></table></figure>
<p>Go 1.5 版本之前，默认使用的是单核心执行。从 Go 1.5 版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用 CPU。</p>
<p>GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。</p>
<h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>在讲解并发概念时，总会涉及另外一个概念并行。下面让我们来了解并发和并行之间的区别。</p>
<ul>
<li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li>
<li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li>
</ul>
<p>并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。</p>
<p>在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，也是指导 Go语言设计的哲学。</p>
<p>如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。</p>
<p>下图展示了在一个逻辑处理器上并发运行 goroutine 和在两个逻辑处理器上并行运行两个并发的 goroutine 之间的区别。调度器包含一些聪明的算法，这些算法会随着 Go语言的发布被更新和改进，所以不推荐盲目修改语言运行时对逻辑处理器的默认设置。如果真的认为修改逻辑处理器的数量可以改进性能，也可以对语言运行时的参数进行细微调整。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/concurrency.gif" alt="图：并发与并行的区别"></p>
<p>Go语言在 GOMAXPROCS 数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。</p>
<h3 id="goroutine和coroutine的区别"><a href="#goroutine和coroutine的区别" class="headerlink" title="goroutine和coroutine的区别"></a>goroutine和coroutine的区别</h3><p>C#、Lua、Python 语言都支持 coroutine 特性。coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p>
<ul>
<li>goroutine 可能发生并行执行；</li>
<li>但 coroutine 始终顺序执行。</li>
</ul>
<p>goroutines 意味着并行（或者可以以并行的方式部署），coroutines 一般来说不是这样的，goroutines 通过通道来通信；coroutines 通过让出和恢复操作来通信，goroutines 比 coroutines 更强大，也很容易从 coroutines 的逻辑复用到 goroutines。</p>
<p>狭义地说，goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持；coroutine 始终发生在单线程，coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。</p>
<p>goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。</p>
<p>goroutine 和 coroutine 的概念和运行机制都是脱胎于早期的操作系统。</p>
<p>coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。</p>
<p>goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。</p>
<h2 id="通道（chan）——goroutine之间通信的管道"><a href="#通道（chan）——goroutine之间通信的管道" class="headerlink" title="通道（chan）——goroutine之间通信的管道"></a>通道（chan）——goroutine之间通信的管道</h2><p>如果说 goroutine 是 Go语言程序的并发体的话，那么 channels 就是它们之间的通信机制。一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。</p>
<p>Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p>
<p>这里通信的方法就是使用通道（channel），如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goroutineandchannel.jpg" alt="图：goroutine 与 channel 的通信"></p>
<h3 id="通道的特性"><a href="#通道的特性" class="headerlink" title="通道的特性"></a>通道的特性</h3><p>Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。</p>
<p>通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p>
<h3 id="声明通道类型"><a href="#声明通道类型" class="headerlink" title="声明通道类型"></a>声明通道类型</h3><p>通道本身需要一个类型进行修饰，就像切片类型需要标识元素类型。通道的元素类型就是在其内部传输的数据类型，声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 通道变量 chan 通道类型</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通道类型：通道内的数据类型。</li>
<li>通道变量：保存通道的变量。</li>
</ul>
<p><strong>chan 类型的空值是 nil，声明后需要配合 make 后才能使用。</strong></p>
<h3 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a>创建通道</h3><p>通道是引用类型，需要使用 make 进行创建，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">通道实例 := make(chan 数据类型)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>数据类型：通道内传输的元素类型。</li>
<li>通道实例：通过make创建的通道句柄。</li>
</ul>
<p>请看下面的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ch1 := make(chan int)                 // 创建一个整型类型的通道</span><br><span class="line">ch2 := make(chan interface{})         // 创建一个空接口类型的通道, 可以存放任意格式</span><br><span class="line"></span><br><span class="line">type Equip struct{ /* 一些字段 */ }</span><br><span class="line">ch2 := make(chan *Equip)             // 创建Equip指针类型的通道, 可以存放*Equip</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用通道发送数据"><a href="#使用通道发送数据" class="headerlink" title="使用通道发送数据"></a>使用通道发送数据</h3><p>通道创建后，就可以使用通道进行发送和接收操作。</p>
<p><strong>1) 通道发送数据的格式</strong></p>
<p>通道的发送使用特殊的操作符 <code>&lt;-</code> ，将数据通过通道发送的格式为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">通道变量 &lt;- 值</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通道变量：通过make创建好的通道实例。</li>
<li>值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。</li>
</ul>
<p><strong>2) 通过通道发送数据的例子</strong></p>
<p>使用 make 创建一个通道后，就可以使用 <code>&lt;-</code> 向通道发送数据，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个空接口通道</span><br><span class="line">ch := make(chan interface{})</span><br><span class="line">// 将0放入通道中</span><br><span class="line">ch &lt;- 0</span><br><span class="line">// 将hello字符串放入通道中</span><br><span class="line">ch &lt;- "hello"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 发送将持续阻塞直到数据被接收</strong></p>
<p>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个整型通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 尝试将0通过通道发送</span><br><span class="line">    ch &lt;- 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>
<p>报错的意思是：运行时发现所有的 goroutine（包括main）都处于等待 goroutine。也就是说所有 goroutine 中的 channel 并没有形成发送和接收对应的代码。</p>
<h2 id="使用通道接收数据"><a href="#使用通道接收数据" class="headerlink" title="使用通道接收数据"></a>使用通道接收数据</h2><p>通道接收同样使用 <code>&lt;-</code> 操作符，通道接收有如下特性：</p>
<p>① 通道的收发操作在不同的两个 goroutine 间进行。</p>
<p>由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行。</p>
<p>② 接收将持续阻塞直到发送方发送数据。</p>
<p>如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。</p>
<p>③ 每次接收一个元素。<br>通道一次只能接收一个数据元素。</p>
<p>通道的数据接收一共有以下 4 种写法</p>
<p><strong>1) 阻塞接收数据</strong></p>
<p>阻塞模式接收数据时，将接收变量作为 <code>&lt;-</code> 操作符的左值，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">data := &lt;-ch</span><br></pre></td></tr></tbody></table></figure>
<p>执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。</p>
<p><strong>2) 非阻塞接收数据</strong></p>
<p>使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">data, ok := &lt;-ch</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。</li>
<li>ok：表示是否接收到数据。</li>
</ul>
<p>非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，可以参见后面的内容。</p>
<p><strong>3) 接收任意数据，忽略接收的数据</strong></p>
<p>阻塞接收数据后，忽略从通道返回的数据，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></tbody></table></figure>
<p>执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。</p>
<p>使用通道做并发同步的写法，可以参考下面的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 构建一个通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 开启一个并发匿名函数</span><br><span class="line">    go func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("start goroutine")</span><br><span class="line"></span><br><span class="line">        // 通过通道通知main的goroutine</span><br><span class="line">        ch &lt;- 0</span><br><span class="line"></span><br><span class="line">        fmt.Println("exit goroutine")</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    fmt.Println("wait goroutine")</span><br><span class="line"></span><br><span class="line">    // 等待匿名goroutine</span><br><span class="line">    &lt;-ch</span><br><span class="line"></span><br><span class="line">    fmt.Println("all done")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wait goroutine</span><br><span class="line">start goroutine</span><br><span class="line">exit goroutine</span><br><span class="line">all done</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，构建一个同步用的通道。</li>
<li>第 13 行，开启一个匿名函数的并发。</li>
<li>第 18 行，匿名 goroutine 即将结束时，通过通道通知 main 的 goroutine，这一句会一直阻塞直到 main 的 goroutine 接收为止。</li>
<li>第 27 行，开启 goroutine 后，马上通过通道等待匿名 goroutine 结束。</li>
</ul>
<p><strong>4) 循环接收</strong></p>
<p>通道的数据接收可以借用 <code>for range</code> 语句进行多个元素的接收操作，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for data := range ch {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过 for 遍历获得的变量只有一个，即上面例子中的 data。</p>
<p>遍历通道数据的例子请参考下面的代码。</p>
<p>使用 for 从通道中接收数据：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line"></span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 构建一个通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 开启一个并发匿名函数</span><br><span class="line">    go func() {</span><br><span class="line"></span><br><span class="line">        // 从3循环到0</span><br><span class="line">        for i := 3; i &gt;= 0; i-- {</span><br><span class="line"></span><br><span class="line">            // 发送3到0之间的数值</span><br><span class="line">            ch &lt;- i</span><br><span class="line"></span><br><span class="line">            // 每次发送完时等待</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    // 遍历接收通道数据</span><br><span class="line">    for data := range ch {</span><br><span class="line"></span><br><span class="line">        // 打印通道数据</span><br><span class="line">        fmt.Println(data)</span><br><span class="line"></span><br><span class="line">        // 当遇到数据0时, 退出接收循环</span><br><span class="line">        if data == 0 {</span><br><span class="line">                break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 12 行，通过 make 生成一个整型元素的通道。</li>
<li>第 15 行，将匿名函数并发执行。</li>
<li>第 18 行，用循环生成 3 到 0 之间的数值。</li>
<li>第 21 行，将 3 到 0 之间的数值依次发送到通道 ch 中。</li>
<li>第 24 行，每次发送后暂停 1 秒。</li>
<li>第 30 行，使用 for 从通道中接收数据。</li>
<li>第 33 行，将接收到的数据打印出来。</li>
<li>第 36 行，当接收到数值 0 时，停止接收。如果继续发送，由于接收 goroutine 已经退出，没有 goroutine 发送到通道，因此运行时将会触发宕机报错。</li>
</ul>
<h2 id="并发打印（借助通道实现）"><a href="#并发打印（借助通道实现）" class="headerlink" title="并发打印（借助通道实现）"></a>并发打印（借助通道实现）</h2><p>前面的例子创建的都是无缓冲通道。使用无缓冲通道往里面装入数据时，装入方将被阻塞，直到另外通道在另外一个 goroutine 中被取出。同样，如果通道中没有放入任何数据，接收方试图从通道中获取数据时，同样也是阻塞。发送和接收的操作是同步完成的。</p>
<p>下面通过一个并发打印的例子，将 goroutine 和 channel 放在一起展示它们的用法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printer(c chan int) {</span><br><span class="line"></span><br><span class="line">    // 开始无限循环等待数据</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 从channel中获取一个数据</span><br><span class="line">        data := &lt;-c</span><br><span class="line"></span><br><span class="line">        // 将0视为数据结束</span><br><span class="line">        if data == 0 {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 打印数据</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通知main已经结束循环(我搞定了!)</span><br><span class="line">    c &lt;- 0</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个channel</span><br><span class="line">    c := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 并发执行printer, 传入channel</span><br><span class="line">    go printer(c)</span><br><span class="line"></span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line"></span><br><span class="line">        // 将数据通过channel投送给printer</span><br><span class="line">        c &lt;- i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通知并发的printer结束循环(没数据啦!)</span><br><span class="line">    c &lt;- 0</span><br><span class="line"></span><br><span class="line">    // 等待printer结束(搞定喊我!)</span><br><span class="line">    &lt;-c</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，创建一个无限循环，只有当第 16 行获取到的数据为 0 时才会退出循环。</li>
<li>第 13 行，从函数参数传入的通道中获取一个整型数值。</li>
<li>第 21 行，打印整型数值。</li>
<li>第 25 行，在退出循环时，通过通道通知 main() 函数已经完成工作。</li>
<li>第 32 行，创建一个整型通道进行跨 goroutine 的通信。</li>
<li>第 35 行，创建一个 goroutine，并发执行 printer() 函数。</li>
<li>第 37 行，构建一个数值循环，将 1～10 的数通过通道传送给 printer 构造出的 goroutine。</li>
<li>第 44 行，给通道传入一个 0，表示将前面的数据处理完成后，退出循环。</li>
<li>第 47 行，在数据发送过去后，因为并发和调度的原因，任务会并发执行。这里需要等待 printer 的第 25 行返回数据后，才可以退出 main()。</li>
</ul>
<p>本例的设计模式就是典型的生产者和消费者。生产者是第 37 行的循环，而消费者是 printer() 函数。整个例子使用了两个 goroutine，一个是 main()，一个是通过第 35 行 printer() 函数创建的 goroutine。两个 goroutine 通过第 32 行创建的通道进行通信。这个通道有下面两重功能。</p>
<ul>
<li>数据传送：第 40 行中发送数据和第 13 行接收数据。</li>
<li><p>控制指令：类似于信号量的功能。同步 goroutine 的操作。功能简单描述为：</p>
<ul>
<li>第 44 行：“没数据啦！”</li>
<li>第 25 行：“我搞定了！”</li>
<li>第 47 行：“搞定喊我！”</li>
</ul>
</li>
</ul>
<h2 id="单向通道——通道中的单行道"><a href="#单向通道——通道中的单行道" class="headerlink" title="单向通道——通道中的单行道"></a>单向通道——通道中的单行道</h2><p>Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 就是只能用于写入或者只能用于读取数据。当然 channel 本身必然是同时支持读写的，否则根本没法用。</p>
<p>假如一个 channel 真的只能读取数据，那么它肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写入数据，即使写进去了，也没有丝毫意义，因为没有办法读取到里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。</p>
<h3 id="单向通道的声明格式"><a href="#单向通道的声明格式" class="headerlink" title="单向通道的声明格式"></a>单向通道的声明格式</h3><p>我们在将一个 channel 变量传递到一个函数时，可以通过将其指定为单向 channel 变量，从而限制该函数中可以对此 channel 的操作，比如只能往这个 channel 中写入数据，或者只能从这个 channel 读取数据。</p>
<p>单向 channel 变量的声明非常简单，只能写入数据的通道类型为 <code>chan&lt;-</code> ，只能读取数据的通道类型为 <code>&lt;-chan</code> ，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 通道实例 chan&lt;- 元素类型    // 只能写入数据的通道</span><br><span class="line">var 通道实例 &lt;-chan 元素类型    // 只能读取数据的通道</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>元素类型：通道包含的元素类型。</li>
<li>通道实例：声明的通道变量。</li>
</ul>
<h3 id="单向通道的使用例子"><a href="#单向通道的使用例子" class="headerlink" title="单向通道的使用例子"></a>单向通道的使用例子</h3><p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">// 声明一个只能写入数据的通道类型, 并赋值为ch</span><br><span class="line">var chSendOnly chan&lt;- int = ch</span><br><span class="line">//声明一个只能读取数据的通道类型, 并赋值为ch</span><br><span class="line">var chRecvOnly &lt;-chan int = ch</span><br></pre></td></tr></tbody></table></figure>
<p>上面的例子中，chSendOnly 只能写入数据，如果尝试读取数据，将会出现如下报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">invalid operation: &lt;-chSendOnly (receive from send-only type chan&lt;- int)</span><br></pre></td></tr></tbody></table></figure>
<p>同理，chRecvOnly 也是不能写入数据的。</p>
<p>当然，使用 make 创建通道时，也可以创建一个只写入或只读取的通道：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ch := make(&lt;-chan int)</span><br><span class="line">var chReadOnly &lt;-chan int = ch</span><br><span class="line">&lt;-chReadOnly</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码编译正常，运行也是正确的。但是，一个不能写入数据只能读取的通道是毫无意义的。</p>
<h3 id="time包中的单向通道"><a href="#time包中的单向通道" class="headerlink" title="time包中的单向通道"></a>time包中的单向通道</h3><p>time 包中的计时器会返回一个 timer 实例，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br></pre></td></tr></tbody></table></figure>
<p>timer的Timer类型定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Timer struct {</span><br><span class="line">    C &lt;-chan Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 2 行中 C 通道的类型就是一种只能读取的单向通道。如果此处不进行通道方向约束，一旦外部向通道写入数据，将会造成其他使用到计时器的地方逻辑产生混乱。</p>
<p>因此，单向通道有利于代码接口的严谨性。</p>
<h3 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h3><p>关闭 channel 非常简单，直接使用Go语言内置的 close() 函数即可：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></tbody></table></figure>
<p>在介绍了如何关闭 channel 之后，我们就多了一个问题：如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">x, ok := &lt;-ch</span><br></pre></td></tr></tbody></table></figure>
<p>这个用法与 map 中的按键获取 value 的过程比较类似，只需要看第二个 bool 返回值即可，如果返回值是 false 则表示 ch 已经被关闭。</p>
<h2 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h2><p>Go语言中无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。</p>
<p>如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p>阻塞指的是由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。</p>
<p>同步指的是在两个或多个协程（线程）之间，保持数据内容一致性的机制。</p>
<p>下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/unbufferedchannel.gif" alt="图：使用无缓冲的通道在 goroutine 之间同步"></p>
<p>在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。</p>
<p>在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。在第 4 步和第 5 步，进行交换，并最终在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。</p>
<p>为了讲得更清楚，让我们来看两个完整的例子。这两个例子都会使用无缓冲的通道在两个 goroutine 之间同步交换数据。</p>
<p>【示例 1】在网球比赛中，两位选手会把球在两个人之间来回传递。选手总是处在以下两种状态之一，要么在等待接球，要么将球打向对方。可以使用两个 goroutine 来模拟网球比赛，并使用无缓冲的通道来模拟球的来回，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 这个示例程序展示如何用无缓冲的通道来模拟</span><br><span class="line">// 2 个goroutine 间的网球比赛</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/rand"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// wg 用来等待程序结束</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// main 是所有Go 程序的入口</span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个无缓冲的通道</span><br><span class="line">    court := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 计数加 2，表示要等待两个goroutine</span><br><span class="line">    wg.Add(2)</span><br><span class="line"></span><br><span class="line">    // 启动两个选手</span><br><span class="line">    go player("Nadal", court)</span><br><span class="line">    go player("Djokovic", court)</span><br><span class="line"></span><br><span class="line">    // 发球</span><br><span class="line">    court &lt;- 1</span><br><span class="line"></span><br><span class="line">    // 等待游戏结束</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// player 模拟一个选手在打网球</span><br><span class="line">func player(name string, court chan int) {</span><br><span class="line">    // 在函数退出时调用Done 来通知main 函数工作已经完成</span><br><span class="line">    defer wg.Done()</span><br><span class="line"></span><br><span class="line">    for {</span><br><span class="line">        // 等待球被击打过来</span><br><span class="line">        ball, ok := &lt;-court</span><br><span class="line">        if !ok {</span><br><span class="line">            // 如果通道被关闭，我们就赢了</span><br><span class="line">            fmt.Printf("Player %s Won\n", name)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 选随机数，然后用这个数来判断我们是否丢球</span><br><span class="line">        n := rand.Intn(100)</span><br><span class="line">        if n%13 == 0 {</span><br><span class="line">            fmt.Printf("Player %s Missed\n", name)</span><br><span class="line"></span><br><span class="line">            // 关闭通道，表示我们输了</span><br><span class="line">            close(court)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 显示击球数，并将击球数加1</span><br><span class="line">        fmt.Printf("Player %s Hit %d\n", name, ball)</span><br><span class="line">        ball++</span><br><span class="line"></span><br><span class="line">        // 将球打向对手</span><br><span class="line">        court &lt;- ball</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行这个程序，输出结果如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Player Nadal Hit 1</span><br><span class="line">Player Djokovic Hit 2</span><br><span class="line">Player Nadal Hit 3</span><br><span class="line">Player Djokovic Missed</span><br><span class="line">Player Nadal Won</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 22 行，创建了一个 int 类型的无缓冲的通道，让两个 goroutine 在击球时能够互相同步。</li>
<li>第 28 行和第 29 行，创建了参与比赛的两个 goroutine。在这个时候，两个 goroutine 都阻塞住等待击球。</li>
<li>第 32 行，将球发到通道里，程序开始执行这个比赛，直到某个 goroutine 输掉比赛。</li>
<li>第 43 行可以找到一个无限循环的 for 语句。在这个循环里，是玩游戏的过程。</li>
<li>第 45 行，goroutine 从通道接收数据，用来表示等待接球。这个接收动作会锁住 goroutine，直到有数据发送到通道里。通道的接收动作返回时。</li>
<li>第 46 行会检测 ok 标志是否为 false。如果这个值是 false，表示通道已经被关闭，游戏结束。</li>
<li>第 53 行到第 60 行，会产生一个随机数，用来决定 goroutine 是否击中了球。</li>
<li>第 58 行如果某个 goroutine 没有打中球，关闭通道。之后两个 goroutine 都会返回，通过 defer 声明的 Done 会被执行，程序终止。</li>
<li>第 64 行，如果击中了球 ball 的值会递增 1，并在第 67 行，将 ball 作为球重新放入通道，发送给另一位选手。在这个时刻，两个 goroutine 都会被锁住，直到交换完成。</li>
</ul>
<p>【示例 2】用不同的模式，使用无缓冲的通道，在 goroutine 之间同步数据，来模拟接力比赛。在接力比赛里，4 个跑步者围绕赛道轮流跑。第二个、第三个和第四个跑步者要接到前一位跑步者的接力棒后才能起跑。比赛中最重要的部分是要传递接力棒，要求同步传递。在同步接力棒的时候，参与接力的两个跑步者必须在同一时刻准备好交接。代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 这个示例程序展示如何用无缓冲的通道来模拟</span><br><span class="line">// 4 个goroutine 间的接力比赛</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// wg 用来等待程序结束</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">// main 是所有Go 程序的入口</span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个无缓冲的通道</span><br><span class="line">    baton := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 为最后一位跑步者将计数加1</span><br><span class="line">    wg.Add(1)</span><br><span class="line"></span><br><span class="line">    // 第一位跑步者持有接力棒</span><br><span class="line">    go Runner(baton)</span><br><span class="line"></span><br><span class="line">    // 开始比赛</span><br><span class="line">    baton &lt;- 1</span><br><span class="line"></span><br><span class="line">    // 等待比赛结束</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Runner 模拟接力比赛中的一位跑步者</span><br><span class="line">func Runner(baton chan int) {</span><br><span class="line">    var newRunner int</span><br><span class="line"></span><br><span class="line">    // 等待接力棒</span><br><span class="line">    runner := &lt;-baton</span><br><span class="line"></span><br><span class="line">    // 开始绕着跑道跑步</span><br><span class="line">    fmt.Printf("Runner %d Running With Baton\n", runner)</span><br><span class="line"></span><br><span class="line">    // 创建下一位跑步者</span><br><span class="line">    if runner != 4 {</span><br><span class="line">        newRunner = runner + 1</span><br><span class="line">        fmt.Printf("Runner %d To The Line\n", newRunner)</span><br><span class="line">        go Runner(baton)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 围绕跑道跑</span><br><span class="line">    time.Sleep(100 * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    // 比赛结束了吗？</span><br><span class="line">    if runner == 4 {</span><br><span class="line">        fmt.Printf("Runner %d Finished, Race Over\n", runner)</span><br><span class="line">        wg.Done()</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将接力棒交给下一位跑步者</span><br><span class="line">    fmt.Printf("Runner %d Exchange With Runner %d\n",</span><br><span class="line">        runner,</span><br><span class="line">        newRunner)</span><br><span class="line"></span><br><span class="line">    baton &lt;- newRunner</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行这个程序，输出结果如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Runner 1 Running With Baton</span><br><span class="line">Runner 1 To The Line</span><br><span class="line">Runner 1 Exchange With Runner 2</span><br><span class="line">Runner 2 Running With Baton</span><br><span class="line">Runner 2 To The Line</span><br><span class="line">Runner 2 Exchange With Runner 3</span><br><span class="line">Runner 3 Running With Baton</span><br><span class="line">Runner 3 To The Line</span><br><span class="line">Runner 3 Exchange With Runner 4</span><br><span class="line">Runner 4 Running With Baton</span><br><span class="line">Runner 4 Finished, Race Over</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 17 行，创建了一个无缓冲的 int 类型的通道 baton，用来同步传递接力棒。</li>
<li>第 20 行，我们给 WaitGroup 加 1，这样 main 函数就会等最后一位跑步者跑步结束。</li>
<li>第 23 行创建了一个 goroutine，用来表示第一位跑步者来到跑道。</li>
<li>第 26 行，将接力棒交给这个跑步者，比赛开始。</li>
<li>第 29 行，main 函数阻塞在 WaitGroup，等候最后一位跑步者完成比赛。</li>
<li>第 37 行，goroutine 对 baton 通道执行接收操作，表示等候接力棒。</li>
<li>第 46 行，一旦接力棒传了进来，就会创建一位新跑步者，准备接力下一棒，直到 goroutine 是第四个跑步者。</li>
<li>第 50 行，跑步者围绕跑道跑 100 ms。</li>
<li>第 55 行，如果第四个跑步者完成了比赛，就调用 Done，将 WaitGroup 减 1，之后 goroutine 返回。</li>
<li>第 64 行，如果这个 goroutine 不是第四个跑步者，接力棒会交到下一个已经在等待的跑步者手上。在这个时候，goroutine 会被锁住，直到交接完成。</li>
</ul>
<p>在这两个例子里，我们使用无缓冲的通道同步 goroutine，模拟了网球和接力赛。代码的流程与这两个活动在真实世界中的流程完全一样，这样的代码很容易读懂。</p>
<p>现在知道了无缓冲的通道是如何工作的，下一节我们将为大家介绍带缓冲的通道。</p>
<h2 id="带缓冲的通道"><a href="#带缓冲的通道" class="headerlink" title="带缓冲的通道"></a>带缓冲的通道</h2><p>Go语言中有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p>
<p>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p>
<p>在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。</p>
<p>无缓冲通道保证收发过程同步。无缓冲收发过程类似于快递员给你电话让你下楼取快递，整个递交快递的过程是同步发生的，你和快递员不见不散。但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就成了异步收发过程，效率可以有明显的提升。带缓冲的通道就是这样的一个“快递柜”。</p>
<h3 id="创建带缓冲通道"><a href="#创建带缓冲通道" class="headerlink" title="创建带缓冲通道"></a>创建带缓冲通道</h3><p>如何创建带缓冲的通道呢？参见如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">通道实例 := make(chan 通道类型, 缓冲大小)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。</li>
<li>缓冲大小：决定通道最多可以保存的元素数量。</li>
<li>通道实例：被创建出的通道实例。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个3个元素缓冲大小的整型通道</span><br><span class="line">    ch := make(chan int, 3)</span><br><span class="line"></span><br><span class="line">    // 查看当前通道的大小</span><br><span class="line">    fmt.Println(len(ch))</span><br><span class="line"></span><br><span class="line">    // 发送3个整型元素到通道</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">    ch &lt;- 2</span><br><span class="line">    ch &lt;- 3</span><br><span class="line"></span><br><span class="line">    // 查看当前通道的大小</span><br><span class="line">    fmt.Println(len(ch))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，创建一个带有 3 个元素缓冲大小的整型类型的通道。</li>
<li>第 11 行，查看当前通道的大小。带缓冲的通道在创建完成时，内部的元素是空的，因此使用 len() 获取到的返回值为 0。</li>
<li>第 14～16 行，发送 3 个整型元素到通道。因为使用了缓冲通道。即便没有 goroutine 接收，发送者也不会发生阻塞。</li>
<li>第 19 行，由于填充了 3 个通道，此时的通道长度变为 3。</li>
</ul>
<h3 id="阻塞条件"><a href="#阻塞条件" class="headerlink" title="阻塞条件"></a>阻塞条件</h3><p>带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：</p>
<ul>
<li>带缓冲通道被填满时，尝试再次发送数据时发生阻塞。</li>
<li>带缓冲通道为空时，尝试接收数据时发生阻塞。</li>
</ul>
<p><strong>为什么Go语言对通道要限制长度而不提供无限长度的通道？</strong></p>
<p>我们知道通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。</p>
<h2 id="channel超时机制"><a href="#channel超时机制" class="headerlink" title="channel超时机制"></a>channel超时机制</h2><p>Go语言没有提供直接的超时处理机制，所谓超时可以理解为当我们上网浏览一些网站时，如果一段时间之后不作操作，就需要重新登录。</p>
<p>那么我们应该如何实现这一功能呢，这时就可以使用 select 来设置超时。</p>
<p>虽然 select 机制不是专门为超时而设计的，却能很方便的解决超时问题，因为 select 的特点是只要其中有一个 case 已经完成，程序就会继续往下执行，而不会考虑其他 case 的情况。</p>
<p>超时机制本身虽然也会带来一些问题，比如在运行比较快的机器或者高速的网络上运行正常的程序，到了慢速的机器或者网络上运行就会出问题，从而出现结果不一致的现象，但从根本上来说，解决死锁问题的价值要远大于所带来的问题。</p>
<p>select 的用法与 switch 语言非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。</p>
<p>与 switch 语句相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">select {</span><br><span class="line">    case &lt;-chan1:</span><br><span class="line">    // 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="line">    case chan2 &lt;- 1:</span><br><span class="line">    // 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="line">    default:</span><br><span class="line">    // 如果上面都没有成功，则进入default处理流程</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。</p>
<p>如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。</p>
<p>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：</p>
<ul>
<li>如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复；</li>
<li>如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。</li>
</ul>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    quit := make(chan bool)</span><br><span class="line"></span><br><span class="line">    //新开一个协程</span><br><span class="line">    go func() {</span><br><span class="line">        for {</span><br><span class="line">            select {</span><br><span class="line">            case num := &lt;-ch:</span><br><span class="line">                fmt.Println("num = ", num)</span><br><span class="line">            case &lt;-time.After(3 * time.Second):</span><br><span class="line">                fmt.Println("超时")</span><br><span class="line">                quit &lt;- true</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }() //别忘了()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    &lt;-quit</span><br><span class="line">    fmt.Println("程序结束")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">num =  0</span><br><span class="line">num =  1</span><br><span class="line">num =  2</span><br><span class="line">num =  3</span><br><span class="line">num =  4</span><br><span class="line">超时</span><br><span class="line">程序结束</span><br></pre></td></tr></tbody></table></figure>
<h2 id="通道的多路复用——同时处理接收和发送多个通道的数据"><a href="#通道的多路复用——同时处理接收和发送多个通道的数据" class="headerlink" title="通道的多路复用——同时处理接收和发送多个通道的数据"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/101.html">通道的多路复用——同时处理接收和发送多个通道的数据</a></h2><p>多路复用是通信和网络中的一个专业术语。多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。</p>
<p><strong>提示</strong></p>
<p>报话机同一时刻只能有一边进行收或者发的单边通信，报话机需要遵守的通信流程如下：</p>
<ul>
<li>说话方在完成时需要补上一句“完毕”，随后放开通话按钮，从发送切换到接收状态，收听对方说话。</li>
<li>收听方在听到对方说“完毕”时，按下通话按钮，从接收切换到发送状态，开始说话。</li>
</ul>
<p>电话可以在说话的同时听到对方说话，所以电话是一种多路复用的设备，一条通信线路上可以同时接收或者发送数据。同样的，网线、光纤也都是基于多路复用模式来设计的，网线、光纤不仅可支持同时收发数据，还支持多个人同时收发数据。</p>
<p>在使用通道时，想同时接收多个通道的数据是一件困难的事情。通道在接收数据时，如果没有数据可以接收将会发生阻塞。虽然可以使用如下模式进行遍历，但运行性能会非常差。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for{</span><br><span class="line">    // 尝试接收ch1通道</span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    // 尝试接收ch2通道</span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    // 接收后续通道</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言中提供了 select 关键字，可以同时响应多个通道的操作。select 的用法与 switch 语句非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。</p>
<p>与 switch 语句可以选择任何可使用相等比较的条件相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">select{</span><br><span class="line">    case 操作1:</span><br><span class="line">        响应操作1</span><br><span class="line">    case 操作2:</span><br><span class="line">        响应操作2</span><br><span class="line">    …</span><br><span class="line">    default:</span><br><span class="line">        没有操作情况</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>操作1、操作2：包含通道收发语句，请参考下表。</p>
<table>
    <caption>select多路复用中可以接收的样式</caption>
    <thead><tr><th>操&nbsp;作</th><th>语句示例</th></tr></thead>
    <tbody>
        <tr><td>接收任意数据</td><td>case&nbsp;&lt;-ch;</td></tr>
        <tr><td>接收变量</td><td>case d:=&nbsp;&lt;-ch;</td></tr>
        <tr><td>发送数据</td><td>case ch&lt;-100;</td></tr>
    </tbody>
</table>

<p>响应操作1、响应操作2：当操作发生时，会执行对应 case 的响应操作。<br>default：当没有任何操作时，默认执行 default 中的语句。</p>
<p>可以看出，select 不像 switch，后面并不带判断条件，而是直接去查看 case 语句。每个 case 语句都必须是一个面向 channel 的操作。</p>
<p>基于此功能，我们可以实现一个有趣的程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ch := make(chan int, 1)</span><br><span class="line">for {</span><br><span class="line">    select {</span><br><span class="line">        case ch &lt;- 0:</span><br><span class="line">        case ch &lt;- 1:</span><br><span class="line">    }</span><br><span class="line">    i := &lt;-ch</span><br><span class="line">    fmt.Println("Value received:", i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>能看明白这段代码的含义吗？其实很简单，这个程序实现了一个随机向 ch 中写入一个 0 或者 1 的过程。当然，这是个死循环。</p>
<h2 id="RPC模拟远程过程调用"><a href="#RPC模拟远程过程调用" class="headerlink" title="RPC模拟远程过程调用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/102.html">RPC模拟远程过程调用</a></h2><p>服务器开发中会使用RPC（Remote Procedure Call，远程过程调用）简化进程间通信的过程。RPC 能有效地封装通信过程，让远程的数据收发通信过程看起来就像本地的函数调用一样。</p>
<p>本例中，使用通道代替 Socket 实现 RPC 的过程。客户端与服务器运行在同一个进程，服务器和客户端在两个 goroutine 中运行。</p>
<p>我们先给出完整代码，然后再详细分析每一个部分。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 模拟RPC客户端的请求和接收消息封装</span><br><span class="line">func RPCClient(ch chan string, req string) (string, error) {</span><br><span class="line"></span><br><span class="line">    // 向服务器发送请求</span><br><span class="line">    ch &lt;- req</span><br><span class="line"></span><br><span class="line">    // 等待服务器返回</span><br><span class="line">    select {</span><br><span class="line">    case ack := &lt;-ch: // 接收到服务器返回数据</span><br><span class="line">        return ack, nil</span><br><span class="line">    case &lt;-time.After(time.Second): // 超时</span><br><span class="line">        return "", errors.New("Time out")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 模拟RPC服务器端接收客户端请求和回应</span><br><span class="line">func RPCServer(ch chan string) {</span><br><span class="line">    for {</span><br><span class="line">        // 接收客户端请求</span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        // 打印接收到的数据</span><br><span class="line">        fmt.Println("server received:", data)</span><br><span class="line"></span><br><span class="line">        // 反馈给客户端收到</span><br><span class="line">        ch &lt;- "roger"</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个无缓冲字符串通道</span><br><span class="line">    ch := make(chan string)</span><br><span class="line"></span><br><span class="line">    // 并发执行服务器逻辑</span><br><span class="line">    go RPCServer(ch)</span><br><span class="line"></span><br><span class="line">    // 客户端请求数据和接收数据</span><br><span class="line">    recv, err := RPCClient(ch, "hi")</span><br><span class="line">    if err != nil {</span><br><span class="line">        // 发生错误打印</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        // 正常接收到数据</span><br><span class="line">        fmt.Println("client received", recv)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="客户端请求和接收封装"><a href="#客户端请求和接收封装" class="headerlink" title="客户端请求和接收封装"></a>客户端请求和接收封装</h3><p>下面的代码封装了向服务器请求数据，等待服务器返回数据，如果请求方超时，该函数还会处理超时逻辑。</p>
<p>模拟 RPC 的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 模拟RPC客户端的请求和接收消息封装</span><br><span class="line">func RPCClient(ch chan string, req string) (string, error) {</span><br><span class="line"></span><br><span class="line">    // 向服务器发送请求</span><br><span class="line">    ch &lt;- req</span><br><span class="line"></span><br><span class="line">    // 等待服务器返回</span><br><span class="line">    select {</span><br><span class="line">    case ack := &lt;-ch:  // 接收到服务器返回数据</span><br><span class="line">        return ack, nil</span><br><span class="line">    case &lt;-time.After(time.Second):  // 超时</span><br><span class="line">        return "", errors.New("Time out")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行，模拟 socket 向服务器发送一个字符串信息。服务器接收后，结束阻塞执行下一行。</li>
<li>第 8 行，使用 select 开始做多路复用。注意，select 虽然在写法上和 switch 一样，都可以拥有 case 和 default。但是 select 关键字后面不接任何语句，而是将要复用的多个通道语句写在每一个 case 上，如第 9 行和第 11 行所示。</li>
<li>第 11 行，使用了 time 包提供的函数 After()，从字面意思看就是多少时间之后，其参数是 time 包的一个常量，time.Second 表示 1 秒。time.After 返回一个通道，这个通道在指定时间后，通过通道返回当前时间。</li>
<li>第 12 行，在超时时，返回超时错误。</li>
</ul>
<p>RPCClient() 函数中，执行到 select 语句时，第 9 行和第 11 行的通道操作会同时开启。如果第 9 行的通道先返回，则执行第 10 行逻辑，表示正常接收到服务器数据；如果第 11 行的通道先返回，则执行第 12 行的逻辑，表示请求超时，返回错误。</p>
<h3 id="服务器接收和反馈数据"><a href="#服务器接收和反馈数据" class="headerlink" title="服务器接收和反馈数据"></a>服务器接收和反馈数据</h3><p>服务器接收到客户端的任意数据后，先打印再通过通道返回给客户端一个固定字符串，表示服务器已经收到请求。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 模拟RPC服务器端接收客户端请求和回应</span><br><span class="line">func RPCServer(ch chan string) {</span><br><span class="line">    for {</span><br><span class="line">        // 接收客户端请求</span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        // 打印接收到的数据</span><br><span class="line">        fmt.Println("server received:", data)</span><br><span class="line"></span><br><span class="line">        //向客户端反馈已收到</span><br><span class="line">        ch &lt;- "roger"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，构造出一个无限循环。服务器处理完客户端请求后，通过无限循环继续处理下一个客户端请求。</li>
<li>第 5 行，通过字符串通道接收一个客户端的请求。</li>
<li>第 8 行，将接收到的数据打印出来。</li>
<li>第 11 行，给客户端反馈一个字符串。</li>
</ul>
<p>运行整个程序，客户端可以正确收到服务器返回的数据，客户端 RPCClient() 函数的代码按下面代码中加粗部分的分支执行。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 等待服务器返回</span><br><span class="line">select {</span><br><span class="line">case ack := &lt;-ch:  // 接收到服务器返回数据</span><br><span class="line">    return ack, nil</span><br><span class="line">case &lt;-time.After(time.Second):  // 超时</span><br><span class="line">    return "", errors.New("Time out")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server received: hi</span><br><span class="line">client received roger</span><br></pre></td></tr></tbody></table></figure>
<h3 id="模拟超时"><a href="#模拟超时" class="headerlink" title="模拟超时"></a>模拟超时</h3><p>上面的例子虽然有客户端超时处理，但是永远不会触发，因为服务器的处理速度很快，也没有真正的网络延时或者“服务器宕机”的情况。因此，为了展示 select 中超时的处理，在服务器逻辑中增加一条语句，故意让服务器延时处理一段时间，造成客户端请求超时，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 模拟RPC服务器端接收客户端请求和回应</span><br><span class="line">func RPCServer(ch chan string) {</span><br><span class="line">    for {</span><br><span class="line">        // 接收客户端请求</span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        // 打印接收到的数据</span><br><span class="line">        fmt.Println("server received:", data)</span><br><span class="line"></span><br><span class="line">        // 通过睡眠函数让程序执行阻塞2秒的任务</span><br><span class="line">        time.Sleep(time.Second * 2)</span><br><span class="line"></span><br><span class="line">        // 反馈给客户端收到</span><br><span class="line">        ch &lt;- "roger"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 11 行中，time.Sleep() 函数会让 goroutine 执行暂停 2 秒。使用这种方法模拟服务器延时，造成客户端超时。客户端处理超时 1 秒时通道就会返</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 等待服务器返回</span><br><span class="line">select {</span><br><span class="line">case ack := &lt;-ch:  // 接收到服务器返回数据</span><br><span class="line">    return ack, nil</span><br><span class="line">case &lt;-time.After(time.Second):  // 超时</span><br><span class="line">    return "", errors.New("Time out")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>主流程中会创建一个无缓冲的字符串格式通道。将通道传给服务器的 RPCServer() 函数，这个函数并发执行。使用 RPCClient() 函数通过 ch 对服务器发出 RPC 请求，同时接收服务器反馈数据或者等待超时。参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个无缓冲字符串通道</span><br><span class="line">    ch := make(chan string)</span><br><span class="line"></span><br><span class="line">    // 并发执行服务器逻辑</span><br><span class="line">    go RPCServer(ch)</span><br><span class="line"></span><br><span class="line">    // 客户端请求数据和接收数据</span><br><span class="line">    recv, err := RPCClient(ch, "hi")</span><br><span class="line">    if err != nil {</span><br><span class="line">            // 发生错误打印</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">            // 正常接收到数据</span><br><span class="line">        fmt.Println("client received", recv)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，创建无缓冲的字符串通道，这个通道用于模拟网络和 socke t概念，既可以从通道接收数据，也可以发送。</li>
<li>第 7 行，并发执行服务器逻辑。服务器一般都是独立进程的，这里使用并发将服务器和客户端逻辑同时在一个进程内运行。</li>
<li>第 10 行，使用 RPCClient() 函数，发送“hi”给服务器，同步等待服务器返回。</li>
<li>第 13 行，如果通信过程发生错误，打印错误。</li>
<li>第 16 行，正常接收时，打印收到的数据。</li>
</ul>
<h2 id="使用通道响应计时器的事件"><a href="#使用通道响应计时器的事件" class="headerlink" title="使用通道响应计时器的事件"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/103.html">使用通道响应计时器的事件</a></h2><p>Go语言中的 time 包提供了计时器的封装。由于 Go语言中的通道和 goroutine 的设计，定时任务可以在 goroutine 中通过同步的方式完成，也可以通过在 goroutine 中异步回调完成。这里将分两种用法进行例子展示。</p>
<h3 id="一段时间之后（time-After）"><a href="#一段时间之后（time-After）" class="headerlink" title="一段时间之后（time.After）"></a>一段时间之后（time.After）</h3><p>延迟回调：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个退出用的通道</span><br><span class="line">    exit := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 打印开始</span><br><span class="line">    fmt.Println("start")</span><br><span class="line"></span><br><span class="line">    // 过1秒后, 调用匿名函数</span><br><span class="line">    time.AfterFunc(time.Second, func() {</span><br><span class="line"></span><br><span class="line">        // 1秒后, 打印结果</span><br><span class="line">        fmt.Println("one second after")</span><br><span class="line"></span><br><span class="line">        // 通知main()的goroutine已经结束</span><br><span class="line">        exit &lt;- 0</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 等待结束</span><br><span class="line">    &lt;-exit</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，声明一个退出用的通道，往这个通道里写数据表示退出。</li>
<li>第 16 行，调用 time.AfterFunc() 函数，传入等待的时间和一个回调。回调使用一个匿名函数，在时间到达后，匿名函数会在另外一个 goroutine 中被调用。</li>
<li>第 22 行，任务完成后，往退出通道中写入数值表示需要退出。</li>
<li>第 26 行，运行到此处时持续阻塞，直到 1 秒后第 22 行被执行后结束阻塞。</li>
</ul>
<p>time.AfterFunc() 函数是在 time.After 基础上增加了到时的回调，方便使用。</p>
<p>而 time.After() 函数又是在 time.NewTimer() 函数上进行的封装，下面的例子展示如何使用 timer.NewTimer() 和 time.NewTicker()。</p>
<h3 id="定点计时"><a href="#定点计时" class="headerlink" title="定点计时"></a>定点计时</h3><p>计时器（Timer）的原理和倒计时闹钟类似，都是给定多少时间后触发。打点器（Ticker）的原理和钟表类似，钟表每到整点就会触发。这两种方法创建后会返回 time.Ticker 对象和 time.Timer 对象，里面通过一个 C 成员，类型是只能接收的时间通道（&lt;-chan Time），使用这个通道就可以获得时间触发的通知。</p>
<p>下面代码创建一个打点器，每 500 毫秒触发一起；创建一个计时器，2 秒后触发，只触发一次。</p>
<p>计时器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个打点器, 每500毫秒触发一次</span><br><span class="line">    ticker := time.NewTicker(time.Millisecond * 500)</span><br><span class="line"></span><br><span class="line">    // 创建一个计时器, 2秒后触发</span><br><span class="line">    stopper := time.NewTimer(time.Second * 2)</span><br><span class="line"></span><br><span class="line">    // 声明计数变量</span><br><span class="line">    var i int</span><br><span class="line"></span><br><span class="line">    // 不断地检查通道情况</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 多路复用通道</span><br><span class="line">        select {</span><br><span class="line">        case &lt;-stopper.C:  // 计时器到时了</span><br><span class="line"></span><br><span class="line">            fmt.Println("stop")</span><br><span class="line"></span><br><span class="line">            // 跳出循环</span><br><span class="line">            goto StopHere</span><br><span class="line"></span><br><span class="line">        case &lt;-ticker.C:  // 打点器触发了</span><br><span class="line">            // 记录触发了多少次</span><br><span class="line">            i++</span><br><span class="line">            fmt.Println("tick", i)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 退出的标签, 使用goto跳转</span><br><span class="line">StopHere:</span><br><span class="line">    fmt.Println("done")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，创建一个打点器，500 毫秒触发一次，返回 *time.Ticker 类型变量。</li>
<li>第 14 行，创建一个计时器，2 秒后返回，返回 *time.Timer 类型变量。</li>
<li>第 17 行，声明一个变量，用于累计打点器触发次数。</li>
<li>第 20 行，每次触发后，select 会结束，需要使用循环再次从打点器返回的通道中获取触发通知。</li>
<li>第 23 行，同时等待多路计时器信号。</li>
<li>第 24 行，计时器信号到了。</li>
<li>第 29 行，通过 goto 跳出循环。</li>
<li>第 31 行，打点器信号到了，通过i自加记录触发次数并打印。</li>
</ul>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\chebada.com\main&gt;go run gotimerticker.go</span><br><span class="line">tick 1</span><br><span class="line">tick 2</span><br><span class="line">tick 3</span><br><span class="line">tick 4</span><br><span class="line">stop</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>
<h2 id="关闭通道后继续使用通道"><a href="#关闭通道后继续使用通道" class="headerlink" title="关闭通道后继续使用通道"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/104.html">关闭通道后继续使用通道</a></h2><p>通道是一个引用对象，和 map 类似。map 在没有任何外部引用时，Go语言程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection, GC）。类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>使用 close() 来关闭一个通道：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></tbody></table></figure>
<p>关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。</p>
<h3 id="给被关闭通道发送数据将会触发-panic"><a href="#给被关闭通道发送数据将会触发-panic" class="headerlink" title="给被关闭通道发送数据将会触发 panic"></a>给被关闭通道发送数据将会触发 panic</h3><p>被关闭的通道不会被置为 nil。如果尝试对已经关闭的通道进行发送，将会触发宕机，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个整型的通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 关闭通道</span><br><span class="line">    close(ch)</span><br><span class="line"></span><br><span class="line">    // 打印通道的指针, 容量和长度</span><br><span class="line">    fmt.Printf("ptr:%p cap:%d len:%d\n", ch, cap(ch), len(ch))</span><br><span class="line"></span><br><span class="line">    // 给关闭的通道发送数据</span><br><span class="line">    ch &lt;- 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行后触发宕机：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: send on closed channel</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，创建一个整型通道。</li>
<li>第 10 行，关闭通道，注意 ch 不会被 close 设置为 nil，依然可以被访问。</li>
<li>第 13 行，打印已经关闭通道的指针、容量和长度。</li>
<li>第 16 行，尝试给已经关闭的通道发送数据。</li>
</ul>
<p>提示触发宕机的原因是给一个已经关闭的通道发送数据。</p>
<h3 id="从已关闭的通道接收数据时将不会发生阻塞"><a href="#从已关闭的通道接收数据时将不会发生阻塞" class="headerlink" title="从已关闭的通道接收数据时将不会发生阻塞"></a>从已关闭的通道接收数据时将不会发生阻塞</h3><p>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。</p>
<p>操作关闭后的通道：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个整型带两个缓冲的通道</span><br><span class="line">    ch := make(chan int, 2)</span><br><span class="line"></span><br><span class="line">    // 给通道放入两个数据</span><br><span class="line">    ch &lt;- 0</span><br><span class="line">    ch &lt;- 1</span><br><span class="line"></span><br><span class="line">    // 关闭缓冲</span><br><span class="line">    close(ch)</span><br><span class="line"></span><br><span class="line">    // 遍历缓冲所有数据, 且多遍历1个</span><br><span class="line">    for i := 0; i &lt; cap(ch)+1; i++ {</span><br><span class="line"></span><br><span class="line">        // 从通道中取出数据</span><br><span class="line">        v, ok := &lt;-ch</span><br><span class="line"></span><br><span class="line">        // 打印取出数据的状态</span><br><span class="line">        fmt.Println(v, ok)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 true</span><br><span class="line">1 true</span><br><span class="line">0 false</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，创建一个能保存两个元素的带缓冲的通道，类型为整型。</li>
<li>第 10 行和第11行，给这个带缓冲的通道放入两个数据。这时，通道装满了。</li>
<li>第 14 行，关闭通道。此时，带缓冲通道的数据不会被释放，通道也没有消失。</li>
<li>第 17 行，cap() 函数可以获取一个对象的容量，这里获取的是带缓冲通道的容量，也就是这个通道在 make 时的大小。虽然此时这个通道的元素个数和容量都是相同的，但是 cap 取出的并不是元素个数。这里多遍历一个元素，故意造成这个通道的超界访问。</li>
<li>第 20 行，从已关闭的通道中获取数据，取出的数据放在 v 变量中，类型为 int。ok 变量的结果表示数据是否获取成功。</li>
<li>第 23 行，将 v 和 ok 变量打印出来。</li>
</ul>
<p>运行结果前两行正确输出带缓冲通道的数据，表明缓冲通道在关闭后依然可以访问内部的数据。</p>
<p>运行结果第三行的“0 false”表示通道在关闭状态下取出的值。0 表示这个通道的默认值，false 表示没有获取成功，因为此时通道已经空了。我们发现，在通道关闭后，即便通道没有数据，在获取时也不会发生阻塞，但此时取出数据会失败。</p>
<h2 id="多核并行化"><a href="#多核并行化" class="headerlink" title="多核并行化"></a>多核并行化</h2><p>Go语言具有支持高并发的特性，可以很方便地实现多线程运算，充分利用多核心 cpu 的性能。</p>
<p>众所周知服务器的处理器大都是单核频率较低而核心数较多，对于支持高并发的程序语言，可以充分利用服务器的多核优势，从而降低单核压力，减少性能浪费。</p>
<p>Go语言实现多核多线程并发运行是非常方便的，下面举个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        go AsyncFunc(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func AsyncFunc(index int) {</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 10000; i++ {</span><br><span class="line">        sum += 1</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf("线程%d, sum为:%d\n", index, sum)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">线程0, sum为:10000</span><br><span class="line">线程2, sum为:10000</span><br><span class="line">线程3, sum为:10000</span><br><span class="line">线程1, sum为:10000</span><br><span class="line">线程4, sum为:10000</span><br></pre></td></tr></tbody></table></figure>
<p>在执行一些昂贵的计算任务时，我们希望能够尽量利用现代服务器普遍具备的多核特性来尽量将任务并行化，从而达到降低总计算时间的目的。此时我们需要了解 CPU 核心的数量，并针对性地分解计算任务到多个 goroutine 中去并行运行。</p>
<p>下面我们来模拟一个完全可以并行的计算任务：计算 N 个整型数的总和。我们可以将所有整型数分成 M 份，M 即 CPU 的个数。让每个 CPU 开始计算分给它的那份计算任务，最后将每个 CPU 的计算结果再做一次累加，这样就可以得到所有 N 个整型数的总和：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Vector []float64</span><br><span class="line">// 分配给每个CPU的计算任务</span><br><span class="line">func (v Vector) DoSome(i, n int, u Vector, c chan int) {</span><br><span class="line">    for ; i &lt; n; i++ {</span><br><span class="line">        v[i] += u.Op(v[i])</span><br><span class="line">    }</span><br><span class="line">    c &lt;- 1 // 发信号告诉任务管理者我已经计算完成了</span><br><span class="line">}</span><br><span class="line">const NCPU = 16 // 假设总共有16核</span><br><span class="line">func (v Vector) DoAll(u Vector) {</span><br><span class="line">    c := make(chan int, NCPU) // 用于接收每个CPU的任务完成信号</span><br><span class="line">    for i := 0; i &lt; NCPU; i++ {</span><br><span class="line">        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)</span><br><span class="line">    }</span><br><span class="line">    // 等待所有CPU的任务完成</span><br><span class="line">    for i := 0; i &lt; NCPU; i++ {</span><br><span class="line">        &lt;-c // 获取到一个数据，表示一个CPU计算完成了</span><br><span class="line">    }</span><br><span class="line">    // 到这里表示所有计算已经结束</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这两个函数看起来设计非常合理，其中 DoAll() 会根据 CPU 核心的数目对任务进行分割，然后开辟多个 goroutine 来并行执行这些计算任务。</p>
<p>是否可以将总的计算时间降到接近原来的 1/N 呢？答案是不一定。如果掐秒表，会发现总的执行时间没有明显缩短。再去观察 CPU 运行状态，你会发现尽管我们有 16 个 CPU 核心，但在计算过程中其实只有一个 CPU 核心处于繁忙状态，这是会让很多Go语言初学者迷惑的问题。</p>
<p>官方给出的答案是，这是当前版本的 Go 编译器还不能很智能地去发现和利用多核的优势。虽然我们确实创建了多个 goroutine，并且从运行状态看这些 goroutine 也都在并行运行，但实际上所有这些 goroutine 都运行在同一个 CPU 核心上，在一个 goroutine 得到时间片执行的时候，其他 goroutine 都会处于等待状态。从这一点可以看出，虽然 goroutine 简化了我们写并行代码的过程，但实际上整体运行效率并不真正高于单线程程序。</p>
<p>虽然Go语言还不能很好的利用多核心的优势，我们可以先通过设置环境变量 GOMAXPROCS 的值来控制使用多少个 CPU 核心。具体操作方法是通过直接设置环境变量 GOMAXPROCS 的值，或者在代码中启动 goroutine 之前先调用以下这个语句以设置使用 16 个 CPU 核心：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">runtime.GOMAXPROCS(16)</span><br></pre></td></tr></tbody></table></figure>
<p>到底应该设置多少个 CPU 核心呢，其实 runtime 包中还提供了另外一个 NumCPU() 函数来获取核心数，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">cpuNum := runtime.NumCPU() //获得当前设备的cpu核心数</span><br><span class="line">fmt.Println("cpu核心数:", cpuNum)</span><br><span class="line"></span><br><span class="line">runtime.GOMAXPROCS(cpuNum) //设置需要用到的cpu数量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cpu核心数: 4</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Telnet回音服务器——TCP服务器的基本结构"><a href="#Telnet回音服务器——TCP服务器的基本结构" class="headerlink" title="Telnet回音服务器——TCP服务器的基本结构"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/105.html">Telnet回音服务器——TCP服务器的基本结构</a></h2><p>Telnet 协议是 TCP/IP 协议族中的一种。它允许用户（Telnet 客户端）通过一个协商过程与一个远程设备进行通信。本例将使用一部分 Telnet 协议与服务器进行通信。</p>
<p>服务器的网络库为了完整展示自己的代码实现了完整的收发过程，一般比较倾向于使用发送任意封包返回原数据的逻辑。这个过程类似于对着大山高喊，大山把你的声音原样返回的过程。也就是回音（Echo）。本节使用 Go语言中的 Socket、goroutine 和通道编写一个简单的 Telnet 协议的回音服务器。</p>
<p>回音服务器的代码分为 4 个部分，分别是接受连接、会话处理、Telnet 命令处理和程序入口。</p>
<h3 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h3><p>回音服务器能同时服务于多个连接。要接受连接就需要先创建侦听器，侦听器需要一个侦听地址和协议类型。就像你想卖东西，需要先确认卖什么东西，卖东西的类型就是协议类型，然后需要一个店面，店面位于街区的某个位置，这就是侦听器的地址。一个服务器可以开启多个侦听器，就像一个街区可以有多个店面。街区上的编号对应的就是地址中的端口号，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ipandprot.jpg" alt="图：IP和端口号"></p>
<ul>
<li>主机 IP：一般为一个 IP 地址或者域名，127.0.0.1 表示本机地址。</li>
<li>端口号：16 位无符号整型值，一共有 65536 个有效端口号。</li>
</ul>
<p>通过地址和协议名创建侦听器后，可以使用侦听器响应客户端连接。响应连接是一个不断循环的过程，就像到银行办理业务时，一般是排队处理，前一个人办理完后，轮到下一个人办理。</p>
<p>我们把每个客户端连接处理业务的过程叫做会话。在会话中处理的操作和接受连接的业务并不冲突可以同时进行。就像银行有 3 个窗口，喊号器会将用户分配到不同的柜台。这里的喊号器就是 Accept 操作，窗口的数量就是 CPU 的处理能力。因此，使用 goroutine 可以轻松实现会话处理和接受连接的并发执行。</p>
<p>如下图清晰地展现了这一过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/socket.jpg" alt="图：Socket 处理过程"></p>
<p>Go语言中可以根据实际会话数量创建多个 goroutine，并自动的调度它们的处理。</p>
<p>telnet 服务器处理：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "net"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 服务逻辑, 传入地址和退出的通道</span><br><span class="line">func server(address string, exitChan chan int) {</span><br><span class="line"></span><br><span class="line">    // 根据给定地址进行侦听</span><br><span class="line">    l, err := net.Listen("tcp", address)</span><br><span class="line"></span><br><span class="line">    // 如果侦听发生错误, 打印错误并退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        exitChan &lt;- 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 打印侦听地址, 表示侦听成功</span><br><span class="line">    fmt.Println("listen: " + address)</span><br><span class="line"></span><br><span class="line">    // 延迟关闭侦听器</span><br><span class="line">    defer l.Close()</span><br><span class="line"></span><br><span class="line">    // 侦听循环</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 新连接没有到来时, Accept是阻塞的</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line"></span><br><span class="line">        // 发生任何的侦听错误, 打印错误并退出服务器</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err.Error())</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 根据连接开启会话, 这个过程需要并行执行</span><br><span class="line">        go handleSession(conn, exitChan)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，接受连接的入口，address 为传入的地址，退出服务器使用 exitChan 的通道控制。往 exitChan 写入一个整型值时，进程将以整型值作为程序返回值来结束服务器。</li>
<li>第 12 行，使用 net 包的 Listen() 函数进行侦听。这个函数需要提供两个参数，第一个参数为协议类型，本例需要做的是 TCP 连接，因此填入“tcp”；address 为地址，格式为“主机:端口号”。</li>
<li>第 15 行，如果侦听发生错误，通过第 17 行，往 exitChan 中写入非 0 值结束服务器，同时打印侦听错误。</li>
<li>第 24 行，使用 defer，将侦听器的结束延迟调用。</li>
<li>第 27 行，侦听开始后，开始进行连接接受，每次接受连接后需要继续接受新的连接，周而复始。</li>
<li>第 30 行，服务器接受了一个连接。在没有连接时，Accept() 函数调用后会一直阻塞。连接到来时，返回 conn 和错误变量，conn 的类型是 *tcp.Conn。</li>
<li>第 33 行，某些情况下，连接接受会发生错误，不影响服务器逻辑，这时重新进行新连接接受。</li>
<li>第 39 行，每个连接会生成一个会话。这个会话的处理与接受逻辑需要并行执行，彼此不干扰。</li>
</ul>
<h3 id="会话处理"><a href="#会话处理" class="headerlink" title="会话处理"></a>会话处理</h3><p>每个连接的会话就是一个接收数据的循环。当没有数据时，调用 reader.ReadString 会发生阻塞，等待数据的到来。一旦数据到来，就可以进行各种逻辑处理。</p>
<p>回音服务器的基本逻辑是“收到什么返回什么”，reader.ReadString 可以一直读取 Socket 连接中的数据直到碰到期望的结尾符。这种期望的结尾符也叫定界符，一般用于将 TCP 封包中的逻辑数据拆分开。下例中使用的定界符是回车换行符（“\r\n”），HTTP 协议也是使用同样的定界符。使用 reader.ReadString() 函数可以将封包简单地拆分开。</p>
<p>如下图所示为 Telnet 数据处理过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/telnet.jpg" alt="图：Telnet 数据处理过程"></p>
<p>回音服务器需要将收到的有效数据通过 Socket 发送回去。</p>
<p>Telnet会话处理：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "net"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 连接的会话逻辑</span><br><span class="line">func handleSession(conn net.Conn, exitChan chan int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("Session started:")</span><br><span class="line"></span><br><span class="line">    // 创建一个网络连接数据的读取器</span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line"></span><br><span class="line">    // 接收数据的循环</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 读取字符串, 直到碰到回车返回</span><br><span class="line">        str, err := reader.ReadString('\n')</span><br><span class="line"></span><br><span class="line">        // 数据读取正确</span><br><span class="line">        if err == nil {</span><br><span class="line"></span><br><span class="line">            // 去掉字符串尾部的回车</span><br><span class="line">            str = strings.TrimSpace(str)</span><br><span class="line"></span><br><span class="line">            // 处理Telnet指令</span><br><span class="line">            if !processTelnetCommand(str, exitChan) {</span><br><span class="line">                conn.Close()</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // Echo逻辑, 发什么数据, 原样返回</span><br><span class="line">            conn.Write([]byte(str + "\r\n"))</span><br><span class="line"></span><br><span class="line">        } else {</span><br><span class="line">            // 发生错误</span><br><span class="line">            fmt.Println("Session closed")</span><br><span class="line">            conn.Close()</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行是会话入口，传入连接和退出用的通道。handle Session() 函数被并发执行。</li>
<li>第 16 行，使用 bufio 包的 NewReader() 方法，创建一个网络数据读取器，这个 Reader 将输入数据的读取过程进行封装，方便我们迅速获取到需要的数据。</li>
<li>第 19 行，会话处理开始时，从 Socket 连接，通过 reader 读取器读取封包，处理封包后需要继续读取从网络发送过来的下一个封包，因此需要一个会话处理循环。</li>
<li>第 22 行，使用 reader.ReadString() 方法进行封包读取。内部会自动处理粘包过程，直到下一个回车符到达后返回数据。这里认为封包来自 Telnet，每个指令以回车换行符（“\r\n”）结尾。</li>
<li>第 25 行，数据读取正常时，返回 err 为 nil。如果发生连接断开、接收错误等网络错误时，err 就不是 nil 了。</li>
<li>第 28 行，reader.ReadString 读取返回的字符串尾部带有回车符，使用 strings.TrimSpace() 函数将尾部带的回车和空白符去掉。</li>
<li>第 31 行，将 str 字符串传入 Telnet 指令处理函数 processTelnetCommand() 中，同时传入退出控制通道 exitChan。当这个函数返回 false 时，表示需要关闭当前连接。</li>
<li>第 32 行和第 33 行，关闭当前连接并退出会话接受循环。</li>
<li>第 37 行，将有效数据通过 conn 的 Write() 方法写入，同时在字符串尾部添加回车换行符（“\r\n”），数据将被 Socket 发送给连接方。</li>
<li>第 41～43 行，处理当 reader.ReadString() 函数返回错误时，打印错误信息并关闭连接，退出会话并接收循环。</li>
</ul>
<h3 id="Telnet命令处理"><a href="#Telnet命令处理" class="headerlink" title="Telnet命令处理"></a>Telnet命令处理</h3><p>Telnet 是一种协议。在操作系统中可以在命令行使用 Telnet 命令发起 TCP 连接。我们一般用 Telnet 来连接 TCP 服务器，键盘输入一行字符回车后，即被发送到服务器上。</p>
<p>在下例中，定义了以下两个特殊控制指令，用以实现一些功能：</p>
<ul>
<li>输入“@close”退出当前连接会话。</li>
<li>输入“@shutdown”终止服务器运行。</li>
</ul>
<p>Telnet命令处理：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func processTelnetCommand(str string, exitChan chan int) bool {</span><br><span class="line"></span><br><span class="line">    // @close指令表示终止本次会话</span><br><span class="line">    if strings.HasPrefix(str, "@close") {</span><br><span class="line"></span><br><span class="line">        fmt.Println("Session closed")</span><br><span class="line"></span><br><span class="line">        // 告诉外部需要断开连接</span><br><span class="line">        return false</span><br><span class="line"></span><br><span class="line">        // @shutdown指令表示终止服务进程</span><br><span class="line">    } else if strings.HasPrefix(str, "@shutdown") {</span><br><span class="line"></span><br><span class="line">        fmt.Println("Server shutdown")</span><br><span class="line"></span><br><span class="line">        // 往通道中写入0, 阻塞等待接收方处理</span><br><span class="line">        exitChan &lt;- 0</span><br><span class="line"></span><br><span class="line">        // 告诉外部需要断开连接</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 打印输入的字符串</span><br><span class="line">    fmt.Println(str)</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，处理 Telnet 命令的函数入口，传入有效字符并退出通道。</li>
<li>第 11～16 行，当输入字符串中包含“@close”前缀时，在第 16 行返回 false，表示需要关闭当前会话。</li>
<li>第 19～27 行，当输入字符串中包含“@shutdown”前缀时，第 24 行将 0 写入 - exitChan，表示结束服务器。</li>
<li>第 31 行，没有特殊的控制字符时，打印输入的字符串。</li>
</ul>
<h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>Telnet 回音处理主流程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个程序结束码的通道</span><br><span class="line">    exitChan := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 将服务器并发运行</span><br><span class="line">    go server("127.0.0.1:7001", exitChan)</span><br><span class="line"></span><br><span class="line">    // 通道阻塞, 等待接收返回值</span><br><span class="line">    code := &lt;-exitChan</span><br><span class="line"></span><br><span class="line">    // 标记程序返回值并退出</span><br><span class="line">    os.Exit(code)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，创建一个整型的无缓冲通道作为退出信号。</li>
<li>第 13 行，接受连接的过程可以并发操作，使用 go 将 server() 函数开启 goroutine。</li>
<li>第 16 行，从 exitChan 中取出返回值。如果取不到数据就一直阻塞。</li>
<li>第 19 行，将程序返回值传入 os.Exit() 函数中并终止程序。</li>
</ul>
<p>编译所有代码并运行，命令行提示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">listen: 127.0.0.1:7001</span><br></pre></td></tr></tbody></table></figure>
<p>此时，Socket 侦听成功。在操作系统中的命令行中输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 7001</span><br></pre></td></tr></tbody></table></figure>
<p>尝试连接本地的 7001 端口。接下来进入测试服务器的流程。</p>
<h3 id="测试输入字符串"><a href="#测试输入字符串" class="headerlink" title="测试输入字符串"></a>测试输入字符串</h3><p>在 Telnet 连接后，输入字符串 hello，Telnet 命令行显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ telnet 127.0.0.1 7001</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure>
<p>服务器显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">listen: 127.0.0.1:7001</span><br><span class="line">Session started:</span><br><span class="line">hello</span><br></pre></td></tr></tbody></table></figure>
<p>客户端输入的字符串会在服务器中显示，同时客户端也会收到自己发给服务器的内容，这就是一次回音。</p>
<h3 id="测试关闭会话"><a href="#测试关闭会话" class="headerlink" title="测试关闭会话"></a>测试关闭会话</h3><p>当输入 @close 时，Telnet 命令行显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@close</span><br><span class="line">Connection closed by foreign host</span><br></pre></td></tr></tbody></table></figure>
<p>服务器显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Session closed</span><br></pre></td></tr></tbody></table></figure>
<p>此时，客户端 Telnet 与服务器断开连接。</p>
<h3 id="测试关闭服务器"><a href="#测试关闭服务器" class="headerlink" title="测试关闭服务器"></a>测试关闭服务器</h3><p>当输入 @shutdown 时，Telnet 命令行显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@shutdown</span><br><span class="line">Connection closed by foreign host</span><br></pre></td></tr></tbody></table></figure>
<p>服务器显示如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Server shutdown</span><br></pre></td></tr></tbody></table></figure>
<p>此时服务器会自动关闭。</p>
<h2 id="竞态检测——检测代码在并发环境下可能出现的问题"><a href="#竞态检测——检测代码在并发环境下可能出现的问题" class="headerlink" title="竞态检测——检测代码在并发环境下可能出现的问题"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/106.html">竞态检测——检测代码在并发环境下可能出现的问题</a></h2><p>Go语言程序可以使用通道进行多个 goroutine 间的数据交换，但这仅仅是数据同步中的一种方法。通道内部的实现依然使用了各种锁，因此优雅代码的代价是性能。在某些轻量级的场合，原子访问（atomic包）、互斥锁（sync.Mutex）以及等待组（sync.WaitGroup）能最大程度满足需求。</p>
<p>当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞态问题。</p>
<p>下面的代码中有一个 ID 生成器，每次调用生成器将会生成一个不会重复的顺序序号，使用 10 个并发生成序号，观察 10 个并发后的结果。</p>
<p>竞态检测的具体代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync/atomic"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    // 序列号</span><br><span class="line">    seq int64</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 序列号生成器</span><br><span class="line">func GenID() int64 {</span><br><span class="line"></span><br><span class="line">// 尝试原子的增加序列号</span><br><span class="line">    atomic.AddInt64(&amp;seq, 1)</span><br><span class="line">    return seq</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    //生成10个并发序列号</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">            go GenID()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println(GenID())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，序列号生成器中的保存上次序列号的变量。</li>
<li>第 17 行，使用原子操作函数 atomic.AddInt64() 对 seq() 函数加 1 操作。不过这里故意没有使用 atomic.AddInt64() 的返回值作为 GenID() 函数的返回值，因此会造成一个竞态问题。</li>
<li>第 25 行，循环 10 次生成 10 个 goroutine 调用 GenID() 函数，同时忽略 GenID() 的返回值。</li>
<li>第 28 行，单独调用一次 GenID() 函数。</li>
</ul>
<p>在运行程序时，为运行参数加入 <code>-race</code> 参数，开启运行时（runtime）对竞态问题的分析，命令如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run -race racedetect.go</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行发生宕机，输出信息如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x000000f52f40 by goroutine 7:</span><br><span class="line">  sync/atomic.AddInt64()</span><br><span class="line">      C:/Go/src/runtime/race_amd64.s:276 +0xb</span><br><span class="line">  main.GenID()</span><br><span class="line">      racedetect.go:17 +0x4a</span><br><span class="line"></span><br><span class="line">Previous read at 0x000000f52f40 by goroutine 6:</span><br><span class="line">  main.GenID()</span><br><span class="line">      racedetect.go:18 +0x5a</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      racedetect.go:25 +0x5a</span><br><span class="line"></span><br><span class="line">Goroutine 6 (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      racedetect.go:25 +0x5a</span><br><span class="line">==================</span><br><span class="line">10</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></tbody></table></figure>
<p>根据报错信息，第 18 行有竞态问题，根据 atomic.AddInt64() 的参数声明，这个函数会将修改后的值以返回值方式传出。下面代码对加粗部分进行了修改：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func GenID() int64 {</span><br><span class="line">    // 尝试原子的增加序列号</span><br><span class="line">    return atomic.AddInt64(&amp;seq, 1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再次运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run -race main.go</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
<p>没有发生竞态问题，程序运行正常。</p>
<p>本例中只是对变量进行增减操作，虽然可以使用互斥锁（sync.Mutex）解决竞态问题，但是对性能消耗较大。在这种情况下，推荐使用原子操作（atomic）进行变量操作。</p>
<h2 id="互斥锁（sync-Mutex）和读写互斥锁（sync-RWMutex）"><a href="#互斥锁（sync-Mutex）和读写互斥锁（sync-RWMutex）" class="headerlink" title="互斥锁（sync.Mutex）和读写互斥锁（sync.RWMutex）"></a>互斥锁（sync.Mutex）和读写互斥锁（sync.RWMutex）</h2><p>Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。</p>
<p>Mutex 是最简单的一种锁类型，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。</p>
<p>RWMutex 相对友好些，是经典的单写多读模型。在读锁占用的情况下，会阻止写，但不阻止读，也就是多个 goroutine 可同时获取读锁（调用 RLock() 方法；而写锁（调用 Lock() 方法）会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占。从 RWMutex 的实现看，RWMutex 类型其实组合了 Mutex：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type RWMutex struct {</span><br><span class="line">    w Mutex</span><br><span class="line">    writerSem uint32</span><br><span class="line">    readerSem uint32</span><br><span class="line">    readerCount int32</span><br><span class="line">    readerWait int32</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于这两种锁类型，任何一个 Lock() 或 RLock() 均需要保证对应有 Unlock() 或 RUnlock() 调用与之对应，否则可能导致等待该锁的所有 goroutine 处于饥饿状态，甚至可能导致死锁。锁的典型使用模式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    // 逻辑中使用的某个变量</span><br><span class="line">    count int</span><br><span class="line"></span><br><span class="line">    // 与变量对应的使用互斥锁</span><br><span class="line">    countGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetCount() int {</span><br><span class="line"></span><br><span class="line">    // 锁定</span><br><span class="line">    countGuard.Lock()</span><br><span class="line"></span><br><span class="line">    // 在函数退出时解除锁定</span><br><span class="line">    defer countGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return count</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func SetCount(c int) {</span><br><span class="line">    countGuard.Lock()</span><br><span class="line">    count = c</span><br><span class="line">    countGuard.Unlock()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 可以进行并发安全的设置</span><br><span class="line">    SetCount(1)</span><br><span class="line"></span><br><span class="line">    // 可以进行并发安全的获取</span><br><span class="line">    fmt.Println(GetCount())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行是某个逻辑步骤中使用到的变量，无论是包级的变量还是结构体成员字段，都可以。</li>
<li><p>第 13 行，一般情况下，建议将互斥锁的粒度设置得越小越好，降低因为共享访问时等待的时间。这里笔者习惯性地将互斥锁的变量命名为以下格式：</p>
  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">变量名+Guard</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>以表示这个互斥锁用于保护这个变量。</p>
<ul>
<li>第 16 行是一个获取 count 值的函数封装，通过这个函数可以并发安全的访问变量 count。</li>
<li>第 19 行，尝试对 countGuard 互斥量进行加锁。一旦 countGuard 发生加锁，如果另外一个 goroutine 尝试继续加锁时将会发生阻塞，直到这个 countGuard 被解锁。</li>
<li>第 22 行使用 defer 将 countGuard 的解锁进行延迟调用，解锁操作将会发生在 GetCount() 函数返回时。</li>
<li>第 27 行在设置 count 值时，同样使用 countGuard 进行加锁、解锁操作，保证修改 count 值的过程是一个原子过程，不会发生并发访问冲突。</li>
</ul>
<p>在读多写少的环境中，可以优先使用读写互斥锁（sync.RWMutex），它比互斥锁更加高效。sync 包中的 RWMutex 提供了读写互斥锁的封装。</p>
<p>我们将互斥锁例子中的一部分代码修改为读写互斥锁，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    // 逻辑中使用的某个变量</span><br><span class="line">    count int</span><br><span class="line"></span><br><span class="line">    // 与变量对应的使用互斥锁</span><br><span class="line">    countGuard sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func GetCount() int {</span><br><span class="line"></span><br><span class="line">    // 锁定</span><br><span class="line">    countGuard.RLock()</span><br><span class="line"></span><br><span class="line">    // 在函数退出时解除锁定</span><br><span class="line">    defer countGuard.RUnlock()</span><br><span class="line"></span><br><span class="line">    return count</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，在声明 countGuard 时，从 sync.Mutex 互斥锁改为 sync.RWMutex 读写互斥锁。</li>
<li>第 12 行，获取 count 的过程是一个读取 count 数据的过程，适用于读写互斥锁。在这一行，把 countGuard.Lock() 换做 countGuard.RLock()，将读写互斥锁标记为读状态。如果此时另外一个 goroutine 并发访问了 countGuard，同时也调用了 countGuard.RLock() 时，并不会发生阻塞。</li>
<li>第 15 行，与读模式加锁对应的，使用读模式解锁。</li>
</ul>
<h2 id="等待组（sync-WaitGroup）"><a href="#等待组（sync-WaitGroup）" class="headerlink" title="等待组（sync.WaitGroup）"></a>等待组（sync.WaitGroup）</h2><p>Go语言中除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务</p>
<p>在 sync.WaitGroup（等待组）类型中，每个 sync.WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。</p>
<p>等待组有下面几个方法可用，如下表所示:</p>
<table>
    <caption>等待组的方法</caption>
    <thead><tr><th>方法名</th><th>功能</th></tr></thead>
    <tbody>
        <tr><td>(wg*WaitGroup)Add(delta int)</td><td>等待组的计数器+1</td></tr>
        <tr><td>(wg*WaitGroup)Done()</td><td>等待组的计数器-1</td></tr>
        <tr><td>(wg*WaitGroup)Wait()</td><td>当等待组计数器不等于0时阻塞直到变0。</td></tr>
    </tbody>
</table>

<p>对于一个可寻址的 sync.WaitGroup 值 wg：</p>
<ul>
<li>我们可以使用方法调用 wg.Add(delta) 来改变值 wg 维护的计数。</li>
<li>方法调用 wg.Done() 和 wg.Add(-1) 是完全等价的。</li>
<li>如果一个 wg.Add(delta) 或者 wg.Done() 调用将 wg 维护的计数更改成一个负数，一个恐慌将产生。</li>
<li><p>当一个协程调用了 wg.Wait() 时，</p>
<ul>
<li>如果此时 wg 维护的计数为零，则此 wg.Wait() 此操作为一个空操作（noop）；</li>
<li>否则（计数为一个正整数），此协程将进入阻塞状态。当以后其它某个协程将此计数更改至 0 时（一般通过调用 wg.Done()），此协程将重新进入运行状态（即 wg.Wait() 将返回）。</li>
</ul>
</li>
</ul>
<p>等待组内部拥有一个计数器，计数器的值可以通过方法调用实现计数器的增加和减少。当我们添加了 N 个并发任务进行工作时，就将等待组的计数器值增加 N。每个任务完成时，这个值减 1。同时，在另外一个 goroutine 中等待这个等待组的计数器值为 0 时，表示所有任务已经完成。</p>
<p>下面的代码演示了这一过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "net/http"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个等待组</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // 准备一系列的网站地址</span><br><span class="line">    var urls = []string{</span><br><span class="line">        "http://www.github.com/",</span><br><span class="line">        "https://www.qiniu.com/",</span><br><span class="line">        "https://www.golangtc.com/",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历这些地址</span><br><span class="line">    for _, url := range urls {</span><br><span class="line"></span><br><span class="line">        // 每一个任务开始时, 将等待组增加1</span><br><span class="line">        wg.Add(1)</span><br><span class="line"></span><br><span class="line">        // 开启一个并发</span><br><span class="line">        go func(url string) {</span><br><span class="line"></span><br><span class="line">            // 使用defer, 表示函数完成时将等待组值减1</span><br><span class="line">            defer wg.Done()</span><br><span class="line"></span><br><span class="line">            // 使用http访问提供的地址</span><br><span class="line">            _, err := http.Get(url)</span><br><span class="line"></span><br><span class="line">            // 访问完成后, 打印地址和可能发生的错误</span><br><span class="line">            fmt.Println(url, err)</span><br><span class="line"></span><br><span class="line">            // 通过参数传递url地址</span><br><span class="line">        }(url)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 等待所有的任务完成</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println("over")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 12 行，声明一个等待组，对一组等待任务只需要一个等待组，而不需要每一个任务都使用一个等待组。</li>
<li>第 15 行，准备一系列可访问的网站地址的字符串切片。</li>
<li>第 22 行，遍历这些字符串切片。</li>
<li>第 25 行，将等待组的计数器加1，也就是每一个任务加 1。</li>
<li>第 28 行，将一个匿名函数开启并发。</li>
<li>第 31 行，在匿名函数结束时会执行这一句以表示任务完成。wg.Done() 方法等效于执行 wg.Add(-1)。</li>
<li>第 34 行，使用 http 包提供的 Get() 函数对 url 进行访问，Get() 函数会一直阻塞直到网站响应或者超时。</li>
<li>第 37 行，在网站响应和超时后，打印这个网站的地址和可能发生的错误。</li>
<li>第 40 行，这里将 url 通过 goroutine 的参数进行传递，是为了避免 url 变量通过闭包放入匿名函数后又被修改的问题。</li>
<li>第 44 行，等待所有的网站都响应或者超时后，任务完成，Wait 就会停止阻塞。</li>
</ul>
<h2 id="死锁、活锁和饥饿"><a href="#死锁、活锁和饥饿" class="headerlink" title="死锁、活锁和饥饿"></a>死锁、活锁和饥饿</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>死锁发生的条件有如下几种：</p>
<p><strong>1) 互斥条件</strong></p>
<p>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到该资源被释放。</p>
<p><strong>2) 请求和保持条件</strong></p>
<p>线程 T1 至少已经保持了一个资源 R1 占用，但又提出使用另一个资源 R2 请求，而此时，资源 R2 被其他线程 T2 占用，于是该线程 T1 也必须等待，但又对自己保持的资源 R1 不释放。</p>
<p><strong>3) 不剥夺条件</strong></p>
<p>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</p>
<p><strong>4) 环路等待条件</strong></p>
<p>在死锁发生时，必然存在一个“进程 - 资源环形链”，即：{p0,p1,p2,…pn}，进程 p0（或线程）等待 p1 占用的资源，p1 等待 p2 占用的资源，pn 等待 p0 占用的资源。</p>
<p>最直观的理解是，p0 等待 p1 占用的资源，而 p1 而在等待 p0 占用的资源，于是两个进程就相互等待。</p>
<p>死锁解决办法：</p>
<ul>
<li>如果并发查询多个表，约定访问顺序；</li>
<li>在同一个事务中，尽可能做到一次锁定获取所需要的资源；</li>
<li>对于容易产生死锁的业务场景，尝试升级锁颗粒度，使用表级锁；</li>
<li>采用分布式事务锁或者使用乐观锁。</li>
</ul>
<p>死锁程序是所有并发进程彼此等待的程序，在这种情况下，如果没有外界的干预，这个程序将永远无法恢复。</p>
<p>为了便于大家理解死锁是什么，我们先来看一个例子（忽略代码中任何不知道的类型，函数，方法或是包，只理解什么是死锁即可），代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type value struct {</span><br><span class="line">    memAccess sync.Mutex</span><br><span class="line">    value     int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    runtime.GOMAXPROCS(3)</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    sum := func(v1, v2 *value) {</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        v1.memAccess.Lock()</span><br><span class="line">        time.Sleep(2 * time.Second)</span><br><span class="line">        v2.memAccess.Lock()</span><br><span class="line">        fmt.Printf("sum = %d\n", v1.value+v2.value)</span><br><span class="line">        v2.memAccess.Unlock()</span><br><span class="line">        v1.memAccess.Unlock()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    product := func(v1, v2 *value) {</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        v2.memAccess.Lock()</span><br><span class="line">        time.Sleep(2 * time.Second)</span><br><span class="line">        v1.memAccess.Lock()</span><br><span class="line">        fmt.Printf("product = %d\n", v1.value*v2.value)</span><br><span class="line">        v1.memAccess.Unlock()</span><br><span class="line">        v2.memAccess.Unlock()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    var v1, v2 value</span><br><span class="line">    v1.value = 1</span><br><span class="line">    v2.value = 1</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go sum(&amp;v1, &amp;v2)</span><br><span class="line">    go product(&amp;v1, &amp;v2)</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码，可能会看到：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></tbody></table></figure>
<p>为什么呢？如果仔细观察，就可以在此代码中看到时机问题，以下是运行时的图形表示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/deadlock.gif" alt="图 ：一个因时间问题导致死锁的演示"></p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复同样的操作，而且总会失败。</p>
<p>例如线程 1 可以使用资源，但它很礼貌，让其他线程先使用资源，线程 2 也可以使用资源，但它同样很绅士，也让其他线程先使用资源。就这样你让我，我让你，最后两个线程都无法使用资源。</p>
<p>活锁通常发生在处理事务消息中，如果不能成功处理某个消息，那么消息处理机制将回滚事务，并将它重新放到队列的开头。这样，错误的事务被一直回滚重复执行，这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误地将不可修复的错误认为是可修复的错误。</p>
<p>当多个相互协作的线程都对彼此进行相应而修改自己的状态，并使得任何一个线程都无法继续执行时，就导致了活锁。这就像两个过于礼貌的人在路上相遇，他们彼此让路，然后在另一条路上相遇，然后他们就一直这样避让下去。</p>
<p>要解决这种活锁问题，需要在重试机制中引入随机性。例如在网络上发送数据包，如果检测到冲突，都要停止并在一段时间后重发，如果都在 1 秒后重发，还是会冲突，所以引入随机性可以解决该类问题。</p>
<p>下面通过示例来演示一下活锁：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">    "sync/atomic"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    runtime.GOMAXPROCS(3)</span><br><span class="line">    cv := sync.NewCond(&amp;sync.Mutex{})</span><br><span class="line">    go func() {</span><br><span class="line">        for range time.Tick(1 * time.Second) { // 通过tick控制两个人的步调</span><br><span class="line">            cv.Broadcast()</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    takeStep := func() {</span><br><span class="line">        cv.L.Lock()</span><br><span class="line">        cv.Wait()</span><br><span class="line">        cv.L.Unlock()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tryDir := func(dirName string, dir *int32, out *bytes.Buffer) bool {</span><br><span class="line">        fmt.Fprintf(out, " %+v", dirName)</span><br><span class="line">        atomic.AddInt32(dir, 1)</span><br><span class="line">        takeStep()                      //走上一步</span><br><span class="line">        if atomic.LoadInt32(dir) == 1 { //走成功就返回</span><br><span class="line">            fmt.Fprint(out, ". Success!")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line">        takeStep() // 没走成功，再走回来</span><br><span class="line">        atomic.AddInt32(dir, -1)</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    var left, right int32</span><br><span class="line">    tryLeft := func(out *bytes.Buffer) bool {</span><br><span class="line">        return tryDir("向左走", &amp;left, out)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tryRight := func(out *bytes.Buffer) bool {</span><br><span class="line">        return tryDir("向右走", &amp;right, out)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    walk := func(walking *sync.WaitGroup, name string) {</span><br><span class="line">        var out bytes.Buffer</span><br><span class="line">        defer walking.Done()</span><br><span class="line">        defer func() { fmt.Println(out.String()) }()</span><br><span class="line">        fmt.Fprintf(&amp;out, "%v is trying to scoot:", name)</span><br><span class="line"></span><br><span class="line">        for i := 0; i &lt; 5; i++ {</span><br><span class="line">            if tryLeft(&amp;out) || tryRight(&amp;out) {</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        fmt.Fprintf(&amp;out, "\n%v is tried!", name)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    var trail sync.WaitGroup</span><br><span class="line">    trail.Add(2)</span><br><span class="line">    go walk(&amp;trail, "男人") // 男人在路上走</span><br><span class="line">    go walk(&amp;trail, "女人") // 女人在路上走</span><br><span class="line">    trail.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">女人 is trying to scoot: 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走</span><br><span class="line">女人 is tried!</span><br><span class="line">男人 is trying to scoot: 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走</span><br><span class="line">男人 is tried!</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子演示了使用活锁的一个十分常见的原因，两个或两个以上的并发进程试图在没有协调的情况下防止死锁。这就好比，如果走廊里的人都同意，只有一个人会移动，那就不会有活锁；一个人会站着不动，另一个人会移到另一边，他们就会继续移动。</p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待，活锁有可能自行解开，死锁则不能。</p>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。</p>
<p>与死锁不同的是，饥饿锁在一段时间内，优先级低的线程最终还是会执行的，比如高优先级的线程执行完之后释放了资源。</p>
<p>活锁与饥饿是无关的，因为在活锁中，所有并发进程都是相同的，并且没有完成工作。更广泛地说，饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能有效地完成工作，或者阻止全部并发进程。</p>
<p>下面的示例程序中包含了一个贪婪的 goroutine 和一个平和的 goroutine：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    runtime.GOMAXPROCS(3)</span><br><span class="line"></span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    const runtime = 1 * time.Second</span><br><span class="line">    var sharedLock sync.Mutex</span><br><span class="line"></span><br><span class="line">    greedyWorker := func() {</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        var count int</span><br><span class="line">        for begin := time.Now(); time.Since(begin) &lt;= runtime; {</span><br><span class="line">            sharedLock.Lock()</span><br><span class="line">            time.Sleep(3 * time.Nanosecond)</span><br><span class="line">            sharedLock.Unlock()</span><br><span class="line">            count++</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        fmt.Printf("Greedy worker was able to execute %v work loops\n", count)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    politeWorker := func() {</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        var count int</span><br><span class="line">        for begin := time.Now(); time.Since(begin) &lt;= runtime; {</span><br><span class="line">            sharedLock.Lock()</span><br><span class="line">            time.Sleep(1 * time.Nanosecond)</span><br><span class="line">            sharedLock.Unlock()</span><br><span class="line"></span><br><span class="line">            sharedLock.Lock()</span><br><span class="line">            time.Sleep(1 * time.Nanosecond)</span><br><span class="line">            sharedLock.Unlock()</span><br><span class="line"></span><br><span class="line">            sharedLock.Lock()</span><br><span class="line">            time.Sleep(1 * time.Nanosecond)</span><br><span class="line">            sharedLock.Unlock()</span><br><span class="line">            count++</span><br><span class="line">        }</span><br><span class="line">        fmt.Printf("Polite worker was able to execute %v work loops\n", count)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go greedyWorker()</span><br><span class="line">    go politeWorker()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Greedy worker was able to execute 276 work loops</span><br><span class="line">Polite worker was able to execute 92 work loops</span><br></pre></td></tr></tbody></table></figure>
<p>贪婪的 worker 会贪婪地抢占共享锁，以完成整个工作循环，而平和的 worker 则试图只在需要时锁定。两种 worker 都做同样多的模拟工作（sleeping 时间为 3ns），可以看到，在同样的时间里，贪婪的 worker 工作量几乎是平和的 worker 工作量的两倍！</p>
<p>假设两种 worker 都有同样大小的临界区，而不是认为贪婪的 worker 的算法更有效（或调用 Lock 和 Unlock 的时候，它们也不是缓慢的），我们得出这样的结论，贪婪的 worker 不必要地扩大其持有共享锁上的临界区，井阻止（通过饥饿）平和的 worker 的 goroutine 高效工作。</p>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><p>不适用锁肯定会出问题。如果用了，虽然解了前面的问题，但是又出现了更多的新问题。</p>
<ul>
<li>死锁：是因为错误的使用了锁，导致异常；</li>
<li>活锁：是饥饿的一种特殊情况，逻辑上感觉对，程序也一直在正常的跑，但就是效率低，逻辑上进行不下去；</li>
<li>饥饿：与锁使用的粒度有关，通过计数取样，可以判断进程的工作效率。</li>
</ul>
<p>只要有共享资源的访问，必定要使其逻辑上进行顺序化和原子化，确保访问一致，这绕不开锁这个概念。</p>
<h2 id="封装qsort快速排序函数"><a href="#封装qsort快速排序函数" class="headerlink" title="封装qsort快速排序函数"></a>封装qsort快速排序函数</h2><p>qsort快速排序函数是C语言的高阶函数，支持用于自定义排序比较函数，可以对任意类型的数组进行排序。本节我们尝试基于C语言的qsort函数封装一个Go语言版本的qsort函数。</p>
<h3 id="认识qsort函数"><a href="#认识qsort函数" class="headerlink" title="认识qsort函数"></a>认识qsort函数</h3><p>qsort快速排序函数有<stdlib.h>标准库提供，函数的声明如下：</stdlib.h></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">void qsort(</span><br><span class="line">    void* base, size_t num, size_t size,</span><br><span class="line">    int (*cmp)(const void*, const void*)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明如下：</p>
<ul>
<li>base：参数是要排序数组的首个元素的地址；</li>
<li>num：是数组中元素的个数；</li>
<li>size：是数组中每个元素的大小；</li>
<li>cmp：用于对数组中任意两个元素进行排序。</li>
</ul>
<p>cmp排序函数的两个指针参数分别是要比较的两个元素的地址，如果第一个参数对应元素大于第二个参数对应的元素将返回结果大于0，如果两个元素相等则返回0，如果第一个元素小于第二个元素则返回结果小于0。</p>
<p>下面的代码是用C语言的qsort对一个int类型的数组进行排序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#define DIM(x) (</span><br><span class="line">    sizeof(x)/sizeof((x)[0])</span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line">static int cmp(const void* a, const void* b) {</span><br><span class="line">    const int* pa = (int*)a;</span><br><span class="line">    const int* pb = (int*)b;</span><br><span class="line">    return *pa - *pb;  </span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line">int main() {</span><br><span class="line">    int values[] = { 42, 8, 109, 97, 23, 25 };</span><br><span class="line">    int i;</span><br><span class="line">    qsort(values, DIM(values), sizeof(values[0]), cmp);</span><br><span class="line">    for(i = 0; i &lt; DIM(values); i++) {</span><br><span class="line">        printf ("%d ",values[i]);</span><br><span class="line">    }</span><br><span class="line">    return 0;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>DIM(values) 宏用于计算数组元素的个数；</li>
<li>sizeof(values[0]) 用于计算数组元素的大小；</li>
<li>cmp 是用于排序时比较两个元素大小的回调函数。</li>
</ul>
<p>为了避免对全局名字空间的污染，我们将cmp回调函数定义为仅当前文件内可访问的静态函数。</p>
<h3 id="将qsort函数从Go包导出"><a href="#将qsort函数从Go包导出" class="headerlink" title="将qsort函数从Go包导出"></a>将qsort函数从Go包导出</h3><p>为了方便Go语言的非CGO用户使用qsort函数，我们需要将C语言的qsort函数包装为一个外部可以访问的Go函数。</p>
<p>用Go语言将qsort函数重新包装为qsort.Sort函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package qsort//</span><br><span class="line">type def int(*qsort_cmp_func_t)(constvoid*a,constvoid*b);</span><br><span class="line"></span><br><span class="line">import "C"</span><br><span class="line">import "unsafe"</span><br><span class="line"></span><br><span class="line">func Sort(base unsafe.Pointer,num,size C.size_t,cmp C.qsort_cmp_func_t,){</span><br><span class="line">    C.qsort(base,num,size,cmp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为Go语言的CGO语言不好直接表达C语言的函数类型，因此在C语言空间将比较函数类型重新定义为一个qsort_cmp_func_t类型。</p>
<p>被CGO处理后的Sort函数的类型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">funcSort(base unsafe.Pointer,num,size _Ctype_size_t,cmp _Ctype_qsort_cmp_func_t,)</span><br></pre></td></tr></tbody></table></figure>
<p>这样将会导致包外部用于无法构造 <code>_Ctype_size_t</code> 和 <code>_Ctype_qsort_cmp_func_t</code> 类型的参数而无法使用Sort函数。因此，导出的Sort函数的参数和返回值要避免对虚拟C包的依赖。</p>
<p>重新调整Sort函数的参数类型和实现如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*#include &lt;stdlib.h&gt;</span><br><span class="line">type def int(*qsort_cmp_func_t)(constvoid*a,constvoid*b);*/</span><br><span class="line"></span><br><span class="line">import "C"</span><br><span class="line">import "unsafe"</span><br><span class="line">type CompareFunc C.qsort_cmp_func_t </span><br><span class="line"></span><br><span class="line">func Sort(base unsafe.Pointer,num,sizeint,cmp CompareFunc){</span><br><span class="line">    C.qsort(base,C.size_t(num),C.size_t(size),C.qsort_cmp_func_t(cmp))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们将虚拟C包中的类型通过Go语言类型代替，在内部调用C函数时重新转型为C函数需要的类型。因此外部用户将不再依赖qsort包内的虚拟C包。</p>
<p>以下代码展示了Sort函数的使用方式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//externintgo_qsort_compare(void*a,void*b);</span><br><span class="line"></span><br><span class="line">import "C"</span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "unsafe"</span><br><span class="line">    qsort "."</span><br><span class="line">)</span><br><span class="line">//exportgo_qsort_compare</span><br><span class="line">func go_qsort_compare(a,b unsafe.Pointer) C.int {</span><br><span class="line">    pa,pb:=(*C.int)(a),(*C.int)(b)</span><br><span class="line">    return C.int(*pa-*pb)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    values:=[]int32{42,9,101,95,27,25}</span><br><span class="line"></span><br><span class="line">    qsort.Sort(unsafe.Pointer(&amp;values[0]),len(values),int(unsafe.Sizeof(values[0])),qsort.CompareFunc(C.go_qsort_compare),)</span><br><span class="line"></span><br><span class="line">    fmt.Println(values)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了使用Sort函数，我们需要将Go语言的切片取首地址、元素个数、元素大小等信息作为调用参数，同时还需要提供一个C语言规格的比较函数。其中go_qsort_compare是用Go语言实现的，并导出到C语言空间的函数，用于qsort排序时的比较函数。</p>
<p>目前已经实现了对C语言的qsort初步包装，并且可以通过包的方式被其它用户使用。但是qsort.Sort函数已经有很多不便使用之处：用户要提供C语言的比较函数，这对许多Go语言用户是一个挑战。</p>
<p>下一步我们将继续改进qsort函数的包装函数，尝试通过闭包函数代替C语言的比较函数。消除用户对CGO代码的直接依赖。</p>
<h3 id="改进：闭包函数作为比较函数"><a href="#改进：闭包函数作为比较函数" class="headerlink" title="改进：闭包函数作为比较函数"></a>改进：闭包函数作为比较函数</h3><p>在改进之前我们先回顾下Go语言sort包自带的排序函数的接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Slice(slice interface{},less func(i,jint)bool)</span><br></pre></td></tr></tbody></table></figure>
<p>标准库的sort.Slice因为支持通过闭包函数指定比较函数，对切片的排序非常简单：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import "sort"</span><br><span class="line">func main(){</span><br><span class="line">    values:=[]int32{42,9,101,95,27,25}</span><br><span class="line"></span><br><span class="line">    sort.Slice(values,func(i,jint)bool{</span><br><span class="line">        return values[i]&lt;values[j]</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Println(values)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们也尝试将C语言的qsort函数包装为以下格式的Go语言函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package qsort</span><br><span class="line">func Sort(base unsafe.Pointer,num,size int,cmp func(a,bunsafe.Pointer)int)</span><br></pre></td></tr></tbody></table></figure>
<p>闭包函数无法导出为C语言函数，因此无法直接将闭包函数传入C语言的qsort函数。为此我们可以用Go构造一个可以导出为C语言的代理函数，然后通过一个全局变量临时保存当前的闭包比较函数。</p>
<p>代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var go_qsort_compare_info struct{</span><br><span class="line">    fn func(a,bunsafe.Pointer)</span><br><span class="line">    int sync.Mutex</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//export_cgo_qsort_compare</span><br><span class="line">func _cgo_qsort_compare(a, b unsafe.Pointer) C.int {</span><br><span class="line">    return C.int(go_qsort_compare_info.fn(a,b))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中导出的C语言函数_cgo_qsort_compare是公用的qsort比较函数，内部通过go_qsort_compare_info.fn来调用当前的闭包比较函数。</p>
<p>新的Sort包装函数实现如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">type def int(*qsort_cmp_func_t)(constvoid*a,constvoid*b);</span><br><span class="line">externint_cgo_qsort_compare(void*a,void*b);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import "C"</span><br><span class="line"></span><br><span class="line">func Sort(base unsafe.Pointer,num,size int,cmp func(a,bunsafe.Pointer)int){</span><br><span class="line">    go_qsort_compare_info.Lock()</span><br><span class="line">    defer go_qsort_compare_info.Unlock()</span><br><span class="line">    go_qsort_compare_info.fn = cmp</span><br><span class="line">    C.qsort(base,C.size_t(num),C.size_t(size),C.qsort_cmp_func_t(C._cgo_qsort_compare),)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每次排序前，对全局的go_qsort_compare_info变量加锁，同时将当前的闭包函数保存到全局变量，然后调用C语言的qsort函数。</p>
<p>基于新包装的函数，我们可以简化之前的排序代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main(){</span><br><span class="line">    values:=[]int32{42,9,101,95,27,25}</span><br><span class="line">    qsort.Sort(</span><br><span class="line">        unsafe.Pointer(&amp;values[0]),</span><br><span class="line">        len(values),</span><br><span class="line">        int(unsafe.Sizeof(values[0])),</span><br><span class="line">        func( a, b unsafe.Pointer) int {</span><br><span class="line">            pa,pb := (*int32)(a),(*int32)(b)</span><br><span class="line">            return int(*pa-*pb)</span><br><span class="line">        },</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fmt.Println(values)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在排序不再需要通过CGO实现C语言版本的比较函数了，可以传入Go语言闭包函数作为比较函数。但是导入的排序函数依然依赖unsafe包，这是违背Go语言编程习惯的。</p>
<h3 id="改进：消除用户对unsafe包的依赖"><a href="#改进：消除用户对unsafe包的依赖" class="headerlink" title="改进：消除用户对unsafe包的依赖"></a>改进：消除用户对unsafe包的依赖</h3><p>前一个版本的qsort.Sort包装函数已经比最初的C语言版本的qsort易用很多，但是依然保留了很多C语言底层数据结构的细节。现在我们将继续改进包装函数，尝试消除对unsafe包的依赖，并实现一个类似标准库中sort.Slice的排序函数。</p>
<p>新的包装函数声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">packageq sort</span><br><span class="line">func Slice(slice interface{},less func(a,bint)bool)</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们将slice作为接口类型参数传入，这样可以适配不同的切片类型。然后切片的首个元素的地址、元素个数和元素大小可以通过reflect反射包从切片中获取。</p>
<p>为了保存必要的排序上下文信息，我们需要在全局包变量增加要排序数组的地址、元素个数和元素大小等信息，比较函数改为less：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var go_qsort_compare_info struct{</span><br><span class="line">    base unsafe.Pointer</span><br><span class="line">    elemnum int</span><br><span class="line">    elemsize int</span><br><span class="line">    less func(a,b int)bool</span><br><span class="line">    sync.Mutex</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同样比较函数需要根据元素指针、排序数组的开始地址和元素的大小计算出元素对应数组的索引下标，然后根据less函数的比较结果返回qsort函数需要格式的比较结果。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//export_cgo_qsort_compare</span><br><span class="line">func _cgo_qsort_compare(a,b unsafe.Pointer) C.int {</span><br><span class="line">    var (</span><br><span class="line">        //arraymemoryislocked</span><br><span class="line">        base=uintptr(go_qsort_compare_info.base)</span><br><span class="line">        elemsize=uintptr(go_qsort_compare_info.elemsize)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    i:=int((uintptr(a)-base)/elemsize)</span><br><span class="line">    j:=int((uintptr(b)-base)/elemsize)</span><br><span class="line"></span><br><span class="line">    switch{</span><br><span class="line">        case go_qsort_compare_info.less(i,j):</span><br><span class="line">            //v[i]&lt;v[j]</span><br><span class="line">            return -1</span><br><span class="line">        case go_qsort_compare_info.less(j,i):</span><br><span class="line">            //v[i]&gt;v[j]</span><br><span class="line">            return +1</span><br><span class="line">        default:return 0</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>新的Slice函数的实现如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Slice(slice interface{},less func(a,b int)bool){</span><br><span class="line">    sv:=reflect.ValueOf(slice)</span><br><span class="line">    if sv.Kind()!=reflect.Slice {</span><br><span class="line">        panic(fmt.Sprintf("qsortcalledwithnon-slicevalueoftype%T",slice))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if sv.Len() == 0 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    go_qsort_compare_info.Lock()</span><br><span class="line">    defer go_qsort_compare_info.Unlock()</span><br><span class="line">    defer func(){</span><br><span class="line">        go_qsort_compare_info.base = nil</span><br><span class="line">        go_qsort_compare_info.elemnum = 0</span><br><span class="line">        go_qsort_compare_info.elemsize = 0</span><br><span class="line">        go_qsort_compare_info.less=nil</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    //baseMem=unsafe.Pointer(sv.Index(0).Addr().Pointer())</span><br><span class="line">    //baseMemmay be moved,so must saved after call C.fn</span><br><span class="line">    go_qsort_compare_info.base = unsafe.Pointer(</span><br><span class="line">        sv.Index(0).Addr().Pointer()</span><br><span class="line">    )</span><br><span class="line">    go_qsort_compare_info.elemnum = sv.Len()</span><br><span class="line">    go_qsort_compare_info.elemsize = int(sv.Type().Elem().Size())</span><br><span class="line">    go_qsort_compare_info.less = lessC.qsort(</span><br><span class="line">        go_qsort_compare_info.base,</span><br><span class="line">        C.size_t(go_qsort_compare_info.elemnum),</span><br><span class="line">        C.size_t(go_qsort_compare_info.elemsize),</span><br><span class="line">        C.qsort_cmp_func_t(C._cgo_qsort_compare),</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先需要判断传入的接口类型必须是切片类型。然后通过反射获取qsort函数需要的切片信息，并调用C语言的qsort函数。</p>
<p>基于新包装的函数我们可以采用和标准库相似的方式排序切片：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    qsort "."</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    values:=[]int64{42,9,101,95,27,25}</span><br><span class="line">    qsort.Slice(values,func(i,j int) bool {</span><br><span class="line">        return values[i]&lt;values[j]</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Println(values)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了避免在排序过程中，排序数组的上下文信息go_qsort_compare_info被修改，我们进行了全局加锁。因此目前版本的qsort.Slice函数是无法并发执行的，读者可以自己尝试改进这个限制。</p>
<h2 id="CSP：通信顺序进程简述"><a href="#CSP：通信顺序进程简述" class="headerlink" title="CSP：通信顺序进程简述"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/126.html">CSP：通信顺序进程简述</a></h2><p>Go实现了两种并发形式，第一种是大家普遍认知的多线程共享内存，其实就是 Java 或 C++ 等语言中的多线程开发；另外一种是Go语言特有的，也是Go语言推荐的 CSP（communicating sequential processes）并发模型。</p>
<p>CSP 并发模型是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享 channel（管道）进行通信的并发模型。</p>
<p>Go语言就是借用 CSP 并发模型的一些概念为之实现并发的，但是Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。</p>
<p>process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。</p>
<p>这里我们要明确的是“并发不是并行”。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核 CPU 上才可能真正地同时运行；并行更关注的是程序的运行层面，并行一般是简单的大量重复，例如 GPU 中对图像处理都会有大量的并行运算。</p>
<p>为了更好地编写并发程序，从设计之初Go语言就注重如何在编程语言层级上设计一个简洁安全高效的抽象模型，让开发人员专注于分解问题和组合方案，而且不用被线程管理和信号互斥这些烦琐的操作分散精力。</p>
<p>在并发编程中，对共享资源的正确访问需要精确地控制，在目前的绝大多数语言中，都是通过加锁等线程同步方案来解决这一困难问题，而Go语言却另辟蹊径，它将共享的值通过通道传递（实际上多个独立执行的线程很少主动共享资源）。</p>
<p>并发编程的核心概念是同步通信，但是同步的方式却有多种。先以大家熟悉的互斥量 sync.Mutex 来实现同步通信，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("C语言中文网")</span><br><span class="line">        mu.Lock()</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    mu.Unlock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于 mu.Lock() 和 mu.Unlock() 并不在同一个 Goroutine 中，所以也就不满足顺序一致性内存模型。同时它们也没有其他的同步事件可以参考，也就是说这两件事是可以并发的。</p>
<p>因为可能是并发的事件，所以 main() 函数中的 mu.Unlock() 很有可能先发生，而这个时刻 mu 互斥对象还处于未加锁的状态，因而会导致运行时异常。</p>
<p>下面是修复后的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var mu sync.Mutex</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("C语言中文网")</span><br><span class="line">        mu.Unlock()</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    mu.Lock()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>修复的方式是在 main() 函数所在线程中执行两次 mu.Lock()，当第二次加锁时会因为锁已经被占用（不是递归锁）而阻塞，main() 函数的阻塞状态驱动后台线程继续向前执行。</p>
<p>当后台线程执行到 mu.Unlock() 时解锁，此时打印工作已经完成了，解锁会导致 main() 函数中的第二个 mu.Lock() 阻塞状态取消，此时后台线程和主线程再没有其他的同步事件参考，它们退出的事件将是并发的，在 main() 函数退出导致程序退出时，后台线程可能已经退出了，也可能没有退出。虽然无法确定两个线程退出的时间，但是打印工作是可以正确完成的。</p>
<p>使用 sync.Mutex 互斥锁同步是比较低级的做法，我们现在改用无缓存通道来实现同步：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    done := make(chan int)</span><br><span class="line"></span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("C语言中文网")</span><br><span class="line">        &lt;-done</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    done &lt;- 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>根据Go语言内存模型规范，对于从无缓存通道进行的接收，发生在对该通道进行的发送完成之前。因此，后台线程&lt;-done 接收操作完成之后，main 线程的done &lt;- 1 发送操作才可能完成（从而退出 main、退出程序），而此时打印工作已经完成了。</p>
<p>上面的代码虽然可以正确同步，但是对通道的缓存大小太敏感，如果通道有缓存，就无法保证 main() 函数退出之前后台线程能正常打印了，更好的做法是将通道的发送和接收方向调换一下，这样可以避免同步事件受通道缓存大小的影响：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    done := make(chan int, 1) // 带缓存通道</span><br><span class="line"></span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("C语言中文网")</span><br><span class="line">        done &lt;- 1</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    &lt;-done</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于带缓存的通道，对通道的第 K 个接收完成操作发生在第 K+C 个发送操作完成之前，其中 C 是通道的缓存大小。虽然通道是带缓存的，但是 main 线程接收完成是在后台线程发送开始但还未完成的时刻，此时打印工作也是已经完成的。</p>
<p>基于带缓存通道，我们可以很容易将打印线程扩展到 N 个，下面的示例是开启 10 个后台线程分别打印：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    done := make(chan int, 10) // 带10个缓存</span><br><span class="line"></span><br><span class="line">    // 开N个后台打印线程</span><br><span class="line">    for i := 0; i &lt; cap(done); i++ {</span><br><span class="line">        go func() {</span><br><span class="line">            fmt.Println("C语言中文网")</span><br><span class="line">            done &lt;- 1</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 等待N个后台线程完成</span><br><span class="line">    for i := 0; i &lt; cap(done); i++ {</span><br><span class="line">        &lt;-done</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于这种要等待 N 个线程完成后再进行下一步的同步操作有一个简单的做法，就是使用 sync.WaitGroup 来等待一组事件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // 开N个后台打印线程</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        wg.Add(1)</span><br><span class="line"></span><br><span class="line">        go func() {</span><br><span class="line">            fmt.Println("C语言中文网")</span><br><span class="line">            wg.Done()</span><br><span class="line">        }()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 等待N个后台线程完成</span><br><span class="line">    wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中 wg.Add(1) 用于增加等待事件的个数，必须确保在后台线程启动之前执行（如果放到后台线程之中执行则不能保证被正常执行到）。当后台线程完成打印工作之后，调用 wg.Done() 表示完成一个事件，main() 函数的 wg.Wait() 是等待全部的事件完成。</p>
<h2 id="聊天服务器"><a href="#聊天服务器" class="headerlink" title="聊天服务器"></a>聊天服务器</h2><h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><p>服务端程序中包含 4 个 goroutine，分别是一个主 goroutine 和广播（broadcaster）goroutine，每一个连接里面又包含一个连接处理（handleConn）goroutine 和一个客户写入（clientwriter）goroutine。</p>
<p>广播器（broadcaster）是用于如何使用 select 的一个规范说明，因为它需要对三种不同的消息进行响应。</p>
<p>主 goroutine 的工作是监听端口，接受连接客户端的网络连接，对每一个连接，它将创建一个新的 handleConn goroutine。</p>
<p>完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    listener, err := net.Listen("tcp", "localhost:8000")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    go broadcaster()</span><br><span class="line">    for {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        if err != nil {</span><br><span class="line">            log.Print(err)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        go handleConn(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type client chan&lt;- string // 对外发送消息的通道</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    entering = make(chan client)</span><br><span class="line">    leaving  = make(chan client)</span><br><span class="line">    messages = make(chan string) // 所有连接的客户端</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func broadcaster() {</span><br><span class="line">    clients := make(map[client]bool)</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case msg := &lt;-messages:</span><br><span class="line">            // 把所有接收到的消息广播给所有客户端</span><br><span class="line">            // 发送消息通道</span><br><span class="line">            for cli := range clients {</span><br><span class="line">                cli &lt;- msg</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        case cli := &lt;-entering:</span><br><span class="line">            clients[cli] = true</span><br><span class="line"></span><br><span class="line">        case cli := &lt;-leaving:</span><br><span class="line">            delete(clients, cli)</span><br><span class="line">            close(cli)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func handleConn(conn net.Conn) {</span><br><span class="line">    ch := make(chan string) // 对外发送客户消息的通道</span><br><span class="line">    go clientWriter(conn, ch)</span><br><span class="line"></span><br><span class="line">    who := conn.RemoteAddr().String()</span><br><span class="line">    ch &lt;- "欢迎 " + who</span><br><span class="line">    messages &lt;- who + " 上线"</span><br><span class="line">    entering &lt;- ch</span><br><span class="line"></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    for input.Scan() {</span><br><span class="line">        messages &lt;- who + ": " + input.Text()</span><br><span class="line">    }</span><br><span class="line">    // 注意：忽略 input.Err() 中可能的错误</span><br><span class="line"></span><br><span class="line">    leaving &lt;- ch</span><br><span class="line">    messages &lt;- who + " 下线"</span><br><span class="line">    conn.Close()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func clientWriter(conn net.Conn, ch &lt;-chan string) {</span><br><span class="line">    for msg := range ch {</span><br><span class="line">        fmt.Fprintln(conn, msg) // 注意：忽略网络层面的错误</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码中 main 函数里面写的代码非常简单，其实服务器要做的事情总结一下无非就是获得 listener 对象，然后不停的获取链接上来的 conn 对象，最后把这些对象丢给处理链接函数去进行处理。</p>
<p>在使用 handleConn 方法处理 conn 对象的时候，对不同的链接都启一个 goroutine 去并发处理每个 conn 这样则无需等待。</p>
<p>由于要给所有在线的用户发送消息，而不同用户的 conn 对象都在不同的 goroutine 里面，但是Go语言中有 channel 来处理各不同 goroutine 之间的消息传递，所以在这里我们选择使用 channel 在各不同的 goroutine 中传递广播消息。</p>
<p>下面来介绍一下 broadcaster 广播器，它使用局部变量 clients 来记录当前连接的客户集合，每个客户唯一被记录的信息是其对外发送消息通道的 ID，下面是细节：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type client chan&lt;- string // 对外发送消息的通道</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    entering = make(chan client)</span><br><span class="line">    leaving  = make(chan client)</span><br><span class="line">    messages = make(chan string) // 所有连接的客户端</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func broadcaster() {</span><br><span class="line">    clients := make(map[client]bool)</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case msg := &lt;-messages:</span><br><span class="line">            // 把所有接收到的消息广播给所有客户端</span><br><span class="line">            // 发送消息通道</span><br><span class="line">            for cli := range clients {</span><br><span class="line">                cli &lt;- msg</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        case cli := &lt;-entering:</span><br><span class="line">            clients[cli] = true</span><br><span class="line"></span><br><span class="line">        case cli := &lt;-leaving:</span><br><span class="line">            delete(clients, cli)</span><br><span class="line">            close(cli)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 main 函数里面使用 goroutine 开启了一个 broadcaster 函数来负责广播所有用户发送的消息。</p>
<p>这里使用一个字典来保存用户 clients，字典的 key 是各连接申明的单向并发队列。</p>
<p>使用一个 select 开启一个多路复用：</p>
<ul>
<li>每当有广播消息从 messages 发送进来，都会循环 cliens 对里面的每个 channel 发消息。</li>
<li>每当有消息从 entering 里面发送过来，就生成一个新的 key - value，相当于给 clients 里面增加一个新的 client。</li>
<li>每当有消息从 leaving 里面发送过来，就删掉这个 key - value 对，并关闭对应的 channel。</li>
</ul>
<p>下面再来看一下每个客户自己的 goroutine。</p>
<p>handleConn 函数创建一个对外发送消息的新通道，然后通过 entering 通道通知广播者新客户到来，接着它读取客户发来的每一行文本，通过全局接收消息通道将每一行发送给广播者，发送时在每条消息前面加上发送者 ID 作为前缀。一旦从客户端读取完毕消息，handleConn 通过 leaving 通道通知客户离开，然后关闭连接。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func handleConn(conn net.Conn) {</span><br><span class="line">    ch := make(chan string) // 对外发送客户消息的通道</span><br><span class="line">    go clientWriter(conn, ch)</span><br><span class="line"></span><br><span class="line">    who := conn.RemoteAddr().String()</span><br><span class="line">    ch &lt;- "欢迎 " + who</span><br><span class="line">    messages &lt;- who + " 上线"</span><br><span class="line">    entering &lt;- ch</span><br><span class="line"></span><br><span class="line">    input := bufio.NewScanner(conn)</span><br><span class="line">    for input.Scan() {</span><br><span class="line">        messages &lt;- who + ": " + input.Text()</span><br><span class="line">    }</span><br><span class="line">    // 注意：忽略 input.Err() 中可能的错误</span><br><span class="line"></span><br><span class="line">    leaving &lt;- ch</span><br><span class="line">    messages &lt;- who + " 下线"</span><br><span class="line">    conn.Close()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func clientWriter(conn net.Conn, ch &lt;-chan string) {</span><br><span class="line">    for msg := range ch {</span><br><span class="line">        fmt.Fprintln(conn, msg) // 注意：忽略网络层面的错误</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>handleConn 函数会为每个过来处理的 conn 都创建一个新的 channel，开启一个新的 goroutine 去把发送给这个 channel 的消息写进 conn。</p>
<p>handleConn 函数的执行过程可以简单总结为如下几个步骤：</p>
<ul>
<li>获取连接过来的 ip 地址和端口号；</li>
<li>把欢迎信息写进 channel 返回给客户端；</li>
<li>生成一条广播消息写进 messages 里；</li>
<li>把这个 channel 加入到客户端集合，也就是 entering &lt;- ch；</li>
<li>监听客户端往 conn 里写的数据，每扫描到一条就将这条消息发送到广播 channel 中；</li>
<li>如果关闭了客户端，那么把队列离开写入 leaving 交给广播函数去删除这个客户端并关闭这个客户端；</li>
<li>广播通知其他客户端该客户端已关闭；</li>
<li>最后关闭这个客户端的连接 Conn.Close()。</li>
</ul>
<h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><p>前面对服务端做了简单的介绍，下面介绍客户端，这里将其命名为“netcat.go”，完整代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// netcat 是一个简单的TCP服务器读/写客户端</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "net"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    conn, err := net.Dial("tcp", "localhost:8000")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    done := make(chan struct{})</span><br><span class="line">    go func() {</span><br><span class="line">        io.Copy(os.Stdout, conn) // 注意：忽略错误</span><br><span class="line">        log.Println("done")</span><br><span class="line">        done &lt;- struct{}{} // 向主Goroutine发出信号</span><br><span class="line">    }()</span><br><span class="line">    mustCopy(conn, os.Stdin)</span><br><span class="line">    conn.Close()</span><br><span class="line">    &lt;-done // 等待后台goroutine完成</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func mustCopy(dst io.Writer, src io.Reader) {</span><br><span class="line">    if _, err := io.Copy(dst, src); err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当有 n 个客户 session 在连接的时候，程序并发运行着 <code>2n+2</code> 个相互通信的 goroutine，它不需要隐式的加锁操作。clients map 限制在广播器这一个 goroutine 中被访问，所以不会并发访问它。唯一被多个 goroutine 共享的变量是通道以及 <code>net.Conn</code> 的实例，它们又都是并发安全的。</p>
<p>使用 <code>go build</code> 命令编译服务端和客户端，并运行生成的可执行文件。</p>
<p>下图中展示了在同一台计算机上运行的一个服务端和三个客户端：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gonetcat.gif" alt="服务端和三个客户端"></p>
<h2 id="goroutine如何使用才更加高效"><a href="#goroutine如何使用才更加高效" class="headerlink" title="goroutine如何使用才更加高效"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/126.html">goroutine如何使用才更加高效</a></h2><p>Go语言原生支持并发是被众人津津乐道的特性。goroutine 早期是 Inferno 操作系统的一个试验性特性，而现在这个特性与操作系统一起，将开发变得越来越简单。</p>
<p>很多刚开始使用Go语言开发的人都很喜欢使用并发特性，而没有考虑并发是否真正能解决他们的问题。</p>
<h3 id="了解-goroutine-的生命期时再创建-goroutine"><a href="#了解-goroutine-的生命期时再创建-goroutine" class="headerlink" title="了解 goroutine 的生命期时再创建 goroutine"></a>了解 goroutine 的生命期时再创建 goroutine</h3><p>在Go语言中，开发者习惯将并发内容与 goroutine 一一对应地创建 goroutine。开发者很少会考虑 goroutine 在什么时候能退出和控制 goroutine 生命期，这就会造成 goroutine 失控的情况。下面来看一段代码。</p>
<p>失控的 goroutine：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 一段耗时的计算函数</span><br><span class="line">func consumer(ch chan int) {</span><br><span class="line"></span><br><span class="line">    // 无限获取数据的循环</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 从通道获取数据</span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        // 打印数据</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个传递数据用的通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 空变量, 什么也不做</span><br><span class="line">        var dummy string</span><br><span class="line"></span><br><span class="line">        // 获取输入, 模拟进程持续运行</span><br><span class="line">        fmt.Scan(&amp;dummy)</span><br><span class="line"></span><br><span class="line">        // 启动并发执行consumer()函数</span><br><span class="line">        go consumer(ch)</span><br><span class="line"></span><br><span class="line">        // 输出现在的goroutine数量</span><br><span class="line">        fmt.Println("goroutines:", runtime.NumGoroutine())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，consumer() 函数模拟平时业务中放到 goroutine 中执行的耗时操作。该函数从其他 goroutine 中获取和接收数据或者指令，处理后返回结果。</li>
<li>第 12 行，需要通过无限循环不停地获取数据。</li>
<li>第 15 行，每次从通道中获取数据。</li>
<li>第 18 行，模拟处理完数据后的返回数据。</li>
<li>第 26 行，创建一个整型通道。</li>
<li>第 34 行，使用 fmt.Scan() 函数接收数据时，需要提供变量地址。如果输入匹配的变量类型，将会成功赋值给变量。</li>
<li>第 37 行，启动并发执行 consumer() 函数，并传入 ch 通道。</li>
<li>第 40 行，每启动一个 goroutine，使用 runtime.NumGoroutine 检查进程创建的 goroutine 数量总数。</li>
</ul>
<p>运行程序，每输入一个字符串+回车，将会创建一个 goroutine，结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a</span><br><span class="line">goroutines: 2</span><br><span class="line">b</span><br><span class="line">goroutines: 3</span><br><span class="line">c</span><br><span class="line">goroutines: 4</span><br></pre></td></tr></tbody></table></figure>
<p>注意，结果中 a、b、c 为通过键盘输入的字符，其他为打印字符。</p>
<p>这个程序实际在模拟一个进程根据需要创建 goroutine 的情况。运行后，问题已经被暴露出来：随着输入的字符串越来越多，goroutine 将会无限制地被创建，但并不会结束。这种情况如果发生在生产环境中，将会造成内存大量分配，最终使进程崩溃。现实的情况也许比这段代码更加隐蔽：也许你设置了一个退出的条件，但是条件永远不会被满足或者触发。</p>
<p>为了避免这种情况，在这个例子中，需要为 consumer() 函数添加合理的退出条件，修改代码后如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 一段耗时的计算函数</span><br><span class="line">func consumer(ch chan int) {</span><br><span class="line"></span><br><span class="line">    // 无限获取数据的循环</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 从通道获取数据</span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        if data == 0 {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 打印数据</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("goroutine exit")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 传递数据用的通道</span><br><span class="line">    ch := make(chan int)</span><br><span class="line"></span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 空变量, 什么也不做</span><br><span class="line">        var dummy string</span><br><span class="line"></span><br><span class="line">        // 获取输入, 模拟进程持续运行</span><br><span class="line">        fmt.Scan(&amp;dummy)</span><br><span class="line"></span><br><span class="line">        if dummy == "quit" {</span><br><span class="line"></span><br><span class="line">            for i := 0; i &lt; runtime.NumGoroutine()-1; i++ {</span><br><span class="line">                ch &lt;- 0</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 启动并发执行consumer()函数</span><br><span class="line">        go consumer(ch)</span><br><span class="line"></span><br><span class="line">        // 输出现在的goroutine数量</span><br><span class="line">        fmt.Println("goroutines:", runtime.NumGoroutine())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码中加粗部分是新添加的代码，具体说明如下：</p>
<ul>
<li>第 17 行，为无限循环设置退出条件，这里设置 0 为退出。</li>
<li>第 41 行，当命令行输入 quit 时，进入退出处理的流程。</li>
<li>第 43 行，runtime.NumGoroutine 返回一个进程的所有 goroutine 数，main() 的 goroutine 也被算在里面。因此需要扣除 main() 的 goroutine 数。剩下的 goroutine 为实际创建的 goroutine 数，对这些 goroutine 进行遍历。</li>
<li>第 44 行，并发开启的 goroutine 都在竞争获取通道中的数据，因此只要知道有多少个 goroutine 需要退出，就给通道里发多少个 0。</li>
</ul>
<p>修改程序并运行，结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a</span><br><span class="line">goroutines: 2</span><br><span class="line">b</span><br><span class="line">goroutines: 3</span><br><span class="line">quit</span><br><span class="line">goroutine exit</span><br><span class="line">goroutine exit</span><br><span class="line">c</span><br><span class="line">goroutines: 2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="避免在不必要的地方使用通道"><a href="#避免在不必要的地方使用通道" class="headerlink" title="避免在不必要的地方使用通道"></a>避免在不必要的地方使用通道</h3><p>通道（channel）和 map、切片一样，也是由 Go 源码编写而成。为了保证两个 goroutine 并发访问的安全性，通道也需要做一些锁操作，因此通道其实并不比锁高效。</p>
<p>下面的例子展示套接字的接收和并发管理。对于 TCP 来说，一般是接收过程创建 goroutine 并发处理。当套接字结束时，就要正常退出这些 goroutine</p>
<p>下面是对各个部分的详细分析。</p>
<p><strong>1)套接字接收部分</strong></p>
<p>套接字在连接后，就需要不停地接收数据，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 套接字接收过程</span><br><span class="line">func socketRecv(conn net.Conn, exitChan chan string) {</span><br><span class="line"></span><br><span class="line">// 创建一个接收的缓冲</span><br><span class="line">    buff := make([]byte, 1024)</span><br><span class="line"></span><br><span class="line">    // 不停地接收数据</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 从套接字中读取数据</span><br><span class="line">        _, err := conn.Read(buff)</span><br><span class="line"></span><br><span class="line">        // 需要结束接收, 退出循环</span><br><span class="line">        if err != nil {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 函数已经结束, 发送通知</span><br><span class="line">    exitChan &lt;- "recv exit"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行传入的 net.Conn 是套接字的接口，exitChan 为退出发送同步通道。</li>
<li>第 5 行为套接字的接收数据创建一个缓冲。</li>
<li>第 8 行构建一个接收的循环，不停地接收数据。</li>
<li>第 11 行，从套接字中取出数据。这个例子中，不关注具体接收到的数据，只是关注错误，这里将接收到的字节数做匿名处理。</li>
<li>第 14 行，当套接字调用了 Close 方法时，会触发错误，这时需要结束接收循环。</li>
<li>第 21 行，结束函数时，与函数绑定的 goroutine 会同时结束，此时需要通知 main() 的 goroutine。</li>
</ul>
<p><strong>2)连接、关闭、同步 goroutine 主流程部分</strong></p>
<p>下面代码中尝试使用套接字的 TCP 协议连接一个网址，连接上后，进行数据接收，等待一段时间后主动关闭套接字，等待套接字所在的 goroutine 自然结束，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 连接一个地址</span><br><span class="line">    conn, err := net.Dial("tcp", "www.163.com:80")</span><br><span class="line"></span><br><span class="line">    // 发生错误时打印错误退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 创建退出通道</span><br><span class="line">    exit := make(chan string)</span><br><span class="line"></span><br><span class="line">    // 并发执行套接字接收</span><br><span class="line">    go socketRecv(conn, exit)</span><br><span class="line"></span><br><span class="line">    // 在接收时, 等待1秒</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    // 主动关闭套接字</span><br><span class="line">    conn.Close()</span><br><span class="line"></span><br><span class="line">    // 等待goroutine退出完毕</span><br><span class="line">    fmt.Println(&lt;-exit)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，使用 net.Dial 发起 TCP 协议的连接，调用函数就会发送阻塞直到连接超时或者连接完成。</li>
<li>第 7 行，如果连接发生错误，将会打印错误并退出。</li>
<li>第 13 行，创建一个通道用于退出信号同步，这个通道会在接收用的 goroutine 中使用。</li>
<li>第 16 行，并发执行接收函数，传入套接字和用于退出通知的通道。</li>
<li>第 19 行，接收需要一个过程，使用 time.Sleep() 等待一段时间。</li>
<li>第 22 行，主动关闭套接字，此时会触发套接字接收错误。</li>
<li>第 25 行，从 exit 通道接收退出数据，也就是等待接收 goroutine 结束。</li>
</ul>
<p>在这个例子中，goroutine 退出使用通道来通知，这种做法可以解决问题，但是实际上通道中的数据并没有完全使用。</p>
<p><strong>3)优化：使用等待组替代通道简化同步</strong></p>
<p>通道的内部实现代码在Go语言开发包的 <code>src/runtime/chan.go</code> 中，经过分析后大概了解到通道也是用常见的互斥量等进行同步。因此通道虽然是一个语言级特性，但也不是被神化的特性，通道的运行和使用都要比传统互斥量、等待组（sync.WaitGroup）有一定的消耗。</p>
<p>所以在这个例子中，更建议使用等待组来实现同步，调整后的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "net"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 套接字接收过程</span><br><span class="line">func socketRecv(conn net.Conn, wg *sync.WaitGroup) {</span><br><span class="line"></span><br><span class="line">    // 创建一个接收的缓冲</span><br><span class="line">    buff := make([]byte, 1024)</span><br><span class="line"></span><br><span class="line">    // 不停地接收数据</span><br><span class="line">    for {</span><br><span class="line"></span><br><span class="line">        // 从套接字中读取数据</span><br><span class="line">        _, err := conn.Read(buff)</span><br><span class="line"></span><br><span class="line">        // 需要结束接收, 退出循环</span><br><span class="line">        if err != nil {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 函数已经结束, 发送通知</span><br><span class="line">    wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 连接一个地址</span><br><span class="line">    conn, err := net.Dial("tcp", "www.163.com:80")</span><br><span class="line"></span><br><span class="line">    // 发生错误时打印错误退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 退出通道</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // 添加一个任务</span><br><span class="line">    wg.Add(1)</span><br><span class="line"></span><br><span class="line">    // 并发执行接收套接字</span><br><span class="line">    go socketRecv(conn, &amp;wg)</span><br><span class="line"></span><br><span class="line">    // 在接收时, 等待1秒</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">    // 主动关闭套接字</span><br><span class="line">    conn.Close()</span><br><span class="line"></span><br><span class="line">    // 等待goroutine退出完毕</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println("recv done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调整后的代码说明如下：</p>
<ul>
<li>第 45 行，声明退出同步用的等待组。</li>
<li>第 48 行，为等待组的计数器加 1，表示需要完成一个任务。</li>
<li>第 51 行，将等待组的指针传入接收函数。</li>
<li>第 60 行，等待等待组的完成，完成后打印提示。</li>
<li>第 30 行，接收完成后，使用 wg.Done() 方法将等待组计数器减一。</li>
</ul>
<h2 id="使用select切换协程"><a href="#使用select切换协程" class="headerlink" title="使用select切换协程"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4479.html">使用select切换协程</a></h2><p>从不同的并发执行的协程中获取值可以通过关键字 select 来完成，它和 switch 控制语句非常相似也被称作通信开关；它的行为像是“你准备好了吗”的轮询机制；select 监听进入通道的数据，也可以是用通道发送值的时候。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">select {</span><br><span class="line">case u:= &lt;- ch1:</span><br><span class="line">    ...</span><br><span class="line">case v:= &lt;- ch2:</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">default: // no value ready to be received</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>default 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 break 或者 return，select 就结束了。</p>
<p>select 做的就是：选择处理列出的多个通信情况中的一个。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。</li>
</ul>
<p>在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</p>
<p>select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。</p>
<p>在下面的示例程序中有 2 个通道 ch1 和 ch2 ，三个协程 pump1() 、pump2() 和 suck() 。这是一个典型的生产者消费者模式。在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也是在无限循环中轮询输入的，通过 select 语句获取 ch1 和 ch2 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    ch1 := make(chan int)</span><br><span class="line">    ch2 := make(chan int)</span><br><span class="line">    go pump1(ch1)</span><br><span class="line">    go pump2(ch2)</span><br><span class="line">    go suck(ch1, ch2)</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">}</span><br><span class="line">func pump1(ch chan int) {</span><br><span class="line">    for i := 0; ; i++ {</span><br><span class="line">        ch &lt;- i * 2</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func pump2(ch chan int) {</span><br><span class="line">    for i := 0; ; i++ {</span><br><span class="line">        ch &lt;- i + 5</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func suck(ch1, ch2 chan int) {</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case v := &lt;-ch1:</span><br><span class="line">            fmt.Printf("Received on channel 1: %d\n", v)</span><br><span class="line">        case v := &lt;-ch2:</span><br><span class="line">            fmt.Printf("Received on channel 2: %d\n", v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Received on channel 2: 5</span><br><span class="line">Received on channel 2: 6</span><br><span class="line">Received on channel 1: 0</span><br><span class="line">Received on channel 2: 7</span><br><span class="line">Received on channel 2: 8</span><br><span class="line">Received on channel 2: 9</span><br><span class="line">Received on channel 2: 10</span><br><span class="line">Received on channel 1: 2</span><br><span class="line">Received on channel 2: 11</span><br><span class="line">...</span><br><span class="line">Received on channel 2: 47404</span><br><span class="line">Received on channel 1: 94346</span><br><span class="line">Received on channel 1: 94348</span><br></pre></td></tr></tbody></table></figure>
<p>一秒内的输出非常惊人，如果我们给它计数，得到了 90000 个左右的数字。</p>
<h2 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h2><p>一般的 HTTPS 是基于 SSL（Secure Sockets Layer）协议。SSL 是网景公司开发的位于 TCP 与 HTTP 之间的透明安全协议，通过 SSL，可以把 HTTP 包数据以非对称加密的形式往返于浏览器和站点之间，从而避免被第三方非法获取。</p>
<p>目前，伴随着电子商务的兴起，HTTPS 获得了广泛的应用。由 IETF（Internet Engineering Task Force）实现的 TLS（Transport Layer Security）是建立于 SSL v3.0 之上的兼容协议，它们主要的区别在于所支持的加密算法。</p>
<h3 id="加密通信流程"><a href="#加密通信流程" class="headerlink" title="加密通信流程"></a>加密通信流程</h3><p>当用户在浏览器中输入一个以 https 开头的网址时，便开启了浏览器与被访问站点之间的加密通信。下面我们以百度 <code>https://www.baidu.com/</code> 为例，为大家展现一下 SSL/TLS 的工作方式。</p>
<p>1)在浏览器中输入 HTTPS 协议的网址，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/httpsbaidu.gif" alt="httpsbaidu"></p>
<p>2)服务器向浏览器返回证书，浏览器检查该证书的合法性，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/httpsbaidu1.gif" alt="httpsbaidu1"></p>
<p>3)验证合法性，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/httpsbaidu2.gif" alt="httpsbaidu2"></p>
<p>4)浏览器使用证书中的公钥加密一个随机对称密钥，并将加密后的密钥和使用密钥加密后的请求 URL 一起发送到服务器。</p>
<p>5)服务器用私钥解密随机对称密钥，并用获取的密钥解密加密的请求 URL。</p>
<p>6)服务器把用户请求的网页用密钥加密，并返回给用户。</p>
<p>7)用户浏览器用密钥解密服务器发来的网页数据，并将其显示出来。</p>
<p>上述过程都是依赖于 SSL/TLS 层实现的。在实际开发中，SSL/TLS 的实现和工作原理比较复杂，但基本流程与上面的过程一致。</p>
<p>SSL 协议由两层组成，上层协议包括 SSL 握手协议、更改密码规格协议、警报协议，下层协议包括 SSL 记录协议。</p>
<p>SSL 握手协议建立在 SSL 记录协议之上，在实际的数据传输开始前，用于在客户与服务器之间进行“握手”。“握手”是一个协商过程。这个协议使得客户和服务器能够互相鉴别身份，协商加密算法。在任何数据传输之前，必须先进行“握手”。</p>
<p>在“握手”完成之后，才能进行 SSL 记录协议，它的主要功能是为高层协议提供数据封装、压缩、添加MAC、加密等支持。</p>
<h3 id="支持-HTTPS-的-Web-服务器"><a href="#支持-HTTPS-的-Web-服务器" class="headerlink" title="支持 HTTPS 的 Web 服务器"></a>支持 HTTPS 的 Web 服务器</h3><p>Go语言目前实现了 TLS 协议的部分功能，已经可以提供最基础的安全层服务。下面我们来看一下如何实现支持 TLS 的 Web 服务器。下面的代码示范了如何使用 http.ListenAndServerTLS 实现一个支持 HTTPS 的 Web 服务器。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const RESPONSE_TEMPLATE = "C语言中文网"</span><br><span class="line"></span><br><span class="line">func rootHandler(w http.ResponseWriter, req *http.Request) {</span><br><span class="line">    w.Header().Set("Content-Type", "text/plain")</span><br><span class="line">    w.Header().Set("Content-Length", fmt.Sprint(len(RESPONSE_TEMPLATE)))</span><br><span class="line">    w.Write([]byte(RESPONSE_TEMPLATE))</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", rootHandler)</span><br><span class="line">    http.ListenAndServeTLS(":8080", "cert.pem", "key.pem", nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的程序需要用到 cert.pem 和 key.pem 这两个文件，可以使用 crypto/tls 包的 generate_cert.go 文件来生成，运行成功后我们可以在浏览器中通过 <code>https://localhost:8080</code> 查看访问效果，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/httplocalhost.gif" alt="httplocalhost"></p>
<p>可以看到，我们使用了 http.ListenAndServerTLS() 这个方法，这表明它是执行在 TLS 层上的 HTTP 协议。如果我们并不需要支持 HTTPS，只需要把该方法替换为 http.ListenAndServeTLS(fmt.Sprintf(“:%d”, SERVER_PORT), nil) 即可。</p>
<h3 id="支持-HTTPS-的文件服务器"><a href="#支持-HTTPS-的文件服务器" class="headerlink" title="支持 HTTPS 的文件服务器"></a>支持 HTTPS 的文件服务器</h3><p>利用 Go语言标准库中提供的完备封装，我们也可以很容易实现一个支持 HTTPS 的文件服务器，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    h := http.FileServer(http.Dir("."))</span><br><span class="line">    http.ListenAndServeTLS(":8001", "cert.pem", "key.pem", h)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行效果如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/httplocalhost1.gif" alt="httplocalhost1"></p>
<h3 id="基于-SSL-TLS-的-ECHO-程序"><a href="#基于-SSL-TLS-的-ECHO-程序" class="headerlink" title="基于 SSL/TLS 的 ECHO 程序"></a>基于 SSL/TLS 的 ECHO 程序</h3><p>在本章最后，我们用一个完整的安全版 ECHO 程序来演示如何让 Socket 通信也支持 HTTPS。当然，ECHO 程序支持 HTTPS 似乎没有什么必要，但这个程序可以比较容易地改造成有实际价值的程序，比如安全的聊天工具等。</p>
<p>下面我们首先实现这个超级 ECHO 程序的服务器端，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "crypto/rand"</span><br><span class="line">    "crypto/tls"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "net"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    cert, err := tls.LoadX509KeyPair("rui.crt", "rui.key")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatalf("server: loadkeys: %s", err)</span><br><span class="line">    }</span><br><span class="line">    config := tls.Config{Certificates:[]tls.Certificate{cert}}</span><br><span class="line">    config.Time = time.Now</span><br><span class="line">    config.Rand = rand.Reader</span><br><span class="line">    service := "127.0.0.1:8000"</span><br><span class="line">    listener, err := tls.Listen("tcp", service, &amp;config)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatalf("server: listen: %s", err)</span><br><span class="line">    }</span><br><span class="line">    log.Print("server: listening")</span><br><span class="line">    for {</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        if err != nil {</span><br><span class="line">            log.Printf("server: accept: %s", err)</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        log.Printf("server: accepted from %s", conn.RemoteAddr())</span><br><span class="line">        go handleClient(conn)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func handleClient(conn net.Conn) {</span><br><span class="line">    defer conn.Close()</span><br><span class="line">    buf := make([]byte, 512)</span><br><span class="line">    for {</span><br><span class="line">        log.Print("server: conn: waiting")</span><br><span class="line">        n, err := conn.Read(buf)</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Printf("server: conn: read: %s", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        log.Printf("server: conn: echo %q\n", string(buf[:n]))</span><br><span class="line">        n, err = conn.Write(buf[:n])</span><br><span class="line">        log.Printf("server: conn: wrote %d bytes", n)</span><br><span class="line">        if err != nil {</span><br><span class="line">            log.Printf("server: write: %s", err)</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    log.Println("server: conn: closed")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在服务器端已经实现了。我们再实现超级 ECHO 的客户端，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "crypto/tls"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    conn, err := tls.Dial("tcp", "127.0.0.1:8000", nil)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatalf("client: dial: %s", err)</span><br><span class="line">    }</span><br><span class="line">    defer conn.Close()</span><br><span class="line">    log.Println("client: connected to: ", conn.RemoteAddr())</span><br><span class="line">    state := conn.ConnectionState()</span><br><span class="line">    log.Println("client: handshake: ", state.HandshakeComplete)</span><br><span class="line">    log.Println("client: mutual: ", state.NegotiatedProtocolIsMutual)</span><br><span class="line">    message := "Hello\n"</span><br><span class="line">    n, err := io.WriteString(conn, message)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatalf("client: write: %s", err)</span><br><span class="line">    }</span><br><span class="line">    log.Printf("client: wrote %q (%d bytes)", message, n)</span><br><span class="line">    reply := make([]byte, 256)</span><br><span class="line">    n, err = conn.Read(reply)</span><br><span class="line">    log.Printf("client: read %q (%d bytes)", string(reply[:n]), n)</span><br><span class="line">    log.Print("client: exiting")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们分别编译和运行服务器端和客户端程序，可以看到类似以下的运行效果。</p>
<p>服务器端的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2012/04/06 13:48:24 server: listening</span><br><span class="line">2012/04/06 13:50:41 server: accepted from 127.0.0.1:15056</span><br><span class="line">2012/04/06 13:50:41 server: conn: waiting</span><br><span class="line">2012/04/06 13:50:41 server: conn: echo "Hello\n"</span><br><span class="line">2012/04/06 13:50:41 server: conn: wrote 6 bytes</span><br><span class="line">2012/04/06 13:50:41 server: conn: waiting</span><br><span class="line">2012/04/06 13:50:41 server: conn: closed</span><br></pre></td></tr></tbody></table></figure>
<p>客户端的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2012/04/06 13:50:41 client: connected to: 127.0.0.1:8000</span><br><span class="line">2012/04/06 13:50:41 client: handshake: true</span><br><span class="line">2012/04/06 13:50:41 client: mutual: true</span><br><span class="line">2012/04/06 13:50:41 client: wrote "Hello\n" (6 bytes)</span><br><span class="line">2012/04/06 13:50:41 client: read "Hello\n" (6 bytes)</span><br><span class="line">2012/04/06 13:50:41 client: exiting</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，SSL/TLS 协议只能运行于 TCP 之上，不能在 UDP 上工作，且 SSL/TLS 位于 TCP 与应用层协议之间，因此所有基于 TCP 的应用层协议都可以透明地使用 SSL/TLS 为自己提供安全保障。所谓透明地使用是指既不需要了解细节，也不需要专门处理该层的包，比如封装、解封等。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go 并发</tag>
        <tag>goroutine</tag>
      </tags>
  </entry>
  <entry>
    <title>go gateway</title>
    <url>/posts/238f595d/</url>
    <content><![CDATA[<h2 id="Manba-一个http网关"><a href="#Manba-一个http网关" class="headerlink" title="Manba 一个http网关"></a><a target="_blank" rel="noopener" href="https://github.com/fagongzi/manba">Manba 一个http网关</a></h2><h2 id="goku-悟空-API-网关"><a href="#goku-悟空-API-网关" class="headerlink" title="goku 悟空 API 网关"></a><a target="_blank" rel="noopener" href="https://github.com/eolinker/goku-api-gateway">goku 悟空 API 网关</a></h2><h2 id="go-gateway-学习代码"><a href="#go-gateway-学习代码" class="headerlink" title="go_gateway 学习代码"></a><a target="_blank" rel="noopener" href="https://github.com/e421083458/go_gateway/">go_gateway 学习代码</a></h2><h2 id="etcd-cluster"><a href="#etcd-cluster" class="headerlink" title="etcd_cluster"></a>etcd_cluster</h2><ul>
<li><code>http://10.100.202.121:2379</code>  <code>http://10.100.202.121:2380</code></li>
<li><code>http://10.100.218.121:2379</code>  <code>http://10.100.218.121:2380</code></li>
<li><code>http://10.100.218.122:2379</code>  <code>http://10.100.218.122:2380</code></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>go compile</title>
    <url>/posts/50eae218/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go compile</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring FrameWork基础(一)</title>
    <url>/posts/aa4b0e29/</url>
    <content><![CDATA[<p>Spring-Core</p>
<a id="more"></a>
<p>本部分从最基本的Spring开始。配置文件:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"pro.ang.wss.demo.user.service.impl.UserServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>启动代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClassPathXmlApplicationContext appContext = </span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        UserService userService = appContext.getBean(<span class="string">"userService"</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">        User user = appContext.getBean(<span class="string">"user"</span>, User.class);</span><br><span class="line">        userService.save(user);</span><br><span class="line">        appContext.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>UserService:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>{</span><br><span class="line">    <span class="function">Long <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>UserServiceImpl:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service("userService")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>{</span><br><span class="line">    Logger log = LoggerFactory.getLogger(UserServiceImpl.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        log.debug(<span class="string">"[Spring Bean Lifecycle-1 UserService#constructor]"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">save</span><span class="params">(User user)</span> </span>{</span><br><span class="line">        log.debug(<span class="string">"[Spring Bean Lifecycle-10 UserService#save] - "</span> + user.getName());</span><br><span class="line">        <span class="keyword">return</span> userDao.save(user);</span><br><span class="line">    }</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure>
<h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ResourceLoader.jpg" alt="ResourceLoader继承体系"></p>
<p>ResourceLoader代表了加载资源的一种方式，正是策略模式的实现。</p>
<p>构造器源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">super</span>(parent);<span class="comment">//null</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) {<span class="comment">//默认为true</span></span><br><span class="line">        refresh();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p>
<h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... locations)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) {</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) {</span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>resolvePath的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: new ClassPathXmlApplicationContext(“classpath:config.xml”);那么classpath:就是需要被解析的。</p>
<p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Environment.jpg" alt="Environment继承体系"></p>
<p>Environmen接口 <strong>代表了当前应用所处的环境。</strong> 从此接口的方法可以看出，其主要和profile、Property相关。</p>
<h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在不同环境之间无缝切换。 <strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong> 使用了Profile的配置文件示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"develop"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-develop.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-production.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"test"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:jdbc-test.properties"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>在启动代码中可以用如下代码设置活跃(当前使用的)Profile:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">"develop"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>当然使用的方式还有很多(比如注解)，参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/radiumxie-1851919">spring3.1 profile 配置不同的环境</a></li>
<li><a target="_blank" rel="noopener" href="https://mkyong.com/spring/spring-profiles-example/">Spring Profiles example</a></li>
</ul>
<h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on.</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>{</span><br><span class="line">    customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Initialized "</span> + getClass().getSimpleName() + <span class="string">" with PropertySources "</span> + <span class="keyword">this</span>.propertySources);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertySources.jpg" alt="PropertySources继承体系"></p>
<p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p>
<p>StandardEnvironment.customizePropertySources:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** System environment property source name: {<span class="doctag">@value</span>} */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** JVM system properties property source name: {<span class="doctag">@value</span>} */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>{</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> MapPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>继承体系：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertySource.jpg" alt="PropertySource继承体系"></p>
<p>PropertySource接口代表了键值对的Property来源。</p>
<p>AbstractEnvironment.getSystemProperties:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings({"unchecked", "rawtypes"})</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> (Map) System.getProperties();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) {</span><br><span class="line">        <span class="keyword">return</span> (Map) <span class="keyword">new</span> ReadOnlySystemAttributesMap() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">getSystemAttribute</span><span class="params">(String attributeName)</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(attributeName);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (AccessControlException ex) {</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                        logger.info(<span class="string">"Caught AccessControlException when accessing system property '"</span> +</span><br><span class="line">                            attributeName + <span class="string">"'; its value will be returned [null]. Reason: "</span> + ex.getMessage());</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p>
<p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p>
<h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);<span class="comment">//text即配置文件路径，比如classpath:config.xml</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</span><br><span class="line">    <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</span><br></pre></td></tr></tbody></table></figure>
<h5 id="PropertyResolver接口"><a href="#PropertyResolver接口" class="headerlink" title="PropertyResolver接口"></a>PropertyResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertyResolver.jpg" alt="PropertyResolver继承体系"></p>
<p>PropertyResolver接口正是用来解析PropertyResource。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>{</span><br><span class="line">    <span class="comment">//三个参数分别是${, }, :</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</span><br><span class="line">        <span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>{</span><br><span class="line">    <span class="comment">//PlaceholderResolver接口依然是策略模式的体现</span></span><br><span class="line">    <span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> getPropertyAsRawString(placeholderName);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">"spring"</span>, <span class="string">"classpath"</span>);</span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"${spring}:config.xml"</span>);</span><br><span class="line">SimpleBean bean = context.getBean(SimpleBean.class);</span><br></pre></td></tr></tbody></table></figure>
<p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getProperty(key, String.class, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetValueType, <span class="keyword">boolean</span> resolveNestedPlaceholders)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="keyword">this</span>.propertySources) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) {</span><br><span class="line">                logger.trace(<span class="string">"Searching for key '"</span> + key + <span class="string">"' in PropertySource '"</span> +</span><br><span class="line">                    propertySource.getName() + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">            Object value = propertySource.getProperty(key);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (resolveNestedPlaceholders &amp;&amp; value <span class="keyword">instanceof</span> String) {</span><br><span class="line">                    value = resolveNestedPlaceholders((String) value);</span><br><span class="line">                }</span><br><span class="line">                logKeyFound(key, propertySource, value);</span><br><span class="line">                <span class="keyword">return</span> convertValueIfNecessary(value, targetValueType);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Could not find key '"</span> + key + <span class="string">"' in any property source"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p>
<p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p>
<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p>Spring bean解析就在此方法，所以单独提出来。</p>
<p>AbstractApplicationContext.refresh:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>{</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) {</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">        logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">    initPropertySources();<span class="comment">//空实现</span></span><br><span class="line">    <span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h4><p>AbstractEnvironment.validateRequiredProperties:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>{</span><br><span class="line">    <span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AbstractPropertyResolver.validateRequiredProperties:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> </span>{</span><br><span class="line">    MissingRequiredPropertiesException ex = <span class="keyword">new</span> MissingRequiredPropertiesException();</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.requiredProperties) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getProperty(key) == <span class="keyword">null</span>) {</span><br><span class="line">            ex.addMissingRequiredProperty(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) {</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。</p>
<h3 id="BeanFactory创建"><a href="#BeanFactory创建" class="headerlink" title="BeanFactory创建"></a>BeanFactory创建</h3><p>由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) {</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) {</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h4><p>BeanFactory接口实际上就是Bean容器，其继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/BeanFactory.jpg" alt="BeanFactory继承体系"></p>
<h4 id="BeanFactory定制"><a href="#BeanFactory定制" class="headerlink" title="BeanFactory定制"></a>BeanFactory定制</h4><p>AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) {</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);<span class="comment">//默认false，不允许覆盖</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) {</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);<span class="comment">//默认false，不允许循环引用</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Bean加载"><a href="#Bean加载" class="headerlink" title="Bean加载"></a>Bean加载</h4><p>AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>{</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);<span class="comment">//默认空实现</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h5><p>只说明用到的部分继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/EntityResolver.jpg" alt="EntityResolver继承体系"></p>
<p>EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。</p>
<h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/BeanDefinitionReader.jpg" alt="BeanDefinitionReader继承体系"></p>
<h5 id="路径解析-Ant"><a href="#路径解析-Ant" class="headerlink" title="路径解析(Ant)"></a>路径解析(Ant)</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>{</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) {</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    }</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) {</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AbstractBeanDefinitionReader.loadBeanDefinitions:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) {</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>之后调用:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//第二个参数为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="comment">//参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) {</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//加载</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="comment">//解析</span></span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) {</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) {</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getResource的实现在AbstractApplicationContext：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">//构造器中初始化，PathMatchingResourcePatternResolver对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException {</span><br><span class="line">    Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">    <span class="comment">//classpath:</span></span><br><span class="line">    <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {</span><br><span class="line">        <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">        <span class="comment">//matcher是一个AntPathMatcher对象</span></span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {</span><br><span class="line">            <span class="comment">// a class path resource pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// all class path resources with the given name</span></span><br><span class="line">            <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Generally only look for a pattern after a prefix here,</span></span><br><span class="line">        <span class="comment">// and on Tomcat only after the "*/" separator for its "war:" protocol.</span></span><br><span class="line">        <span class="keyword">int</span> prefixEnd = (locationPattern.startsWith(<span class="string">"war:"</span>) ? locationPattern.indexOf(<span class="string">"*/"</span>) + <span class="number">1</span> :</span><br><span class="line">                locationPattern.indexOf(<span class="string">':'</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {</span><br><span class="line">            <span class="comment">// a file pattern</span></span><br><span class="line">            <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// a single resource with the given name</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Resource[] {getResourceLoader().getResource(locationPattern)};</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>isPattern:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPattern</span><span class="params">(String path)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (path.indexOf(<span class="string">'*'</span>) != -<span class="number">1</span> || path.indexOf(<span class="string">'?'</span>) != -<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出配置文件路径是支持ant风格的，也就是可以这么写:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"con*.xml"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>具体怎么解析ant风格的就不写了。</p>
<h5 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h5><p>入口方法在AbstractBeanDefinitionReader的loadBeanDefinitions方法中:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//加载</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br></pre></td></tr></tbody></table></figure>
<p>最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Resource是代表一种资源的接口，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Resource.jpg" alt="Resource类图"></p>
<p>EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。</p>
<p>之后关键的源码只有两行:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>InputSource是org.xml.sax的类。</p>
<p>doLoadBeanDefinitions：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> </span>{</span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>doLoadDocument:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">            getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。</p>
<p>校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。</p>
<p>NamespaceAware默认false，因为默认配置了校验为true。</p>
<p>DefaultDocumentLoader.loadDocument:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">//这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存</span></span><br><span class="line">    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">    <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>createDocumentBuilderFactory比较有意思:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> ParserConfigurationException </span>{</span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    factory.setNamespaceAware(namespaceAware);</span><br><span class="line">    <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {</span><br><span class="line">        <span class="comment">//此方法设为true仅对dtd有效，xsd(schema)无效</span></span><br><span class="line">        factory.setValidating(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {</span><br><span class="line">            <span class="comment">// Enforce namespace aware for XSD...</span></span><br><span class="line">            <span class="comment">//开启xsd(schema)支持</span></span><br><span class="line">            factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//这个也是Java支持Schema的套路，可以问度娘</span></span><br><span class="line">                factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (IllegalArgumentException ex) {</span><br><span class="line">                ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(</span><br><span class="line">                        <span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory +</span><br><span class="line">                        <span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> +</span><br><span class="line">                        <span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);</span><br><span class="line">                pcex.initCause(ex);</span><br><span class="line">                <span class="keyword">throw</span> pcex;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Bean解析"><a href="#Bean解析" class="headerlink" title="Bean解析"></a>Bean解析</h5><p>XmlBeanDefinitionReader.registerBeanDefinitions:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>createBeanDefinitionDocumentReader:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));<span class="comment">//反射</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。</p>
<p>注意cast方法，代替了强转。</p>
<p>createReaderContext：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">            <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>problemReporter是一个FailFastProblemReporter对象。</p>
<p>eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。</p>
<p>sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。</p>
<p>getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。</p>
<p>XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。</p>
<p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>doRegisterBeanDefinitions:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>{</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">//默认的命名空间即,http://www.springframework.org/schema/beans</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) {</span><br><span class="line">        <span class="comment">//检查profile属性</span></span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) {</span><br><span class="line">            <span class="comment">//profile属性可以以,分割</span></span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                    logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec + <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"java.lang.Object"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>xml(schema)的命名空间其实类似于java的包名，命名空间采用URL，比如Spring的是这样:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于<code>http://www.springframework.org/schema/beans:bean</code>,可以有效的防止命名冲突。命名空间可以通过规范定义的<code>org.w3c.dom.Node.getNamespaceURI</code>方法获得。</p>
<p>注意一下profile的检查, AbstractEnvironment.acceptsProfiles:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span> </span>{</span><br><span class="line">    Assert.notEmpty(profiles, <span class="string">"Must specify at least one profile"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String profile : profiles) {</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(<span class="number">0</span>) == <span class="string">'!'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (!isProfileActive(profile.substring(<span class="number">1</span>))) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isProfileActive(profile)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>原理很简单，注意从源码可以看出，profile属性支持!取反。</p>
<p>preProcessXml方法是个空实现，供子类去覆盖，目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会, 想的真周到。</p>
<p>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) {</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) {</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) {</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可见，对于非默认命名空间的元素交由delegate处理。</p>
<h5 id="默认命名空间解析"><a href="#默认命名空间解析" class="headerlink" title="默认命名空间解析"></a>默认命名空间解析</h5><p>即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {</span><br><span class="line">        <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>写法示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"CTIContext.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"customerContext.xml"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。</p>
<h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"componentA-dataSource"</span> <span class="attr">alias</span>=<span class="string">"componentB-dataSource"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>processAliasRegistration核心源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>{</span><br><span class="line">    String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line">    getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String name, String alias)</span> </span>{</span><br><span class="line">    Assert.hasText(name, <span class="string">"'name' must not be empty"</span>);</span><br><span class="line">    Assert.hasText(alias, <span class="string">"'alias' must not be empty"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.aliasMap) {</span><br><span class="line">         <span class="comment">//名字和别名一样</span></span><br><span class="line">        <span class="keyword">if</span> (alias.equals(name)) {</span><br><span class="line">            <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            String registeredName = <span class="keyword">this</span>.aliasMap.get(alias);</span><br><span class="line">            <span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (registeredName.equals(name)) {</span><br><span class="line">                    <span class="comment">// An existing alias - no need to re-register</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (!allowAliasOverriding()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register alias '"</span> + alias + <span class="string">"' for name '"</span> +</span><br><span class="line">                            name + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            checkForAliasCircle(name, alias);</span><br><span class="line">            <span class="keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以别名关系的保存使用Map完成，key为别名，value为本来的名字。</p>
<h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>bean节点是Spring最最常见的节点了。</p>
<p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>{</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) {</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) {</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="id-amp-name处理"><a href="#id-amp-name处理" class="headerlink" title="id &amp; name处理"></a>id &amp; name处理</h5><p>最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>{</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) {</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<span class="comment">//按,分隔</span></span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    }</span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);<span class="comment">//name的第一个值作为id</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) {<span class="comment">//默认null</span></span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele); <span class="comment">//校验id是否已重复，如果重复直接抛异常;校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set</span></span><br><span class="line">    }</span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) {</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);<span class="comment">//如果name和id属性都没有指定，那么Spring会自己生成一个</span></span><br><span class="line">                    <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                    <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                    <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();<span class="comment">//可见，Spring同时会把类名作为其别名</span></span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                            !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                            <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先获取到id和name属性，name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做。</p>
<p>如果name和id属性都没有指定，那么Spring会自己生成一个，Spring同时会把类名作为其别名</p>
<p>最终调用的是BeanDefinitionReaderUtils.generateBeanName:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">    <span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) {</span><br><span class="line">            generatedBeanName = definition.getParentName() + <span class="string">"$child"</span>;<span class="comment">//工厂方法产生的bean</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) {</span><br><span class="line">            generatedBeanName = definition.getFactoryBeanName() + <span class="string">"$created"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(generatedBeanName)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Unnamed bean definition specifies neither "</span> +</span><br><span class="line">                <span class="string">"'class' nor 'parent' nor 'factory-bean' - can't generate bean name"</span>);</span><br><span class="line">    }</span><br><span class="line">    String id = generatedBeanName;</span><br><span class="line">    <span class="keyword">if</span> (isInnerBean) {</span><br><span class="line">        <span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Top-level bean: use plain class name.</span></span><br><span class="line">        <span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">        <span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) {<span class="comment">//用类名#自增的数字命名</span></span><br><span class="line">            counter++;</span><br><span class="line">            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="bean解析"><a href="#bean解析" class="headerlink" title="bean解析"></a>bean解析</h5><p>还是分部分说明(parseBeanDefinitionElement)。</p>
<p>首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, String beanName, BeanDefinition containingBean)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) {</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        String parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) {</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        }</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">        error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (NoClassDefFoundError err) {</span><br><span class="line">        error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(String parentName, String className, ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) {</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br></pre></td></tr></tbody></table></figure>
<p>之后解析bean的decription子元素:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SimpleBean<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>就仅仅是个描述。</p>
<p>然后是meta子元素的解析，meta元素在xml配置文件里是这样的:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">name</span>=<span class="string">"one, two"</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMetaElements</span><span class="params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> </span>{</span><br><span class="line">    NodeList nl = ele.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) {</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {</span><br><span class="line">            Element metaElement = (Element) node;</span><br><span class="line">            String key = metaElement.getAttribute(KEY_ATTRIBUTE);</span><br><span class="line">            String value = metaElement.getAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">            BeanMetadataAttribute attribute = <span class="keyword">new</span> BeanMetadataAttribute(key, value);<span class="comment">//就是一个key, value的载体，无他</span></span><br><span class="line">            attribute.setSource(extractSource(metaElement));<span class="comment">//sourceExtractor默认是NullSourceExtractor，返回的是空</span></span><br><span class="line">            attributeAccessor.addMetadataAttribute(attribute);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。</p>
<p>lookup-method解析：</p>
<p>此标签的作用在于当一个bean的某个方法被设置为lookup-method后，每次调用此方法时，都会返回一个新的指定bean的对象。用法示例:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"apple"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.com.willchen.test.di.Apple"</span> scope=<span class="string">"prototype"</span>/&gt;</span><br><span class="line">&lt;!--水果盘--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"fruitPlate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.com.willchen.test.di.FruitPlate"</span>&gt;</span><br><span class="line">    &lt;lookup-method name=<span class="string">"getFruit"</span> bean=<span class="string">"apple"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>数据保存在Set中，对应的类是MethodOverrides。可以参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ViviChan/p/4981619.html">lookup-method方式实现依赖注入</a></p>
<p>replace-mothod解析:</p>
<p>此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。</p>
<p>配置文件示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"replacer"</span> <span class="attr">class</span>=<span class="string">"spring.MethodReplace"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"spring.LookupMethodBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">replacer</span>=<span class="string">"replacer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span> <span class="attr">match</span>=<span class="string">"String"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure>
<p>arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: <a target="_blank" rel="noopener" href="https://www.iteye.com/blog/elim-2384135">方法注入之替换方法实现</a></p>
<p>解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList专门用于保存arg-type。</p>
<p>构造参数(constructor-arg)解析:</p>
<p>作用一目了然，使用示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span>Cat<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以<code>Map&lt;Integer, ValueHolder&gt;</code> 的形式保存，反之，以List的形式保存。</p>
<p>property解析:</p>
<p>非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。</p>
<p>qualifier解析:</p>
<p>配置示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"12"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"seaswalker"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"student_2"</span>&gt;</span><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBean"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>SimpleBean部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier("student")</span></span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></tbody></table></figure>
<p>此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"org.springframework.beans.factory.annotation.Qualifier"</span> <span class="attr">value</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。</p>
<h5 id="Bean装饰"><a href="#Bean装饰" class="headerlink" title="Bean装饰"></a>Bean装饰</h5><p>这部分是针对其它schema的属性以及子节点，比如:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-override</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="Bean注册"><a href="#Bean注册" class="headerlink" title="Bean注册"></a>Bean注册</h5><p>BeanDefinitionReaderUtils.registerBeanDefinition:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。</p>
<p>ComponentRegistered事件触发:</p>
<p>默认是个空实现，前面说过了。</p>
<h5 id="BeanDefiniton数据结构"><a href="#BeanDefiniton数据结构" class="headerlink" title="BeanDefiniton数据结构"></a>BeanDefiniton数据结构</h5><p>BeanDefiniton数据结构如下图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/BeanDefinition.jpg" alt="BeanDefiniton数据结构"></p>
<h5 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h5><p>beans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>{</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) {</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) {</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                    logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                            <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="其它命名空间解析"><a href="#其它命名空间解析" class="headerlink" title="其它命名空间解析"></a>其它命名空间解析</h4><p>入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions -&gt; BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>{</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">        error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。</p>
<p>其resolve方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>{</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) {</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        String className = (String) handlerOrClassName;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line">                        <span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">            }</span><br><span class="line">            NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">            namespaceHandler.init();</span><br><span class="line">            handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">            <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">                    namespaceUri + <span class="string">"] not found"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError err) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Invalid NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">                    namespaceUri + <span class="string">"]: problem with handler class file or dependent class"</span>, err);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回。</p>
<p>NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></tbody></table></figure>
<h5 id="NamespaceHandler继承体系"><a href="#NamespaceHandler继承体系" class="headerlink" title="NamespaceHandler继承体系"></a>NamespaceHandler继承体系</h5><p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/NamespaceHandler.jpg" alt="NamespaceHandler继承体系"></p>
<h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>resolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。 <strong>此接口用以解析顶层(beans下)的非默认命名空间元素，比如<context:annotation-config></context:annotation-config></strong> 。</p>
<p>所以这样逻辑就很容易理解了:  <strong>每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程</strong>。</p>
<p>此部分较为重要，所以重新开始大纲。</p>
<h5 id="BeanFactory数据结构"><a href="#BeanFactory数据结构" class="headerlink" title="BeanFactory数据结构"></a>BeanFactory数据结构</h5><p>BeanDefinition在BeanFactory中的主要数据结构如下图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Beanfactory_structure.jpg" alt="Beanfactory数据结构"></p>
<h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面:</p>
<h4 id="BeanExpressionResolver"><a href="#BeanExpressionResolver" class="headerlink" title="BeanExpressionResolver"></a>BeanExpressionResolver</h4><p>此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">evaluate</span><span class="params">(String value, BeanExpressionContext evalContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>prepareBeanFactory将一个此对象放入BeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br></pre></td></tr></tbody></table></figure>
<p>StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ExpressionParser.jpg" alt="ExpressionParser继承体系"></p>
<p>这便是Spring3.0开始出现的Spel表达式的解释器。</p>
<h4 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a>PropertyEditorRegistrar</h4><p>此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>实现也只有一个: ResourceEditorRegistrar。</p>
<p>在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。</p>
<p>prepareBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br></pre></td></tr></tbody></table></figure>
<p>BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。</p>
<p>我们有两种方式可以添加自定义PropertyEditor:</p>
<ul>
<li>通过 <code>context.getBeanFactory().registerCustomEditor</code></li>
<li><p>通过Spring配置文件:</p>
  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.CustomEditorConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"customEditors"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"base.Cat"</span> <span class="attr">value</span>=<span class="string">"base.CatEditor"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>参考: <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoudaxia/article/details/36247883">属性编辑器PropertyEditor</a></p>
<h4 id="环境注入"><a href="#环境注入" class="headerlink" title="环境注入"></a>环境注入</h4><p>在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) {</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) {</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) {</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) {</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) {</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) {</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) {</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="依赖解析忽略"><a href="#依赖解析忽略" class="headerlink" title="依赖解析忽略"></a>依赖解析忽略</h4><p>此部分设置哪些接口在进行依赖注入的时候应该被忽略:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="bean伪装"><a href="#bean伪装" class="headerlink" title="bean伪装"></a>bean伪装</h4><p>有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>伪装关系保存在一个<code>Map&lt;Class&lt;?&gt;, Object&gt;</code>里。</p>
<h4 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h4><p>如果配置了此bean，那么：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个东西具体是干什么的在后面<code>context:load-time-weaver</code>中说明。</p>
<h4 id="注册环境"><a href="#注册环境" class="headerlink" title="注册环境"></a>注册环境</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>containsLocalBean特殊之处在于不会去父BeanFactory寻找。</p>
<h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。</p>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>BeanFactoryPostProcessor接口允许我们在bean正式初始化之前改变其值。此接口只有一个方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span></span><br></pre></td></tr></tbody></table></figure>
<p>有两种方式可以向Spring添加此对象:</p>
<ul>
<li><p>通过代码的方式:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">context.addBeanFactoryPostProcessor</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过xml配置的方式:</p>
  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"base.SimpleBeanFactoryPostProcessor"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。</p>
<p>此方法的关键源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，<strong>只有通过<code>context.addBeanFactoryPostProcessor</code>这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在<code>PostProcessorRegistrationDelegate</code>里</strong>。</p>
<p>核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。</p>
<p>注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。</p>
<h3 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h3><p>此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。</p>
<h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>此接口用以支持Spring国际化。继承体系如下:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/MessageSource.jpg" alt="MessageSource继承体系"></p>
<p>AbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。</p>
<p>参考:<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/stamen-1541732">Spring国际化信息</a></p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>java的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/EventObject.jpg" alt="EventObject继承体系"></p>
<h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><h5 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h5><p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ApplicationEventPublisher.jpg" alt="ApplicationEventPublisher继承体系"></p>
<p>一目了然。</p>
<h5 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h5><p>ApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ApplicationEventMulticaster.jpg" alt="ApplicationEventMulticaster继承体系"></p>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/EventListener.jpg" alt="EventListener继承体系"></p>
<p>可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br></pre></td></tr></tbody></table></figure>
<p>initApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。</p>
<h4 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h4><p>AbstractApplicationContext.publishEvent核心代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, ResolvableType eventType)</span> </span>{</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SimpleApplicationEventMulticaster.multicastEvent:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>{</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) {</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    invokeListener(listener, event);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="监听器获取"><a href="#监听器获取" class="headerlink" title="监听器获取"></a>监听器获取</h4><p>获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。</p>
<h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><p>可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?</p>
<h5 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"multicasterExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"multicasterExecutor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>task schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span><br></pre></td></tr></tbody></table></figure>
<p>参考:<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/gong1208-1773177">Spring定时任务的几种实现</a></p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p>开启注解支持:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启@AspectJ AOP代理 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务调度器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 任务执行器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"executor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"executor"</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>在代码中使用示例:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailRegisterListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RegisterEvent</span>&gt; </span>{  </span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(<span class="keyword">final</span> RegisterEvent event)</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"注册成功，发送确认邮件给："</span> + ((User)event.getSource()).getUsername());  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>
<p>参考: <a target="_blank" rel="noopener" href="https://www.iteye.com/blog/jinnianshilongnian-1902886">Spring事件驱动模型</a></p>
<h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。</p>
<h3 id="ApplicationListener注册"><a href="#ApplicationListener注册" class="headerlink" title="ApplicationListener注册"></a>ApplicationListener注册</h3><p>registerListeners方法干的，没什么好说的。</p>
<h3 id="singleton初始化"><a href="#singleton初始化" class="headerlink" title="singleton初始化"></a>singleton初始化</h3><p>finishBeanFactoryInitialization：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) {</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) {</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分部分说明。</p>
<h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><p>此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Specify a Spring 3.0 ConversionService to use for converting property values, as an alternative to JavaBeans PropertyEditors. @since 3.0</span><br></pre></td></tr></tbody></table></figure>
<h4 id="StringValueResolver"><a href="#StringValueResolver" class="headerlink" title="StringValueResolver"></a>StringValueResolver</h4><p>用于解析注解的值。接口只定义了一个方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><p>实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。</p>
<h4 id="进行初始化"><a href="#进行初始化" class="headerlink" title="进行初始化"></a>进行初始化</h4><p>DefaultListableBeanFactory.preInstantiateSingletons:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) {</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {</span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) {</span><br><span class="line">                <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) {</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                            <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                        }</span><br><span class="line">                    }, getAccessControlContext());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) {</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) {</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                }, getAccessControlContext());</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。</p>
<h2 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h2><p>这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。</p>
<h3 id="beanName转化"><a href="#beanName转化" class="headerlink" title="beanName转化"></a>beanName转化</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br></pre></td></tr></tbody></table></figure>
<p>这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。</p>
<h3 id="手动注册bean检测"><a href="#手动注册bean检测" class="headerlink" title="手动注册bean检测"></a>手动注册bean检测</h3><p>前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) {</span><br><span class="line">            logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="检查父容器"><a href="#检查父容器" class="headerlink" title="检查父容器"></a>检查父容器</h3><p>如果父容器存在并且存在此bean定义，那么交由其父容器初始化:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) {</span><br><span class="line">    <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">    <span class="comment">//此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作</span></span><br><span class="line">    String nameToLookup = originalBeanName(name);</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">        <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">        <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="依赖初始化"><a href="#依赖初始化" class="headerlink" title="依赖初始化"></a>依赖初始化</h3><p>bean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">for</span> (String dep : dependsOn) {</span><br><span class="line">        <span class="comment">//检测是否存在循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (isDependent(beanName, dep)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line">        registerDependentBean(dep, beanName);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            getBean(dep);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>registerDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap<string, set="">完成的，key是bean的真实名字。</string,></p>
<h3 id="Singleton初始化"><a href="#Singleton初始化" class="headerlink" title="Singleton初始化"></a>Singleton初始化</h3><p>虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">    sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) {</span><br><span class="line">                <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                destroySingleton(beanName);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="getSingleton方法"><a href="#getSingleton方法" class="headerlink" title="getSingleton方法"></a>getSingleton方法</h4><h5 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h5><p>首先会检测是否已经存在，如果存在，直接返回:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) {</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所有的单例bean都保存在这样的数据结构中: ConcurrentHashMap<string, object="">。</string,></p>
<h5 id="bean创建"><a href="#bean创建" class="headerlink" title="bean创建"></a>bean创建</h5><p>源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:</p>
<h6 id="lookup-method检测"><a href="#lookup-method检测" class="headerlink" title="lookup-method检测"></a>lookup-method检测</h6><p>此部分用于检测lookup-method标签配置的方法是否存在:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br></pre></td></tr></tbody></table></figure>
<p>prepareMethodOverrides:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>{</span><br><span class="line">    <span class="comment">// Check that lookup methods exists.</span></span><br><span class="line">    MethodOverrides methodOverrides = getMethodOverrides();</span><br><span class="line">    <span class="keyword">if</span> (!methodOverrides.isEmpty()) {</span><br><span class="line">        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();</span><br><span class="line">        <span class="keyword">synchronized</span> (overrides) {</span><br><span class="line">            <span class="keyword">for</span> (MethodOverride mo : overrides) {</span><br><span class="line">                prepareMethodOverride(mo);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>prepareMethodOverride:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>{</span><br><span class="line">    <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(</span><br><span class="line">                <span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() +</span><br><span class="line">                <span class="string">"' on class ["</span> + getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span></span><br><span class="line">        mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="InstantiationAwareBeanPostProcessor触发"><a href="#InstantiationAwareBeanPostProcessor触发" class="headerlink" title="InstantiationAwareBeanPostProcessor触发"></a>InstantiationAwareBeanPostProcessor触发</h6><p>在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br></pre></td></tr></tbody></table></figure>
<p>继续:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) {</span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) {</span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从这里可以看出，<strong>如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用</strong>。</p>
<h6 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h6><p>同样分为几部分。</p>
<h6 id="创建-createBeanInstance"><a href="#创建-createBeanInstance" class="headerlink" title="创建(createBeanInstance)"></a>创建(createBeanInstance)</h6><p>关键代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) {</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>createBeanInstance的创建过程又分为以下几种情况:</p>
<ul>
<li><p>工厂bean:</p>
<p>  调用instantiateUsingFactoryMethod方法:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:</p>
<ul>
<li><p>初始化一个BeanWrapperImpl对象。</p>
</li>
<li><p>根据设置的参数列表使用反射的方法寻找相应的方法对象。</p>
</li>
<li><p>InstantiationStrategy:</p>
<p>bean的初始化在此处又抽成了策略模式，类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/InstantiationStrategy.jpg" alt="InstantiationStrategy类图"></p>
<p>instantiateUsingFactoryMethod部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                mbd, beanName, <span class="keyword">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br></pre></td></tr></tbody></table></figure>
<p>getInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.</p>
<p>instantiate核心源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    Object factoryBean, <span class="keyword">final</span> Method factoryMethod, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> factoryMethod.invoke(factoryBean, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>构造器自动装配</p>
<p>  createBeanInstance部分源码:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Need to determine the constructor...</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">        mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">        <span class="comment">//配置了&lt;constructor-arg&gt;子元素</span></span><br><span class="line">        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {</span><br><span class="line">    <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></tbody></table></figure>
<p>  determineConstructorsFromBeanPostProcessors源码:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException {</span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) {</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> ctors;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。</p>
<p>  之后就是判断bean的自动装配模式，可以通过如下方式配置:</p>
  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span> <span class="attr">primary</span>=<span class="string">"true"</span> <span class="attr">autowire</span>=<span class="string">"default"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>  autowire共有以下几种选项:</p>
<ul>
<li><p>no: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。</p>
</li>
<li><p>byName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。</p>
</li>
<li><p>byType: 按类型。</p>
</li>
<li><p>constructor: 以byType的方式查找bean的构造参数列表。</p>
</li>
<li><p>default: 由父bean决定。</p>
</li>
</ul>
<p>参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ViviChan/p/4981539.html">bean的autowire属性(自动装配)</a></p>
<p>autowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:</p>
<ul>
<li><p>得到合适的构造器对象。</p>
</li>
<li><p>根据构造器参数的类型去BeanFactory查找相应的bean:</p>
<p>入口方法在ConstructorResolver.resolveAutowiredArgument:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveAutowiredArgument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames, </span></span></span><br><span class="line"><span class="function"><span class="params">        TypeConverter typeConverter)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.resolveDependency(</span><br><span class="line">            <span class="keyword">new</span> DependencyDescriptor(param, <span class="keyword">true</span>), beanName, </span><br><span class="line">            autowiredBeanNames, typeConverter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) {</span><br><span class="line">        <span class="comment">//反射调用</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，如果配置了lookup-method标签，<strong>得到的实际上是用Cglib生成的目标类的代理子类</strong>。</p>
<p>CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">instantiateWithMethodInjection</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner,Constructor&lt;?&gt; ctor, Object... args)</span> </span>{</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CglibSubclassCreator(bd, owner).instantiate(ctor, args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>默认构造器</p>
<p>  一行代码，很简单:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h6 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h6><p>触发源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line">    <span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">        mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此接口也是Spring内部使用的，不管它了。</p>
<h6 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h6><p>入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>{</span><br><span class="line">    <span class="comment">//所有&lt;property&gt;的值</span></span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//设值</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>autowireByName源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>{</span><br><span class="line">    <span class="comment">//返回所有引用(ref="XXX")的bean名称</span></span><br><span class="line">    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) {</span><br><span class="line">        <span class="keyword">if</span> (containsBean(propertyName)) {</span><br><span class="line">             <span class="comment">//从BeanFactory获取</span></span><br><span class="line">            Object bean = getBean(propertyName);</span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            registerDependentBean(propertyName, beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>autowireByType也是同样的套路，所以可以得出结论: <strong>autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的</strong>。</p>
<h6 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h6><p>Spring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是<strong>此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字</strong>。</p>
<h6 id="初始化完成"><a href="#初始化完成" class="headerlink" title="初始化完成"></a>初始化完成</h6><p>此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) {</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {</span><br><span class="line">        <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>initializeBean:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }, getAccessControlContext());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    }</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) {</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主要的操作步骤一目了然。</p>
<ul>
<li><p>Aware方法触发:</p>
<p>  我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) {</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) {</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) {</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) {</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>BeanPostProcessor触发，没什么好说的</p>
</li>
<li><p>调用init方法:</p>
<p>  在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。</p>
<p>  此接口只有一个方法：</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。</p>
</li>
</ul>
<h4 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h4><p>位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。</p>
<h3 id="Prototype初始化"><a href="#Prototype初始化" class="headerlink" title="Prototype初始化"></a>Prototype初始化</h3><p>AbstractBeanFactory.doGetBean相关源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) {</span><br><span class="line">    <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        beforePrototypeCreation(beanName);</span><br><span class="line">        prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        afterPrototypeCreation(beanName);</span><br><span class="line">    }</span><br><span class="line">    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="beforePrototypeCreation"><a href="#beforePrototypeCreation" class="headerlink" title="beforePrototypeCreation"></a>beforePrototypeCreation</h4><p>此方法用于确保在同一时刻只能有一个此bean在初始化。</p>
<h4 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h4><p>和单例的是一样的，不在赘述。</p>
<h4 id="afterPrototypeCreation"><a href="#afterPrototypeCreation" class="headerlink" title="afterPrototypeCreation"></a>afterPrototypeCreation</h4><p>和beforePrototypeCreation对应的，你懂的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。</p>
<h3 id="其它Scope初始化"><a href="#其它Scope初始化" class="headerlink" title="其它Scope初始化"></a>其它Scope初始化</h3><p>其它就指的是request、session。此部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">                beforePrototypeCreation(beanName);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>scopes是一个<code>LinkedHashMap&lt;String, Scope&gt;</code>，可以调用<code>ConfigurableBeanFactory</code>定义的<code>registerScope</code>方法注册其值。</p>
<p>Scope接口继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Scope.jpg" alt="Scope继承体系"></p>
<p>根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。</p>
<h2 id="Spring-context"><a href="#Spring-context" class="headerlink" title="Spring-context"></a>Spring-context</h2><p>入口方法在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions —&gt; BeanDefinitionParserDelegate.parseCustomElement:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>{</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">        error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) {</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">                <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p>
<h3 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>AnnotationConfigBeanDefinitionParser.parse:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    CompositeComponentDefinition compDefinition = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) {</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, Object source)</span> </span>{<span class="comment">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span></span><br><span class="line"></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);<span class="comment">//将registery强转为DefaultListableBeanFactory类型</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) {</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) {</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                    AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot load optional framework class: "</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        }</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h5><p>其继承体系如下:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Comparator.jpg" alt="Comparator继承体系"></p>
<p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.tuicool.com/articles/VnqUv2">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p>
<h5 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h5><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ContextAnnotationAutowireCandidateResolver.jpg" alt="ContextAnnotationAutowireCandidateResolver类图"></p>
<h5 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h5><p>此类用于处理标注了@Configuration注解的类。类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ConfigurationClassPostProcessor.jpg" alt="ConfigurationClassPostProcessor类图"></p>
<h5 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h5><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor类图"></p>
<h5 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h5><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p>
<h5 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h5><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr250Present =</span><br><span class="line">            ClassUtils.isPresent(<span class="string">"javax.annotation.Resource"</span>, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></tbody></table></figure>
<p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/CommonAnnotationBeanPostProcessor.jpg" alt="CommonAnnotationBeanPostProcessor类图"></p>
<h5 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h5><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jpaPresent =</span><br><span class="line">            ClassUtils.isPresent(<span class="string">"javax.persistence.EntityManagerFactory"</span>, AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">            ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader()); <span class="comment">//org.springframework.orm包</span></span><br></pre></td></tr></tbody></table></figure>
<p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p>
<h5 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h5><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/EventListenerMethodProcessor.jpg" alt="EventListenerMethodProcessor类图"></p>
<h5 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h5><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/DefaultEventListenerFactory.jpg" alt="DefaultEventListenerFactory类图"></p>
<h4 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h4><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/CompositeComponentDefinition.jpg" alt="CompositeComponentDefinition类图"></p>
<p>最终形成的数据结构如下图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/context_annotation_stack.png" alt="数据结构"></p>
<p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><h5 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h5><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></tbody></table></figure>
<p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p>
<h6 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h6><p>此方法大体由两部分组成。</p>
<h6 id="BeanPostProcessor注册-2"><a href="#BeanPostProcessor注册-2" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h6><p>此部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ImportAwareBeanPostProcessor.jpg" alt="ImportAwareBeanPostProcessor类图"></p>
<p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p>
<p>有一个类负责生成Student bean:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>{</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"importaware"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(StudentConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentConfig studentConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">getSimpleBean</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//bean依赖</span></span><br><span class="line">        SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean(studentConfig.student());</span><br><span class="line">        <span class="keyword">return</span> simpleBean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>启动代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p>
<h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p>
<h6 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h6><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p>
<h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p>
<p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) {</span><br><span class="line">    sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {</span><br><span class="line">        BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/BeanNameGenerator.jpg" alt="BeanNameGenerator类图"></p>
<p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p>
<h6 id="postProcessBeanFactory-1"><a href="#postProcessBeanFactory-1" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h6><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//寻找@Configuration的BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) {</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) {</span><br><span class="line">            <span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot enhance @Configuration bean definition '"</span> +</span><br><span class="line">                        beanName + <span class="string">"' since it is not stored in an AbstractBeanDefinition subclass"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (logger.isWarnEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) {</span><br><span class="line">                logger.warn(<span class="string">"Cannot enhance @Configuration bean definition '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' since its singleton instance has been created too early. The typical cause "</span> +</span><br><span class="line">                        <span class="string">"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "</span> +</span><br><span class="line">                        <span class="string">"return type: Consider declaring such methods as 'static'."</span>);</span><br><span class="line">            }</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) {</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) {</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">            Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            <span class="keyword">if</span> (configClass != enhancedClass) {</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(String.format(<span class="string">"Replacing bean definition '%s' existing class '%s' with "</span> +</span><br><span class="line">                            <span class="string">"enhanced class '%s'"</span>, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">                }</span><br><span class="line">                beanDef.setBeanClass(enhancedClass);<span class="comment">//替换</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot load configuration class: "</span> + beanDef.getBeanClassName(), ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ConfigurationClassEnhancer.newEnhancer:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, ClassLoader classLoader)</span> </span>{</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(configSuperClass);</span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] {EnhancedConfiguration.class});<span class="comment">//这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span></span><br><span class="line">    enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);<span class="comment">//关键</span></span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>CALLBACK_FILTER是个什么东西呢:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// The callbacks to use. Note that these callbacks must be stateless.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] {</span><br><span class="line">        <span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">        <span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">        NoOp.INSTANCE</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br></pre></td></tr></tbody></table></figure>
<p>这么做的原因有两个:</p>
<ul>
<li><p>提供Scope支持:</p>
<p>  我们可以使用@Scope注解来使用注解的方式配置其Scope:</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope("prototype")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>{</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">22</span>);</span><br><span class="line">    student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p>
</li>
<li><p>实现EnhancedConfiguration接口</p>
</li>
</ul>
<h5 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h5><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p>
<h6 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h6><h6 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h6><p>其中前者首先被调用，时机是已创建Bean实例但还没有对实例执行初始化操作。回顾下其调用入口:</p>
<p>AbstractAutowireCapableBeanFactory.doCreateBean:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) {</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) {</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) {</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            }</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        }</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) {</span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) {</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) {</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) {</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) {</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) {</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>findAutowiringMetadata:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>{</span><br><span class="line">    <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) {</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) {</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) {</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) {</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                    <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (NoClassDefFoundError err) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to introspect bean class ["</span> + clazz.getName() +</span><br><span class="line">                            <span class="string">"] for autowiring metadata: could not find class that it depends on"</span>, err);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p>
<ul>
<li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li>
<li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li>
</ul>
<p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p>
<p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>{</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    <span class="comment">//循环检测父类</span></span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line"></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>{</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">//不支持静态变量</span></span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) {</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>{</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) {</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) {</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">                                    method);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p>
<h6 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h6><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p>
<p>ReflectionUtils的实现其实就是访问者模式，其源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, FieldCallback fc)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (Field field : getDeclaredFields(clazz)) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Not allowed to access field '"</span> + field.getName() + <span class="string">"': "</span> + ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p>
<h6 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h6><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></tbody></table></figure>
<p>此句代码的作用是 <strong>判断method是否是bridge方法，如果是，寻找其真正的方法</strong> 。这里的bridge方法并不是所谓的bridge模式。</p>
<p>有这样的demo代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>{</span><br><span class="line">        <span class="comment">//注意父类的返回类型是Object</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (Method method : MyList.class.getDeclaredMethods()) {</span><br><span class="line">            System.out.println(<span class="string">"name: "</span> + method.getName() + <span class="string">", return: "</span> + method.getReturnType());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></tbody></table></figure>
<p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns {<span class="doctag">@code</span> true} if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method; returns {<span class="doctag">@code</span> false} otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method as defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBridge</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (getModifiers() &amp; Modifier.BRIDGE) != <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p>
<p>可以参考: <a target="_blank" rel="noopener" href="http://ifeve.com/syntethic-and-bridge-methods/">Java那些不为人知的特殊方法</a></p>
<p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p>
<h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p>
<h6 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h6><h6 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h6><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p>
<h6 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h6><p>源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeanCreationException </span>{</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) {</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                <span class="string">"Injection of autowired dependencies failed for class ["</span> + clazz + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p>
<h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p>
<h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p>
<h5 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h5><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p>
<h6 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h6><p>空实现，就是这么任性:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h6><p>源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) {</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) {</span><br><span class="line">            List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor pd : pds) {</span><br><span class="line">                <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) {</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!invalidProperties.isEmpty()) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage(invalidProperties, beanName));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.validatedBeanNames.add(beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h6><p>validatedBeanNames是一个Set类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</p>
<h6 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p>
<p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) {</span><br><span class="line">    PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps) {</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) {</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (needsDepCheck) {</span><br><span class="line">        checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) {</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) {</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        <span class="keyword">if</span> (isExcludedFromDependencyCheck(pd)) {</span><br><span class="line">            it.remove();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pds.toArray(<span class="keyword">new</span> PropertyDescriptor[pds.size()]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p>
<p>BeanWrapperImpl.getPropertyDescriptors:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() {</span><br><span class="line">    <span class="keyword">return</span> getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CachedIntrospectionResults <span class="title">getCachedIntrospectionResults</span><span class="params">()</span> </span>{</span><br><span class="line">    Assert.state(getWrappedInstance() != <span class="keyword">null</span>, <span class="string">"BeanWrapper does not hold a bean instance"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedIntrospectionResults == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cachedIntrospectionResults;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>有一个bean如下:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component("simpleBean")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">()</span> </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">(Student student)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/@required_test.png" alt="@Required测试"></p>
<h5 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h5><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p>
<h6 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h6><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) {</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h6><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) {</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>{</span><br><span class="line">    setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">    ignoreResourceType(<span class="string">"javax.xml.ws.WebServiceContext"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p>
<p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initAnnotationType"</span> <span class="attr">value</span>=<span class="string">"annotation.Init"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>Init是一个很简单的自定义注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Init {}</span><br></pre></td></tr></tbody></table></figure>
<p>在自己的bean中使用此注解:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    System.out.println(<span class="string">"Init!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行Spring便可以看到效果。</p>
<p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p>
<h6 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h6><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p>
<h6 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h6><p>源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of resource dependencies failed"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>套路很明显了。</p>
<h6 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h6><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Invocation of init method failed"</span>, ex.getTargetException());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Failed to invoke init method"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>invokeInitMethods:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (<span class="keyword">this</span>.checkedInitMethods != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">    <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) {</span><br><span class="line">        <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) {</span><br><span class="line">            <span class="keyword">if</span> (debug) {</span><br><span class="line">                logger.debug(<span class="string">"Invoking init method on bean '"</span> + beanName + <span class="string">"': "</span> + element.getMethod());</span><br><span class="line">            }</span><br><span class="line">            element.invoke(target);<span class="comment">// 反射调用</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不过从源码来看应该支持多个init方法。</p>
<h6 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h6><p>反射调用销毁方法，没啥说的了。</p>
<h5 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h5><p>就一个值得关注的方法: afterSingletonsInstantiated。</p>
<h6 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h6><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) {</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) {</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }, getAccessControlContext());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>{</span><br><span class="line">    List&lt;EventListenerFactory&gt; factories = getEventListenerFactories();</span><br><span class="line">    String[] beanNames = <span class="keyword">this</span>.applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        <span class="keyword">if</span> (!ScopedProxyUtils.isScopedTarget(beanName)) {</span><br><span class="line">            Class&lt;?&gt; type = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                type = AutoProxyUtils.determineTargetClass(<span class="keyword">this</span>.applicationContext.getBeanFactory(), beanName);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                <span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                    logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (type != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">if</span> (ScopedObject.class.isAssignableFrom(type)) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        type = AutoProxyUtils.determineTargetClass(<span class="keyword">this</span>.applicationContext.getBeanFactory(),</span><br><span class="line">                                ScopedProxyUtils.getTargetBeanName(beanName));</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                        <span class="comment">// An invalid scoped proxy arrangement - let's ignore it.</span></span><br><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                            logger.debug(<span class="string">"Could not resolve target bean for scoped proxy '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    processBean(factories, beanName, type);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Failed to process @EventListener "</span> +</span><br><span class="line">                            <span class="string">"annotation on bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h3><p>ComponentScanBeanDefinitionParser.parse源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);<span class="comment">// base-package属性</span></span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);<span class="comment">// 解析占位符</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);<span class="comment">//分割成数据</span></span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        parseBeanNameGenerator(element, scanner);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        parseScope(element, scanner);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());</span><br><span class="line">    }</span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    <span class="keyword">return</span> scanner;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面开始按顺序分部分说明。</p>
<h5 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h5><p>component-scan注解会默认扫描@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p>
<h5 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h5><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p>
<h5 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h5><p>用以配置扫描器扫描的路径，默认<em>*/</em>.class。</p>
<h5 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h5><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p>
<h5 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h5><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ScopeMetadataResolver.jpg" alt="ScopeMetadataResolver类图"></p>
<p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p>
<h5 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h5><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p>
<h5 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h5><p>用法示例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"base"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"javax.annotation.Resource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (INCLUDE_FILTER_ELEMENT.equals(localName)) {</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (EXCLUDE_FILTER_ELEMENT.equals(localName)) {</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h5><p>此属性等同于<code>&lt;context:annotation-config /&gt;</code>配置，默认就是true，也就是说，如果配置了<code>context:component-scan</code>其实就没有必要配置<code>annotation-config</code> 了。</p>
<h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>{</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) {<span class="comment">// 逐包扫描</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) {</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) {</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<span class="comment">// 为BeanDefinition设置默认的属性</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) {</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) {</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h5><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/MetadataReader.jpg" alt="MetadataReader类图"></p>
<p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException {</span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"ASM ClassReader failed to parse class file - "</span> +</span><br><span class="line">                <span class="string">"probably due to a new Java class file version that isn't supported yet: "</span> + resource, ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        is.close();</span><br><span class="line">    }</span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line">    <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    <span class="comment">// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span></span><br><span class="line">    <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/AnnotationMetadataReadingVisitor.jpg" alt="AnnotationMetadataReadingVisitor类图"></p>
<p>核心在于其visitAnnotation方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String desc, <span class="keyword">boolean</span> visible)</span> </span>{</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(</span><br><span class="line">            className, <span class="keyword">this</span>.attributesMap, <span class="keyword">this</span>.metaAnnotationMap, <span class="keyword">this</span>.classLoader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ScannedGenericBeanDefinition.jpg" alt="ScannedGenericBeanDefinition类图"></p>
<h5 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h5><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>{</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) {</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">        <span class="comment">// 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// @Scope值</span></span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyMode == <span class="keyword">null</span> || proxyMode == ScopedProxyMode.DEFAULT) {</span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            }</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>proxyMode和xml的scoped-proxy属性是一个概念:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(value = "singleton", proxyMode = ScopedProxyMode.DEFAULT)</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p>
<h5 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h5><p>AnnotationBeanNameGenerator.generateBeanName:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) {</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) {</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h6><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>{</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String type : types) {<span class="comment">// 遍历当前bean拥有的所有类级注解</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);<span class="comment">// 获取此注解所有的属性</span></span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) {</span><br><span class="line">            Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) {</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(strVal)) {</span><br><span class="line">                    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) {</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Stereotype annotations suggest inconsistent "</span> +</span><br><span class="line">                                <span class="string">"component names: '"</span> + beanName + <span class="string">"' versus '"</span> + strVal + <span class="string">"'"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes)</span> </span>{</span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">            (metaAnnotationTypes != <span class="keyword">null</span> &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">            annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) ||</span><br><span class="line">            annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>metaAnnotationTypes用以判断元注解，针对这种情况:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller {}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p>
<h6 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h6><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>{</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p>
<h5 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h5><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@DependsOn("student")</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_APPLICATION)</span></span><br><span class="line"><span class="meta">@Description("This is a simple bean.")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>
<p>解析源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(Lazy.class.getName())) {</span><br><span class="line">        abd.setLazyInit(attributesFor(metadata, Lazy.class).getBoolean(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata &amp;&amp; abd.getMetadata().isAnnotated(Lazy.class.getName())) {</span><br><span class="line">        abd.setLazyInit(attributesFor(abd.getMetadata(), Lazy.class).getBoolean(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) {</span><br><span class="line">        abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(DependsOn.class.getName())) {</span><br><span class="line">        abd.setDependsOn(attributesFor(metadata, DependsOn.class).getStringArray(<span class="string">"value"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abd <span class="keyword">instanceof</span> AbstractBeanDefinition) {</span><br><span class="line">        AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(Role.class.getName())) {</span><br><span class="line">            absBd.setRole(attributesFor(metadata, Role.class).getNumber(<span class="string">"value"</span>).intValue());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (metadata.isAnnotated(Description.class.getName())) {</span><br><span class="line">            absBd.setDescription(attributesFor(metadata, Description.class).getString(<span class="string">"value"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p>
<h5 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h5><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> IllegalStateException </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) {<span class="comment">// 没有同名的，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) {</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"Annotation-specified bean name '"</span> + beanName +</span><br><span class="line">            <span class="string">"' for bean class ["</span> + beanDefinition.getBeanClassName() + <span class="string">"] conflicts with existing, "</span> +</span><br><span class="line">            <span class="string">"non-compatible bean definition of same name and class ["</span> + existingDef.getBeanClassName() + <span class="string">"]"</span>);<span class="comment">//冲突啦</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) ||  <span class="comment">// explicitly registered overriding bean</span></span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) ||  <span class="comment">// scanned same file twice</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  <span class="comment">// scanned equivalent class twice</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的</strong>。</p>
<h5 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h5><p>入口: ClassPathBeanDefinitionScanner.doScan —&gt; AnnotationConfigUtils.applyScopedProxyMode:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) {</span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">    definitionHolder =</span><br><span class="line">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    beanDefinitions.add(definitionHolder);</span><br><span class="line">    registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AnnotationConfigUtils.applyScopedProxyMode:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">// 基本都是从这里跑了</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) {</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p>
<ul>
<li><p>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</p>
</li>
<li><p>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</p>
</li>
<li><p>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</p>
</li>
<li><p>代理者和被代理者同时存在于容器中。</p>
</li>
</ul>
<p>可以看出，这其实是一个偷天换日的过程。</p>
<p>做个实验:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boostrap</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SimpleBean已开启代理，输出的结果:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$<span class="number">27256</span>c61</span><br></pre></td></tr></tbody></table></figure>
<p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p>
<p>DefaultListableBeanFactory.getBean(Class requiredType, Object… args)部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line"><span class="comment">//不止一个满足条件(代理者和被代理者)</span></span><br><span class="line"><span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) {</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">         <span class="comment">// here</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (autowireCandidates.size() &gt; <span class="number">0</span>) {</span><br><span class="line">        beanNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p>
<h5 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h5><p>注册BeanDefinition源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>{</span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) {</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h4><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p>
<h3 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p>
<p>定义如下的属性文件(property.properties):</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">student.name</span>=<span class="string">dog</span></span><br></pre></td></tr></tbody></table></figure>
<p>格式为: bean名字.属性名字=值。由如下的bean:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>进行如下的配置:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"property.properties"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>运行如下的代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>打印的便是dog，而不是skywalker。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertyOverrideBeanDefinitionParser.jpg" alt="PropertyOverrideBeanDefinitionParser类图"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码:</p>
<p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>{</span><br><span class="line">    String location = element.getAttribute(<span class="string">"location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(location)) {</span><br><span class="line">        location = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(location);</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(<span class="string">"locations"</span>, locations);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) {</span><br><span class="line">        builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String fileEncoding = element.getAttribute(<span class="string">"file-encoding"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"fileEncoding"</span>, fileEncoding);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String order = element.getAttribute(<span class="string">"order"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(order)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"order"</span>, Integer.valueOf(order));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreResourceNotFound"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-resource-not-found"</span>)));</span><br><span class="line"></span><br><span class="line">    builder.addPropertyValue(<span class="string">"localOverride"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"local-override"</span>)));</span><br><span class="line"></span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h5><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;context:property-override  properties-ref=<span class="string">"property"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">"property"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.Properties"</span>&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key="student.name"&gt;cat&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>这样便可以看到结果。</p>
<h5 id="order"><a href="#order" class="headerlink" title="order"></a>order</h5><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p>
<h5 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h5><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p>
<h5 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h5><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p>
<h5 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h5><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Properties[] localProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set local properties, e.g. via the "props" tag in XML bean definitions.</span></span><br><span class="line"><span class="comment"> * These can be considered defaults, to be overridden by properties</span></span><br><span class="line"><span class="comment"> * loaded from files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.localProperties = <span class="keyword">new</span> Properties[] {properties};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">location</span>=<span class="string">"property.properties"</span> <span class="attr">local-override</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p>
<h5 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h5><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertyOverrideConfigurer.jpg" alt="PropertyOverrideConfigurer类图"></p>
<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><p>入口当然是AbstractApplicationContext.invokeBeanFactoryPostProcessors —&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors —&gt; PropertyOverrideConfigurer.postProcessBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Properties mergedProps = mergeProperties();<span class="comment">// 属性加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h5><p>PropertiesLoaderSupport.mergeProperties:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Properties <span class="title">mergeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) {</span><br><span class="line">        <span class="comment">// Load properties from file upfront, to let local properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localProperties != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Properties localProp : <span class="keyword">this</span>.localProperties) {</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localOverride) {</span><br><span class="line">        <span class="comment">// Load properties from file afterwards, to let those properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p>
<h5 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h5><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p>
<h5 id="属性设置-1"><a href="#属性设置-1" class="headerlink" title="属性设置"></a>属性设置</h5><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processKey</span><span class="params">(ConfigurableListableBeanFactory factory, String key, String value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> separatorIndex = key.indexOf(<span class="keyword">this</span>.beanNameSeparator);</span><br><span class="line">    <span class="keyword">if</span> (separatorIndex == -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Invalid key '"</span> + key +</span><br><span class="line">                <span class="string">"': expected 'beanName"</span> + <span class="keyword">this</span>.beanNameSeparator + <span class="string">"property'"</span>);</span><br><span class="line">    }</span><br><span class="line">    String beanName = key.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">    String beanProperty = key.substring(separatorIndex+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanNames.add(beanName);</span><br><span class="line">    applyPropertyValue(factory, beanName, beanProperty, value);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">        logger.debug(<span class="string">"Property '"</span> + key + <span class="string">"' set to value ["</span> + value + <span class="string">"]"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>{</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">while</span> (bd.getOriginatingBeanDefinition() != <span class="keyword">null</span>) {</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    }</span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p>
<h3 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h3><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p>
<p>PropertyPlaceholderBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>.doParse(element, parserContext, builder);</span><br><span class="line"></span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreUnresolvablePlaceholders"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-unresolvable"</span>)));</span><br><span class="line"></span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"systemPropertiesModeName"</span>, <span class="string">"SYSTEM_PROPERTIES_MODE_"</span> + systemPropertiesModeName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"value-separator"</span>)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"valueSeparator"</span>, element.getAttribute(<span class="string">"value-separator"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"trim-values"</span>)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"trimValues"</span>, element.getAttribute(<span class="string">"trim-values"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"null-value"</span>)) {</span><br><span class="line">        builder.addPropertyValue(<span class="string">"nullValue"</span>, element.getAttribute(<span class="string">"null-value"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h5><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p>
<h5 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h5><p>用于配置默认的值的分隔符:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"${student.name:skywalker}"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p>
<h5 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h5><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p>
<h5 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h5><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p>
<h5 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h5><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/PropertySourcesPlaceholderConfigurer.jpg" alt="PropertySourcesPlaceholderConfigurer类图"></p>
<h4 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h4><p>入口当然是AbstractApplicationContext.invokeBeanFactoryPostProcessors —&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors —&gt; PropertySourcesPlaceholderConfigurer.postProcessBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, <span class="keyword">this</span>.environment) {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>{</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.source.getProperty(key);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                    <span class="keyword">new</span> PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) {</span><br><span class="line">                <span class="keyword">this</span>.propertySources.addFirst(localPropertySource);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">this</span>.propertySources.addLast(localPropertySource);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    processProperties(beanFactory, <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources));</span><br><span class="line">    <span class="keyword">this</span>.appliedPropertySources = <span class="keyword">this</span>.propertySources;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p>
<p>不使用property-placeholder标签，以显式的bean定义代替。</p>
<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p>
<h3 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h3><p>这两个配置是紧密相关的，所以在一起说了。</p>
<p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p>
<p>可以参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/sexycoding-1062372">Spring之LoadTimeWeaver</a><br><a target="_blank" rel="noopener" href="https://www.iteye.com/topic/481813">Spring LoadTimeWeaver 的那些事儿</a></p>
<h4 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h4><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p>
<p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p>
<p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p>
<p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge nt</p>
<p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationSavingAgent</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>{</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instrumentation;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p>
<h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p>
<h5 id="LoadTimeWeaver-1"><a href="#LoadTimeWeaver-1" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h5><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/LoadTimeWeaver.jpg" alt="LoadTimeWeaver继承体系"></p>
<p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果配置了weaver-class属性，那么使用其值</span></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) {</span><br><span class="line">        <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>那么这个BeanDefinition的id/name又是什么呢?</p>
<p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveId</span><span class="params">(Element element, AbstractBeanDefinition definition, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p>
<h5 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h5><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>{</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) {</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) {</span><br><span class="line">            RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) {</span><br><span class="line">            <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h5><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p>
<p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p>
<h5 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h5><p>isAspectJWeavingEnabled方法用于判断是否启用:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAspectJWeavingEnabled</span><span class="params">(String value, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"on"</span>.equals(value)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"off"</span>.equals(value)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Determine default...</span></span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();<span class="comment">// 寻找aop.xml</span></span><br><span class="line">        <span class="keyword">return</span> (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h5><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/AspectJWeavingEnabler.jpg" alt="AspectJWeavingEnabler类图"></p>
<h5 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h5><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其parse方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) {</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(<span class="string">"aspectOf"</span>);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition(def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/AnnotationBeanConfigurerAspect.jpg" alt="AnnotationBeanConfigurerAspect类图"></p>
<p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p>
<p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p>
<p>语法可以参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/jinnianshilongnian-1415606">Spring 之AOP AspectJ切入点详解</a></p>
<h6 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h6><h6 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h6><p>在AnnotationBeanConfigurerAspect中定义，源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">inConfigurableBean</span><span class="params">()</span> : @<span class="title">this</span><span class="params">(Configurable)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p>
<h6 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h6><p>源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">beanConstruction</span><span class="params">(Object bean)</span> :</span></span><br><span class="line"><span class="function">            <span class="title">initialization</span><span class="params">(ConfigurableObject+.new(..)</span>) &amp;&amp; <span class="title">this</span><span class="params">(bean)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p>
<h6 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> &amp;&amp; <span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>由两个pointcut与运算而来。</p>
<h6 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> : <span class="title">initialization</span><span class="params">(ConfigurableObject.new(..)</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
<h6 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">preConstructionConfiguration</span><span class="params">()</span> : <span class="title">preConstructionConfigurationSupport</span><span class="params">(*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionConfigurationSupport</span><span class="params">(Configurable c)</span> : @<span class="title">this</span><span class="params">(c)</span> &amp;&amp; <span class="title">if</span> <span class="params">(c.preConstruction()</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p>
<h6 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">postConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> &amp;&amp; !<span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>mostSpecificSubTypeConstruction:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(thisJoinPoint.getSignature()</span>.<span class="title">getDeclaringType</span><span class="params">()</span> </span>== thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></tbody></table></figure>
<p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p>
<h5 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h5><h6 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  {</span><br><span class="line">    configureBean(bean);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h4><p>AspectJWeavingEnabler.postProcessBeanFactory:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    enableAspectJWeaving(<span class="keyword">this</span>.loadTimeWeaver, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>enableAspectJWeaving:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAspectJWeaving</span><span class="params">(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (weaverToUse == <span class="keyword">null</span>) {<span class="comment">// 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {</span><br><span class="line">            weaverToUse = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No LoadTimeWeaver available"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            <span class="keyword">new</span> AspectJClassBypassingClassFileTransformer(<span class="keyword">new</span> ClassPreProcessorAgentAdapter()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="LoadTimeWeaverAware-1"><a href="#LoadTimeWeaverAware-1" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h5><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p>
<p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/LoadTimeWeaverAwareProcessor.jpg" alt="LoadTimeWeaverAwareProcessor类图"></p>
<p>postProcessBeforeInitialization方法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadTimeWeaverAware) {</span><br><span class="line">        LoadTimeWeaver ltw = <span class="keyword">this</span>.loadTimeWeaver;</span><br><span class="line">        <span class="keyword">if</span> (ltw == <span class="keyword">null</span>) {</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"BeanFactory required if no LoadTimeWeaver explicitly specified"</span>);</span><br><span class="line">            <span class="comment">// 去容器找         </span></span><br><span class="line">            ltw = <span class="keyword">this</span>.beanFactory.getBean(</span><br><span class="line">                    ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        }</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p>
<p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p>
<p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p>
<p>AbstractApplicationContext.refresh:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></tbody></table></figure>
<p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p>
<p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getBeanPostProcessors:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></tbody></table></figure>
<p>直接将实例添加到BeanFactory中，所以可以得出结论:</p>
<p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p>
<h5 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h5><h6 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h6><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p>
<p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) {</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) {</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) {</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) {</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h6><p>这个方法很关键，对instrument的获取就是在这里。源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>{</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (serverSpecificLoadTimeWeaver != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">            logger.info(<span class="string">"Determined server-specific load-time weaver: "</span> +</span><br><span class="line">                    serverSpecificLoadTimeWeaver.getClass().getName());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {</span><br><span class="line">        logger.info(<span class="string">"Found Spring's JVM agent for instrumentation"</span>);</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">                logger.info(<span class="string">"Using a reflective load-time weaver for class loader: "</span> +</span><br><span class="line">                        <span class="keyword">this</span>.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex.getMessage() + <span class="string">" Specify a custom LoadTimeWeaver or start your "</span> +</span><br><span class="line">                    <span class="string">"Java virtual machine with Spring's agent: -javaagent:org.springframework.instrument.jar"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>很明显分为三部分。</p>
<h6 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h6><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br></pre></td></tr></tbody></table></figure>
<p>createServerSpecificLoadTimeWeaver源码:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadTimeWeaver <span class="title">createServerSpecificLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>{</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">"org.apache.catalina"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.glassfish"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.jboss"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JBossLoadTimeWeaver(classLoader);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"com.ibm"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"weblogic"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">            logger.info(<span class="string">"Could not obtain server-specific LoadTimeWeaver: "</span> + ex.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p>
<p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p>
<h6 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h6><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInstrumentationAvailable</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (getInstrumentation() != <span class="keyword">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (AGENT_CLASS_PRESENT) {</span><br><span class="line">        <span class="keyword">return</span> InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p>
<p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationAccessor</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p>
<h6 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h6><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(ClassUtils.getDefaultClassLoader());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>{</span><br><span class="line">    Assert.notNull(classLoader, <span class="string">"ClassLoader must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="keyword">this</span>.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addTransformerMethod == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"ClassLoader ["</span> + classLoader.getClass().getName() + <span class="string">"] does NOT provide an "</span> +</span><br><span class="line">                <span class="string">"'addTransformer(ClassFileTransformer)' method."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.getThrowawayClassLoaderMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), GET_THROWAWAY_CLASS_LOADER_METHOD_NAME);</span><br><span class="line">    <span class="comment">// getThrowawayClassLoader method is optional</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getThrowawayClassLoaderMethod == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">            logger.info(<span class="string">"The ClassLoader ["</span> + classLoader.getClass().getName() + <span class="string">"] does NOT provide a "</span> +</span><br><span class="line">                    <span class="string">"'getThrowawayClassLoader()' method; SimpleThrowawayClassLoader will be used instead."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p>
<p><img src="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" alt="Load-Time Weaving"></p>
<h5 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h5><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p>
<p>AspectJClassBypassingClassFileTransformer.transform:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException {</span><br><span class="line">    <span class="comment">// aspectj自身的类无需检测(织入)，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (className.startsWith(<span class="string">"org.aspectj"</span>) || className.startsWith(<span class="string">"org/aspectj"</span>)) {</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/ClassPreProcessorAgentAdapter.jpg" alt="ClassPreProcessorAgentAdapter类图"></p>
<p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p>
<h5 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h5><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p>
<h6 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h6><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p>
<h6 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h6><h6 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p>
<p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.AnnotationCacheAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.JCacheCacheAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>那么解析后的结果:</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/aop_xml_parse.png" alt="aop.xml解析结果"></p>
<h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">registerDefinitions</span><span class="params">(<span class="keyword">final</span> BcelWeaver weaver, <span class="keyword">final</span> ClassLoader loader, List&lt;Definition&gt; definitions)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (trace.isTraceEnabled()) {</span><br><span class="line">        trace.enter(<span class="string">"registerDefinitions"</span>, <span class="keyword">this</span>, definitions);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        registerOptions(weaver, loader, definitions);<span class="comment">//对应&lt;weaver options="-verbose"&gt;</span></span><br><span class="line">        registerAspectExclude(weaver, loader, definitions);<span class="comment">//对应&lt;exclude&gt;标签</span></span><br><span class="line">        registerAspectInclude(weaver, loader, definitions);<span class="comment">//对应&lt;include&gt;标签</span></span><br><span class="line">        success = registerAspects(weaver, loader, definitions);<span class="comment">// &lt;aspect&gt;</span></span><br><span class="line">        registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">        registerDump(weaver, loader, definitions);<span class="comment">//对应&lt;dump&gt;标签</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        trace.error(<span class="string">"register definition failed"</span>, ex);</span><br><span class="line">        success = <span class="keyword">false</span>;</span><br><span class="line">        warn(<span class="string">"register definition failed"</span>, (ex <span class="keyword">instanceof</span> AbortException) ? <span class="keyword">null</span> : ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (trace.isTraceEnabled()) {</span><br><span class="line">        trace.exit(<span class="string">"registerDefinitions"</span>, success);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mapstruct实体转换神器</title>
    <url>/posts/5133cec2/</url>
    <content><![CDATA[<p>介绍一个开源项目 mapstruct ，可以轻松优雅的进行转换，简化你的代码，尤其是字段特别多的实体转换的时候。</p>
<p>当然有的人喜欢写get set，或者用BeanUtils 进行复制，代码只是工具，本文只是提供一种思路。</p>
<p>先贴下官网地址吧：<code>https://mapstruct.org/</code></p>
<p>废话不多说，上代码：</p>
<h2 id="pom-xml配置"><a href="#pom-xml配置" class="headerlink" title="pom.xml配置"></a>pom.xml配置</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;org.mapstruct.version&gt;1.4.1.Final&lt;/org.mapstruct.version&gt;</span><br><span class="line">    &lt;org.projectlombok.version&gt;1.18.12&lt;/org.projectlombok.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- lombok dependencies should not end up on classpath --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${org.projectlombok.version}&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- idea 2018.1.1 之前的版本需要添加下面的配置，后期的版本就不需要了，可以注释掉，我自己用的2019.3 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;${maven.compiler.source}&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;${maven.compiler.target}&lt;/target&gt;</span><br><span class="line">                &lt;annotationProcessorPaths&gt;</span><br><span class="line">                    &lt;path&gt;</span><br><span class="line">                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${org.projectlombok.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/path&gt;</span><br><span class="line">                    &lt;path&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/path&gt;</span><br><span class="line">                &lt;/annotationProcessorPaths&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>关于lombok和mapstruct的版本兼容问题多说几句，maven插件要使用3.6.0版本以上、lombok使用1.16.16版本以上，另外编译的lombok mapstruct的插件不要忘了加上。否则会出现下面的错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">No property named "aaa" exists in source parameter(s). Did you mean "null"?</span><br></pre></td></tr></tbody></table></figure>
<p>这种异常就是lombok编译异常导致缺少get setter方法造成的。还有就是缺少构造函数也会抛异常。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> GenderEnum gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenderEnum</span> </span>{</span><br><span class="line">    Male(<span class="string">"1"</span>, <span class="string">"男"</span>),</span><br><span class="line">    Female(<span class="string">"0"</span>, <span class="string">"女"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    GenderEnum(String code, String name) {</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentVO</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = "gender.name", target = "gender")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "birthday", target = "birthday", dateFormat = "yyyy-MM-dd HH:mm:ss")</span></span><br><span class="line">    <span class="function">StudentVO <span class="title">student2StudentVO</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实体类是开发过程少不了的，就算是用工具生成肯定也是要有的，需要手写的部分就是这个Mapper的接口，编译完成后会自动生成相应的实现类</p>
<p>然后就可以直接用mapper进行实体的转换了</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Student student = Student.builder().name(<span class="string">"小明"</span>).age(<span class="number">6</span>).gender(GenderEnum.Male).height(<span class="number">121.1</span>).birthday(<span class="keyword">new</span> Date()).build();</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        <span class="comment">//这行代码便是实际要用的代码</span></span><br><span class="line">        StudentVO studentVO = StudentMapper.INSTANCE.student2StudentVO(student);</span><br><span class="line">        System.out.println(studentVO);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>mapper可以进行字段映射，改变字段类型，指定格式化的方式，包括一些日期的默认处理。</p>
<p>可以手动指定格式化的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = "gender", target = "gender")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "birthday", target = "birthday", dateFormat = "yyyy-MM-dd HH:mm:ss")</span></span><br><span class="line">    <span class="function">StudentVO <span class="title">student2StudentVO</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getGenderName</span><span class="params">(GenderEnum gender)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> gender.getName();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面只是最简单的实体映射处理，下面介绍一些高级用法</p>
<h2 id="List-转换"><a href="#List-转换" class="headerlink" title="List 转换"></a>List 转换</h2><p>属性映射基于上面的mapping配置</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = "gender.name", target = "gender")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "birthday", target = "birthday", dateFormat = "yyyy-MM-dd HH:mm:ss")</span></span><br><span class="line">    <span class="function">StudentVO <span class="title">student2StudentVO</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;StudentVO&gt; <span class="title">students2StudentVOs</span><span class="params">(List&lt;Student&gt; studentList)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    Student student = Student.builder().name(<span class="string">"小明"</span>).age(<span class="number">6</span>).gender(GenderEnum.Male).height(<span class="number">121.1</span>).birthday(<span class="keyword">new</span> Date()).build();</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(student);</span><br><span class="line">    List&lt;StudentVO&gt; result = StudentMapper.INSTANCE.students2StudentVOs(list);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多对象转换到一个对象"><a href="#多对象转换到一个对象" class="headerlink" title="多对象转换到一个对象"></a>多对象转换到一个对象</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> GenderEnum gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sortNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentVO</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Double height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    <span class="keyword">private</span> String course;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = "student.gender.name", target = "gender")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "student.birthday", target = "birthday", dateFormat = "yyyy-MM-dd HH:mm:ss")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "course.courseName", target = "course")</span></span><br><span class="line">    <span class="function">StudentVO <span class="title">studentAndCourse2StudentVO</span><span class="params">(Student student, Course course)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        Student student = Student.builder().name(<span class="string">"小明"</span>).age(<span class="number">6</span>).gender(GenderEnum.Male).height(<span class="number">121.1</span>).birthday(<span class="keyword">new</span> Date()).build();</span><br><span class="line">        Course course = Course.builder().id(<span class="number">1L</span>).courseName(<span class="string">"语文"</span>).build();</span><br><span class="line"></span><br><span class="line">        StudentVO studentVO = StudentMapper.INSTANCE.studentAndCourse2StudentVO(student, course);</span><br><span class="line">        System.out.println(studentVO);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>{</span><br><span class="line"></span><br><span class="line">    StudentMapper INSTANCE = Mappers.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(source = "student.gender.name", target = "gender")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "student.birthday", target = "birthday", dateFormat = "yyyy-MM-dd HH:mm:ss")</span></span><br><span class="line">    <span class="meta">@Mapping(source = "course.courseName", target = "course")</span></span><br><span class="line">    <span class="meta">@Mapping(target = "name", source = "student.name", defaultValue = "张三")</span></span><br><span class="line">    <span class="function">StudentVO <span class="title">studentAndCourse2StudentVO</span><span class="params">(Student student, Course course)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>mapstruct</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Maven</tag>
        <tag>java</tag>
        <tag>pom.xml</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 闭包的实现</title>
    <url>/posts/5beda5d4/</url>
    <content><![CDATA[<p>【导读】什么是闭包？什么场景下会用闭包？本文对 go 语言中的闭包做了详细介绍。</p>
<p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。</p>
<h2 id="Go中的闭包"><a href="#Go中的闭包" class="headerlink" title="Go中的闭包"></a>Go中的闭包</h2><p>闭包是函数式语言中的概念，没有研究过函数式语言的用户可能很难理解闭包的强大，相关的概念超出了本书的范围。Go语言是支持闭包的，这里只是简单地讲一下在Go语言中闭包是如何实现的。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数f返回了一个函数，返回的这个函数就是一个闭包。这个函数中本身是没有定义变量i的，而是引用了它所在的环境（函数f）中的变量i。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c1 := f(<span class="number">0</span>)</span><br><span class="line">c2 := f(<span class="number">0</span>)</span><br><span class="line">c1()    <span class="comment">// reference to i, i = 0, return 1</span></span><br><span class="line">c2()    <span class="comment">// reference to another i, i = 0, return 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>c1跟c2引用的是不同的环境，在调用i++时修改的不是同一个i，因此两次的输出都是1。函数f每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。</p>
<p>变量i是函数f中的局部变量，假设这个变量是在函数f的栈中分配的，是不可以的。因为函数f返回以后，对应的栈就失效了，f返回的那个函数中变量i就引用一个失效的位置了。所以闭包的环境中引用的变量不能够在栈上分配。</p>
<h2 id="escape-analyze"><a href="#escape-analyze" class="headerlink" title="escape analyze"></a>escape analyze</h2><p>在继续研究闭包的实现之前，先看一看Go的一个语言特性：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">Cursor</span></span> {</span><br><span class="line">    <span class="keyword">var</span> c Cursor</span><br><span class="line">    c.X = <span class="number">500</span></span><br><span class="line">    noinline()</span><br><span class="line">    <span class="keyword">return</span> &amp;c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Cursor是一个结构体，这种写法在C语言中是不允许的，因为变量c是在栈上分配的，当函数f返回后c的空间就失效了。但是，在Go语言规范中有说明，这种写法在Go语言中合法的。语言会自动地识别出这种情况并在堆上分配c的内存，而不是函数f的栈上。</p>
<p>为了验证这一点，可以观察函数f生成的汇编代码：</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">MOVQ    $type."".Cursor+0(SB),(SP)    // 取变量c的类型，也就是Cursor</span><br><span class="line">PCDATA    $0,$16</span><br><span class="line">PCDATA    $1,$0</span><br><span class="line">CALL    ,runtime.new(SB)    // 调用new函数，相当于new(Cursor)</span><br><span class="line">PCDATA    $0,$-1</span><br><span class="line">MOVQ    8(SP),AX    // 取c.X的地址放到AX寄存器</span><br><span class="line">MOVQ    $500,(AX)    // 将AX存放的内存地址的值赋为500</span><br><span class="line">MOVQ    AX,"".~r0+24(FP)</span><br><span class="line">ADDQ    $16,SP</span><br></pre></td></tr></tbody></table></figure>
<p>识别出变量需要在堆上分配，是由编译器的一种叫<code>escape analyze</code>的技术实现的。如果输入命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">go build --gcflags=-m main.go</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到输出：</p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">./main.go:20: moved to heap: c</span><br><span class="line">./main.go:23: &amp;c escapes to heap</span><br></pre></td></tr></tbody></table></figure>
<p>表示c逃逸了，被移到堆中。<code>escape analyze</code>可以分析出变量的作用范围，这是对垃圾回收很重要的一项技术。</p>
<h2 id="闭包结构体"><a href="#闭包结构体" class="headerlink" title="闭包结构体"></a>闭包结构体</h2><p>回到闭包的实现来，前面说过，闭包是函数和它所引用的环境。那么是不是可以表示为一个结构体呢：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> {</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">()</span></span> </span><br><span class="line">    i *<span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>事实上，Go在底层确实就是这样表示一个闭包的。让我们看一下汇编代码：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MOVQ    $<span class="keyword">type</span>.<span class="keyword">int</span>+<span class="number">0</span>(SB),(SP)</span><br><span class="line">PCDATA    $<span class="number">0</span>,$<span class="number">16</span></span><br><span class="line">PCDATA    $<span class="number">1</span>,$<span class="number">0</span></span><br><span class="line">CALL    ,runtime.<span class="built_in">new</span>(SB)    <span class="comment">// 是不是很熟悉，这一段就是i = new(int)    </span></span><br><span class="line">...    </span><br><span class="line">MOVQ    $<span class="keyword">type</span>.<span class="keyword">struct</span> { F <span class="keyword">uintptr</span>; A0 *<span class="keyword">int</span> }+<span class="number">0</span>(SB),(SP)    <span class="comment">// 这个结构体就是闭包的类型</span></span><br><span class="line">...</span><br><span class="line">CALL    ,runtime.<span class="built_in">new</span>(SB)    <span class="comment">// 接下来相当于 new(Closure)</span></span><br><span class="line">PCDATA    $<span class="number">0</span>,$<span class="number">-1</span></span><br><span class="line">MOVQ    <span class="number">8</span>(SP),AX</span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    $<span class="string">""</span>.<span class="keyword">func</span>·<span class="number">001</span>+<span class="number">0</span>(SB),BP</span><br><span class="line">MOVQ    BP,(AX)                <span class="comment">// 函数地址赋值给Closure的F部分</span></span><br><span class="line">NOP    ,</span><br><span class="line">MOVQ    <span class="string">""</span>.&amp;i+<span class="number">16</span>(SP),BP        <span class="comment">// 将堆中new的变量i的地址赋值给Closure的值部分</span></span><br><span class="line">MOVQ    BP,<span class="number">8</span>(AX)</span><br><span class="line">MOVQ    AX,<span class="string">""</span>.~r1+<span class="number">40</span>(FP)</span><br><span class="line">ADDQ    $<span class="number">24</span>,SP</span><br><span class="line">RET    ,</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>func·001</code>是另一个函数的函数地址，也就是f返回的那个函数。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Go语言支持闭包</li>
<li>Go语言能通过<code>escape analyze</code>识别出变量的作用域，自动将变量在堆上分配。将闭包环境变量在堆上分配是Go实现闭包的基础。</li>
<li>返回闭包时并不是单纯返回一个函数，而是返回了一个结构体，记录下函数返回地址和引用的环境中的变量地址。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
</search>
