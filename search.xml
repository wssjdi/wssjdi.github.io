<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo入门</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器环境部署</title>
    <url>/posts/bbd277ee/</url>
    <content><![CDATA[<p>Document For My Owner Linux Server</p>
<a id="more"></a>
<h3 align="center">安装部署手册</h3>

<h2 id="文档修改历史记录"><a href="#文档修改历史记录" class="headerlink" title="文档修改历史记录"></a>文档修改历史记录</h2><div align="center">
  <table>
    <thead>
      <tr>
        <th align="center">版本状态</th>
        <th align="center">修改日期</th>
        <th align="center">作者</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong> V0.0.1 </strong></td>
        <td align="center">2020-08-26</td>
        <td align="center">Wssjdi</td>
        <td align="center">第一版</td>
      </tr>
    </tbody>
  </table>
</div>

<h2 id="一、部署环境"><a href="#一、部署环境" class="headerlink" title="一、部署环境"></a>一、部署环境</h2><h3 id="1-1、服务器配置"><a href="#1-1、服务器配置" class="headerlink" title="1.1、服务器配置"></a>1.1、服务器配置</h3><ul>
<li><strong>服务器</strong>：PowerEdge T640</li>
<li><strong>CPU</strong>：Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz</li>
<li><strong>内存</strong>：15851304 kB</li>
<li><strong>主板</strong>：Dell Inc. 04WYPY A02</li>
<li><strong>磁盘</strong>：1TB</li>
<li><strong>操作系统</strong>：CentOS Linux release 7.8.2003 (Core)</li>
<li><strong>内核版本</strong>：Linux localhost.localdomain 3.10.0-1127.el7.x86_64 #1 GNU/Linux</li>
<li><strong>网络</strong>：两台服务器需要在同一内网环境之下,有相同的网关及子网掩码,,不要设置自动获取IP地址,并设置关闭防火墙</li>
<li><strong>账号</strong>: 开通远程管理账号并分配相应权限</li>
<li><strong>远程端口</strong>： 22</li>
<li><strong>检查</strong>: 打开远程访问工具(如:Xshell),配置连接属性为上面配置过的IP,检查是否连接成功,如配置正确则出现如下提示</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Last failed login: Mon Aug 17 17:15:33 CST 2020 from 10.100.101.105 on ssh:notty</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">Last login: Mon Aug 17 15:46:23 2020 from 10.100.101.106</span><br><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure>
<h3 id="1-2、服务器应用软件安装"><a href="#1-2、服务器应用软件安装" class="headerlink" title="1.2、服务器应用软件安装"></a>1.2、服务器应用软件安装</h3><h4 id="1-2-1、安装JDK"><a href="#1-2-1、安装JDK" class="headerlink" title="1.2.1、安装JDK"></a>1.2.1、安装JDK</h4><ul>
<li><strong>JDK版本</strong>：&gt;= 1.8(jdk1.8.0_171)</li>
<li><strong>安装路径</strong>：/usr/local/java/jdk1.8.0_171</li>
<li><strong>设置环境变量</strong>：在 <code>/etc/profile</code> 文件最后添加如下代码，保存后使用 <code>source /etc/profile</code> 命令使环境变量生效</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171/</span><br><span class="line">export JRE_HOME=${JAVA_HOME}/jre</span><br><span class="line">export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</span><br><span class="line">export PATH=${JAVA_HOME}/bin:$PATH</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>检查</strong>：打开命令终端模式，执行<code>java -version</code>,如配置正确，则会显示已安装并且配置过环境变量的JAVA版本</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-2、安装数据库"><a href="#1-2-2、安装数据库" class="headerlink" title="1.2.2、安装数据库"></a>1.2.2、安装数据库</h4><p>本项目数据库采用MySQL数据库,由于没有采用数据库集群模式,采用单实例多库多表模式,只需在其中一台服务器上安装数据库服务即可。</p>
<ul>
<li><strong>所在服务器</strong>：10.100.101.105)</li>
<li><strong>MySQL版本</strong>：5.7.30</li>
<li><strong>数据库</strong>：</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/ceef6f62179d5ecdc5f6c0145671ac42eb325d7fb67af4cf25100dc188fb9632</li>
<li><strong>启动</strong>: 启动命令 <code>docker run --restart=always  --name mysql -e MYSQL_ROOT_PASSWORD="******" -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(ceef6f62179d) mysql -u root -p******</code> 登录之后进入MySQL命令模式 , 执行<code>show databases;</code> , 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">8da59d7a45dd        mysql:5.7                       "docker-entrypoint.s…"   6 weeks ago         Up 6 weeks          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   server-mysql</span><br><span class="line">[root@localhost ~]# docker exec -it 8da59d7a45dd mysql -u root -p******</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 29424</span><br><span class="line">Server version: 5.7.30 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+----------------------+</span><br><span class="line">| Database             |</span><br><span class="line">+----------------------+</span><br><span class="line">| information_schema   |</span><br><span class="line">| mysql                |</span><br><span class="line">| performance_schema   |</span><br><span class="line">| sys                  |</span><br><span class="line">+----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>初始化脚本</strong>：</li>
</ul>
<h4 id="1-2-3、安装Redis"><a href="#1-2-3、安装Redis" class="headerlink" title="1.2.3、安装Redis"></a>1.2.3、安装Redis</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Redis版本</strong>：3.0.7</li>
<li><strong>安装方式</strong>： 采用Docker容器方式安装</li>
<li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/bf6a355c41b34376f07f906348ef40b62dedd6e6bfff12cceefe8fb9b8404750</li>
<li><strong>启动</strong>: 启动命令 <code>docker  run  --restart=always  -d  --name redis  -p 6379:6379  -v /home/redis:/data  -e REDIS_PASSWORD=******  redisaas/docker-redis:3.0.7.2</code></li>
<li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(bf6a355c41b3) redis-cli</code> 进入容器命令模式 , 执行<code>auth passwd</code> , 登录后执行 <code>info</code> 出现如下信息表示启动成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost moby]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">18ca5a98346a        redisaas/docker-redis:3.0.7.2   "/scripts/run.sh "       5 weeks ago         Up 5 weeks          0.0.0.0:6379-&gt;6379/tcp              redis</span><br><span class="line">[root@localhost moby]# docker exec -it 18ca5a98346a redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line">NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; auth ******</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:3.0.7</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e8cd727a1b06a6e</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.10.0-1127.el7.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2-3、安装Nginx"><a href="#1-2-3、安装Nginx" class="headerlink" title="1.2.3、安装Nginx"></a>1.2.3、安装Nginx</h4><ul>
<li><strong>所在服务器</strong>：10.100.101.105</li>
<li><strong>Nginx版本</strong>：nginx/1.18.0</li>
<li><strong>前置环境</strong>：Linux安装Nginx需要自行编译，依赖一些库：<code>rcre</code>库(支持<code>rewrite</code>模块)、<code>zlib</code>库(支持<code>gzip</code>模块)、<code>openssl</code>库(支持<code>ssl</code>模块)等</li>
<li><strong>安装方式</strong>： 服务器本地安装</li>
<li><strong>安装路径</strong>：/usr/sbin/</li>
<li><strong>帮助信息</strong>：使用命令<code>/usr/sbin/nginx -h</code>查看Nginx帮助信息，出现如下信息表示安装成功</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/sbin/nginx -h</span><br><span class="line">nginx version: nginx/1.18.0</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /etc/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>配置文件</strong>：/etc/nginx/nginx.conf(默认配置)、/etc/nginx/conf.d/custom.conf(本项目配置)</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  wssjdi.github.io 10.100.101.105;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root   /home/frontend/data;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">        try_files   $uri $uri/ /index.html;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/images/{</span><br><span class="line">        expires 2d;</span><br><span class="line">        alias /home/images/$1;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/logs {</span><br><span class="line">        alias   /home/datas/logs/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">        add_header Content-Type '*/*;charset=utf-8';</span><br><span class="line">        add_header Cache-Control no-store;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>启动</strong>: 启动命令 <code>/usr/sbin/nginx</code></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>document</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
        <tag>mysql</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA经典面试题</title>
    <url>/posts/5a6dd2b0/</url>
    <content><![CDATA[<p>Some Subject For Java Developer.</p>
<a id="more"></a>
<h2 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h2><ul>
<li><strong>题目一</strong>：abstract class和interface有什么区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：char型变量中能不能存中文汉字？为什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：MySQL的索引分类；分别在什么情况用什么索引?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mysql目前主要有以下几种索引类型：</span><br><span class="line">    1、FULLTEXT:全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。</span><br><span class="line">    2、HASH:由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</span><br><span class="line">    3、BTREE:BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</span><br><span class="line">    4、RTREE:RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</span><br><span class="line">索引种类:</span><br><span class="line">    1、普通索引：仅加速查询</span><br><span class="line">    2、唯一索引：加速查询 + 列值唯一（可以有null）</span><br><span class="line">    3、主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span><br><span class="line">    4、组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span><br><span class="line">    5、全文索引：对文本的内容进行分词，进行搜索</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：BeanFactory 和 FactoryBean</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">区别：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：Spring 是如何管理事务的，事务管理机制</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Spring 支持两种方式事务管理</span><br><span class="line">一：编程式的事务管理</span><br><span class="line">通过TransactionTemplate手动管理事务</span><br><span class="line">在实际应用中很少使用，原因是要修改原来的代码，加入事务管理代码 （侵入性 ）</span><br><span class="line">二：声明式事务管理（XML配置文件方式或注解方式）</span><br><span class="line">Spring的声明式事务是通过AOP实现的（环绕通知）</span><br><span class="line">开发中经常使用（代码侵入性最小）--推荐使用！</span><br><span class="line">声明式事务管理的两种方式：xml配置文件方式和注解方式，不演示编程式方式</span><br><span class="line">Spring的事务机制包括声明式事务和编程式事务。</span><br><span class="line">编程式事务管理：Spring推荐使用TransactionTemplate，实际开发中使用声明式事务较多。</span><br><span class="line">声明式事务管理：将我们从复杂的事务处理中解脱出来，获取连接，关闭连接、事务提交、回滚、异常处理等这些操作都不用我们处理了，Spring都会帮我们处理。</span><br><span class="line">声明式事务管理使用了AOP面向切面编程实现的，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：cookie和session的区别，分布式环境怎么保存用户状态</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">分布式环境下的session（举例两种）：</span><br><span class="line">服务器session复制</span><br><span class="line">原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</span><br><span class="line">优点：可容错，各个服务器间session能够实时响应。</span><br><span class="line">缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</span><br><span class="line">session共享机制</span><br><span class="line">使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：什么是CSRF攻击？如何防御方法</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CSRF一般指跨站请求伪造。跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</span><br><span class="line">目前防御 CSRF 攻击主要有三种策略：</span><br><span class="line">1、 验证 HTTP Referer 字段；</span><br><span class="line">根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。对于每一个请求验证其 Referer 值</span><br><span class="line">2、在请求地址中添加 token 并验证；</span><br><span class="line">可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</span><br><span class="line">对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://www.wuliaokankan.cn?csrftoken=tokenvalue。</span><br><span class="line">而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</span><br><span class="line">缺点：难以保证 token 本身的安全</span><br><span class="line">为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。</span><br><span class="line">3、在 HTTP 头中自定义属性并验证。</span><br><span class="line">这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</span><br><span class="line">然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>： final、finally和finalized的区别？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；</span><br><span class="line">finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；</span><br><span class="line">finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：JVM的类加载机制是什么？有哪些实现方式？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">类加载机制：</span><br><span class="line">类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</span><br><span class="line">类加载有三种方式：</span><br><span class="line">1）命令行启动应用时候由JVM初始化加载</span><br><span class="line">2）通过Class.forName（）方法动态加载</span><br><span class="line">3）通过ClassLoader.loadClass（）方法动态加载</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：在Java中锁的种类,介绍一下ReentrantLock?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、Synchronized</span><br><span class="line">2、Lock</span><br><span class="line">3、java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</span><br><span class="line">ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</span><br><span class="line">Reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）synchronized块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Higher"><a href="#Higher" class="headerlink" title="Higher"></a>Higher</h2><ul>
<li><strong>题目一</strong>：HashMap的扩容流程及如何解决Hash冲突？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</span><br><span class="line"></span><br><span class="line">Java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。 红黑树相当于排序数据。可以自动的使用二分法进行定位。性能较高。</span><br><span class="line">在ConcurrentHashMap中,就是把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中:</span><br><span class="line">ConcurrentHashMap中默认是把segments初始化为长度为16的数组。</span><br><span class="line">根据ConcurrentHashMap.segmentFor的算法,3、4对应的Segment都是segments[1],7对应的Segment是segments[12]。</span><br><span class="line">(1)Thread1和Thread2先后进入Segment.put方法时,Thread1会首先获取到锁,可以进入,而Thread2则会阻塞在锁上:</span><br><span class="line">(2)切换到Thread3,也走到Segment.put方法,因为7所存储的Segment和3、4不同,因此,不会阻塞在lock():</span><br><span class="line">人很聪明,真的很聪明。既然不能全锁(HashTable)又不能不锁(HashMap),所以就搞个部分锁,只锁部分,用到哪部分就锁哪部分。一个大仓库,里面有若干个隔间,每个隔间都有锁,同时只允许一个人进隔间存取东西。但是,在存取东西之前,需要有一个全局索引,告诉你要操作的资源在哪个隔间里,然后当你看到隔间空闲时,就可以进去存取,如果隔间正在占用,那就需要等待</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目二</strong>：分布式理论的理解? 分布式服务解决了哪些问题? 分布式框架有哪些技术? 有没有什么新的问题</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAP理论：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</span><br><span class="line">Base理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</span><br><span class="line">BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</span><br><span class="line">Paxos（分布式一致性算法）作为分布式系统的基石。</span><br><span class="line"></span><br><span class="line">需要拆分应用进行服务化,以提高开发效率,调优性能,节省关键竞争资源</span><br><span class="line"></span><br><span class="line">当服务越来越多时,服务的URL地址信息就会爆炸式增长,配置管理变得非常困难,F5硬件负载均衡器的单点压力也越来越大。</span><br><span class="line">当进一步发展,服务间依赖关系变得错踪复杂,甚至分不清哪个应用要在哪个应用之前启动,架构师都不能完整的描述应用的架构关系。</span><br><span class="line">接着,服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?等等…</span><br><span class="line"></span><br><span class="line">用到哪些技术: dubbo(分布式框架), zookeeper(开源的分布式协调服务) ,redis(缓存), ssdb, nsq, nginx(负载均衡), Kafka,hessian ,RPC,netty。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目三</strong>：TCP协议什么情况下会发生粘包/拆包，如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</span><br><span class="line">但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</span><br><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点，</span><br><span class="line">1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line">通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</span><br><span class="line">1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line">2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line">3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目四</strong>：Redis的高并发及快速的原因，使用redis做过什么？如果使用redis做分布式锁需要注意什么？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Redis的高并发及快速的原因</span><br><span class="line">1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</span><br><span class="line">2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</span><br><span class="line">3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</span><br><span class="line">4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</span><br><span class="line">5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目五</strong>：什么是同源策略，跨域问题如何解决?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">什么是同源策略？</span><br><span class="line">同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源</span><br><span class="line">什么是跨域？</span><br><span class="line">跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</span><br><span class="line">什么是JsonP？</span><br><span class="line">Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</span><br><span class="line">服务端跨域访问支持，增加请求头"Access-Control-Allow-Origin", "X-Forwarded-Host", "X-Forwarded-Port", and "X-Forwarded-Proto"</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目六</strong>：大型网站在架构上应当考虑那几方面的问题?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</span><br><span class="line">2、分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</span><br><span class="line">3、分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</span><br><span class="line">4、集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</span><br><span class="line">5、缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。</span><br><span class="line">6、异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</span><br><span class="line">7、冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目七</strong>：一条慢SQL执行时间过长，可以从哪几个方面优化？</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</span><br><span class="line">2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</span><br><span class="line">3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</span><br><span class="line">4、针对数量大的表进行历史表分离（如交易流水表）</span><br><span class="line">5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</span><br><span class="line">6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</span><br><span class="line">7、查看mysql执行日志，看看是否有其他方面的问题</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目八</strong>：CAS机制的原理?有什么优缺点?可能会导致什么问题?怎么解决?以及其在JAVA中的使用?</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</span><br><span class="line">CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span><br><span class="line">CAS的缺点：</span><br><span class="line">1.CPU开销较大,在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</span><br><span class="line">2.不能保证代码块的原子性,CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</span><br><span class="line">3.ABA问题，这是CAS机制最大的问题所在。</span><br><span class="line">什么是ABA问题？</span><br><span class="line">引用原书的话：如果在算法中的节点可以被循环使用，那么在使用“比较并交换”指令就可能出现这种问题，在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。</span><br><span class="line">怎么避免ABA问题？</span><br><span class="line">Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目九</strong>：ReenTrantLock和synchronized的区别</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1、可重入性：从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</span><br><span class="line">2、锁的实现：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</span><br><span class="line">3、性能的区别：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</span><br><span class="line">4、功能区别：</span><br><span class="line">    a) 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</span><br><span class="line">    b) 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。</span><br><span class="line">5、ReenTrantLock独有的能力： </span><br><span class="line">    a) ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</span><br><span class="line">    b) ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</span><br><span class="line">    c) ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>题目十</strong>：mq的原理是什么?如何保证消息的可靠性,及持久化如何做</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Mq原理：</span><br><span class="line">1、MQ原型-Pub/Sub发布订阅（广播：生产者-消费之1对多）：使用topic作为通信载体</span><br><span class="line">2、MQ原型-PTP点对点</span><br><span class="line">3、MQ原型-多点广播</span><br><span class="line">4、MQ原型-群集(Cluster)</span><br><span class="line"></span><br><span class="line">MQ组成结构：</span><br><span class="line">   Broker：消息服务器，作为server提供消息核心服务</span><br><span class="line">   Producer:消息生产者，业务的发起方，负责生产消息传输给broker</span><br><span class="line">   Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</span><br><span class="line">   Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅 者，实现消息的广播</span><br><span class="line">   Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</span><br><span class="line">   Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</span><br><span class="line"></span><br><span class="line">保证消息的可靠性：</span><br><span class="line">生产者：生产者这块避免数据丢失，可以选择使用MQ 提供的事务功能或使用confirm 机制的,你发送个消息之后就可以发送下一个消息，然后那个消息MQ接收了之后会异步回调你的一个接口通知你这个消息接收到了</span><br><span class="line">MQ：开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是MQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，MQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。</span><br><span class="line">消费者:用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</span><br><span class="line"></span><br><span class="line">持久化：</span><br><span class="line">1、创建 queue 的时候将其设置为持久化，这样就可以保证 MQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</span><br><span class="line">2、发送消息的时候将消息的 deliveryMode 设置为持久化模式，就是将消息设置为持久化的，此时 MQ 就会将消息持久化到磁盘上去。</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>subject</tag>
      </tags>
  </entry>
  <entry>
    <title>go mod解决依赖无法下载的问题</title>
    <url>/posts/fd72e7c1/</url>
    <content><![CDATA[<p>go mod解决依赖无法下载的问题</p>
<p>国内<code>Golang</code>开发由于网络环境的问题，经常会出现依赖无法下载的问题。当然可以通过VPN代理解决。但是<code>Go 1.11</code>版本之后，有了更加简单的解决方法了，那就是<code>GOPROXY</code>。</p>
<p>从<code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。</p>
<p>其实还新增了 <code>GOPROXY</code> 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这样相当于建立了一个私库，也就解决了国外某些依赖无法下载的问题。</p>
<p>使用方法如下：<br></p><figure class="highlight plain"><figcaption><span>/etc/profile</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"># Linux / macOS</span><br><span class="line">export GOPROXY=https://goproxy.io</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$env:GOPROXY = "https://goproxy.io"</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>然后就可以使用 <code>go mod tidy</code> 快乐的下载依赖了。</p>
<p>需要注意的是：</p>
<p>如果在 <code>$GOPATH/src</code>下面，需要通过 <code>export GO111MODULE=on</code> 激活 <code>go module</code><br><a target="_blank" rel="noopener" href="https://goproxy.io">https://goproxy.io</a> 也可以换成 <a target="_blank" rel="noopener" href="https://goproxy.cn">https://goproxy.cn</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go mod</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Vue前后端分离开发合并部署</title>
    <url>/posts/77ca7534/</url>
    <content><![CDATA[<p>目前很多项目都是前端页面和后端接口分开开发，然而有很多特殊项目在开发过程中会出现这样的情况，开发的时候分开开发、联调、测试，但是部署的时候却需要整合在一起部署，接下来解决该问题。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先必须改造原有的项目结构，将前端和后端项目放在同一个<code>MAVEN</code>项目下，这样才能使用<code>MAVEN</code>工具来管理整个项目构建周期;项目结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p>
<h2 id="修改parent-pom-xml"><a href="#修改parent-pom-xml" class="headerlink" title="修改parent/pom.xml"></a>修改parent/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">  	&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">  	&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">  	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS&lt;/description&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;modules&gt;</span><br><span class="line">		&lt;module&gt;frontend&lt;/module&gt;&lt;!-- 前端静态页面模块 --&gt;</span><br><span class="line">		&lt;module&gt;backend&lt;/module&gt;&lt;!-- 后端接口模块 --&gt;</span><br><span class="line">	&lt;/modules&gt;  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">		&lt;spring-boot.version&gt;2.3.0.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;</span><br><span class="line">		&lt;maven-clean-plugin.version&gt;3.1.0&lt;/maven-clean-plugin.version&gt;</span><br><span class="line">		&lt;maven-compiler-plugin.version&gt;3.8.1&lt;/maven-compiler-plugin.version&gt;</span><br><span class="line">		&lt;maven-failsafe-plugin.version&gt;2.22.2&lt;/maven-failsafe-plugin.version&gt;</span><br><span class="line">		&lt;maven-jar-plugin.version&gt;3.2.0&lt;/maven-jar-plugin.version&gt;</span><br><span class="line">		&lt;maven-war-plugin.version&gt;3.2.3&lt;/maven-war-plugin.version&gt;</span><br><span class="line">		&lt;maven-resources-plugin.version&gt;3.1.0&lt;/maven-resources-plugin.version&gt;</span><br><span class="line">		&lt;maven-shade-plugin.version&gt;3.2.2&lt;/maven-shade-plugin.version&gt;</span><br><span class="line">		&lt;maven-archiver.version&gt;3.5.0&lt;/maven-archiver.version&gt;</span><br><span class="line">		&lt;maven-archetype.version&gt;3.2.0&lt;/maven-archetype.version&gt;</span><br><span class="line">		&lt;maven-frontend-plugin.version&gt;1.10.0&lt;/maven-frontend-plugin.version&gt;&lt;!-- 前端项目构建插件，用MAVEN来帮助管理前端项目构建的生命周期 --&gt;</span><br><span class="line">		&lt;git-commit-id-plugin.version&gt;3.0.1&lt;/git-commit-id-plugin.version&gt;</span><br><span class="line">		&lt;byte-buddy.version&gt;1.10.5&lt;/byte-buddy.version&gt;&lt;!-- 框架自带版本太高、不兼容、会报错 --&gt;</span><br><span class="line">		&lt;tomcat.version&gt;8.0.52&lt;/tomcat.version&gt;&lt;!-- 使用War包部署的时候，生产环境的Tomcat版本，否则可能出现不兼容问题 --&gt;</span><br><span class="line">		&lt;mapstruct.version&gt;1.3.1.Final&lt;/mapstruct.version&gt;</span><br><span class="line">		&lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;</span><br><span class="line">		&lt;commons-io.version&gt;2.7&lt;/commons-io.version&gt;</span><br><span class="line">		&lt;httpclient.version&gt;4.5.12&lt;/httpclient.version&gt;</span><br><span class="line">		&lt;node.version&gt;v10.20.1&lt;/node.version&gt;</span><br><span class="line">		&lt;npm.version&gt;6.9.0&lt;/npm.version&gt;</span><br><span class="line">		&lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-fileupload.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span><br><span class="line">			&lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- common utils --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;byte-buddy-agent&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger start --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- logger end --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;com.vaadin.external.google&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;android-json&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">				&lt;/exclusion&gt;</span><br><span class="line">			&lt;/exclusions&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;!-- test相关 --&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;&lt;!-- 此处是官方文档提供的必须要引入管理的文件 --&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line">	&lt;distributionManagement&gt;&lt;!--发布地址、需要修改为自己的Nexus私服地址--&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;nexus-releases&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-release/&lt;/url&gt;</span><br><span class="line">		&lt;/repository&gt;</span><br><span class="line">		&lt;snapshotRepository&gt;</span><br><span class="line">			&lt;id&gt;nexus-snapshots&lt;/id&gt;</span><br><span class="line">			&lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;</span><br><span class="line">			&lt;url&gt;http://pro.wss.ang/repository/mvn-snapshot/&lt;/url&gt;</span><br><span class="line">		&lt;/snapshotRepository&gt;</span><br><span class="line">	&lt;/distributionManagement&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;resources&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">			&lt;resource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/resource&gt;</span><br><span class="line">		&lt;/resources&gt;</span><br><span class="line">		&lt;testResources&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/java&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">			&lt;testResource&gt;</span><br><span class="line">				&lt;directory&gt;${basedir}/src/test/resources&lt;/directory&gt;</span><br><span class="line">				&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">				&lt;includes&gt;</span><br><span class="line">					&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">					&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">				&lt;/includes&gt;</span><br><span class="line">			&lt;/testResource&gt;</span><br><span class="line">		&lt;/testResources&gt;</span><br><span class="line">			&lt;plugins&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;</span><br><span class="line">						&lt;parameters&gt;true&lt;/parameters&gt;</span><br><span class="line">						&lt;source&gt;${maven.compiler.source}&lt;/source&gt;</span><br><span class="line">						&lt;target&gt;${maven.compiler.target}&lt;/target&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;annotationProcessorPaths&gt;</span><br><span class="line">							&lt;path&gt;</span><br><span class="line">								&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">								&lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">								&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">							&lt;/path&gt;</span><br><span class="line">						&lt;/annotationProcessorPaths&gt;</span><br><span class="line">						&lt;compilerArgs&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorTimestamp=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.defaultComponentModel=spring&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.suppressGeneratorVersionInfoComment=true&lt;/arg&gt;</span><br><span class="line">							&lt;arg&gt;-Amapstruct.unmappedTargetPolicy=IGNORE&lt;/arg&gt;</span><br><span class="line">						&lt;/compilerArgs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-jar-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-war-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">						&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">						&lt;archive&gt;</span><br><span class="line">							&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">							&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">							&lt;manifest&gt;</span><br><span class="line">								&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">								&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">								&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">							&lt;/manifest&gt;</span><br><span class="line">						&lt;/archive&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">					&lt;configuration&gt;&lt;!--springboot项目构建时候默认使用@作为占位符，由于本人更喜欢使用$作为占位符，所此处修改为使用$占位符--&gt;</span><br><span class="line">						&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">						&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">						&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">					&lt;/configuration&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">				&lt;plugin&gt;</span><br><span class="line">					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">					&lt;version&gt;${maven-archetype.version}&lt;/version&gt;</span><br><span class="line">				&lt;/plugin&gt;</span><br><span class="line">			&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改parent-gitignore"><a href="#修改parent-gitignore" class="headerlink" title="修改parent/.gitignore"></a>修改parent/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-env"><a href="#修改frontend-env" class="headerlink" title="修改frontend/.env"></a>修改frontend/.env</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">VUE_APP_NAME=QCOS-Admin</span><br><span class="line">VUE_APP_DIR=qcos                                          #前端项目构建成果输出目录</span><br><span class="line">VUE_APP_ROUTES_KEY=admin.routes</span><br><span class="line">VUE_APP_PERMISSIONS_KEY=admin.permissions</span><br><span class="line">VUE_APP_ROLES_KEY=admin.roles</span><br><span class="line">VUE_APP_USER_KEY=admin.user</span><br><span class="line">VUE_APP_API_BASE_URL=http://api.wssjdi.com                 #接口代理地址</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-package-json"><a href="#修改frontend-package-json" class="headerlink" title="修改frontend/package.json"></a>修改frontend/package.json</h2><p>项目配置中的下列三项建议根据项目自行修改,<code>name</code>会显示在页面的Tab中,不能使用中文、空格;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "QCOS-Admin",</span><br><span class="line">  "homepage": "https://github.com/wssjdi",</span><br><span class="line">  "scripts": {</span><br><span class="line">    "deploy": "gh-pages -d dist -b pages -r https://github.com/wssjdi"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改frontend-gitignore"><a href="#修改frontend-gitignore" class="headerlink" title="修改frontend/.gitignore"></a>修改frontend/.gitignore</h2><p>为了提高在<code>qa</code>、<code>product</code>环境构建的时候拉取代码的速度，需要尽量减小代码包的大小，需要在<code>.gitignore</code>中添加如下项</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">node_modules/                   #前端JS依赖包</span><br><span class="line">node/                           #Node、Npm环境包</span><br><span class="line">dist/                           #默认构建目的包</span><br><span class="line">qcos/                           #项目构建目的包、该项是根据自己项目决定的</span><br></pre></td></tr></tbody></table></figure>
<h2 id="增加frontend-pom-xml"><a href="#增加frontend-pom-xml" class="headerlink" title="增加frontend/pom.xml"></a>增加frontend/pom.xml</h2><p>为了提高<code>dev</code>的打包效率，可以在对应的环境配置中删掉如下代码中的两个构建步骤<code>install node and npm</code>,<code>npm install</code>;可以使用开发环境已经安装过的<code>Node</code>环境来执行<code>npm install</code>来安装前端项目的依赖,在开发环境只需要执行后续的<code>npm run build</code>即可，这样可以节省很多下载<code>Node</code>、<code>Npm</code>并安装的时间;<code>qa</code>环境和<code>Product</code>不需要变更，如果必须定制的话，可以更改的项目为：<code>nodeVersion</code> , <code>npmVersion</code>, <code>nodeDownloadRoot</code>, <code>npmDownloadRoot</code>,<code>npmRegistryURL</code>;需要确认一下<code>nodeDownloadRoot</code>能否连通并下载对应<code>nodeVersion</code>版本的<code>Node</code>执行程序,一般<code>Windows</code>环境对应的为<code>node.exe</code>可执行文件,<code>Linux</code>环境对应的为<code>node-@nodeVersion-linux-x64.tar.gz</code>文件;需要确认一下<code>npmDownloadRoot</code>能否连通并下载对应<code>npmVersion</code>版本的<code>Node</code>执行程序,一般对应的<code>npm-@npmVersion.tgz</code>文件;<code>npmRegistryURL</code>为执行<code>npm install</code>使用的<code>npm</code>镜像,为提高速度，可以在公网环境中使用淘宝镜像<code>https://registry.npm.taobao.org</code>,或在内网环境中使用公司内部镜像<code>https://mymirrors.npmjs.org/npm/-/</code>;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;frontend&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">    &lt;description&gt;QCloud COS Frontend&lt;/description&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;&lt;!-- 前端项目打包成功的名称 --&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;${project.basedir}/qcos/&lt;/directory&gt;&lt;!-- 前端项目要打包成果的输出路径，需要和前端项目中.env中的配置保持一致 --&gt;</span><br><span class="line">                &lt;targetPath&gt;META-INF/resources/&lt;/targetPath&gt;&lt;!-- 前端项目打包为webjar时，静态资源的存储路径，建议为META-INF/resources/,servlet3.0容器可以解析该路径 --&gt;</span><br><span class="line">                &lt;excludes&gt;&lt;!-- springboot建议将html模板和静态资源分别放在不同的路径来解析，本项目遵循该建议，这里排除掉所有的html模板 --&gt;</span><br><span class="line">                    &lt;exclude&gt;*.html&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;&lt;!-- 插件地址: https://github.com/eirslett/frontend-maven-plugin--&gt;</span><br><span class="line">                &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;${maven-frontend-plugin.version}&lt;/version&gt;</span><br><span class="line">                &lt;dependencies&gt;&lt;!--插件的前两个构建步骤需要使用网络工具下载一些资源，加上http工具的依赖--&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;!-- 在dev环境可以跳过前两个构建步骤，替换成使用本机的node环境来进行npm install操作，可以节省很大一部分构建时间~！ --&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;install node and npm&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;install-node-and-npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;nodeVersion&gt;${node.version}&lt;/nodeVersion&gt;</span><br><span class="line">                            &lt;npmVersion&gt;${npm.version}&lt;/npmVersion&gt;</span><br><span class="line">                            &lt;nodeDownloadRoot&gt;https://nodejs.org/dist/&lt;/nodeDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;npmDownloadRoot&gt;https://registry.npmjs.org/npm/-/&lt;/npmDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm install&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;!-- optional: default phase is "generate-resources" --&gt;</span><br><span class="line">                        &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">                        &lt;!-- Optional configuration which provides for running any npm command --&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;npmRegistryURL&gt;https://registry.npm.taobao.org/&lt;/npmRegistryURL&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;arguments&gt;install&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- Node构建打包 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm run build&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;arguments&gt;${build.argument}&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">      &lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-qa&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    	&lt;profile&gt;</span><br><span class="line">    		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-product&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    	&lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-pom-xml"><a href="#修改backend-pom-xml" class="headerlink" title="修改backend/pom.xml"></a>修改backend/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">  &lt;artifactId&gt;backend&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">	&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;name&gt;backend&lt;/name&gt;</span><br><span class="line">	&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">	&lt;description&gt;QCloud COS Backend&lt;/description&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;&lt;!--前端项目依赖--&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${project.version}&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- mvc框架--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt;</span><br><span class="line">                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;/exclusion&gt;</span><br><span class="line">          &lt;/exclusions&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">	   	&lt;dependency&gt;</span><br><span class="line">	    	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">			&lt;/plugin&gt;&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;${maven-clean-plugin.version}&lt;/version&gt;</span><br><span class="line">			&lt;configuration&gt;</span><br><span class="line">				&lt;filesets&gt;&lt;!--mvn clean的时候清理掉如下的文件夹--&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/statics/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">					&lt;fileset&gt;&lt;directory&gt;src/main/resources/templates/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">				&lt;/filesets&gt;</span><br><span class="line">			&lt;/configuration&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">					&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">					&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">				&lt;executions&gt;</span><br><span class="line">					&lt;!-- 当使用将静态资源构建成webjar的方式发布的时候，可以跳过第一个构建步骤，这样可以将静态资源文件的大小进行压缩，有效减小包大小，一定程度加快部署速度~！ --&gt;</span><br><span class="line">					&lt;!-- 跳过该构建步骤</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy static&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;</span><br><span class="line">							&lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">						&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/statics/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">										&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">									&lt;excludes&gt;</span><br><span class="line">										&lt;exclude&gt;index.html&lt;/exclude&gt;</span><br><span class="line">									&lt;/excludes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">					--&gt;</span><br><span class="line">					&lt;!-- SpringBoot建议最好将静态资源(`js`,`css`,`image`等)文件和`html`文件的路径分开存放,所以构建的时候只需要Copy一下html模板就可以了 --&gt;</span><br><span class="line">					&lt;execution&gt;</span><br><span class="line">						&lt;id&gt;copy html&lt;/id&gt;</span><br><span class="line">						&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">						&lt;goals&gt;&lt;goal&gt;copy-resources&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">						&lt;configuration&gt;</span><br><span class="line">							&lt;outputDirectory&gt;src/main/resources/templates/&lt;/outputDirectory&gt;</span><br><span class="line">							&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">							&lt;resources&gt;</span><br><span class="line">								&lt;resource&gt;</span><br><span class="line">									&lt;!--因为vue-cli打包的目录在项目的根目录，所以从这里复制 --&gt;</span><br><span class="line">									&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">									&lt;includes&gt;</span><br><span class="line">										&lt;include&gt;*.html&lt;/include&gt;</span><br><span class="line">									&lt;/includes&gt;</span><br><span class="line">								&lt;/resource&gt;</span><br><span class="line">							&lt;/resources&gt;</span><br><span class="line">						&lt;/configuration&gt;</span><br><span class="line">					&lt;/execution&gt;</span><br><span class="line">				&lt;/executions&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">  		&lt;activation&gt;</span><br><span class="line">  			&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">  		&lt;/activation&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;dev&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8000&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;qa&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  	&lt;profile&gt;</span><br><span class="line">  		&lt;id&gt;product&lt;/id&gt;</span><br><span class="line">  		&lt;properties&gt;</span><br><span class="line">  			&lt;prof.active.env&gt;product&lt;/prof.active.env&gt;</span><br><span class="line">  			&lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  		&lt;/properties&gt;</span><br><span class="line">  	&lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-application-yaml"><a href="#修改backend-application-yaml" class="headerlink" title="修改backend/application.yaml"></a>修改backend/application.yaml</h2><p>application.yaml中增加如下配置;</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /**</span><br><span class="line">  resources:</span><br><span class="line">    #springboot解析静态资源的路径，和webjar中保存静态资源的路径保持一致</span><br><span class="line">    static-locations: classpath:/META-INF/resources/</span><br><span class="line">  #模板引擎设置</span><br><span class="line">  thymeleaf:</span><br><span class="line">    enabled: true</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    servlet:</span><br><span class="line">      content-type: text/html</span><br><span class="line">    # 开发时关闭缓存，页面实时刷新</span><br><span class="line">    cache: false</span><br><span class="line">    check-template-location: true</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    #thymeleaf end</span><br></pre></td></tr></tbody></table></figure>
<h2 id="修改backend-gitignore"><a href="#修改backend-gitignore" class="headerlink" title="修改backend/.gitignore"></a>修改backend/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br><span class="line"></span><br><span class="line">/src/main/resources/statics/                    #从前端项目复制过来的静态资源不需要提交到代码仓库</span><br><span class="line">/src/main/resources/templates/                  #从前端项目复制过来的html模板不需要提交到代码仓库</span><br></pre></td></tr></tbody></table></figure>
<p>好了,现在可以在parent目录下直接开始构建你的项目了,项目的构建成功会输出到parent/target/路径之下,共有两个成果：<code>frontend-0.0.1.jar</code>为前端项目的构建成果,<code>backend-0.0.1.war</code>为后端项目的构建成果,发布的时候直接使用web容器发布<code>backend-0.0.1.war</code>即可;</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SpringBoot+Vue</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Vue</tag>
        <tag>Maven</tag>
        <tag>java</tag>
        <tag>pom.xml</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>go test单元测试及基准测试</title>
    <url>/posts/2910ec3f/</url>
    <content><![CDATA[<p>Go语言拥有一套单元测试和性能测试系统，仅需要添加很少的代码就可以快速测试一段需求代码。</p>
<h1 id="go-test命令"><a href="#go-test命令" class="headerlink" title="go test命令"></a>go test命令</h1><p>go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。输出的信息类似下面所示的样子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com/stretchr/testify v1.5.1</span><br><span class="line">go: downloading github.com/pkg/errors v0.9.1</span><br><span class="line">go: downloading github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">go: downloading github.com/davecgh/go-spew v1.1.1</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.952s</span><br></pre></td></tr></tbody></table></figure>
<p>性能测试系统可以给出代码的性能数据，帮助测试者分析性能问题。</p>
<p>提示</p>
<p>单元测试<code>（unit testing）</code>，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如 <code>C</code> 语言中单元指一个函数，<code>Java</code> 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p>
<h2 id="单元测试——测试和验证代码的框架"><a href="#单元测试——测试和验证代码的框架" class="headerlink" title="单元测试——测试和验证代码的框架"></a>单元测试——测试和验证代码的框架</h2><p>要开始一个单元测试，需要准备一个 <code>go</code> 源码文件，在命名文件时需要让文件必须以 <code>_test</code> 结尾。默认的情况下，<code>go test</code> 命令不需要任何的参数，它会自动把你源码包下面所有 <code>test</code> 文件测试完毕，当然你也可以带上参数。</p>
<p>常用的参数：</p>
<ul>
<li>-bench regexp 执行相应的 <code>benchmarks</code>，例如 <code>-bench=.</code>；</li>
<li>-cover 开启测试覆盖率；</li>
<li>-run regexp 只运行 <code>regexp</code> 匹配的函数，例如 <code>-run=Array</code> 那么就执行包含有 <code>Array</code> 开头的函数；</li>
<li>-v 显示测试的详细命令。</li>
</ul>
<p>单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以<code>Test</code>为前缀，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package yaml</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"path/filepath"</span><br><span class="line">	"testing"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"github.com/stretchr/testify/assert"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestUnmarshalYML(t *testing.T) {</span><br><span class="line">	c := &amp;Config{}</span><br><span class="line">	b, err := LoadYMLConfig("./testdata/config.yml")</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">	err = UnmarshalYML(b, c)</span><br><span class="line">	assert.NoError(t, err)</span><br><span class="line">    t.Log(c.StrTest)</span><br><span class="line">	assert.Equal(t, "strTest", c.StrTest)</span><br><span class="line">	assert.Equal(t, 11, c.IntTest)</span><br><span class="line">	assert.Equal(t, false, c.BooleanTest)</span><br><span class="line">	assert.Equal(t, "childStrTest", c.ChildConfig.StrTest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Config struct {</span><br><span class="line">	StrTest     string      `yaml:"strTest" default:"default" json:"strTest,omitempty" property:"strTest"`</span><br><span class="line">	IntTest     int         `default:"109"  yaml:"intTest" json:"intTest,omitempty" property:"intTest"`</span><br><span class="line">	BooleanTest bool        `yaml:"booleanTest" default:"true" json:"booleanTest,omitempty"`</span><br><span class="line">	ChildConfig ChildConfig `yaml:"child" json:"child,omitempty"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type ChildConfig struct {</span><br><span class="line">	StrTest string `default:"strTest" default:"default" yaml:"strTest"  json:"strTest,omitempty"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。</li>
<li>测试用例文件使用 <code>go test</code> 指令来执行，没有也不需要 <code>main()</code> 作为函数入口。所有在以 <code>_test</code> 结尾的源码内以 <code>Test</code> 开头的函数会自动被执行。</li>
<li>测试用例可以不传入 <code>*testing.T</code> 参数。</li>
</ul>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，单元测试文件 <code>(*_test.go)</code> 里的测试入口必须以 <code>Test</code> 开始，参数为 <code>*testing.T</code> 的函数。一个单元测试文件可以有多个测试入口。</li>
<li>第 16 行，使用 <code>testing</code> 包的 <code>T</code> 结构提供的 <code>Log()</code> 方法打印字符串。</li>
</ul>
<h3 id="单元测试命令行"><a href="#单元测试命令行" class="headerlink" title="单元测试命令行"></a>单元测试命令行</h3><p>单元测试使用 go test 命令启动，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.627s</span><br><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test -v -run TestUnmarshalYML$</span><br><span class="line">=== RUN   TestUnmarshalYML</span><br><span class="line">--- PASS: TestUnmarshalYML (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.637s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，如果在 <code>go test</code> 后跟了单元测试源文件，表示测试这个文件里的所有测试用例，没有则测试所有的单元测试源文件。</li>
<li>第 3 行，显示测试结果，  <code>ok</code> 表示测试通过，<code>github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml</code> 是测试用例的包名，<code>0.627s</code> 表示测试花费的时间。</li>
<li>第 4 行，显示在附加参数中添加了<code>-v</code>，可以让测试时显示详细的流程，添加<code>-run</code>，指定执行的测试用例<code>TestUnmarshalYML$</code>匹配正则表达式。</li>
<li>第 5 行，表示开始运行名叫 <code>TestUnmarshalYML</code> 的测试用例。</li>
<li>第 6 行，表示已经运行完 <code>TestUnmarshalYML</code> 的测试用例，PASS 表示测试成功。</li>
</ul>
<p><code>-run</code>跟随的测试用例的名称支持正则表达式，使用<code>-run TestUnmarshalYML$</code>即可只执行 <code>TestUnmarshalYML</code> 测试用例，如果不带最后的<code>$</code>，则执行所有以<code>TestUnmarshalYML</code>为开头的测试用例。</p>
<h3 id="标记单元测试结果"><a href="#标记单元测试结果" class="headerlink" title="标记单元测试结果"></a>标记单元测试结果</h3><p>当需要终止当前测试用例时，可以使用 <code>t.FailNow()</code>。</p>
<p>还有一种只标记错误不终止测试的方法 <code>t.Fail()</code> ，调用 Fail() 后测试结果标记为失败，但是后续代码依然会被程序执行。</p>
<h3 id="单元测试日志"><a href="#单元测试日志" class="headerlink" title="单元测试日志"></a>单元测试日志</h3><p>每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。</p>
<div align="center">
  单元测试框架提供的日志方法<table>
    <thead>
      <tr></tr>
    </thead>
    <thead>
      <tr>
        <th align="center">方法</th>
        <th align="center">备注</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td align="center"><strong>Log</strong></td>
        <td align="center">打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Logf</strong></td>
        <td align="center">格式化打印日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Error</strong></td>
        <td align="center">打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Errorf</strong></td>
        <td align="center">格式化打印错误日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatal</strong></td>
        <td align="center">打印致命日志，同时结束测试</td>
      </tr>
      <tr>
        <td align="center"><strong>Fatalf</strong></td>
        <td align="center">格式化打印致命日志，同时结束测试</td>
      </tr>
    </tbody>
  </table>
</div>

<p>开发者可以根据实际需要选择合适的日志。</p>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>go test -v -bench=. benchmark_test.go</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.341 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.977s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的-bench=.表示运行 <code>benchmark_test.go</code> 文件里的所有基准测试，和单元测试中的<code>-run</code>类似。</li>
<li>第 5 行中显示基准测试名称，1000000000 表示测试的次数，也就是 <code>testing.B</code> 结构中提供给程序使用的 N。<code>0.341 ns/op</code> 表示每一个操作耗费多少时间（纳秒）。</li>
</ul>
<p>注意：<code>Windows</code> 下使用 <code>go test</code> 命令行时，<code>-bench=.</code> 应写为 <code>-bench="."</code>。</p>
<h3 id="基准测试原理"><a href="#基准测试原理" class="headerlink" title="基准测试原理"></a>基准测试原理</h3><p>基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。</p>
<h3 id="自定义测试时间"><a href="#自定义测试时间" class="headerlink" title="自定义测试时间"></a>自定义测试时间</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. -benchtime=5s benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.351 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.902s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="测试内存"><a href="#测试内存" class="headerlink" title="测试内存"></a>测试内存</h3><p>基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Alloc(b *testing.B) {</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        fmt.Sprintf("%d", i)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在命令行中添加-benchmem参数以显示内存分配情况，参见下面的指令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=Alloc -benchmem benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Alloc</span><br><span class="line">Benchmark_Alloc-4        8610186               120 ns/op              16 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.760s</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行的代码中-bench后添加了 <code>Alloc</code>，指定只测试 <code>Benchmark_Alloc()</code> 函数。</li>
<li>第 5 行代码的 <code>16 B/op</code>表示每一次调用需要分配 <code>16</code> 个字节，<code>2 allocs/op</code> 表示每一次调用有两次分配。</li>
</ul>
<p>开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。</p>
<h3 id="控制计时器"><a href="#控制计时器" class="headerlink" title="控制计时器"></a>控制计时器</h3><p>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。</p>
<p>基准测试中的计时器控制<br></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Benchmark_Add_TimerControl(b *testing.B) {</span><br><span class="line">	// 重置计时器</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	// 停止计时器</span><br><span class="line">	b.StopTimer()</span><br><span class="line">	// 开始计时器</span><br><span class="line">	b.StartTimer()</span><br><span class="line">	var n int</span><br><span class="line">	for i := 0; i &lt; b.N; i++ {</span><br><span class="line">		n++</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从 <code>Benchmark()</code> 函数开始，<code>Timer</code> 就开始计数。<code>StopTimer()</code> 可以停止这个计数过程，做一些耗时的操作，通过 <code>StartTimer()</code> 重新开始计时。<code>ResetTimer()</code> 可以重置计数器的数据。</p>
<p>计数器内部不仅包含耗时数据，还包括内存分配的数据。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go test</tag>
        <tag>单元测试</tag>
        <tag>基准测试</tag>
      </tags>
  </entry>
  <entry>
    <title>go dubbo</title>
    <url>/posts/3498a470/</url>
    <content><![CDATA[<p>go语言使用dubbo-go接入现有的dubbo服务</p>
<h2 id="注册中心使用-zookeeper-，序列化使用-hessian2"><a href="#注册中心使用-zookeeper-，序列化使用-hessian2" class="headerlink" title="注册中心使用 zookeeper ，序列化使用 hessian2"></a>注册中心使用 <code>zookeeper</code> ，序列化使用 <code>hessian2</code></h2><p>目前我司在使用 dubbo 的过程使用的 zookeeper 作为注册中心，序列化是 hessian2 ，所以我们要做如下初始化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "github.com/apache/dubbo-go/common/proxy/proxy_factory"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/protocol"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/filter/impl"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/cluster_impl"</span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/loadbalance"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/zookeeper"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>由于我是接入客户端，所以我这边只需要配置 <code>ConsumerConfig</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    # client</span><br><span class="line">    request_timeout: "3s"</span><br><span class="line">    # connect timeout</span><br><span class="line">    connect_timeout: "3s"</span><br><span class="line">    check: true</span><br><span class="line">    application:</span><br><span class="line">        organization: "wssjdi.com"</span><br><span class="line">        name: "soa.sso.ITokenService"</span><br><span class="line">        module: "dubbogo token service client"</span><br><span class="line">        version: "1.0.0"</span><br><span class="line">        owner: "wssjdi"</span><br><span class="line">    registries:</span><br><span class="line">        "localzk":</span><br><span class="line">            protocol: "zookeeper"</span><br><span class="line">            timeout: "3s"</span><br><span class="line">            address: "10.100.156.17:2181"</span><br><span class="line">            username: ""</span><br><span class="line">            password: ""</span><br><span class="line">    references:</span><br><span class="line">        "ITokenService":</span><br><span class="line">            registry: "localzk"</span><br><span class="line">            protocol: "dubbo"</span><br><span class="line">            interface: "com.wssjdi.soa.sso.ITokenService"</span><br><span class="line">            version: "1.0.0"</span><br><span class="line">            methods:</span><br><span class="line">                - name: "validate"</span><br><span class="line">            retries: "3"</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>go dubbo</tag>
        <tag>dubbo</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>go 语言基础</title>
    <url>/posts/f628ea56/</url>
    <content><![CDATA[<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p><code>Go</code>语言是静态类型语言，因此变量<code>（variable）</code>是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。</p>
<p>声明变量的一般形式是使用 <code>var</code> 关键字：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name type</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>var</code> 是声明变量的关键字，<code>name</code> 是变量名，<code>type</code> 是变量的类型。</p>
<p>需要注意的是，<code>Go</code>语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b</code>; 。其中只有 <code>a</code> 是指针而 <code>b</code> 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 <code>Go</code> 中，则可以和轻松地将它们都声明为指针类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b *int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Go语言的基本类型有：</p>
<ul>
<li>bool</li>
<li>string</li>
<li>int、int8、int16、int32、int64</li>
<li>uint、uint8、uint16、uint32、uint64、uintptr</li>
<li>byte // uint8 的别名</li>
<li>rune // int32 的别名 代表一个 Unicode 码</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
</ul>
<p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code> 等。所有的内存在 <code>Go</code> 中都是经过初始化的。</p>
<p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code> 。</p>
<p>变量的声明有几种形式，通过下面几节进行整理归纳。</p>
<h3 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></tbody></table></figure>
<p>变量声明以关键字 var 开头，后置变量类型，行尾无须分号。</p>
<h3 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h3><p>觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">    c []float32</span><br><span class="line">    d func() bool</span><br><span class="line">    e struct {</span><br><span class="line">        x int</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>使用关键字 var 和括号，可以将一组变量定义放在一起。</p>
<h3 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h3><p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，简短模式<code>（short variable declaration）</code>有以下限制：</p>
<ul>
<li>定义变量，同时显式初始化。</li>
<li>不能提供数据类型。</li>
<li>只能用在函数内部。</li>
</ul>
<p>和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i, j := 0, 1</span><br></pre></td></tr></tbody></table></figure>
<p>演示简短格式变量声明的基本样式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">   x:=100</span><br><span class="line">   a,s:=1, "abc"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。<code>var</code> 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p>
<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p><code>Go</code>语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p>
<ul>
<li>整型和浮点型变量的默认值为 <code>0</code> 和 <code>0.0</code>。</li>
<li>字符串变量的默认值为空字符串。</li>
<li>布尔型变量默认为 <code>bool</code>。</li>
<li>切片、函数、指针变量的默认为 <code>nil</code>。</li>
</ul>
<p>当然，依然可以在变量声明时赋予变量一个初始值。</p>
<p>回顾C语言</p>
<p>在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。</p>
<p>在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/C++ 中变量默认不初始化。</p>
<p>微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。</p>
<p>因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。</p>
<h3 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 类型 = 表达式</span><br></pre></td></tr></tbody></table></figure>
<p>例如，游戏中，玩家的血量初始值为100。可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp int = 100</span><br></pre></td></tr></tbody></table></figure>
<p>这句代码中，<code>hp</code> 为变量名，类型为 <code>int</code>，<code>hp</code> 的初始值为 <code>100</code>。</p>
<p>上面代码中，<code>100</code> 和 <code>int</code> 同为 <code>int</code> 类型，<code>int</code> 可以认为是冗余信息，因此可以进一步简化初始化的写法。</p>
<h3 id="编译器推导类型的格式"><a href="#编译器推导类型的格式" class="headerlink" title="编译器推导类型的格式"></a>编译器推导类型的格式</h3><p>在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var hp = 100</span><br></pre></td></tr></tbody></table></figure>
<p>等号右边的部分在编译原理里被称做右值（rvalue）。</p>
<p>编译器根据右值推导变量类型完成初始化的例子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var attack = 40</span><br><span class="line">var defence = 20</span><br><span class="line">var damageRate float32 = 0.17</span><br><span class="line">var damage = float32(attack-defence) * damageRate</span><br><span class="line">fmt.Println(damage)</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 和 <code>2</code> 行，右值为整型，<code>attack</code> 和 <code>defence</code> 变量的类型为 int。</li>
<li>第 <code>3</code> 行，表达式的右值中使用了 <code>0.17</code>。由于<code>Go</code>语言和<code>C</code>语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 <code>damageRate</code> 变量的类型，<code>Go</code>语言编译器会将 <code>damageRate</code> 类型推导为 <code>float64</code>，我们这里不需要 <code>float64</code> 的精度，所以需要强制指定类型为 <code>float32</code>。</li>
<li><p>第 <code>4</code> 行，将 <code>attack</code> 和 <code>defence</code> 相减后的数值结果依然为整型，使用 <code>float32()</code> 将结果转换为 <code>float32</code> 类型，再与 <code>float32</code> 类型的 <code>damageRate</code> 相乘后，<code>damage</code> 类型也是 <code>float32</code> 类型。</p>
<p><strong><em>提示：<code>damage</code> 变量的右值是一个复杂的表达式，整个过程既有 <code>attack</code> 和 <code>defence</code> 的运算还有强制类型转换。</em></strong></p>
</li>
<li><p>第 5 行，输出 <code>damage</code> 的值。</p>
</li>
</ul>
<p>以上代码输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p><code>var</code> 的变量声明还有一种更为精简的写法，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hp := 100</span><br></pre></td></tr></tbody></table></figure>
<p>这是<code>Go</code>语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。</p>
<p><strong><em>注意：由于使用了<code>:=</code>，而不是赋值的<code>=</code>，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。</em></strong></p>
<p>如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明 hp 变量</span><br><span class="line">var hp int</span><br><span class="line">// 再次声明并赋值</span><br><span class="line">hp := 10</span><br></pre></td></tr></tbody></table></figure>
<p>编译报错:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">no new variables on left side of :=</span><br></pre></td></tr></tbody></table></figure>
<p>翻译过来是在<code>:=</code>的左边没有新变量出现，意思就是<code>:=</code>的左边变量已经被声明了。</p>
<p>短变量声明的形式在开发中的例子较多，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp","127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p><code>net.Dial</code> 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象<code>（conn）</code>，一个是错误对象<code>（err）</code>。如果是标准格式将会变成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var conn net.Conn</span><br><span class="line">var err error</span><br><span class="line">conn, err = net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>因此，短变量声明并初始化的格式在开发中使用比较普遍。</p>
<p><strong><em>注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">conn, err := net.Dial("tcp", "127.0.0.1:8080")</span><br><span class="line">conn2, err := net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码片段，编译器不会报 err 重复定义</p>
<h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h2><p>编程最简单的算法之一，莫过于变量交换。交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">var t int</span><br><span class="line">t = a</span><br><span class="line">a = b</span><br><span class="line">b = t</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>这样的算法很多，但是都有一定的数值范围和类型要求。</p>
<p>到了<code>Go</code>语言时，内存不再是紧缺资源，而且写法可以更简单。使用 <code>Go</code> 的“多重赋值”特性，可以轻松完成变量交换的任务：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">b, a = a, b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure>
<p>多重赋值时，变量的左值和右值按从左到右的顺序赋值。</p>
<p>多重赋值在<code>Go</code>语言的错误处理和函数返回值中会大量地使用。例如使用<code>Go</code>语言进行排序时就需要使用交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，将 <code>IntSlice</code> 声明为 <code>[]int</code> 类型。</li>
<li>第 <code>3</code> 行，为 <code>IntSlice</code> 类型编写一个 <code>Len</code> 方法，提供切片的长度。</li>
<li>第 <code>4</code> 行，根据提供的 <code>i、j</code> 元素索引，获取元素后进行比较，返回比较结果。</li>
<li>第 <code>5</code> 行，根据提供的 <code>i、j</code> 元素索引，交换两个元素的值。</li>
</ul>
<h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。</p>
<p>匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func GetData() (int, int) {</span><br><span class="line">    return 100, 200</span><br><span class="line">}</span><br><span class="line">func main(){</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100 200</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行<code>GetData()</code> 是一个函数，拥有两个整型返回值。每次调用将会返回 <code>100</code> 和 <code>200</code> 两个数值。</li>
<li>第 <code>5</code> 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。</li>
<li>第 <code>6</code> 行将第一个返回值的变量设为匿名变量。</li>
</ul>
<p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<p>提示：在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。</p>
<p>了解变量的作用域对我们学习<code>Go</code>语言来说是比较重要的，因为<code>Go</code>语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。</p>
<p>根据变量定义位置的不同，可以分为以下三个类型：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<p>下面就来分别介绍一下。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。</p>
<p>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。</p>
<p>【示例】下面的 <code>main()</code> 函数中使用到了局部变量 <code>a、b、c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量 a 和 b 并赋值</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    //声明局部变量 c 并计算 a 和 b 的和</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用<code>import</code>关键字引入全局变量所在的源文件之后才能使用这个全局变量。</p>
<p>全局变量声明必须以 <code>var</code> 关键字开头，<strong><em>如果想要在外部包中使用全局变量的首字母必须大写</em></strong>。</p>
<p>【示例】下面代码中，第 <code>4</code> 行定义了全局变量 <code>c</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var c int</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a, b int</span><br><span class="line">    //初始化参数</span><br><span class="line">    a = 3</span><br><span class="line">    b = 4</span><br><span class="line">    c = a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，<strong><em>但是函数体内的局部变量会被优先考虑</em></strong>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a int = 3</span><br><span class="line">    fmt.Printf("a = %d\n", a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = 3</span><br></pre></td></tr></tbody></table></figure>
<h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p>
<p>形式参数会作为函数的局部变量来使用。</p>
<p>【示例】下面代码中第 <code>16</code> 行定义了形式参数 <code>a</code> 和 <code>b</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">//全局变量 a</span><br><span class="line">var a int = 13</span><br><span class="line">func main() {</span><br><span class="line">    //局部变量 a 和 b</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    fmt.Printf("main() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("main() 函数中 b = %d\n", b)</span><br><span class="line">    c := sum(a, b)</span><br><span class="line">    fmt.Printf("main() 函数中 c = %d\n", c)</span><br><span class="line">}</span><br><span class="line">func sum(a, b int) int {</span><br><span class="line">    fmt.Printf("sum() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("sum() 函数中 b = %d\n", b)</span><br><span class="line">    num := a + b</span><br><span class="line">    return num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">main() 函数中 a = 3</span><br><span class="line">main() 函数中 b = 4</span><br><span class="line">sum() 函数中 a = 3</span><br><span class="line">sum() 函数中 b = 4</span><br><span class="line">main() 函数中 c = 7</span><br></pre></td></tr></tbody></table></figure>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 <code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。</p>
<p><code>Go</code>语言同时提供了有符号和无符号的整数类型，其中包括 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 四种大小截然不同的有符号整数类型，分别对应 <code>8</code>、<code>16</code>、<code>32</code>、<code>64 bit</code>（二进制位）大小的有符号整数，与此对应的是 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 四种无符号整数类型。</p>
<p>此外还有两种整数类型 <code>int</code> 和 <code>uint</code>，它们分别对应特定 <code>CPU</code> 平台的字长（机器字大小），其中 <code>int</code> 表示有符号整数，应用最为广泛，<code>uint</code> 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，<code>int</code> 和 <code>uint</code> 所能表示的整数大小会在 <code>32bit</code> 或 <code>64bit</code> 之间变化。</p>
<p>大多数情况下，我们只需要 <code>int</code> 一种整型即可，它可以用于循环计数器（<code>for</code> 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 <code>int</code> 类型的处理速度也是最快的。</p>
<p>用来表示 <code>Unicode</code> 字符的 <code>rune</code> 类型和 <code>int32</code> 类型是等价的，通常用于表示一个 <code>Unicode</code> 码点。这两个名称可以互换使用。同样，<code>byte</code> 和 <code>uint8</code> 也是等价类型，<code>byte</code> 类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>
<p>最后，还有一种无符号的整数类型 <code>uintptr</code>，它没有指定具体的 <code>bit</code> 大小但是足以容纳指针。<code>uintptr</code> 类型只有在底层编程时才需要，特别是<code>Go</code>语言和<code>C</code>语言函数库或操作系统接口相交互的地方。</p>
<p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，比如 <code>int</code> 和 <code>int32</code>，虽然 <code>int</code> 类型的大小也可能是 <code>32 bit</code>，但是在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换，反之亦然。</p>
<p><code>Go</code>语言中有符号整数采用 <code>2</code> 的补码形式表示，也就是最高 <code>bit</code> 位用来表示符号位，一个 <code>n-bit</code> 的有符号数的取值范围是从 <code>-2(n-1)</code> 到 <code>2(n-1)-1</code>。无符号整数的所有 <code>bit</code> 位都用于表示非负数，取值范围是 <code>0</code> 到 <code>2n-1</code>。例如，<code>int8</code> 类型整数的取值范围是从 <code>-128</code> 到 <code>127</code>，而 <code>uint8</code> 类型整数的取值范围是从 <code>0</code> 到 <code>255</code>。</p>
<h3 id="哪些情况下使用-int-和-uint"><a href="#哪些情况下使用-int-和-uint" class="headerlink" title="哪些情况下使用 int 和 uint"></a>哪些情况下使用 <code>int</code> 和 <code>uint</code></h3><p>程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 <code>map</code> 的元素数量等都可以用 int 来表示。</p>
<p>反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 <code>int</code> 和 <code>uint</code>。</p>
<h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p><code>Go</code>语言提供了两种精度的浮点数 <code>float32</code> 和 <code>float64</code>，它们的算术规范由 <code>IEEE754</code> 浮点数国际标准定义，该浮点数规范被所有现代的 <code>CPU</code> 支持。</p>
<p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 <code>math</code> 包中找到：</p>
<ul>
<li>常量 <code>math.MaxFloat32</code> 表示 <code>float32</code> 能取到的最大数值，大约是 <code>3.4e38</code>；</li>
<li>常量 <code>math.MaxFloat64</code> 表示 <code>float64</code> 能取到的最大数值，大约是 <code>1.8e308</code>；</li>
<li><code>float32</code> 和 <code>float64</code> 能表示的最小值分别为 <code>1.4e-45</code> 和 <code>4.9e-324</code>。</li>
</ul>
<p>一个 <code>float32</code> 类型的浮点数可以提供大约 <code>6</code> 个十进制数的精度，而 <code>float64</code> 则可以提供约 <code>15</code> 个十进制数的精度，通常应该优先使用 <code>float64</code> 类型，因为 <code>float32</code> 类型的累计计算误差很容易扩散，并且 <code>float32</code> 能精确表示的正整数并不是很大。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var f float32 = 16777216 // 1 &lt;&lt; 24</span><br><span class="line">fmt.Println(f == f+1)    // "true"!</span><br></pre></td></tr></tbody></table></figure>
<p>浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const e = .71828 // 0.71828</span><br><span class="line">const f = 1.     // 1</span><br></pre></td></tr></tbody></table></figure>
<p>很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：</p>
<figure class="highlight plain"><figcaption><span>e 或 E 来指定指数部分</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数</span><br><span class="line">const Planck   = 6.62606957e-34 // 普朗克常数</span><br></pre></td></tr></tbody></table></figure>
<p>用 Printf 函数打印浮点数时可以使用<code>%f</code>来控制保留几位小数:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%f\n", math.Pi)</span><br><span class="line">    fmt.Printf("%.2f\n", math.Pi)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.141593</span><br><span class="line">3.14</span><br></pre></td></tr></tbody></table></figure>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>在计算机中，复数是由两个浮点数表示的，其中一个表示实部<code>（real）</code>，一个表示虚部<code>（imag）</code>。</p>
<p><code>Go</code>语言中复数的类型有两种，分别是  <code>complex128（64 位实数和虚数）</code> 和 <code>complex64（32 位实数和虚数）</code>，其中 <code>complex128</code> 为复数的默认类型。</p>
<p>复数的值由三部分组成 <code>RE</code> + <code>IMi</code>，其中 <code>RE</code> 是实数部分，<code>IM</code> 是虚数部分，<code>RE</code> 和 <code>IM</code> 均为 <code>float</code> 类型，而最后的 <code>i</code> 是虚数单位。</p>
<p>声明复数的语法格式如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name complex128 = complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>name</code> 为复数的变量名，<code>complex128</code> 为复数的类型，<code>=</code> 后面的 <code>complex</code> 为 <code>Go</code> 语言的内置函数用于为复数赋值，<code>x</code> 、<code>y</code> 分别表示构成该复数的两个 <code>float64</code> 类型的数值，<code>x</code> 为实部，<code>y</code> 为虚部。</p>
<p>上面的声明语句也可以简写为下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">name := complex(x, y)</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个复数 <code>z := complex(x, y)</code>，可以通过 <code>Go</code> 语言的内置函数 <code>real(z)</code> 来获得该复数的实部，也就是 <code>x</code> ；通过 <code>imag(z)</code> 获得该复数的虚部，也就是 <code>y</code> 。</p>
<p>【示例】使用内置的 <code>complex</code> 函数构建复数，并使用 <code>real</code> 和 <code>imag</code> 函数返回复数的实部和虚部：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x complex128 = complex(1, 2) // 1+2i</span><br><span class="line">var y complex128 = complex(3, 4) // 3+4i</span><br><span class="line">fmt.Println(x*y)                 // "(-5+10i)"</span><br><span class="line">fmt.Println(real(x*y))           // "-5"</span><br><span class="line">fmt.Println(imag(x*y))           // "10"</span><br></pre></td></tr></tbody></table></figure>
<p>如果大家对复数的运算法则不是很了解，可以查阅<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin">《复数运算法则》</a>，其中详细的讲解了复数的加减乘除操作。</p>
<p>复数也可以用 <code>==</code> 和 <code>!=</code> 进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。</p>
<p><code>Go</code> 语言内置的 <code>math/cmplx</code> 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 <code>complex128</code> 类型，因为这些内置的包中都使用 <code>complex128</code> 类型作为参数。</p>
<h2 id="输出正弦函数-（Sin）-图像"><a href="#输出正弦函数-（Sin）-图像" class="headerlink" title="输出正弦函数 （Sin） 图像"></a>输出正弦函数 <code>（Sin）</code> 图像</h2><p>在 <code>Go</code> 语言中，正弦函数由 <code>math</code> 包提供，函数入口为 <code>math.Sin</code> ，正弦函数的参数为 <code>float64</code> ，返回值也是 <code>float64</code> 。在使用正弦函数时，根据实际精度可以进行转换。</p>
<p><code>Go</code> 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 <code>JPEG</code>、<code>PNG</code>、<code>GIF</code> 等。</p>
<p>首先给出本节完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/png"</span><br><span class="line">    "log"</span><br><span class="line">    "math"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 图片大小</span><br><span class="line">    const size = 300</span><br><span class="line"></span><br><span class="line">    // 根据给定大小创建灰度图</span><br><span class="line">    pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">    // 遍历每个像素</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        for y := 0; y &lt; size; y++ {</span><br><span class="line">            // 填充为白色</span><br><span class="line">            pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 从0到最大像素生成x坐标</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        // 让sin的值的范围在0~2Pi之间</span><br><span class="line">        s := float64(x) * 2 * math.Pi / size</span><br><span class="line">        // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">        y := size/2 - math.Sin(s)*size/2</span><br><span class="line">        // 用黑色绘制sin轨迹</span><br><span class="line">        pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">    }</span><br><span class="line">    // 创建文件</span><br><span class="line">    file, err := os.Create("sin.png")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    // 使用png格式将数据写入文件</span><br><span class="line">    png.Encode(file, pic) //将image信息写入文件中</span><br><span class="line">    // 关闭文件</span><br><span class="line">    file.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="设置图片背景色"><a href="#设置图片背景色" class="headerlink" title="设置图片背景色"></a>设置图片背景色</h3><p>以下是设置图片背景的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 图片大小</span><br><span class="line">const size = 300</span><br><span class="line"></span><br><span class="line">// 根据给定大小创建灰度图</span><br><span class="line">pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">// 遍历每个像素</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line">    for y := 0; y &lt; size; y++ {</span><br><span class="line">        // 填充为白色</span><br><span class="line">        pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，声明一个 <code>size</code> 常量，值为 <code>300</code>。</li>
<li>第 <code>5</code> 行，使用 <code>image</code> 包的 <code>NewGray()</code> 函数创建一个图片对象，使用区域由 <code>image.Rect</code> 结构提供，<code>image.Rect</code> 描述一个方形的两个定位点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> ，<code>image.Rect(0,0,size,size)</code> 表示使用完整灰度图像素，尺寸为宽 <code>300</code>，长 <code>300</code>。</li>
<li>第 <code>8</code> 行和第 <code>9</code> 行，遍历灰度图的所有像素。</li>
<li>第 <code>11</code> 行，将每一个像素的灰度设为 <code>255</code> ，也就是白色。</li>
</ul>
<p>灰度图是一种常见的图片格式，一般情况下颜色由 <code>8</code> 位组成，灰度范围为 <code>0～255</code> ，<code>0</code> 表示黑色，<code>255</code> 表示白色。</p>
<p>初始化好的灰度图默认的灰度值都是 <code>0</code> ，对的是黑色，由于显示效果的效果不是很好，所以这里将所有像素设置为 <code>255</code>，也就是白色。</p>
<h3 id="绘制正弦函数轨迹"><a href="#绘制正弦函数轨迹" class="headerlink" title="绘制正弦函数轨迹"></a>绘制正弦函数轨迹</h3><p>正弦函数是一个周期函数，定义域是实数集，取值范围是 <code>[-1, 1]</code>。用编程的通俗易懂的话来说就是：<code>math.Sin</code> 函数的参数支持任意浮点数范围，函数返回值的范围总是在 <code>-1～1</code> 之间（包含 <code>1</code>、<code>-1</code>）。</p>
<p>要将正弦函数放在图片上需要考虑以下一些因素：</p>
<ul>
<li><code>math.Sin</code> 的返回值在 <code>-1～1</code> 之间，需要考虑将正弦的输出幅度变大，可以将 <code>math.Sin</code> 的返回值乘以一个常量进行放大。</li>
<li>图片的坐标系原点在左上角，而 <code>math.Sin</code> 基于笛卡尔坐标系原点在左下角，需要对图像进行上下翻转和平移。</li>
</ul>
<p>将这些处理逻辑汇总为代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 从0到最大像素生成x坐标</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line"></span><br><span class="line">    // 让sin的值的范围在0~2Pi之间</span><br><span class="line">    s := float64(x) * 2 * math.Pi / size</span><br><span class="line"></span><br><span class="line">    // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">    y := size/2 - math.Sin(s)*size/2</span><br><span class="line"></span><br><span class="line">    // 用黑色绘制sin轨迹</span><br><span class="line">    pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，生成 <code>0</code> 到 <code>size（300）</code> 的 x 坐标轴。</li>
<li><p>第 <code>5</code> 行，计算 <code>math.Sin</code> 的定义域，这段代码等效为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">rate := x / size</span><br><span class="line">s := rate * 2 * math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p><code>x</code> 的范围是 <code>0</code> 到 <code>size</code> ，因此除以 <code>size</code> 后，<code>rate</code> 的范围是 <code>0～1</code> 之间，再乘以 <code>2π</code> 后，<code>s</code> 的范围刚好是 <code>0～2π</code> 之间。</p>
<p><code>float64(x)</code> 表示将整型的 <code>x</code> 变量转换为 <code>float64</code> 类型，之后运算的所有表达式将以 <code>float64</code> 类型进行。</p>
</li>
<li><p>第 <code>8</code> 行中，<code>math.Sin(s)*size/2</code> 表示将正弦函数的返回值幅度从 <code>1</code> 扩大到二分之一的 <code>size</code> 。负号表示将正弦函数图形以图形中心上下翻转。叠加 <code>size/2</code> 表示将图形在 <code>y</code> 轴上向下偏移二分之一的 <code>size</code>（图片坐标系的 <code>y</code> 向下）。</p>
</li>
<li>第 <code>11</code> 行将计算好的 <code>x</code> 轴和 <code>y</code> 轴数据，以灰度为 <code>0</code>（黑色）使用 <code>SetGray()</code> 方法填充到像素中。</li>
</ul>
<p>写入图片的正弦函数图像如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sinImage.png" alt="正弦图片"></p>
<h3 id="写入图片文件"><a href="#写入图片文件" class="headerlink" title="写入图片文件"></a>写入图片文件</h3><p>内存中的正弦函数图形是不可见的，我们选用 <code>PNG</code> 格式将图形输出为文件，<code>Go</code> 语言提供了文件创建函数和 <code>PNG</code> 格式写入函数，代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">file, err := os.Create("sin.png")</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">// 使用PNG格式将数据写入文件</span><br><span class="line">png.Encode(file, pic)  //将image信息写入文件中</span><br><span class="line"></span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行，创建 <code>sin.png</code> 的文件。</li>
<li>第 <code>4</code> 行，如果创建文件失败，返回错误，打印错误并终止。</li>
<li>第 <code>8</code> 行，使用 <code>PNG</code> 包，将图形对象写入文件中。</li>
<li>第 <code>11</code> 行，关闭文件。</li>
</ul>
<h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>一个布尔类型的值只有两种：<code>true</code> 或 <code>false</code>。<code>if</code> 和 <code>for</code> 语句的条件部分都是布尔类型的值，并且 <code>==</code> 和 <code>&lt;</code> 等比较操作也会产生布尔型的值。</p>
<p>一元操作符 <code>!</code> 对应逻辑非操作，因此 <code>!true</code> 的值为 <code>false</code>，更复杂一些的写法是 <code>(!true==false) == true</code>，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 <code>x</code> 来表示 <code>x==true</code> 。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var aVar = 10</span><br><span class="line">aVar == 5  // false</span><br><span class="line">aVar == 10 // true</span><br><span class="line">aVar != 5  // true</span><br><span class="line">aVar != 10 // false</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code>语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口<code>（interface）</code>，那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。</p>
<p>布尔值可以和 <code>&amp;&amp;（AND）</code> 和 <code>||（OR）</code> 操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s != "" &amp;&amp; s[0] == 'x'</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>s[0]</code> 操作如果应用于空字符串将会导致 <code>panic</code> 异常。</p>
<p>因为 <code>&amp;&amp;</code> 的优先级比 <code>||</code> 高（ <code>&amp;&amp;</code> 对应逻辑乘法，<code>||</code> 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if 'a' &lt;= c &amp;&amp; c &lt;= 'z' ||</span><br><span class="line">    'A' &lt;= c &amp;&amp; c &lt;= 'Z' ||</span><br><span class="line">    '0' &lt;= c &amp;&amp; c &lt;= '9' {</span><br><span class="line">    // ...ASCII字母或数字...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>布尔值并不会隐式转换为数字值 <code>0</code> 或 <code>1</code>，反之亦然，必须使用 <code>if</code> 语句显式的进行转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">if b {</span><br><span class="line">    i = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 如果b为真，btoi返回1；如果为假，btoi返回0</span><br><span class="line">func btoi(b bool) int {</span><br><span class="line">    if b {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line">    return 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// itob报告是否为非零。</span><br><span class="line">func itob(i int) bool { return i != 0 }</span><br></pre></td></tr></tbody></table></figure>
<p><code>Go</code> 语言中不允许将整型强制转换为布尔型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var n bool</span><br><span class="line">fmt.Println(int(n) * 2)</span><br></pre></td></tr></tbody></table></figure>
<p>编译错误，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot convert n (type bool) to type int</span><br></pre></td></tr></tbody></table></figure>
<p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 <code>UTF-8</code> 字符的一个序列（当字符为 <code>ASCII</code> 码表上的字符时则占用 <code>1</code> 个字节，其它字符根据需要占用 <code>2-4</code> 个字节）。</p>
<p><code>UTF-8</code> 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 <code>XML</code> 和 <code>JSON</code> 在内也都使用该编码。由于该编码对占用字节长度的不定性，在 <code>Go</code> 语言中字符串也可能根据需要占用 <code>1</code> 至 <code>4</code> 个字节，这与其它编程语言如 <code>C++</code> 、<code>Java</code> 或者 <code>Python</code> 不同（<code>Java</code> 始终使用 <code>2</code> 个字节）。<code>Go</code> 语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 <code>UTF-8</code> 字符集的文本进行编码和解码。</p>
<p>字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。</p>
<h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>可以使用双引号 <code>""</code> 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p>
<ul>
<li>\n：换行符</li>
<li>\r：回车符</li>
<li>\t：tab 键</li>
<li>\u 或 \U：Unicode 字符</li>
<li>\：反斜杠自身</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var str = "Hello\nGo World~!"</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Go World~!</span><br></pre></td></tr></tbody></table></figure>
<p>一般的比较运算符 <code>（==、!=、&lt;、&lt;=、&gt;=、&gt;）</code> 是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 <code>len()</code> 来获取，例如 <code>len(str)</code>。</p>
<p>字符串的内容（纯字节）可以通过标准索引法来获取，在方括号 <code>[ ]</code> 内写入索引，索引从 <code>0</code> 开始计数：</p>
<ul>
<li>字符串 <code>str</code> 的第 <code>1</code> 个字节：<code>str[0]</code></li>
<li>第 <code>i</code> 个字节：<code>str[i - 1]</code></li>
<li>最后 <code>1</code> 个字节：<code>str[len(str)-1]</code></li>
</ul>
<p>需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。</p>
<p><strong><em>注意：获取字符串中某个字节的地址属于非法行为，例如 <code>&amp;str[i]</code>。</em></strong></p>
<h3 id="字符串拼接符"><a href="#字符串拼接符" class="headerlink" title="字符串拼接符 +"></a>字符串拼接符 <code>+</code></h3><p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。将 <code>s2</code> 追加到 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p>
<p>可以通过下面的方式来对代码中多行的字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := "Beginning of the string " +</span><br><span class="line">"second part of the string"</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号 <code>+</code> 必须放在第一行末尾。</em></strong></p>
<p>也可以使用 <code>+=</code> 来对字符串进行拼接：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">s := "hel" + "lo,"</span><br><span class="line">s += "world!"</span><br><span class="line">fmt.Println(s) //输出 “hello, world!”</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串实现基于-UTF-8-编码"><a href="#字符串实现基于-UTF-8-编码" class="headerlink" title="字符串实现基于 UTF-8 编码"></a>字符串实现基于 <code>UTF-8</code> 编码</h3><p><code>Go</code> 语言中字符串的内部实现使用 <code>UTF-8</code> 编码，通过 <code>rune</code> 类型，可以方便地对每个 <code>UTF-8</code> 字符进行访问。当然，<code>Go</code> 语言也支持按照传统的 <code>ASCII</code> 码方式逐字符进行访问。</p>
<p>关于字符串的 <code>UTF-8</code> 字符访问的详细方法，后面的章节将会详细介绍。</p>
<h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在 <code>Go</code> 语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量<code>（string literal）</code> ，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用 ` 反引号，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const str = `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br><span class="line">`</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br></pre></td></tr></tbody></table></figure>
<p>反引号`，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p>
<p>在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<p>多行字符串一般用于内嵌源码和内嵌数据等，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const codeTemplate = `// Generated by github.com/davyxu/cellnet/</span><br><span class="line">protoc-gen-msg</span><br><span class="line">// DO NOT EDIT!{{range .Protos}}</span><br><span class="line">// Source: {{.Name}}{{end}}</span><br><span class="line">package {{.PackageName}}</span><br><span class="line">{{if gt .TotalMessages 0}}</span><br><span class="line">import (</span><br><span class="line">    "github.com/davyxu/cellnet"</span><br><span class="line">    "reflect"</span><br><span class="line">    _ "github.com/davyxu/cellnet/codec/pb"</span><br><span class="line">)</span><br><span class="line">{{end}}</span><br><span class="line">func init() {</span><br><span class="line">    {{range .Protos}}</span><br><span class="line">    // {{.Name}}{{range .Messages}}</span><br><span class="line">    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}</span><br><span class="line">    {{end}}</span><br><span class="line">}</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码只定义了一个常量 codeTemplate，类型为字符串，使用`定义，字符串的内容为一段代码生成中使用到的 Go 源码格式。</p>
<p>在 ` 间的所有代码均不会被编译器识别，而只是作为字符串的一部分。</p>
<p>字符串类型在业务中的应用可以说是最广泛的，读者需要详细了解字符串的常见用法，请猛击下面的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/36.html">Go语言计算字符串长度——len()和RuneCountInString()</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/37.html">Go语言遍历字符串——获取每一个字符串元素</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/38.html">Go语言字符串截取（获取字符串的某一段字符）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/39.html">Go语言修改字符串</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/40.html">Go语言字符串拼接（连接）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/41.html">Go语言fmt.Sprintf（格式化输出）</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/42.html">Go语言Base64编码——电子邮件的基础编码格式</a></li>
</ul>
<h2 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h2><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p>
<p>Go语言的字符有以下两种：</p>
<ul>
<li>一种是 <code>uint8</code> 类型，或者叫 <code>byte</code> 型，代表了 <code>ASCII</code> 码的一个字符。</li>
<li>另一种是 <code>rune</code> 类型，代表一个 <code>UTF-8</code> 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 <code>rune</code> 类型。<code>rune</code> 类型等价于 int32 类型。</li>
</ul>
<p><code>byte</code> 类型是 <code>uint8</code> 的别名，对于只占用 <code>1</code> 个字节的传统 <code>ASCII</code> 编码的字符来说，完全没有问题，例如 <code>var ch byte = 'A'</code>，字符使用单引号括起来。</p>
<p>在 <code>ASCII</code> 码表中，<code>A</code> 的值是 <code>65</code>，使用 <code>16</code> 进制表示则为 <code>41</code>，所以下面的写法是等效的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）</span><br></pre></td></tr></tbody></table></figure>
<p>另外一种可能的写法是 <code>\</code> 后面紧跟着长度为 <code>3</code> 的八进制数，例如 \377。</p>
<p><code>Go</code>语言同样支持 <code>Unicode（UTF-8）</code>，因此字符同样称为 <code>Unicode</code> 代码点或者 <code>runes</code> ，并在内存中使用 <code>int</code> 来表示。在文档中，一般使用格式 <code>U+hhhh</code> 来表示，其中 <code>h</code> 表示一个 <code>16</code> 进制数。</p>
<p>在书写 <code>Unicode</code> 字符时，需要在 <code>16</code> 进制数之前加上前缀 <code>\u</code> 或者 <code>\U</code> 。因为 <code>Unicode</code> 至少占用 <code>2</code> 个字节，所以我们使用 <code>int16</code> 或者 <code>int</code> 类型来表示。如果需要使用到 <code>4</code> 字节，则使用 <code>\u</code> 前缀，如果需要使用到 <code>8</code> 个字节，则使用 <code>\U</code> 前缀。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ch int = '\u0041'</span><br><span class="line">var ch2 int = '\u03B2'</span><br><span class="line">var ch3 int = '\U00101234'</span><br><span class="line">fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer</span><br><span class="line">fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character</span><br><span class="line">fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes</span><br><span class="line">fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">65 - 946 - 1053236</span><br><span class="line">A - β - r</span><br><span class="line">41 - 3B2 - 101234</span><br><span class="line">U+0041 - U+03B2 - U+101234</span><br></pre></td></tr></tbody></table></figure>
<p>格式化说明符 <code>%c</code> 用于表示字符，当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数，<code>%U</code> 输出格式为 <code>U+hhhh</code> 的字符串。</p>
<p><code>Unicode</code> 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 <code>ch</code> 代表字符）：</p>
<ul>
<li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li>
<li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li>
<li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li>
</ul>
<h3 id="UTF-8-和-Unicode-有何区别"><a href="#UTF-8-和-Unicode-有何区别" class="headerlink" title="UTF-8 和 Unicode 有何区别"></a>UTF-8 和 Unicode 有何区别</h3><p><code>Unicode</code> 与 <code>ASCII</code> 类似，都是一种字符集。</p>
<p>字符集为每个字符分配一个唯一的 <code>ID</code>，我们使用到的所有字符在 <code>Unicode</code> 字符集中都有一个唯一的 <code>ID</code>，例如上面例子中的 <code>a</code> 在 <code>Unicode</code> 与 <code>ASCII</code> 中的编码都是 <code>97</code>。汉字 <code>你</code> 在 <code>Unicode</code> 中的编码为 <code>20320</code>，在不同国家的字符集中，字符所对应的 <code>ID</code> 也会不同。而无论任何情况下，<code>Unicode</code> 中的字符的 <code>ID</code> 都是不会变化的。</p>
<p><code>UTF-8</code> 是编码规则，将 <code>Unicode</code> 中字符的 <code>ID</code> 以某种方式进行编码，<code>UTF-8</code> 的是一种变长编码规则，从 <code>1</code> 到 <code>4</code> 个字节不等。编码规则如下：</p>
<ul>
<li><code>0xxxxxx</code> 表示文字符号 <code>0～127</code>，兼容 <code>ASCII</code> 字符集。</li>
<li>从 <code>128</code> 到 <code>0x10ffff</code> 表示其他字符。</li>
</ul>
<p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 <code>3</code> 个字节。</p>
<p>广义的 <code>Unicode</code> 指的是一个标准，它定义了字符集及编码规则，即 <code>Unicode</code> 字符集和 <code>UTF-8</code>、<code>UTF-16</code> 编码等。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 <code>Go</code> 语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></tbody></table></figure>
<p>类型 <code>B</code> 的值 = 类型 <code>B</code> (类型 <code>A</code> 的值)</p>
<p>示例:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></tbody></table></figure>
<p>类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 <code>int16</code> 转换为 <code>int32</code>）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 <code>int32</code> 转换为 <code>int16</code> 或将 <code>float32</code> 转换为 <code>int</code> ），会发生精度丢失（截断）的情况。</p>
<p>只有相同底层类型的变量之间可以进行相互转换（如将 <code>int16</code> 类型转换成 <code>int32</code> 类型），不同底层类型的变量相互转换时会引发编译错误（如将 <code>boo</code>l 类型转换为 <code>int</code> 类型）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        "fmt"</span><br><span class="line">        "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">        // 输出各数值范围</span><br><span class="line">        fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)</span><br><span class="line">        fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)</span><br><span class="line">        fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)</span><br><span class="line">        fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)</span><br><span class="line"></span><br><span class="line">        // 初始化一个32位整型值</span><br><span class="line">        var a int32 = 1047483647</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int32: 0x%x %d\n", a, a)</span><br><span class="line"></span><br><span class="line">        // 将a变量数值转换为十六进制, 发生数值截断</span><br><span class="line">        b := int16(a)</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int16: 0x%x %d\n", b, b)</span><br><span class="line"></span><br><span class="line">        // 将常量保存为float32类型</span><br><span class="line">        var c float32 = math.Pi</span><br><span class="line">        // 转换为int类型, 浮点发生精度丢失</span><br><span class="line">        fmt.Println(int(c))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>11～14 行</code>，输出几个常见整型类型的数值范围。</li>
<li>第 <code>17</code> 行，声明 <code>int32</code> 类型的变量 <code>a</code> 并初始化。</li>
<li>第 <code>19</code> 行，使用 <code>fmt.Printf</code> 的 <code>%x</code> 动词将数值以十六进制格式输出，这一行输出 <code>a</code> 在转换前的 <code>32</code> 位的值。</li>
<li>第 <code>22</code> 行，将 <code>a</code> 的值转换为 <code>int16</code> 类型，也就是从 <code>32</code> 位有符号整型转换为 <code>16</code> 位有符号整型，由于 <code>int16</code> 类型的取值范围比 <code>int32</code> 类型的取值范围小，因此数值会进行截断（精度丢失）。</li>
<li>第 <code>24</code> 行，输出转换后的 <code>a</code> 变量值，也就是 <code>b</code> 的值，同样以十六进制和十进制两种方式进行打印。</li>
<li>第 <code>27</code> 行，<code>math.Pi</code> 是 <code>math</code> 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 <code>math.Pi</code> 被赋值到变量 <code>c</code> 中，因此类型为 <code>float32</code>。</li>
<li>第 <code>29</code> 行，将 <code>float32</code> 转换为 <code>int</code> 类型并输出。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int8 range: -128 127</span><br><span class="line">int16 range: -32768 32767</span><br><span class="line">int32 range: -2147483648 2147483647</span><br><span class="line">int64 range: -9223372036854775808 9223372036854775807</span><br><span class="line">int32: 0x3e6f54ff 1047483647</span><br><span class="line">int16: 0x54ff 21759</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>根据输出结果，<code>16</code> 位有符号整型的范围是 <code>-32768～32767</code>，而变量 <code>a</code> 的值 <code>1047483647</code> 不在这个范围内。<code>1047483647</code> 对应的十六进制为 <code>0x3e6f54ff</code>，转为 <code>int16</code> 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 <code>0x54ff</code>，对应的十进制值为 <code>21759</code>。</p>
<p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 <code>Java</code> 和 <code>.NET</code> 等编程语言不同，<code>Go</code> 语言为程序员提供了控制数据结构指针的能力，<strong>但是，并不能进行指针运算</strong>。<code>Go</code> 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p>
<p>指针 <code>（pointer）</code> 在 <code>Go</code> 语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。</li>
</ul>
<p>受益于这样的约束和拆分，<code>Go</code> 语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p>
<p>切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p>
<p><code>C/C++</code> 中的指针</p>
<p>说到 <code>C/C++</code> 中的指针，会让许多人“谈虎色变”，尤其是对指针的偏移、运算和转换。</p>
<p>其实，指针是 <code>C/C++</code> 语言拥有极高性能的根本所在，在操作大块数据和做偏移时即方便又便捷。因此，操作系统依然使用 <code>C</code> 语言及指针的特性进行编写。</p>
<p><code>C/C++</code> 中指针饱受诟病的根本原因是指针的运算和内存释放，<code>C/C++</code> 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域，我们的计算机操作系统经常需要更新、修复漏洞的本质，就是为解决指针越界访问所导致的“缓冲区溢出”的问题。</p>
<p>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开详细说明。</p>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 <code>32</code> 和 <code>64</code> 位机器上分别占用 <code>4</code> 或 <code>8</code> 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 <code>nil</code>。指针变量通常缩写为 <code>ptr</code> 。</p>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<code>Go</code> 语言中使用在变量名前面添加 <code>&amp;</code> 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr := &amp;v    // v 的类型为 T</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>v</code> 代表被取地址的变量，变量 <code>v</code> 的地址使用变量 <code>ptr</code> 进行接收，<code>ptr</code> 的类型为 <code>*T</code> ，称做 <code>T</code> 的指针类型，<code>*</code> 代表指针。</p>
<p>指针实际用法，可以通过下面的例子了解：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var cat int = 1</span><br><span class="line">    var str string = "banana"</span><br><span class="line">    fmt.Printf("%p %p", &amp;cat, &amp;str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，声明整型变量 <code>cat</code> 。</li>
<li>第 <code>9</code> 行，声明字符串变量 <code>str</code> 。</li>
<li>第 <code>10</code> 行，使用 <code>fmt.Printf</code> 的动词 <code>%p</code> 打印 <code>cat</code> 和 <code>str</code> 变量的内存地址，指针的值是带有 <code>0x</code> 十六进制前缀的一组数据。</li>
</ul>
<p><strong><em>提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</em></strong></p>
<h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>当使用 <code>&amp;</code> 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 <code>*</code> 操作符，也就是指针取值，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个字符串类型</span><br><span class="line">    var house = "Malibu Point 10880, 90265"</span><br><span class="line"></span><br><span class="line">    // 对字符串取地址, ptr类型为*string</span><br><span class="line">    ptr := &amp;house</span><br><span class="line"></span><br><span class="line">    // 打印ptr的类型</span><br><span class="line">    fmt.Printf("ptr type: %T\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf("address: %p\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line"></span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf("value type: %T\n", value)</span><br><span class="line"></span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf("value: %s\n", value)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，准备一个字符串并赋值。</li>
<li>第 <code>13</code> 行，对字符串取地址，将指针保存到变量 <code>ptr</code> 中。</li>
<li>第 <code>16</code> 行，打印变量 <code>ptr</code> 的类型，其类型为 <code>*string</code>。</li>
<li>第 <code>19</code> 行，打印 <code>ptr</code> 的指针地址，地址每次运行都会发生变化。</li>
<li>第 <code>22</code> 行，对 <code>ptr</code> 指针变量进行取值操作，变量 <code>value</code> 的类型为 <code>string</code> 。</li>
<li>第 <code>25</code> 行，打印取值后 <code>value</code> 的类型。</li>
<li>第 <code>28</code> 行，打印 <code>value</code> 的值。</li>
</ul>
<p>取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp;</code> 取出地址，<code>*</code> 根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址操作使用 <code>&amp;</code> 操作符，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值操作使用 <code>*</code> 操作符，可以获得指针变量指向的原变量的值。</li>
</ul>
<h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p>
<p>前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 交换函数</span><br><span class="line">func swap(a, b *int) {</span><br><span class="line"></span><br><span class="line">    // 取a指针的值, 赋给临时变量t</span><br><span class="line">    t := *a</span><br><span class="line"></span><br><span class="line">    // 取b指针的值, 赋给a指针指向的变量</span><br><span class="line">    *a = *b</span><br><span class="line"></span><br><span class="line">    // 将a指针的值赋给b指针指向的变量</span><br><span class="line">    *b = t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备两个变量, 赋值1和2</span><br><span class="line">    x, y := 1, 2</span><br><span class="line"></span><br><span class="line">    // 交换变量值</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line"></span><br><span class="line">    // 输出变量值</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，定义一个交换函数，参数为 <code>a</code> 、<code>b</code>，类型都为 <code>*int</code> 指针类型。</li>
<li>第 <code>9</code> 行，取指针 <code>a</code> 的值，并把值赋给变量 <code>t</code> ，<code>t</code> 此时是 <code>int</code> 类型。</li>
<li>第 <code>12</code> 行，取 <code>b</code> 的指针值，赋给指针 <code>a</code> 指向的变量。注意，此时 <code>*a</code> 的意思不是取 <code>a</code> 指针的值，而是<code>a 指向的变量</code> 。</li>
<li>第 <code>15</code> 行，将 <code>t</code> 的值赋给指针 <code>b</code> 指向的变量。</li>
<li>第 <code>21</code> 行，准备 <code>x</code> 、<code>y</code> 两个变量，分别赋值为 <code>1</code> 和 <code>2</code> ，类型为 <code>int</code> 。</li>
<li>第 <code>24</code> 行，取出 <code>x</code> 和 <code>y</code> 的地址作为参数传给 <code>swap()</code> 函数进行调用。</li>
<li>第 <code>27</code> 行，交换完毕时，输出 <code>x</code> 和 <code>y</code> 的值。</li>
</ul>
<p><code>*</code> 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 <code>a</code> 指针指向的变量。其实归纳起来，<code>*</code> 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p>
<p>如果在 <code>swap()</code> 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) {</span><br><span class="line">    b, a = a, b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    x, y := 1, 2</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>结果表明，交换是不成功的。上面代码中的 <code>swap()</code> 函数交换的是 <code>a</code> 和 <code>b</code> 的地址，在交换完毕后，<code>a</code> 和 <code>b</code> 的变量值确实被交换。但和 <code>a</code> 、<code>b</code> 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p>
<h3 id="示例：使用指针变量获取命令行的输入信息"><a href="#示例：使用指针变量获取命令行的输入信息" class="headerlink" title="示例：使用指针变量获取命令行的输入信息"></a>示例：使用指针变量获取命令行的输入信息</h3><p><code>Go</code> 语言内置的 <code>flag</code> 包实现了对命令行参数的解析，<code>flag</code> 包使得开发命令行工具更为简单。</p>
<p>下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 <code>flag</code> 包的解析后即可获取命令行的数据。</p>
<p>【示例】获取命令行输入：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 导入系统包</span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义命令行参数</span><br><span class="line">var mode = flag.String("mode", "", "process mode")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 解析命令行参数</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // 输出命令行参数</span><br><span class="line">    fmt.Println(*mode)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将这段代码命名为 main.go，然后使用如下命令行运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run main.go --mode=fast</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fast</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>10</code> 行，通过 <code>flag.String</code>，定义一个 <code>mode</code> 变量，这个变量的类型是 <code>*string</code>。后面 <code>3</code> 个参数分别如下：<ul>
<li>参数名称：在命令行输入参数时，使用这个名称。</li>
<li>参数值的默认值：与 <code>flag</code> 所使用的函数创建变量类型对应，<code>String</code> 对应字符串、<code>Int</code> 对应整型、<code>Bool</code> 对应布尔型等。</li>
<li>参数说明：使用 <code>-help</code> 时，会出现在说明中。</li>
</ul>
</li>
<li>第 <code>15</code> 行，解析命令行参数，并将结果写入到变量 <code>mode</code> 中。</li>
<li>第 <code>18</code> 行，打印 <code>mode</code> 指针所指向的变量。</li>
</ul>
<p>由于之前已经使用 <code>flag.String</code> 注册了一个名为 <code>mode</code> 的命令行参数，<code>flag</code> 底层知道怎么解析命令行，并且将值赋给 <code>mode*string</code> 指针，在 <code>Parse</code> 调用完毕后，无须从 <code>flag</code> 获取值，而是通过自己注册的这个 <code>mode</code> 指针获取到最终的值。代码运行流程如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/pstr.jpg" alt="图：命令行参数与变量的关系"></p>
<h3 id="创建指针的另一种方法——-new-函数"><a href="#创建指针的另一种方法——-new-函数" class="headerlink" title="创建指针的另一种方法—— new() 函数"></a>创建指针的另一种方法—— <code>new()</code> 函数</h3><p><code>Go</code> 语言还提供了另外一种方法来创建指针变量，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">new(类型)</span><br></pre></td></tr></tbody></table></figure>
<p>一般这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str := new(string)</span><br><span class="line">*str = "Go语言教程"</span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></tbody></table></figure>
<p><code>new()</code> 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
<h2 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h2><p>了解下计算机组成里两个非常重要的概念：堆和栈。</p>
<h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>栈只允许从线性表的同一端放入和取出数据，按照后进先出<code>（LIFO，Last InFirst Out）</code>的顺序，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/stackImage.jpg" alt="图：栈的操作及扩展"></p>
<p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p>
<p>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的元素数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除了栈顶部的成员）进行任何查看和修改操作。</p>
<p>栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。</p>
<h4 id="变量和栈有什么关系"><a href="#变量和栈有什么关系" class="headerlink" title="变量和栈有什么关系"></a>变量和栈有什么关系</h4><p>栈可用于内存分配，栈的分配和回收速度非常快。下面的代码展示了栈在内存分配上的作用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func calc(a, b int) int {</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行，传入 <code>a</code> 、<code>b</code> 两个整型参数。</li>
<li>第 <code>2</code> 行，声明整型变量 <code>c</code>，运行时，<code>c</code> 会分配一段内存用以存储 <code>c</code> 的数值。</li>
<li>第 <code>3</code> 行，将 <code>a</code> 和 <code>b</code> 相乘后赋值给 <code>c</code>。</li>
<li>第 <code>5</code> 行，声明整型变量 <code>x</code> ，<code>x</code> 也会被分配一段内存。</li>
<li>第 <code>6</code> 行，让 <code>c</code> 乘以 <code>10</code> 后赋值给变量 <code>x</code> 。</li>
<li>第 <code>8</code> 行，返回 <code>x</code> 的值。</li>
</ul>
<p>上面的代码在没有任何优化的情况下，会进行变量 <code>c</code> 和 <code>x</code> 的分配过程。<code>Go</code> 语言默认情况下会将 <code>c</code> 和 <code>x</code> 分配在栈上，这两个变量在 <code>calc()</code> 函数退出时就不再使用，函数结束时，保存 <code>c</code> 和 <code>x</code> 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p>
<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/heapImage.jpg" alt="图：堆的分配及空间"></p>
<p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p>
<h3 id="变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率"><a href="#变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸 （Escape Analysis） —— 自动决定变量分配方式，提高运行效率"></a>变量逃逸 <code>（Escape Analysis）</code> —— 自动决定变量分配方式，提高运行效率</h3><p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 <code>C/C++</code> 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p>
<p><code>Go</code> 语言将这个过程整合到了编译器中，命名为 <code>变量逃逸分析</code> 。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>通过下面的代码来展现 <code>Go</code> 语言如何使用命令行来分析变量逃逸，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 本函数测试入口参数和返回值情况</span><br><span class="line">func dummy(b int) int {</span><br><span class="line">  // 声明一个变量c并赋值</span><br><span class="line">  var c int</span><br><span class="line">  c = b</span><br><span class="line"></span><br><span class="line">  return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 空函数, 什么也不做</span><br><span class="line">func void() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">  // 声明a变量并打印</span><br><span class="line">  var a int</span><br><span class="line"></span><br><span class="line">  // 调用void()函数</span><br><span class="line">  void()</span><br><span class="line"></span><br><span class="line">  // 打印a变量的值和dummy()函数返回</span><br><span class="line">  fmt.Println(a, dummy(0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，<code>dummy()</code> 函数拥有一个参数，返回一个整型值，用来测试函数参数和返回值分析情况。</li>
<li>第 <code>8</code> 行，声明变量 <code>c</code> ，用于演示函数临时变量通过函数返回值返回后的情况。</li>
<li>第 <code>15</code> 行，这是一个空函数，测试没有任何参数函数的分析情况。</li>
<li>第 <code>21</code> 行，在 <code>main()</code> 中声明变量 <code>a</code> ，测试 <code>main()</code> 中变量的分析情况。</li>
<li>第 <code>24</code> 行，调用 <code>void()</code> 函数，没有返回值，测试 <code>void()</code> 调用后的分析情况。</li>
<li>第 <code>27</code> 行，打印 <code>a</code> 和 <code>dummy(0)</code> 的返回值，测试函数返回值没有变量接收时的分析情况。</li>
</ul>
<p>接着使用如下命令行运行上面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run -gcflags "-m -l" goEscapeAnalysis.go</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 运行程序时，<code>-gcflags</code> 参数是编译参数。其中 <code>-m</code> 表示进行内存分配分析，<code>-l</code> 表示避免程序内联，也就是避免进行程序优化。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goEscapeAnalysis.go:27:13: ... argument does not escape</span><br><span class="line">.\goEscapeAnalysis.go:27:13: a escapes to heap</span><br><span class="line">.\goEscapeAnalysis.go:27:22: dummy(0) escapes to heap</span><br><span class="line">0 0</span><br></pre></td></tr></tbody></table></figure>
<p>程序运行结果分析如下：</p>
<ul>
<li>第 <code>2</code> 行，这句提示是默认的，可以忽略。</li>
<li>第 <code>3</code> 行告知“代码的第 <code>27</code> 行的变量 <code>a</code> 逃逸到堆”。</li>
<li>第 <code>4</code> 行告知“dummy(0) 调用逃逸到堆”。由于 <code>dummy()</code> 函数会返回一个整型值，这个值被 <code>fmt.Println</code> 使用后还是会在 <code>main()</code> 函数中继续存在。</li>
</ul>
<p>上面例子中变量 <code>c</code> 是整型，其值通过 <code>dummy()</code> 的返回值“逃出”了 <code>dummy()</code> 函数。变量 <code>c</code> 的值被复制并作为 <code>dummy()</code> 函数的返回值返回，即使变量 <code>c</code> 在 <code>dummy()</code> 函数中分配的内存被释放，也不会影响 <code>main()</code> 中使用 <code>dummy()</code> 返回的值。变量 <code>c</code> 使用栈分配不会影响结果。</p>
<h4 id="取地址发生逃逸"><a href="#取地址发生逃逸" class="headerlink" title="取地址发生逃逸"></a>取地址发生逃逸</h4><p>下面的例子使用结构体做数据，来了解结构体在堆上的分配情况，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明空结构体测试结构体逃逸情况</span><br><span class="line">type Data struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func dummy() *Data {</span><br><span class="line">    // 实例化c为Data类型</span><br><span class="line">    var c Data</span><br><span class="line"></span><br><span class="line">    //返回函数局部变量地址</span><br><span class="line">    return &amp;c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(dummy())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，声明一个空的结构体做结构体逃逸分析。</li>
<li>第 <code>9</code> 行，将 <code>dummy()</code> 函数的返回值修改为 <code>*Data</code> 指针类型。</li>
<li>第 <code>11</code> 行，将变量 <code>c</code> 声明为 <code>Data</code> 类型，此时 <code>c</code> 的结构体为值类型。</li>
<li>第 <code>14</code> 行，取函数局部变量 <code>c</code> 的地址并返回。</li>
<li>第 <code>18</code> 行，打印 <code>dummy()</code> 函数的返回值。</li>
</ul>
<p>执行逃逸分析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goPstrAnalysis.go:11:6: moved to heap: c</span><br><span class="line">.\goPstrAnalysis.go:18:13: ... argument does not escape</span><br><span class="line">&amp;{}</span><br></pre></td></tr></tbody></table></figure>
<p>注意第 <code>2</code> 行出现了新的提示：将 <code>c</code> 移到堆中。这句话表示，<code>Go</code> 编译器已经确认如果将变量 <code>c</code> 分配在栈上是无法保证程序最终结果的，如果这样做，<code>dummy()</code> 函数的返回值将是一个不可预知的内存地址，这种情况一般是 <code>C/C++</code> 语言中容易犯错的地方，引用了一个函数局部变量的地址。</p>
<p><code>Go</code> 语言最终选择将 <code>c</code> 的 <code>Data</code> 结构分配在堆上。然后由垃圾回收器去回收 <code>c</code> 的内存。</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>在使用 <code>Go</code> 语言进行编程时，<code>Go</code> 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于<code>Go</code>语言，在 <code>Java</code> 等语言的编译器优化上也使用了类似的技术。</p>
<p>编译器觉得变量应该分配在堆和栈上的原则是：</p>
<ul>
<li>变量是否被取地址；</li>
<li>变量是否发生逃逸。</li>
</ul>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔</p>
<p>变量的生命周期与变量的作用域有着不可分割的联系：</p>
<ul>
<li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li>
<li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li>
<li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+int(x*size+0.5), size+int(y*size+0.5),</span><br><span class="line">        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br><span class="line">    )               // 小括号另起一行缩进，和大括号的风格保存一致</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，在每次循环的开始会创建临时变量 <code>t</code> ，然后在每次循环迭代中创建临时变量 <code>x</code> 和 <code>y</code>。临时变量 <code>x</code>、<code>y</code> 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p>
<p>栈的和堆的区别在于：</p>
<ul>
<li>堆<code>（heap）</code>：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 <code>malloc</code> 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 <code>free</code> 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；</li>
<li>栈<code>(stack)</code>：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号{ }中定义的局部变量。</li>
</ul>
<p>在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 <code>var</code> 还是 <code>new</code> 关键字声明变量都不会影响编译器的选择。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() {</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func g() {</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，函数 <code>f</code> 里的变量 <code>x</code> 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的。用 <code>Go</code> 语言的术语说，这个局部变量 <code>x</code> 从函数 <code>f</code> 中逃逸了。</p>
<p>相反，当函数 <code>g</code> 返回时，变量 <code>*y</code> 不再被使用，也就是说可以马上被回收的。因此，<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，编译器可以选择在栈上分配 <code>*y</code> 的存储空间，也可以选择在堆上分配，然后由 <code>Go</code> 语言的 <code>GC（垃圾回收机制）</code> 回收这个变量的内存空间。</p>
<p>在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>
<p>虽然 <code>Go</code> 语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们仍然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 <code>GC</code> 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>Go</code> 语言中的常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。</p>
<p>常量的定义格式和变量的声明语法类似：<code>const name [type] = value</code> ，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const pi = 3.14159 // 相当于 math.Pi 的近似值</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>Go</code> 语言中，你可以省略类型说明符 <code>[type]</code> ，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = "abc"</code></li>
<li>隐式类型定义： <code>const b = "abc"</code></li>
</ul>
<p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p>
<ul>
<li>正确的做法：<code>const c1 = 2/3</code></li>
<li>错误的做法：<code>const c2 = getNumber()</code> // 引发构建错误: getNumber() 用做值</li>
</ul>
<p>和变量声明一样，可以批量声明多个常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    e  = 2.7182818</span><br><span class="line">    pi = 3.1415926</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和 <code>unsafe.Sizeof</code>。</p>
<p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const IPv4Len = 4</span><br><span class="line"></span><br><span class="line">// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).</span><br><span class="line">func parseIPv4(s string) IP {</span><br><span class="line">    var p [IPv4Len]byte</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code> 是一个命名类型，底层类型是 <code>int64</code>，<code>time.Minute</code> 是对应类型的常量。下面声明的两个常量都是 <code>time.Duration</code> 类型，可以通过 <code>%T</code> 参数打印类型信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const noDelay time.Duration = 0</span><br><span class="line">const timeout = 5 * time.Minute</span><br><span class="line">fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"</span><br><span class="line">fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"</span><br><span class="line">fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"</span><br></pre></td></tr></tbody></table></figure>
<p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 1</span><br><span class="line">    b</span><br><span class="line">    c = 2</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) // "1 1 2 2"</span><br></pre></td></tr></tbody></table></figure>
<p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 <code>iota</code> 常量生成器语法。</p>
<h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code> ，然后在每一个有常量声明的行加一。</p>
<p>【示例 1】首先定义一个 <code>Weekday</code> 命名类型，然后为一周的每天定义了一个常量，从周日 <code>0</code> 开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>周日将对应 0，周一为 1，以此类推。</p>
<h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p><code>Go</code> 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 <code>int</code> 或 <code>float64</code>，或者是类似 <code>time.Duration</code> 这样的基础类型，但是许多常量并没有一个明确的基础类型。</p>
<p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 <code>256bit</code> 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var x float32 = math.Pi</span><br><span class="line">var y float64 = math.Pi</span><br><span class="line">var z complex128 = math.Pi</span><br></pre></td></tr></tbody></table></figure>
<p>如果 <code>math.Pi</code> 被确定为特定类型，比如 <code>float64</code> ，那么结果精度可能会不一样，同时对于需要 <code>float32</code> 或 <code>complex128</code> 类型值的地方则需要一个明确的强制类型转换：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const Pi64 float64 = math.Pi</span><br><span class="line">var x float32 = float32(Pi64)</span><br><span class="line">var y float64 = Pi64</span><br><span class="line">var z complex128 = complex128(Pi64)</span><br></pre></td></tr></tbody></table></figure>
<p>对于常量面值，不同的写法可能会对应不同的类型。例如 <code>0</code> 、<code>0.0</code> 、<code>0i</code> 和 <code>\u0000</code> 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code> 和 <code>false</code> 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<h2 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举</h2><p><code>Go</code> 语言现阶段没有枚举类型，但是可以使用 <code>const</code> 常量配合上一节 <code>Go语言常量</code> 中介绍的 <code>iota</code> 来模拟枚举类型，请看下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>1</code> 行中，将 <code>int</code> 定义为 <code>Weapon</code> 类型，就像枚举类型的本质是一个 <code>int</code> 类型一样。当然，某些情况下，如果需要 <code>int32</code> 和 <code>int64</code> 的枚举，也是可以的。</li>
<li>第 <code>4</code> 行中，将常量 <code>Arrow</code> 的类型标识为 <code>Weapon</code>，这样标识后，<code>const</code> 下方的常量可以使用 <code>Weapon</code> 作为默认类型。该行使用 <code>iota</code> 进行常量值自动生成，<code>iota</code> 的起始值为 <code>0</code>，一般情况下也是建议枚举从 <code>0</code> 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。</li>
</ul>
<p>一个 <code>const</code> 声明内的每一行常量声明，将会自动套用前面的 <code>iota</code> 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p>
<p>当然，<code>iota</code> 不仅可以生成每次增加 <code>1</code> 的枚举值。还可以利用 <code>iota</code> 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    FlagNone = 1 &lt;&lt; iota</span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf("%d %d %d\n", FlagRed, FlagGreen, FlagBlue)</span><br><span class="line">fmt.Printf("%b %b %b\n", FlagRed, FlagGreen, FlagBlue)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2 4 8</span><br><span class="line">10 100 1000</span><br></pre></td></tr></tbody></table></figure>
<p>在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 <code>ioto</code> 自动生成更加方便。</p>
<p>代码说明如下：</p>
<ul>
<li>第 <code>2</code> 行中 <code>iota</code> 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。</li>
<li>第 <code>8</code> 行，将 <code>3</code> 个枚举按照常量输出，分别输出 <code>2</code>、<code>4</code>、<code>8</code>，都是将 <code>1</code> 每次左移一位的结果。</li>
<li>第 <code>9</code> 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。</li>
</ul>
<h3 id="将枚举值转换为字符串"><a href="#将枚举值转换为字符串" class="headerlink" title="将枚举值转换为字符串"></a>将枚举值转换为字符串</h3><p>枚举在 <code>C#</code> , <code>java</code> 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，<code>C#</code> 中 <code>Week</code> 枚举值 <code>Monday</code> 为 <code>1</code> ，那么可以通过 <code>Week.Monday.ToString()</code> 函数获得 <code>Monday</code> 字符串。</p>
<p><code>Go</code> 语言中也可以实现这一功能，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明芯片类型</span><br><span class="line">type ChipType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None ChipType = iota</span><br><span class="line">    CPU    // 中央处理器</span><br><span class="line">    GPU    // 图形处理器</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func (c ChipType) String() string {</span><br><span class="line">    switch c {</span><br><span class="line">    case None:</span><br><span class="line">        return "None"</span><br><span class="line">    case CPU:</span><br><span class="line">        return "CPU"</span><br><span class="line">    case GPU:</span><br><span class="line">        return "GPU"</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return "N/A"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 输出CPU的值并以整型格式显示</span><br><span class="line">    fmt.Printf("%s %d", CPU, CPU)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CPU 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>6</code> 行，将 <code>int</code> 声明为 <code>ChipType</code> 芯片类型。</li>
<li>第 <code>9</code> 行，将 <code>const</code> 里定义的常量值设为 <code>ChipType</code> 类型，且从 <code>0</code> 开始，每行值加 <code>1</code>。</li>
<li>第 <code>14</code> 行，定义 <code>ChipType</code> 类型的方法 <code>String()</code>，返回值为字符串类型。</li>
<li>第 <code>15～22</code> 行，使用 <code>switch</code> 语句判断当前的 <code>ChitType</code> 类型的值，返回对应的字符串。</li>
<li>第 <code>30</code> 行，按整型的格式输出 <code>CPU</code> 的值。</li>
</ul>
<p><code>String()</code> 方法的 <code>ChipType</code> 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，<code>Go</code> 语言会自动寻找 <code>String()</code> 方法并进行调用。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>Go</code> 语言新版本的功能，内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对Go语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。</p>
<p>类型别名是 <code>Go 1.9</code> 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 <code>C/C++</code> 语言中，代码重构升级可以使用宏快速定义一段新的代码，<code>Go</code> 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。</p>
<p>在 <code>Go 1.9</code> 版本之前定义内建类型的代码是这样写的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte uint8</span><br><span class="line">type rune int32</span><br></pre></td></tr></tbody></table></figure>
<p>而在 Go 1.9 版本之后变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></tbody></table></figure>
<p>这个修改就是配合类型别名而进行的修改。</p>
<h3 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h3><p>定义类型别名的写法为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></tbody></table></figure>
<p>类型别名规定：<code>TypeAlias</code> 只是 <code>Type</code> 的别名，本质上 <code>TypeAlias</code> 与 <code>Type</code> 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<p>类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 查看a的类型名</span><br><span class="line">    fmt.Printf("a type: %T\n", a)</span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 查看a2的类型名</span><br><span class="line">    fmt.Printf("a2 type: %T\n", a2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a type: main.NewInt</span><br><span class="line">a2 type: int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，将 <code>NewInt</code> 定义为 <code>int</code> 类型，这是常见的定义类型的方法，通过 <code>type</code> 关键字的定义，<code>NewInt</code> 会形成一种新的类型，<code>NewInt</code> 本身依然具备 <code>int</code> 类型的特性。</li>
<li>第 <code>11</code> 行，将 <code>IntAlias</code> 设置为 <code>int</code> 的一个别名，使用 <code>IntAlias</code> 与 <code>int</code> 等效。</li>
<li>第 <code>16</code> 行，将 <code>a</code> 声明为 <code>NewInt</code> 类型，此时若打印，则 <code>a</code> 的值为 <code>0</code> 。</li>
<li>第 <code>18</code> 行，使用 <code>%T</code> 格式化参数，打印变量 <code>a</code> 本身的类型。</li>
<li>第 <code>21</code> 行，将 <code>a2</code> 声明为 <code>IntAlias</code> 类型，此时打印 <code>a2</code> 的值为 <code>0</code> 。</li>
<li>第 <code>23</code> 行，打印 <code>a2</code> 变量的类型。</li>
</ul>
<p>结果显示 <code>a</code> 的类型是 <code>main.NewInt</code> ，表示 <code>main</code> 包下定义的 <code>NewInt</code> 类型，<code>a2</code> 类型是 <code>int</code> ，<code>IntAlias</code> 类型只会在代码中存在，编译完成时，不会有 <code>IntAlias</code> 类型。</p>
<h3 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h3><p>能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法呢？参见下面的代码演示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>8</code> 行，为 <code>time.Duration</code> 设定一个类型别名叫 <code>MyDuration</code> 。</li>
<li>第 <code>11</code> 行，为这个别名添加一个方法。</li>
</ul>
<p>编译上面代码报错，信息如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cannot define new methods on non-local type time.Duration</span><br></pre></td></tr></tbody></table></figure>
<p>编译器提示：不能在一个非本地的类型 <code>time.Duration</code> 上定义新方法，非本地类型指的就是 <code>time.Duration</code> 不是在 <code>main</code> 包中定义的，而是在 <code>time</code> 包中定义的，与 <code>main</code> 包不在同一个包中，因此不能为不在一个包中的类型定义方法。</p>
<p>解决这个问题有下面两种方法：</p>
<ul>
<li>将第 <code>8</code> 行修改为 <code>type MyDuration time.Duration</code> ，也就是将 <code>MyDuration</code> 从别名改为类型；</li>
<li>将 <code>MyDuration</code> 的别名定义放在 <code>time</code> 包中。</li>
</ul>
<h3 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h3><p>当类型别名作为结构体嵌入的成员时会发生什么情况呢？请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义商标结构</span><br><span class="line">type Brand struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为商标结构添加Show()方法</span><br><span class="line">func (t Brand) Show() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Brand定义一个别名FakeBrand</span><br><span class="line">type FakeBrand = Brand</span><br><span class="line"></span><br><span class="line">// 定义车辆结构</span><br><span class="line">type Vehicle struct {</span><br><span class="line">    // 嵌入两个结构</span><br><span class="line">    FakeBrand</span><br><span class="line">    Brand</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明变量a为车辆类型</span><br><span class="line">    var a Vehicle</span><br><span class="line"></span><br><span class="line">    // 指定调用FakeBrand的Show</span><br><span class="line">    a.FakeBrand.Show()</span><br><span class="line"></span><br><span class="line">    // 取a的类型反射对象</span><br><span class="line">    ta := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 遍历a的所有成员</span><br><span class="line">    for i := 0; i &lt; ta.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // a的成员信息</span><br><span class="line">        f := ta.Field(i)</span><br><span class="line"></span><br><span class="line">        // 打印成员的字段名和类型</span><br><span class="line">        fmt.Printf("FieldName: %v, FieldType: %v\n", f.Name, f.Type.Name())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FieldName: FakeBrand, FieldType: Brand</span><br><span class="line">FieldName: Brand, FieldType: Brand</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 <code>9</code> 行，定义商标结构。</li>
<li>第 <code>13</code> 行，为商标结构添加 <code>Show()</code> 方法。</li>
<li>第 <code>17</code> 行，为 <code>Brand</code> 定义一个别名 <code>FakeBrand</code>。</li>
<li>第 <code>20～25</code> 行，定义车辆结构 <code>Vehicle</code> ，嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 结构。</li>
<li>第 <code>30</code> 行，将 <code>Vechicle</code> 实例化为 <code>a</code> 。</li>
<li>第 <code>33</code> 行，显式调用 <code>Vehicle</code> 中 <code>FakeBrand</code> 的 <code>Show()</code> 方法。</li>
<li>第 <code>36</code> 行，使用反射取变量 <code>a</code> 的反射类型对象，以查看其成员类型。</li>
<li>第 <code>39～42</code> 行，遍历 <code>a</code> 的结构体成员。</li>
<li>第 <code>45</code> 行，打印 <code>Vehicle</code> 类型所有成员的信息。</li>
</ul>
<p>这个例子中，<code>FakeBrand</code> 是 <code>Brand</code> 的一个别名，在 <code>Vehicle</code> 中嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 并不意味着嵌入两个 <code>Brand</code>，<code>FakeBrand</code> 的类型会以名字的方式保留在 <code>Vehicle</code> 的成员中。</p>
<p>如果尝试将第 <code>33</code> 行改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a.Show()</span><br></pre></td></tr></tbody></table></figure>
<p>编译器将发生报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ambiguous selector a.Show</span><br></pre></td></tr></tbody></table></figure>
<p>在调用 <code>Show()</code> 方法时，因为两个类型都有 <code>Show()</code> 方法，会发生歧义，证明 <code>FakeBrand</code> 的本质确实是 <code>Brand</code> 类型。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释在程序中的作用是对程序进行注解和说明，便于对源码的阅读。编译系统在对源代码进行编译时会自动忽略注释的部分，因此注释对于程序的功能实现不起任何作用。在源码中适当地添加注释，能够提高源码的可读性。</p>
<p><code>Go</code> 语言的注释主要分成两类，分别是单行注释和多行注释。</p>
<ul>
<li>单行注释简称行注释，是最常见的注释形式，可以在任何地方使用以 <code>//</code> 开头的单行注释；</li>
<li>多行注释简称块注释，以 <code>/*</code> 开头，并以 <code>*/</code> 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<p>单行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></tbody></table></figure>
<p>多行注释的格式如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">...</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure>
<p>每一个包都应该有相关注释，在使用 <code>package</code> 语句声明包名之前添加相应的注释，用来对包的功能及作用进行简要说明。</p>
<p>同时，在 <code>package</code> 语句之前的注释内容将被默认认为是这个包的文档说明。一个包可以分散在多个文件中，但是只需要对其中一个进行注释说明即可。</p>
<p>在多段注释之间可以使用空行分隔加以区分，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Package superman implements methods for saving the world.</span><br><span class="line">//</span><br><span class="line">// Experience has shown that a small number of procedures can prove</span><br><span class="line">// helpful when attempting to save the world.</span><br><span class="line">package superman</span><br></pre></td></tr></tbody></table></figure>
<p>对于代码中的变量、常量、函数等对象最好也都加上对应的注释，这样有利于后期对代码进行维护，例如下面代码中对 <code>enterOrbit</code> 函数的注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// enterOrbit causes Superman to fly into low Earth orbit, a position</span><br><span class="line">// that presents several possibilities for planet salvation.</span><br><span class="line">func enterOrbit() error {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当开发人员需要了解包的一些情况时，可以使用 godoc 来显示包的文档说明，下面来介绍一下 godoc 工具的使用。</p>
<h3 id="godoc-工具"><a href="#godoc-工具" class="headerlink" title="godoc 工具"></a>godoc 工具</h3><p><code>godoc</code> 工具会从 <code>Go</code> 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 <code>web</code> 服务器，<code>Go</code> <a target="_blank" rel="noopener" href="https://golang.google.cn/">语言官网</a>就是通过这种形式实现的。</p>
<p>但是<code>Go</code>语言 <code>1.13</code> 版本移除了 <code>godoc</code> 工具，大家可以通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure>
<p>由于防火墙的原因，国内的用户可能无法通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具，这时候就需要大家来手动操作了。</p>
<ul>
<li>首先从 <a target="_blank" rel="noopener" href="https://github.com/golang/tools.git">GitHub</a> 下载 <code>golang.org/x/tools</code> 包；</li>
<li>然后将下载得到的文件解压到 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools</code> 目录中，没有的话可以手动创建；</li>
<li>打开 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools\cmd\godoc</code> 目录，在该目录下打开命令行工具，并执行 <code>go build</code> 命令，生成 <code>godoc.exe</code> 可执行文件；</li>
<li>最后，将生成的 <code>godoc.exe</code> 文件移动到 <code>GOPATH</code> 下的 <code>bin</code> 目录中。（需要把 <code>GOPATH</code> 下的 <code>bin</code> 目录添加到环境变量 <code>Path</code> 中）</li>
</ul>
<p>完成上述操作后就可以使用 <code>godoc</code> 工具了，<code>godoc</code> 工具一般有以下几种用法：</p>
<ul>
<li><code>go doc package</code>：获取包的文档注释，例如 <code>go doc fmt</code> 会显示使用 <code>godoc</code> 生成的 <code>fmt</code> 包的文档注释；</li>
<li><code>go doc package/subpackage</code>：获取子包的文档注释，例如 <code>go doc container/list</code>；</li>
<li><code>go doc package function</code>：获取某个函数在某个包中的文档注释，例如 <code>go doc fmt Printf</code> 会显示有关 <code>fmt.Printf()</code> 的使用说明。</li>
</ul>
<p>下图演示了使用go doc 命令来获取包的文档注释：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">godoc package main</span><br></pre></td></tr></tbody></table></figure>
<p><code>godoc</code> 工具还可以获取 <code>Go</code> 安装目录下 <code>../go/src</code> 中的注释内容，并将这些注释内容整合到 <code>web</code> 服务器中供我们预览。在命令行输入 <code>godoc -http=:6060</code> ，然后使用浏览器打开 <code>http://localhost:6060</code> 后，就可以看到本地文档浏览服务器提供的页面。</p>
<h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><code>Go</code> 语言的词法元素包括 <code>5</code> 种，分别是标识符<code>（identifier）</code>、关键字<code>（keyword）</code>、操作符<code>（operator）</code>、分隔符<code>（delimiter）</code>、字面量<code>（literal）</code>，它们是组成 <code>Go</code> 语言代码和程序的最基本单位。</p>
<p>本节我们主要来介绍一下 <code>Go</code> 语言中的关键字和标识符。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。</p>
<p>Go语言中的关键字一共有 25 个：</p>
<table>
  <tbody>
    <tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr>
    <tr><th>case</th><th>defer</th><th>go</th><th>map</th><th>struct</th></tr>
    <tr><th>chan</th><th>else</th><th>goto</th><th>package</th><th>switch</th></tr>
    <tr><th>const</th><th>fallthrough</th><th>if</th><th>range</th><th>type</th></tr>
    <tr><th>continue</th><th>for</th><th>import</th><th>return</th><th>var</th></tr>
  </tbody>
</table>

<p>之所以刻意地将 <code>Go</code> 语言中的关键字保持的这么少，是为了简化在编译过程中的代码解析。和其它语言一样，关键字不能够作标识符使用。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指 <code>Go</code> 语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线_、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p>
<p>下划线<em>是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用</em>作为变量对其它变量进行赋值或运算。</p>
<p>在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。</p>
<p>标识符的命名需要遵守以下规则：</p>
<ul>
<li>由 <code>26</code> 个英文字母、<code>0~9</code>、<code>_</code> 组成；</li>
<li>不能以数字开头，例如 <code>var 1num int</code> 是错误的；</li>
<li><code>Go</code> 语言中严格区分大小写；</li>
<li>标识符不能包含空格；</li>
<li>不能以系统保留关键字作为标识符，比如 <code>break</code> ，<code>if</code> 等等。</li>
</ul>
<p>命名标识符时还需要注意以下几点：</p>
<ul>
<li>标识符的命名要尽量采取简短且有意义；</li>
<li>不能和标准库中的包名重复；</li>
<li>为变量、函数、常量命名时采用驼峰命名法，例如 <code>stuName</code>、<code>getVal</code> ；</li>
</ul>
<p>当然 <code>Go</code> 语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 <code>Java</code> 中的 <code>public</code> ）；如果首字母小写，则表示它只能在本包中使用 (类似于 <code>Java</code> 中 <code>private</code> ）。</p>
<p>在 <code>Go</code> 语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：</p>
<table>
  <tbody>  
    <tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr>
    <tr><th>copy</th><th>false</th><th>float32</th><th>float64</th><th>imag</th><th>int</th><th>int8</th><th>int16</th><th>uint32</th></tr>
    <tr><th>int32</th><th>int64</th><th>iota</th><th>len</th><th>make</th><th>new</th><th>nil</th><th>panic</th><th>uint64</th></tr>
    <tr><th>print</th><th>println</th><th>real</th><th>recover</th><th>string</th><th>true</th><th>uint</th><th>uint8</th><th>uintptr</th></tr>
  </tbody>
</table>

<p>预定义标识符一共有 <code>36</code> 个，主要包含 <code>Go</code> 语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。</p>
<h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符是用来在程序运行时执行数学或逻辑运算的，在 <code>Go</code> 语言中，一个表达式可以包含多个运算符，当表达式中存在多个运算符时，就会遇到优先级的问题，此时应该先处理哪个运算符呢？这个就由 <code>Go</code> 语言运算符的优先级来决定的。</p>
<p>比如对于下面的表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a, b, c int = 16, 4, 2</span><br><span class="line">d := a + b*c</span><br></pre></td></tr></tbody></table></figure>
<p>对于表达式 <code>a + b * c</code> ，如果按照数学规则推导，应该先计算乘法，再计算加法；<code>b * c</code> 的结果为 <code>8</code> ，<code>a + 8</code> 的结果为 <code>24</code> ，所以 <code>d</code> 最终的值也是 <code>24</code> 。实际上 <code>Go</code> 语言也是这样处理的，先计算乘法再计算加法，和数据中的规则一样，读者可以亲自验证一下。</p>
<p>先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。</p>
<p><code>Go</code> 语言有几十种运算符，被分成十几个级别，有的运算符优先级不同，有的运算符优先级相同，请看下表。</p>
<table>
  <thead><tr><th>优先级</th><th>分类</th><th>运算符</th><th>结合性</th></tr></thead>
  <tbody>        
    <tr><th>1</th><th>逗号运算符</th><th>,</th><th>从左到右</th></tr>
    <tr><th>2</th><th>赋值运算符</th><th>=、+=、-=、*=、/=、 %=、 &gt;=、 &lt;&lt;=、&amp;=、^=、|=</th><th>从右到左</th></tr>
    <tr><th>3</th><th>逻辑或</th><th>||</th><th>从左到右</th></tr>
    <tr><th>4</th><th>逻辑与</th><th>&amp;&amp;</th><th>从左到右</th></tr>
    <tr><th>5</th><th>按位或</th><th>|</th><th>从左到右</th></tr>
    <tr><th>6</th><th>按位异或</th><th>^</th><th>从左到右</th></tr>
    <tr><th>7</th><th>按位与</th><th>&amp;</th><th>从左到右</th></tr>
    <tr><th>8</th><th>相等/不等</th><th>==、!=</th><th>从左到右</th></tr>
    <tr><th>9</th><th>关系运算符</th><th>&lt;、&lt;=、&gt;、&gt;=</th><th>从左到右</th></tr>
    <tr><th>10</th><th>位移运算符</th><th>&lt;&lt;、&gt;&gt;</th><th>从左到右</th></tr>
    <tr><th>11</th><th>加法/减法</th><th>+、-</th><th>从左到右</th></tr>
    <tr><th>12</th><th>乘法/除法/取余</th><th>*（乘号）、/、%</th><th>从左到右</th></tr>
    <tr><th>13</th><th>单目运算符</th><th>!、*（指针）、&amp; 、++、--、+（正号）、-（负号）</th><th>从右到左</th></tr>
    <tr><th>14</th><th>后缀运算符</th><th>( )、[ ]、-&gt;</th><th>从左到右</th></tr>
    </tbody>
</table>

<p>注意：优先级值越大，表示优先级越高。</p>
<p>一下子记住所有运算符的优先级并不容易，还好 <code>Go</code> 语言中大部分运算符的优先级和数学中是一样的，大家在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">d := a + (b * c)</span><br></pre></td></tr></tbody></table></figure>
<p>括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p>
<p>运算符的结合性是指相同优先级的运算符在同一个表达式中，且没有括号的时候，操作数计算的顺序，通常有从左到右和从右到左两种方式，例如，<code>+</code> 加法运算符的结合性是从左到右，那么表达式 <code>a + b + c</code> 则可以理解为为 <code>(a + b) + c</code> 。</p>
<h2 id="字符串和数值类型的转换"><a href="#字符串和数值类型的转换" class="headerlink" title="字符串和数值类型的转换"></a>字符串和数值类型的转换</h2><p>在实际开发中我们往往需要对一些常用的数据类型进行转换，如 <code>string</code> 、<code>int</code> 、<code>int64</code> 、<code>float</code> 等数据类型之间的转换，<code>Go</code> 语言中的 <code>strconv</code> 包为我们提供了字符串和基本数据类型之间的转换功能。</p>
<p><code>strconv</code> 包中常用的函数包括 <code>Atoi()</code> 、<code>Itia()</code> 、<code>parse</code> 系列函数、<code>format</code> 系列函数、<code>append</code> 系列函数等，下面就来分别介绍一下。</p>
<h3 id="string-与-int-类型之间的转换"><a href="#string-与-int-类型之间的转换" class="headerlink" title="string 与 int 类型之间的转换"></a>string 与 int 类型之间的转换</h3><p>字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。</p>
<h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4><p>Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Itoa(i int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := 100</span><br><span class="line">    str := strconv.Itoa(num)</span><br><span class="line">    fmt.Printf("type:%T value:%#v\n", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string value:"100"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4><p><code>Atoi()</code> 函数用于将字符串类型的整数转换为 <code>int</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func Atoi(s string) (i int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>通过函数签名可以看出 <code>Atoi()</code> 函数有两个返回值，<code>i</code> 为转换成功的整型，<code>err</code> 在转换成功是为空转换失败时为相应的错误信息。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    str2 := "s100"</span><br><span class="line">    num1, err := strconv.Atoi(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str1)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num1, num1)</span><br><span class="line">    }</span><br><span class="line">    num2, err := strconv.Atoi(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str2)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num2, num2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:int value:110</span><br><span class="line">s100 转换失败！</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Parse-系列函数"><a href="#Parse-系列函数" class="headerlink" title="Parse 系列函数"></a>Parse 系列函数</h3><p><code>Parse</code> 系列函数用于将字符串转换为指定类型的值，其中包括 <code>ParseBool()</code> 、<code>ParseFloat()</code> 、<code>ParseInt()</code> 、<code>ParseUint()</code> 。</p>
<h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p><code>ParseBool()</code> 函数用于将字符串转换为 <code>bool</code> 类型的值，它只能接受 <code>1</code> 、<code>0</code> 、<code>t</code> 、<code>f</code> 、<code>T</code> 、<code>F</code> 、<code>true</code> 、<code>false</code> 、<code>True</code> 、<code>False</code> 、<code>TRUE</code> 、<code>FALSE</code> ，其它的值均返回错误，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseBool(str string) (value bool, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    boo1, err := strconv.ParseBool(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str1: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo1)</span><br><span class="line">    }</span><br><span class="line">    str2 := "t"</span><br><span class="line">    boo2, err := strconv.ParseBool(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str2: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">str1: strconv.ParseBool: parsing "110": invalid syntax</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h4><p><code>ParseInt()</code> 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>base</code> 指定进制，取值范围是 <code>2</code> 到 <code>36</code>。如果 <code>base</code> 为 <code>0</code> ，则会从字符串前置判断，“0x”是 <code>16</code> 进制，“0”是 <code>8</code> 进制，否则是 <code>10</code> 进制。</li>
<li><code>bitSize</code> 指定结果必须能无溢出赋值的整数类型，<code>0</code> 、<code>8</code> 、<code>16</code> 、<code>32</code> 、<code>64</code> 分别代表 <code>int</code> 、<code>int8</code> 、<code>int16</code> 、<code>int32</code> 、<code>int64</code> 。</li>
<li>返回的 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误，<code>err.Error = ErrSyntax</code> ，如果结果超出类型范围 <code>err.Error = ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "-11"</span><br><span class="line">    num, err := strconv.ParseInt(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h4><p><code>ParseUint()</code> 函数的功能类似于 <code>ParseInt()</code> 函数，但 <code>ParseUint()</code> 函数不接受正负号，用于无符号整型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "11"</span><br><span class="line">    num, err := strconv.ParseUint(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p><code>ParseFloat()</code> 函数用于将一个表示浮点数的字符串转换为 <code>float</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func ParseFloat(s string, bitSize int) (f float64, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li>如果 <code>s</code> 合乎语法规则，函数会返回最为接近 <code>s</code> 表示值的一个浮点数（使用 <code>IEEE754</code> 规范舍入）。</li>
<li><code>bitSize</code> 指定了返回值的类型，<code>32</code> 表示 <code>float32</code>，<code>64</code> 表示 <code>float64</code> ；</li>
<li>返回值 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误 <code>err.Error=ErrSyntax</code> ，如果返回值超出表示范围，返回值 <code>f</code> 为 <code>±Inf，err.Error= ErrRange</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "3.1415926"</span><br><span class="line">    num, err := strconv.ParseFloat(str, 64)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">3.1415926</span><br></pre></td></tr></tbody></table></figure>
<p><code>Parse</code> 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>
<h3 id="Format-系列函数"><a href="#Format-系列函数" class="headerlink" title="Format 系列函数"></a>Format 系列函数</h3><p><code>Format</code> 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 <code>FormatBool()</code>、<code>FormatInt()</code>、<code>FormatUint()</code>、<code>FormatFloat()</code>。</p>
<h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p><code>FormatBool()</code> 函数可以一个 <code>bool</code> 类型的值转换为对应的字符串类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatBool(b bool) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := true</span><br><span class="line">    str := strconv.FormatBool(num)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:true</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatInt(i int64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 <code>i</code> 必须是 <code>int64</code> 类型，参数 <code>base</code> 必须在 <code>2</code> 到 <code>36</code> 之间，返回结果中会使用小写字母“a”到“z”表示大于 <code>10</code> 的数字。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num int64 = 100</span><br><span class="line">    str := strconv.FormatInt(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:64</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h4><p><code>FormatUint()</code> 函数与 <code>FormatInt()</code> 函数的功能类似，但是参数 <code>i</code> 必须是无符号的 <code>uint64</code> 类型，函数签名如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatUint(i uint64, base int) string</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num uint64 = 110</span><br><span class="line">    str := strconv.FormatUint(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:6e</span><br></pre></td></tr></tbody></table></figure>
<h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p><code>FormatFloat()</code> 函数用于将浮点数转换为字符串类型，函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明：</p>
<ul>
<li><code>bitSize</code> 表示参数 <code>f</code> 的来源类型（<code>32</code> 表示 <code>float32</code>、<code>64</code> 表示 <code>float64</code>），会据此进行舍入。</li>
<li><code>fmt</code> 表示格式，可以设置为“f”表示 <code>-ddd.dddd</code> 、“b”表示 <code>-ddddp±ddd</code>，指数为二进制、“e”表示 <code>-d.dddde±dd</code> 十进制指数、“E”表示 <code>-d.ddddE±dd</code> 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li><code>prec</code> 控制精度（排除指数部分）：当参数 <code>fmt</code> 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 <code>fmt</code> 为“g”、“G”时，它控制总的数字个数。如果 <code>prec</code> 为 <code>-1</code> ，则代表使用最少数量的、但又必需的数字来表示 <code>f</code> 。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num float64 = 3.1415926</span><br><span class="line">    str := strconv.FormatFloat(num, 'E', -1, 64)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type:string,value:3.1415926E+00</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Append-系列函数"><a href="#Append-系列函数" class="headerlink" title="Append 系列函数"></a>Append 系列函数</h3><p><code>Append</code> 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 <code>AppendBool()</code> 、<code>AppendFloat()</code> 、<code>AppendInt()</code> 、<code>AppendUint()</code> 。</p>
<p><code>Append</code> 系列函数和 <code>Format</code> 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个slice</span><br><span class="line">    b10 := []byte("int (base 10):")</span><br><span class="line">  </span><br><span class="line">    // 将转换为10进制的string，追加到slice中</span><br><span class="line">    b10 = strconv.AppendInt(b10, -42, 10)</span><br><span class="line">    fmt.Println(string(b10))</span><br><span class="line">    b16 := []byte("int (base 16):")</span><br><span class="line">    b16 = strconv.AppendInt(b16, -42, 16)</span><br><span class="line">    fmt.Println(string(b16))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int (base 10):-42</span><br><span class="line">int (base 16):-2a</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言适合做什么</title>
    <url>/posts/30ebccd/</url>
    <content><![CDATA[<p>前面我们已经介绍过了 <code>Go</code> 语言的种种优势和不足，那么我们究竟可以使用 <code>Go</code> 语言来做些什么呢？</p>
<p>其实 <code>Go</code> 语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的网络服务。</p>
<p><code>Go</code> 语言融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性，不仅提高了项目的开发速度，而且后期维护起来也非常轻松。</p>
<p>鉴于 <code>Go</code> 语言的特点和设计的初衷，从以下几个方面来分析 <code>Go</code> 语言擅长的领域：</p>
<ul>
<li>在服务器编程方面，<code>Go</code> 语言适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；</li>
<li>网络编程方面，<code>Go</code> 语言广泛应用于 <code>Web</code> 应用、<code>API</code> 应用、下载应用等；</li>
<li>此外，<code>Go</code> 语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 <code>Go</code> 开发。</li>
</ul>
<p>除了上面介绍到的，<code>Go</code> 语言还可以用来开发底层，例如以太坊、超级账本等都是基于 <code>Go</code> 语言开发的。</p>
<p>而且对于现在比较流行的区块链技术方面，<code>Go</code> 语言也是非常受欢迎的，很多基于区块链的 <code>DApps</code>（去中心化应用）和工具都是用的 <code>Go</code> 语言来实现的。</p>
<p>下面列举了一些基于 <code>Go</code> 语言开发的优秀开源项目：<br>云计算基础设施领域，代表项目：<code>docker</code> 、<code>kubernetes</code> 、<code>etcd</code> 、<code>consul</code> 、<code>cloudflare CDN</code> 、七牛云存储等。<br>基础软件，代表项目：<code>tidb</code> 、<code>influxdb</code> 、<code>cockroachdb</code> 等。<br>微服务，代表项目：<code>go-kit</code> 、<code>micro</code> 、<code>monzo bank</code> 的 <code>typhon</code> 、<code>bilibili</code> 等。<br>互联网基础设施，代表项目：以太坊、<code>hyperledger</code> 等。</p>
<p>总之，<code>Go</code> 语言的优势还是比较多的，比如 <code>Go</code> 语言的性能非常出色，最关键的是在性能强劲的同时还能像解释型语言一样高效地进行开发。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5721.html">Go语言是怎么完成编译的</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4774.html">Go语言依赖管理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/129.html">Go语言map的多键索引</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5722.html">Go语言make和new关键字的区别及实现原理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5571.html">Go语言分布式id生成器</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5728.html">Go语言冒泡排序</a></p>
<h2 id="Go语言依赖管理"><a href="#Go语言依赖管理" class="headerlink" title="Go语言依赖管理"></a>Go语言依赖管理</h2><p>早期的Go语言被很多开发者所吐槽的一个问题就是没有依赖包的管理，不过随着版本的不断更迭，Go语言依赖管理方面也在不断的完善。</p>
<h3 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h3><p>最初的时候Go语言所依赖的所有的第三方包都放在 GOPATH 目录下面，这就导致了同一个包只能保存一个版本的代码，如果不同的项目依赖同一个第三方的包的不同版本，应该怎么解决呢？</p>
<h3 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h3><p>godep 是一个Go语言官方提供的通过 vender 模式来管理第三方依赖的工具，类似的还有由社区维护的准官方包管理工具 dep。</p>
<p>Go语言从 1.5 版本开始开始引入 vendor 模式，如果项目目录下有 vendor 目录，那么Go语言编译器会优先使用 vendor 内的包进行编译、测试等。</p>
<h4 id="安装godep工具"><a href="#安装godep工具" class="headerlink" title="安装godep工具"></a>安装godep工具</h4><p>我们可以通过go get 命令来获取 godep 工具。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go get github.com/tools/godep</span><br></pre></td></tr></tbody></table></figure>
<p>命令执行成功后会将 godep 工具的源码下载到 GOPATH 的 src 目录下对应的文件夹中，同时还会在 GOPATH 的 bin 目录下生成一个名为 godep.exe 的可执行文件。</p>
<p>为了方便使用 godep 工具，我们需要将存放 godep.exe 文件的目录添加到环境变量 PATH 中。在系统变量中找到并选中“Path”一行，点击“编辑”按钮，在新弹出的窗口中点击“新建”，然后在最下面一行中填入对应的目录信息。确认无误后点击“确定”。</p>
<h4 id="godep工具的基本命令"><a href="#godep工具的基本命令" class="headerlink" title="godep工具的基本命令"></a>godep工具的基本命令</h4><p>完成上面的操作后，我们就可以在命令行窗口（CMD）中使用 godep 工具了，godep 支持的命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>
    <tr><th>godep save</th><th>将依赖包的信息保存到 Godeps.json 文件中</th></tr>
    <tr><th>godep go</th><th>使用保存的依赖项运行 go 工具</th></tr>
    <tr><th>godep get</th><th>下载并安装指定的包</th></tr>
    <tr><th>godep path</th><th>打印依赖的 GOPATH 路径</th></tr>
    <tr><th>godep restore</th><th>在 GOPATH 中拉取依赖的版本</th></tr>
    <tr><th>godep update</th><th>更新选定的包或 go 版本</th></tr>
    <tr><th>godep diff</th><th>显示当前和以前保存的依赖项集之间的差异</th></tr>
    <tr><th>godep version</th><th>查看版本信息</th></tr>
  </tbody>
</table>

<p>使用 <code>godep help [命令名称]</code> 可以查看命令的帮助信息，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy&gt;godep help go</span><br><span class="line">Args: godep go [-v] [-d] command [arguments]</span><br><span class="line"></span><br><span class="line">Go runs the go tool with a modified GOPATH giving access to</span><br><span class="line">dependencies saved in Godeps.</span><br><span class="line"></span><br><span class="line">Any go tool command can run this way, but "godep go get"</span><br><span class="line">is unnecessary and has been disabled. Instead, use</span><br><span class="line">"godep go install".</span><br><span class="line"></span><br><span class="line">If -v is given, verbose output is enabled.</span><br><span class="line"></span><br><span class="line">If -d is given, debug output is enabled (you probably don't want this, see -v).</span><br></pre></td></tr></tbody></table></figure>
<h4 id="使用godep工具"><a href="#使用godep工具" class="headerlink" title="使用godep工具"></a>使用godep工具</h4><p>执行 <code>godep save</code> 命令，会在当前目录中创建 Godeps 和 vender 两个文件夹。Godeps 文件夹下会生成一个 Godeps.json 文件，用来记录项目中所依赖的包信息；vender 目录则是用来保存当前项目所依赖的所有第三方包。</p>
<p>生成的 Godeps.json 文件的结构如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    "ImportPath": "main",</span><br><span class="line">    "GoVersion": "go1.13",</span><br><span class="line">    "GodepVersion": "v80",</span><br><span class="line">    "Deps": [</span><br><span class="line">        {</span><br><span class="line">            "ImportPath": "github.com/go-gomail/gomail",</span><br><span class="line">            "Comment": "2.0.0-23-g81ebce5",</span><br><span class="line">            "Rev": "81ebce5c23dfd25c6c67194b37d3dd3f338c98b1"</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，“ImportPath”为项目的路径信息，“GoVersion”为Go语言的版本号，“GodepVersion”为 godep 工具的版本号，“Deps”为当前依赖包的路径、版本号信息等等。</p>
<p><strong><em>提示：当引用的第三方包要升级时，只需要修改 Godep.json 里面的依赖包的版本号，然后再次执行 godep save 命令即可。</em></strong></p>
<p>godep 工具的主要功能就是控制Go语言程序编译时依赖包搜索路径的优先级。例如查找项目的某个依赖包，首先会在项目根目录下的 vender 文件夹中查找，如果没有找到就会去 GOAPTH/src 目录下查找。</p>
<h3 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h3><p>go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。</p>
<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。</p>
<ul>
<li>GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。</li>
<li>GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li>
<li>GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。</li>
</ul>
<p>Windows 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">set GO111MODULE=on 或者 set GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或者 Linux 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GO111MODULE=on 或者 export GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>使用 go module 的 <code>go mod init</code> 命令后会在当前目录下生成一个 go. mod 文件，并且在编译/运行当前目录下代码或者使用 <code>go get</code> 命令的时候会在当前目录下生成一个 go.sum 文件。</p>
<p>go.mod 文件记录了项目所有的依赖信息，其结构大致如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">module github.com/dubbogo/dubbo-go-proxy</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/apache/dubbo-go v1.5.1</span><br><span class="line">	github.com/apache/dubbo-go-hessian2 v1.6.2</span><br><span class="line">	github.com/dubbogo/gost v1.9.2</span><br><span class="line">	github.com/emirpasic/gods v1.12.0</span><br><span class="line">	github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32</span><br><span class="line">	github.com/goinggo/mapstructure v0.0.0-20140717182941-194205d9b4a9</span><br><span class="line">	github.com/kr/fs v0.1.0 // indirect</span><br><span class="line">	github.com/pkg/errors v0.9.1</span><br><span class="line">	github.com/stretchr/testify v1.6.1</span><br><span class="line">	github.com/tools/godep v0.0.0-20180126220526-ce0bfadeb516 // indirect</span><br><span class="line">	github.com/urfave/cli v1.22.4</span><br><span class="line">	go.uber.org/zap v1.15.0</span><br><span class="line">	gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，module 为 go.mod 文件所属的包，require 为项目所依赖的包及版本号，indirect 表示间接引用。</p>
<p>go.sum 文件则是用来记录每个依赖包的版本及哈希值，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=</span><br><span class="line">cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=</span><br><span class="line">cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=</span><br><span class="line">dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=</span><br><span class="line">github.com/Azure/azure-sdk-for-go v40.3.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.0/go.mod h1:xyHB1BMZT0cuDHU7I0+g046+BFDTQ8rEZB0s4Yfa6bI=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.3/go.mod h1:GsRuLYvwzLjjjRoWEIyMUaYq8GNUx2nRB378IPt/1p0=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.10.0/go.mod h1:/FALq9T/kS7b5J5qsQ+RSTUdAmGFqi0vUdVNNx8q630=</span><br></pre></td></tr></tbody></table></figure>
<p>常用的 go mod 命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>
    <tr><th>go mod download</th><th>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</th></tr>
    <tr><th>go mod edit</th><th>编辑 go.mod 文件</th></tr>
    <tr><th>go mod graph</th><th>打印模块依赖图</th></tr>
    <tr><th>go mod init</th><th>初始化当前文件夹，创建 go.mod 文件</th></tr>
    <tr><th>go mod tidy</th><th>增加缺少的包，删除无用的包</th></tr>
    <tr><th>go mod vendor</th><th>将依赖复制到 vendor 目录下</th></tr>
    <tr><th>go mod verify</th><th>校验依赖</th></tr>
    <tr><th>go mod why</th><th>解释为什么需要依赖</th></tr>
  </tbody>
</table>

<h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h4><p>proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过 <code>go get</code>  命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。</p>
<p>目前公开的代理服务器的地址有：</p>
<ul>
<li>goproxy.io</li>
<li>goproxy.cn：（推荐）由国内的七牛云提供。</li>
</ul>
<p>Windows 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或 Linux 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言在 1.13 版本之后 GOPROXY 默认值为 <a target="_blank" rel="noopener" href="https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将">https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将</a> GOPROXY 设置为国内的 goproxy.cn。</p>
<p>使用 <code>go get</code> 命令下载指定版本的依赖包</p>
<p>执行go get 命令，在下载依赖包的同时还可以指定依赖包的版本。</p>
<ul>
<li>运行go get -u命令会将项目中的包升级到最新的次要版本或者修订版本；</li>
<li>运行go get -u=patch命令会将项目中的包升级到最新的修订版本；</li>
<li>运行go get [包名]@[版本号]命令会下载对应包的指定版本或者将对应包升级到指定的版本。</li>
</ul>
<p><strong><em>提示：<code>go get [包名]@[版本号]</code> 命令中版本号可以是 x.y.z 的形式，例如 <code>go get foo@v1.2.3</code> ，也可以是 git 上的分支或 tag，例如 <code>go get foo@master</code> ，还可以是 git 提交时的哈希值，例如 <code>go get foo@e3702bed2</code> 。</em></strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go容器</title>
    <url>/posts/5c78a85/</url>
    <content><![CDATA[<p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p>
<p>在很多语言里，容器是以标准库的方式提供，你可以随时查看这些标准库的代码，了解如何创建，删除，维护内存。</p>
<p>本章将以实用为目的，详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。本章既可以作为教程，也可以作为字典，以方便开发者日常的查询和应用。</p>
<p>其它语言中的容器:</p>
<ul>
<li>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。</li>
<li>C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。</li>
<li>C# 语言通过 .NET 框架提供，如 List 对应数组，LinkedList 对应双链表，Dictionary 对应映射。</li>
<li>Lua 语言的 table 实现了数组和映射的功能，Lua 语言默认没有双链表支持。</li>
</ul>
<h2 id="go-array"><a href="#go-array" class="headerlink" title="go array"></a>go array</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。</p>
<p>和数组对应的类型是 <code>Slice</code>（切片），<code>Slice</code> 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 <code>Slice</code> 工作原理的话需要先理解数组。</p>
<h3 id="Go语言数组的声明"><a href="#Go语言数组的声明" class="headerlink" title="Go语言数组的声明"></a>Go语言数组的声明</h3><p>数组的声明语法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var 数组变量名 [元素数量]Type</span><br></pre></td></tr></tbody></table></figure>
<p>语法说明如下所示：</p>
<ul>
<li>数组变量名：数组声明及使用时的变量名。</li>
<li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li>
<li>Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li>
</ul>
<p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 <code>len()</code> 可以返回数组中元素的个数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a [3]int             // 定义三个整数的数组</span><br><span class="line">fmt.Println(a[0])        // 打印第一个元素</span><br><span class="line">fmt.Println(a[len(a)-1]) // 打印最后一个元素</span><br><span class="line">// 打印索引和元素</span><br><span class="line">for i, v := range a {</span><br><span class="line">    fmt.Printf("%d %d\n", i, v)</span><br><span class="line">}</span><br><span class="line">// 仅打印元素</span><br><span class="line">for _, v := range a {</span><br><span class="line">    fmt.Printf("%d\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var q [3]int = [3]int{1, 2, 3}</span><br><span class="line">var r [3]int = [3]int{1, 2}</span><br><span class="line">fmt.Println(r[2]) // "0"</span><br></pre></td></tr></tbody></table></figure>
<p>在数组的定义中，如果在数组长度的位置出现“…”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q := [...]int{1, 2, 3}</span><br><span class="line">fmt.Printf("%T\n", q) // "[3]int"</span><br></pre></td></tr></tbody></table></figure>
<p>数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q := [3]int{1, 2, 3}</span><br><span class="line">q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="比较两个数组是否相等"><a href="#比较两个数组是否相等" class="headerlink" title="比较两个数组是否相等"></a>比较两个数组是否相等</h3><p>如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := [2]int{1, 2}</span><br><span class="line">b := [...]int{1, 2}</span><br><span class="line">c := [2]int{1, 3}</span><br><span class="line">fmt.Println(a == b, a == c, b == c) // "true false false"</span><br><span class="line">d := [3]int{1, 2}</span><br><span class="line">fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历数组——访问每一个数组元素"><a href="#遍历数组——访问每一个数组元素" class="headerlink" title="遍历数组——访问每一个数组元素"></a>遍历数组——访问每一个数组元素</h3><p>遍历数组也和遍历切片类似，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var team [3]string</span><br><span class="line">team[0] = "hammer"</span><br><span class="line">team[1] = "soldier"</span><br><span class="line">team[2] = "mum"</span><br><span class="line"></span><br><span class="line">for k, v := range team {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 hammer</span><br><span class="line">1 soldier</span><br><span class="line">2 mum</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。</li>
<li>第 7 行，将每个键值打印出来。</li>
</ul>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。</p>
<p>声明多维数组的语法如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var array_name [size1][size2]...[sizen] array_type</span><br></pre></td></tr></tbody></table></figure>
<p>其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。</p>
<p>以二维数组为例来简单讲解一下多维数组的使用。</p>
<p>二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。</p>
<p>【示例 1】声明二维数组:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型数组，两个维度的长度分别是 4 和 2</span><br><span class="line">var array [4][2]int</span><br><span class="line">// 使用数组字面量来声明并初始化一个二维整型数组</span><br><span class="line">array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}</span><br><span class="line">// 声明并初始化数组中索引为 1 和 3 的元素</span><br><span class="line">array = [4][2]int{1: {20, 21}, 3: {40, 41}}</span><br><span class="line">// 声明并初始化数组中指定的元素</span><br><span class="line">array = [4][2]int{1: {0: 20}, 3: {1: 41}}</span><br></pre></td></tr></tbody></table></figure>
<p>下图展示了上面示例中声明的二维数组在每次声明并初始化后包含的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Array2.gif" alt="图：二维数组及其外层数组和内层数组的值"></p>
<p>为了访问单个元素，需要反复组合使用[ ]方括号，如下所示。</p>
<p>【示例 2】为二维数组的每个元素赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个 2×2 的二维整型数组</span><br><span class="line">var array [2][2]int</span><br><span class="line">// 设置每个元素的整型值</span><br><span class="line">array[0][0] = 10</span><br><span class="line">array[0][1] = 20</span><br><span class="line">array[1][0] = 30</span><br><span class="line">array[1][1] = 40</span><br></pre></td></tr></tbody></table></figure>
<p>只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。</p>
<p>【示例 3】同样类型的多维数组赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明两个二维整型数组</span><br><span class="line">var array1 [2][2]int</span><br><span class="line">var array2 [2][2]int</span><br><span class="line">// 为array2的每个元素赋值</span><br><span class="line">array2[0][0] = 10</span><br><span class="line">array2[0][1] = 20</span><br><span class="line">array2[1][0] = 30</span><br><span class="line">array2[1][1] = 40</span><br><span class="line">// 将 array2 的值复制给 array1</span><br><span class="line">array1 = array2</span><br></pre></td></tr></tbody></table></figure>
<p>因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。</p>
<p>【示例 4】使用索引为多维数组赋值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里</span><br><span class="line">var array3 [2]int = array1[1]</span><br><span class="line">// 将数组中指定的整型值复制到新的整型变量里</span><br><span class="line">var value int = array1[1][0]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="go-slice"><a href="#go-slice" class="headerlink" title="go slice"></a>go slice</h2><p>切片（Slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p>
<p>Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slice.jpg" alt="图：切片结构和内存分配"></p>
<h3 id="从数组或切片生成新的切片"><a href="#从数组或切片生成新的切片" class="headerlink" title="从数组或切片生成新的切片"></a>从数组或切片生成新的切片</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p>
<p>从连续内存区域生成切片是常见的操作，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">slice [开始位置 : 结束位置]</span><br></pre></td></tr></tbody></table></figure>
<p>语法说明如下：</p>
<ul>
<li>slice：表示目标切片对象；</li>
<li>开始位置：对应目标切片对象的索引；</li>
<li>结束位置：对应目标切片的结束索引。</li>
</ul>
<p>从数组生成切片，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a  = [3]int{1, 2, 3}</span><br><span class="line">fmt.Println(a, a[1:2])</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]  [2]</span><br></pre></td></tr></tbody></table></figure>
<p>其中 [2] 就是 a[1:2] 切片操作的结果。</p>
<p>从数组或切片生成新的切片拥有如下特性：</p>
<ul>
<li>取出的元素数量为：结束位置 - 开始位置；</li>
<li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li>
<li>当缺省开始位置时，表示从连续区域开头到结束位置；</li>
<li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li>
<li>两者同时缺省时，与切片本身等效；</li>
<li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li>
</ul>
<p>根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。</p>
<p>下面通过实例来熟悉切片的特性。</p>
<h4 id="从指定范围中生成切片"><a href="#从指定范围中生成切片" class="headerlink" title="从指定范围中生成切片"></a>从指定范围中生成切片</h4><p>切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var highRiseBuilding [30]int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 30; i++ {</span><br><span class="line">        highRiseBuilding[i] = i + 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 区间</span><br><span class="line">fmt.Println(highRiseBuilding[10:15])</span><br><span class="line"></span><br><span class="line">// 中间到尾部的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[20:])</span><br><span class="line"></span><br><span class="line">// 开头到中间指定位置的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[:2])</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[11 12 13 14 15]</span><br><span class="line">[21 22 23 24 25 26 27 28 29 30]</span><br><span class="line">[1 2]</span><br></pre></td></tr></tbody></table></figure>
<p>代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。</p>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，尝试出租一个区间楼层。</li>
<li>第 11 行，出租 20 层以上。</li>
<li>第 14 行，出租 2 层以下，一般是商用铺面。</li>
</ul>
<p>切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p>
<h4 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h4><p>生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[:])</span><br></pre></td></tr></tbody></table></figure>
<p>a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure>
<p>重置切片，清空拥有的元素<br>把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[0:0])</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="直接声明新的切片"><a href="#直接声明新的切片" class="headerlink" title="直接声明新的切片"></a>直接声明新的切片</h3><p>除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var name []Type</span><br></pre></td></tr></tbody></table></figure>
<p>其中 name 表示切片的变量名，Type 表示切片对应的元素类型。</p>
<p>下面代码展示了切片声明的使用过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明字符串切片</span><br><span class="line">var strList []string</span><br><span class="line"></span><br><span class="line">// 声明整型切片</span><br><span class="line">var numList []int</span><br><span class="line"></span><br><span class="line">// 声明一个空切片</span><br><span class="line">var numListEmpty = []int{}</span><br><span class="line"></span><br><span class="line">// 输出3个切片</span><br><span class="line">fmt.Println(strList, numList, numListEmpty)</span><br><span class="line"></span><br><span class="line">// 输出3个切片大小</span><br><span class="line">fmt.Println(len(strList), len(numList), len(numListEmpty))</span><br><span class="line"></span><br><span class="line">// 切片判定空的结果</span><br><span class="line">fmt.Println(strList == nil)</span><br><span class="line">fmt.Println(numList == nil)</span><br><span class="line">fmt.Println(numListEmpty == nil)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[] [] []</span><br><span class="line">0 0 0</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明一个字符串切片，切片中拥有多个字符串。</li>
<li>第 5 行，声明一个整型切片，切片中拥有多个整型数值。</li>
<li>第 8 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。</li>
<li>第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。</li>
<li>第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。</li>
<li>第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。</li>
<li>第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。</li>
</ul>
<p>切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 append() 函数向切片中添加元素。</p>
<h3 id="使用-make-函数构造切片"><a href="#使用-make-函数构造切片" class="headerlink" title="使用 make() 函数构造切片"></a>使用 make() 函数构造切片</h3><p>如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make( []Type, size, cap )</span><br></pre></td></tr></tbody></table></figure>
<p>其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a := make([]int, 2)</span><br><span class="line">b := make([]int, 2, 10)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(len(a), len(b))</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[0 0] [0 0]</span><br><span class="line">2 2</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。</p>
<p>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p>
<p><strong><em>提醒:使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</em></strong></p>
<h3 id="append-为切片添加元素"><a href="#append-为切片添加元素" class="headerlink" title="append()为切片添加元素"></a>append()为切片添加元素</h3><p>Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a, 1) // 追加1个元素</span><br><span class="line">a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式</span><br><span class="line">a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包</span><br></pre></td></tr></tbody></table></figure>
<p>不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。</p>
<p>切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var numbers []int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    numbers = append(numbers, i)</span><br><span class="line">    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">len: 1  cap: 1 pointer: 0xc0420080e8</span><br><span class="line">len: 2  cap: 2 pointer: 0xc042008150</span><br><span class="line">len: 3  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 4  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 5  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 6  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 7  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 8  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 9  cap: 16 pointer: 0xc042074000</span><br><span class="line">len: 10  cap: 16 pointer: 0xc042074000</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明一个整型切片。</li>
<li>第 4 行，循环向 numbers 切片中添加 10 个数。</li>
<li>第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。</li>
</ul>
<p>通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。</p>
<p>往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。</p>
<ul>
<li>员工和工位就是切片中的元素。</li>
<li>办公地就是分配好的内存。</li>
<li>搬家就是重新分配内存。</li>
<li>无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。</li>
<li>由于搬家后地址发生变化，因此内存“地址”也会有修改。</li>
</ul>
<p>除了在切片的尾部追加，我们还可以在切片的开头添加元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = []int{1,2,3}</span><br><span class="line">a = append([]int{0}, a...) // 在开头添加1个元素</span><br><span class="line">a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片</span><br></pre></td></tr></tbody></table></figure>
<p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p>
<p>因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x</span><br><span class="line">a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片</span><br></pre></td></tr></tbody></table></figure>
<p>每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。</p>
<h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p>
<p>copy() 函数的使用格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">copy( destSlice, srcSlice []T) int</span><br></pre></td></tr></tbody></table></figure>
<p>其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。</p>
<p>下面的代码展示了使用 copy() 函数将一个切片复制到另一个切片的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">slice1 := []int{1, 2, 3, 4, 5}</span><br><span class="line">slice2 := []int{5, 4, 3}</span><br><span class="line">copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中</span><br><span class="line">copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre></td></tr></tbody></table></figure>
<p>虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题。</p>
<p>【示例】通过代码演示对切片的引用和复制操作后对切片元素的影响。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 设置元素数量为1000</span><br><span class="line">    const elementCount = 1000</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    srcData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将切片赋值</span><br><span class="line">    for i := 0; i &lt; elementCount; i++ {</span><br><span class="line">        srcData[i] = i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 引用切片数据</span><br><span class="line">    refData := srcData</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    copyData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将数据复制到新的切片空间中</span><br><span class="line">    copy(copyData, srcData)</span><br><span class="line"></span><br><span class="line">    // 修改原始数据的第一个元素</span><br><span class="line">    srcData[0] = 999</span><br><span class="line"></span><br><span class="line">    // 打印引用切片的第一个元素</span><br><span class="line">    fmt.Println(refData[0])</span><br><span class="line"></span><br><span class="line">    // 打印复制切片的第一个和最后一个元素</span><br><span class="line">    fmt.Println(copyData[0], copyData[elementCount-1])</span><br><span class="line"></span><br><span class="line">    // 复制原始数据从4到6(不包含)</span><br><span class="line">    copy(copyData, srcData[4:6])</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        fmt.Printf("%d ", copyData[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">999</span><br><span class="line">0 999</span><br><span class="line">4 5 2 3 4 5 6 7 8 9</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义元素总量为 1000。</li>
<li>第 11 行，预分配拥有 1000 个元素的整型切片，这个切片将作为原始数据。</li>
<li>第 14～16 行，将 srcData 填充 0～999 的整型值。</li>
<li>第 19 行，将 refData 引用 srcData，切片不会因为等号操作进行元素的复制。</li>
<li>第 22 行，预分配与 srcData 等大（大小相等）、同类型的切片 copyData。</li>
<li>第 24 行，使用 copy() 函数将原始数据复制到 copyData 切片空间中。</li>
<li>第 27 行，修改原始数据的第一个元素为 999。</li>
<li>第 30 行，引用数据的第一个元素将会发生变化。</li>
<li>第 33 行，打印复制数据的首位数据，由于数据是复制的，因此不会发生变化。</li>
<li>第 36 行，将 srcData 的局部数据复制到 copyData 中。</li>
<li>第 38～40 行，打印复制局部数据后的 copyData 元素。</li>
</ul>
<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。</p>
<h4 id="从开头位置删除"><a href="#从开头位置删除" class="headerlink" title="从开头位置删除"></a>从开头位置删除</h4><p>删除开头的元素可以直接移动数据指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[1:] // 删除开头1个元素</span><br><span class="line">a = a[N:] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = append(a[:0], a[1:]...) // 删除开头1个元素</span><br><span class="line">a = append(a[:0], a[N:]...) // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>还可以用 copy() 函数来删除开头的元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:copy(a, a[1:])] // 删除开头1个元素</span><br><span class="line">a = a[:copy(a, a[N:])] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure>
<h4 id="从中间位置删除"><a href="#从中间位置删除" class="headerlink" title="从中间位置删除"></a>从中间位置删除</h4><p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3, ...}</span><br><span class="line">a = append(a[:i], a[i+1:]...) // 删除中间1个元素</span><br><span class="line">a = append(a[:i], a[i+N:]...) // 删除中间N个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素</span><br></pre></td></tr></tbody></table></figure>
<h4 id="从尾部删除"><a href="#从尾部删除" class="headerlink" title="从尾部删除"></a>从尾部删除</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:len(a)-1] // 删除尾部1个元素</span><br><span class="line">a = a[:len(a)-N] // 删除尾部N个元素</span><br></pre></td></tr></tbody></table></figure>
<p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。</p>
<p>【示例】删除切片指定位置的元素。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    seq := []string{"a", "b", "c", "d", "e"}</span><br><span class="line"></span><br><span class="line">    // 指定删除位置</span><br><span class="line">    index := 2</span><br><span class="line"></span><br><span class="line">    // 查看删除位置之前的元素和之后的元素</span><br><span class="line">    fmt.Println(seq[:index], seq[index+1:])</span><br><span class="line"></span><br><span class="line">    // 将删除点前后的元素连接起来</span><br><span class="line">    seq = append(seq[:index], seq[index+1:]...)</span><br><span class="line"></span><br><span class="line">    fmt.Println(seq)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[a b] [d e]</span><br><span class="line">[a b d e]</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明一个字符串切片，保存含有从 a 到 e 的字符串。</li>
<li>第 9 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。</li>
<li>第 12 行，seq[:index] 表示的就是被删除元素的前半部分，值为 [a b]，seq[index+1:] 表示的是被删除元素的后半部分，值为 [d e]。</li>
<li>第 15 行，使用 append() 函数将两个切片连接起来。</li>
<li>第 17 行，输出连接好的新切片，此时，索引为 2 的元素已经被删除。</li>
</ul>
<p>代码的删除过程可以使用下图来描述。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceremove.jpg" alt="图：切片删除元素的操作过程"></p>
<p>Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p>
<p><strong><em>提示:连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。</em></strong></p>
<h3 id="循环迭代切片"><a href="#循环迭代切片" class="headerlink" title="循环迭代切片"></a>循环迭代切片</h3><p>通过前面的学习我们了解到切片其实就是多个相同类型元素的连续集合，既然切片是一个集合，那么我们就可以迭代其中的元素，Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每一个元素，并显示其值</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 4 行中的 index 和 value 分别用来接收 range 关键字返回的切片中每个元素的索引和值，这里的 index 和 value 不是固定的，读者也可以定义成其它的名字。</p>
<p>上面代码的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Index: 0 Value: 10</span><br><span class="line">Index: 1 Value: 20</span><br><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>当迭代切片时，关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slicerange.gif" alt="图：使用 range 迭代切片会创建每个元素的副本"></p>
<p>需要强调的是，range 返回的是每个元素的副本，而不是直接返回对该元素的引用，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示值和地址</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &amp;value, &amp;slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100</span><br><span class="line">Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104</span><br><span class="line">Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108</span><br><span class="line">Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C</span><br></pre></td></tr></tbody></table></figure>
<p>因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &amp;slice[index]）。</p>
<p>如果不需要索引值，也可以使用下划线 <code>_</code> 来忽略这个值，代码如下所示。</p>
<p>【示例 2】使用空白标识符（下划线）来忽略索引值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示其值</span><br><span class="line">for _, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d\n", value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br><span class="line">Value: 30</span><br><span class="line">Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环，代码如下所示。</p>
<p>【示例 3】使用传统的 for 循环对切片进行迭代</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 从第三个元素开始迭代每个元素</span><br><span class="line">for index := 2; index &lt; len(slice); index++ {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure>
<p>在前面几节的学习中我们了解了两个特殊的内置函数 len() 和 cap()，可以用于处理数组、切片和通道，对于切片，函数 len() 可以返回切片的长度，函数 cap() 可以返回切片的容量，在上面的示例中，使用到了函数 len() 来控制循环迭代的次数。</p>
<p>当然，range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等，这些我们将在后面的学习中详细介绍。</p>
<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>Go语言中同样允许使用多维切片，声明一个多维切片的语法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></tbody></table></figure>
<p>其中，sliceName 为切片的名字，sliceType为切片的类型，每个 <code>[ ]</code> 代表着一个维度，切片有几个维度就需要几个 <code>[ ]</code> 。</p>
<p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">//为二维切片赋值</span><br><span class="line">slice = [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码也可以简写为下面的样子。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中展示了一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片，切片 slice 的值如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerwei.gif" alt="图：整型切片的切片的值"></p>
<p>通过上图可以看到外层的切片包括两个元素，每个元素都是一个切片，第一个元素中的切片使用单个整数 10 来初始化，第二个元素中的切片包括两个整数，即 100 和 200。</p>
<p>这种组合可以让用户创建非常复杂且强大的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，前面介绍过的关于内置函数 append() 的规则也可以应用到组合后的切片上，如下所示。</p>
<p>【示例】组合切片的切片</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br><span class="line">// 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] = append(slice[0], 20)</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言里使用 append() 函数处理追加的方式很简明，先增长切片，再将新的整型切片赋值给外层切片的第一个元素，当上面代码中的操作完成后，再将切片复制到外层切片的索引为 0 的元素，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerweiappend.gif" alt="图：append 操作之后外层切片索引为 0 的元素的布局"></p>
<p>即便是这么简单的多维切片，操作时也会涉及众多的布局和值，在函数间这样传递数据结构会很复杂，不过切片本身结构很简单，可以用很小的成本在函数间传递。</p>
<h2 id="go-map"><a href="#go-map" class="headerlink" title="go map"></a>go map</h2><p>Go语言中 map 是一种特殊的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value。</p>
<p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p>
<h3 id="map-概念"><a href="#map-概念" class="headerlink" title="map 概念"></a>map 概念</h3><p>map 是引用类型，可以使用如下方式声明：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var mapname map[keytype]valuetype</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>mapname 为 map 的变量名。</li>
<li>keytype 为键类型。</li>
<li>valuetype 是键对应的值类型。</li>
</ul>
<p><strong><em>提示：[keytype] 和 valuetype 之间允许有空格。</em></strong></p>
<p>在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目。</p>
<p>【示例】</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var mapLit map[string]int</span><br><span class="line">    //var mapCreated map[string]float32</span><br><span class="line">    var mapAssigned map[string]int</span><br><span class="line">    mapLit = map[string]int{"one": 1, "two": 2}</span><br><span class="line">    mapCreated := make(map[string]float32)</span><br><span class="line">    mapAssigned = mapLit</span><br><span class="line">    mapCreated["key1"] = 4.5</span><br><span class="line">    mapCreated["key2"] = 3.14159</span><br><span class="line">    mapAssigned["two"] = 3</span><br><span class="line">    fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])</span><br><span class="line">    fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])</span><br><span class="line">    fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])</span><br><span class="line">    fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Map literal at "one" is: 1</span><br><span class="line">Map created at "key2" is: 3.14159</span><br><span class="line">Map assigned at "two" is: 3</span><br><span class="line">Map literal at "ten" is: 0</span><br></pre></td></tr></tbody></table></figure>
<p>示例中 mapLit 演示了使用 <code>{key1: value1, key2: value2}</code> 的格式来初始化 map ，就像数组和结构体一样。</p>
<p>上面代码中的 mapCreated 的创建方式 <code>mapCreated := make(map[string]float)</code> 等价于 <code>mapCreated := map[string]float{}</code> 。</p>
<p>mapAssigned 是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。</p>
<p>注意：可以使用 <code>make()</code> ，但不能使用 <code>new()</code> 来构造 map，如果错误的使用 <code>new()</code> 分配了一个引用对象，会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mapCreated := new(map[string]float)</span><br></pre></td></tr></tbody></table></figure>
<p>接下来当我们调用 <code>mapCreated["key1"] = 4.5</code> 的时候，编译器会报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">invalid operation: mapCreated["key1"] (index of type *map[string]float).</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h3><p>和数组不同，map 可以根据新增的 key-value 动态的伸缩，因此它不存在固定长度或者最大限制，但是也可以选择标明 map 的初始容量 capacity，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">make(map[keytype]valuetype, cap)</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map2 := make(map[string]float, 100)</span><br></pre></td></tr></tbody></table></figure>
<p>当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p>
<p>这里有一个 map 的具体例子，即将音阶和对应的音频映射起来：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">noteFrequency := map[string]float32 {</span><br><span class="line">"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,</span><br><span class="line">"G0": 24.50, "A0": 27.50, "B0": 30.87, "A4": 440}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="用切片作为-map-的值"><a href="#用切片作为-map-的值" class="headerlink" title="用切片作为 map 的值"></a>用切片作为 map 的值</h3><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mp1 := make(map[int][]int)</span><br><span class="line">mp2 := make(map[int]*[]int)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="map-遍历"><a href="#map-遍历" class="headerlink" title="map 遍历"></a>map 遍历</h3><p>map 的遍历过程使用 for range 循环完成，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>遍历对于Go语言的很多对象来说都是差不多的，直接使用 for range 语法即可，遍历时，可以同时获得键和值，如只遍历值，可以使用下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for _, v := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将不需要的键使用_改为匿名变量形式。</p>
<p>只遍历键时，使用下面的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for k := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>无须将值改为匿名变量形式，忽略值即可。</p>
<p><strong><em>注意：遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。</em></strong></p>
<p>如果需要特定顺序的遍历结果，正确的做法是先排序，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">// 声明一个切片保存map数据</span><br><span class="line">var sceneList []string</span><br><span class="line"></span><br><span class="line">// 将map数据遍历复制到切片中</span><br><span class="line">for k := range scene {</span><br><span class="line">    sceneList = append(sceneList, k)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 对切片进行排序</span><br><span class="line">sort.Strings(sceneList)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">fmt.Println(sceneList)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[brazil china route]</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个 map 实例，键为字符串，值为整型。</li>
<li>第 4～6 行，将 3 个键值对写入 map 中。</li>
<li>第 9 行，声明 sceneList 为字符串切片，以缓冲和排序 map 中的所有元素。</li>
<li>第 12 行，将 map 中元素的键遍历出来，并放入切片中。</li>
<li>第 17 行，对 sceneList 字符串切片进行排序，排序时，sceneList 会被修改。</li>
<li>第 20 行，输出排好序的 map 的键。</li>
</ul>
<p>sort.Strings 的作用是对传入的字符串切片进行字符串字符的升序排列，排序接口的使用将在后面的章节中介绍。</p>
<h3 id="map-删除和清空"><a href="#map-删除和清空" class="headerlink" title="map 删除和清空"></a>map 删除和清空</h3><p>Go语言提供了一个内置函数 delete()，用于删除容器内的元素，下面我们简单介绍一下如何用 delete() 函数删除 map 内的元素。</p>
<h4 id="使用-delete-函数从-map-中删除键值对"><a href="#使用-delete-函数从-map-中删除键值对" class="headerlink" title="使用 delete() 函数从 map 中删除键值对"></a>使用 delete() 函数从 map 中删除键值对</h4><p>使用 delete() 内建函数从 map 中删除一组键值对，delete() 函数的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">delete(map, 键)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 map 为要删除的 map 实例，键为要删除的 map 中键值对的键。</p>
<p>从 map 中删除一组键值对可以通过下面的代码来完成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">delete(scene, "brazil")</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">route 66</span><br><span class="line">china 960</span><br></pre></td></tr></tbody></table></figure>
<p>这个例子中使用 delete() 函数将 brazil 从 scene 这个 map 中删除了。</p>
<h4 id="清空-map-中的所有元素"><a href="#清空-map-中的所有元素" class="headerlink" title="清空 map 中的所有元素"></a>清空 map 中的所有元素</h4><p>有意思的是，Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p>
<h3 id="map的多键索引——多个数值条件可以同时查询"><a href="#map的多键索引——多个数值条件可以同时查询" class="headerlink" title="map的多键索引——多个数值条件可以同时查询"></a>map的多键索引——多个数值条件可以同时查询</h3><p>在大多数的编程语言中，映射容器的键必须以单一值存在。这种映射方法经常被用在诸如信息检索上，如根据通讯簿的名字进行检索。但随着查询条件越来越复杂，检索也会变得越发困难。下面例子中涉及通讯簿的结构，结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 人员档案</span><br><span class="line">type Profile struct {</span><br><span class="line">    Name    string   // 名字</span><br><span class="line">    Age     int      // 年龄</span><br><span class="line">    Married bool     // 已婚</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>并且准备好了一堆原始数据，需要算法实现构建索引和查询的过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    list := []*Profile{</span><br><span class="line">        {Name: "张三", Age: 30, Married: true},</span><br><span class="line">        {Name: "李四", Age: 21},</span><br><span class="line">        {Name: "王麻子", Age: 21},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildIndex(list)</span><br><span class="line"></span><br><span class="line">    queryData("张三", 30)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要用算法实现 buildIndex() 构建索引函数及 queryData() 查询数据函数，查询到结果后将数据打印出来。</p>
<p>下面，分别基于传统的基于哈希值的多键索引和利用 map 特性的多键索引进行查询。</p>
<h4 id="基于哈希值的多键索引及查询"><a href="#基于哈希值的多键索引及查询" class="headerlink" title="基于哈希值的多键索引及查询"></a>基于哈希值的多键索引及查询</h4><p>传统的数据索引过程是将输入的数据做特征值。这种特征值有几种常见做法：</p>
<ul>
<li>将特征使用某种算法转为整数，即哈希值，使用整型值做索引。</li>
<li>将特征转为字符串，使用字符串做索引。</li>
</ul>
<p>数据都基于特征值构建好索引后，就可以进行查询。查询时，重复这个过程，将查询条件转为特征值，使用特征值进行查询得到结果。</p>
<h5 id="字符串转哈希值"><a href="#字符串转哈希值" class="headerlink" title="字符串转哈希值"></a>字符串转哈希值</h5><p>查询键（classicQueryKey）的特征值需要将查询键中每一个字段转换为整型，字符串也需要转换为整型值，这里使用一种简单算法将字符串转换为需要的哈希值，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func simpleHash(str string) (ret int) {</span><br><span class="line"></span><br><span class="line">    // 遍历字符串中的每一个ASCII字符</span><br><span class="line">    for i := 0; i &lt; len(str); i++ {</span><br><span class="line">        // 取出字符</span><br><span class="line">        c := str[i]</span><br><span class="line"></span><br><span class="line">        // 将字符的ASCII码相加</span><br><span class="line">        ret += int(c)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行传入需要计算哈希值的字符串。</li>
<li>第 4 行，根据字符串的长度，遍历这个字符串的每一个字符，以 ASCII 码为单位。</li>
<li>第 9 行，c 变量的类型为 uint8，将其转为 int 类型并累加。</li>
</ul>
<p>哈希算法有很多，这里只是选用一种大家便于理解的算法。哈希算法的选用的标准是尽量减少重复键的发生，俗称“哈希冲撞”，即同样两个字符串的哈希值重复率降到最低。</p>
<h5 id="查询键"><a href="#查询键" class="headerlink" title="查询键"></a>查询键</h5><p>有了哈希算法函数后，将哈希函数用在查询键结构中。查询键结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type classicQueryKey struct {</span><br><span class="line">    Name string  // 要查询的名字</span><br><span class="line">    Age  int     // 要查询的年龄</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 计算查询键的哈希值</span><br><span class="line">func (c *classicQueryKey) hash() int {</span><br><span class="line">    // 将名字的Hash和年龄哈希合并</span><br><span class="line">    return simpleHash(c.Name) + c.Age*1000000</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明查询键的结构，查询键包含需要索引和查询的字段。</li>
<li>第 8 行，查询键的成员方法哈希，通过调用这个方法获得整个查询键的哈希值。</li>
<li>第 10 行，查询键哈希的计算方法：使用 simpleHash() 函数根据给定的名字字符串获得其哈希值。同时将年龄乘以 1000000 与名字哈希值相加。</li>
</ul>
<p>哈希值构建过程如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicQueryKey.jpg" alt="哈希值构建过程"></p>
<h5 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h5><p>本例需要快速查询，因此需要提前对已有的数据构建索引。前面已经准备好了数据查询键，使用查询键获得哈希即可对数据进行快速索引，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建哈希值到数据的索引关系</span><br><span class="line">var mapper = make(map[int][]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建数据索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有的数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建数据的查询索引</span><br><span class="line">        key := classicQueryKey{profile.Name, profile.Age}</span><br><span class="line"></span><br><span class="line">        // 计算数据的哈希值, 取出已经存在的记录</span><br><span class="line">        existValue := mapper[key.hash()]</span><br><span class="line"></span><br><span class="line">        // 将当前数据添加到已经存在的记录切片中</span><br><span class="line">        existValue = append(existValue, profile)</span><br><span class="line"></span><br><span class="line">        // 将切片重新设置到映射中</span><br><span class="line">        mapper[key.hash()] = existValue</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，实例化一个 map，键类型为整型，保存哈希值；值类型为 *Profile，为通讯簿的数据格式。</li>
<li>第 5 行，构建索引函数入口，传入数据切片。</li>
<li>第 8 行，遍历数据切片的所有数据元素。</li>
<li>第 11 行，使用查询键（classicQueryKey）来辅助计算哈希值，查询键需要填充两个字段，将数据中的名字和年龄赋值到查询键中进行保存。</li>
<li>第 14 行，使用查询键的哈希方法计算查询键的哈希值。通过这个值在 mapper 索引中查找相同哈希值的数据切片集合。因为哈希函数不能保证不同数据的哈希值一定完全不同，因此要考虑在发生哈希值重复时的处理办法。</li>
<li>第 17 行，将当前数据添加到可能存在的切片中。</li>
<li>第 20 行，将新添加好的数据切片重新赋值到相同哈希的 mapper 中。</li>
</ul>
<p>具体哈希结构如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicMap.jpg" alt="图：哈希结构"></p>
<p>这种多键的算法就是哈希算法。map 的多个元素对应哈希的“桶”。哈希函数的选择决定桶的映射好坏，如果哈希冲撞很厉害，那么就需要将发生冲撞的相同哈希值的元素使用切片保存起来。</p>
<h5 id="经典查询逻辑"><a href="#经典查询逻辑" class="headerlink" title="经典查询逻辑"></a>经典查询逻辑</h5><p>从已经构建好索引的数据中查询需要的数据流程如下：</p>
<ul>
<li>给定查询条件（名字、年龄）。</li>
<li>根据查询条件构建查询键。</li>
<li>查询键生成哈希值。</li>
<li>根据哈希值在索引中查找数据集合。</li>
<li>遍历数据集合逐个与条件比对。</li>
<li>获得结果。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据给定查询条件构建查询键</span><br><span class="line">    keyToQuery := classicQueryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 计算查询键的哈希值并查询, 获得相同哈希值的所有结果集合</span><br><span class="line">    resultList := mapper[keyToQuery.hash()]</span><br><span class="line"></span><br><span class="line">    // 遍历结果集合</span><br><span class="line">    for _, result := range resultList {</span><br><span class="line"></span><br><span class="line">        // 与查询结果比对, 确认找到打印结果</span><br><span class="line">        if result.Name == name &amp;&amp; result.Age == age {</span><br><span class="line">            fmt.Println(result)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 没有查询到时, 打印结果</span><br><span class="line">    fmt.Println("no found")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，查询条件（名字、年龄）。</li>
<li>第 4 行，根据查询条件构建查询键。</li>
<li>第 7 行，使用查询键计算哈希值，使用哈希值查询相同哈希值的所有数据集合。</li>
<li>第 10 行，遍历所有相同哈希值的数据集合。</li>
<li>第 13 行，将每个数据与查询条件进行比对，如果一致，表示已经找到结果，打印并返回。</li>
<li>第 20 行，没有找到记录时，打印 no found。</li>
</ul>
<h4 id="利用-map-特性的多键索引及查询"><a href="#利用-map-特性的多键索引及查询" class="headerlink" title="利用 map 特性的多键索引及查询"></a>利用 map 特性的多键索引及查询</h4><p>使用结构体进行多键索引和查询比传统的写法更为简单，最主要的区别是无须准备哈希函数及相应的字段无须做哈希合并。看下面的实现流程。</p>
<h5 id="经典构建索引"><a href="#经典构建索引" class="headerlink" title="经典构建索引"></a>经典构建索引</h5><p>代码如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type queryKey struct {</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建查询键到数据的映射</span><br><span class="line">var mapper = make(map[queryKey]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建查询索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建查询键</span><br><span class="line">        key := queryKey{</span><br><span class="line">            Name: profile.Name,</span><br><span class="line">            Age:  profile.Age,</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 保存查询键</span><br><span class="line">        mapper[key] = profile</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，与基于哈希值的查询键的结构相同。</li>
<li>第 8 行，在 map 的键类型上，直接使用了查询键结构体。注意，这里不使用查询键的指针。同时，结果只有 <code>*Profile</code> 类型，而不是 <code>*Profile</code> 切片，表示查到的结果唯一。</li>
<li>第 17 行，类似的，使用遍历到的数据的名字和年龄构建查询键。</li>
<li>第 23 行，更简单的，直接将查询键保存对应的数据。</li>
</ul>
<h5 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 根据条件查询数据</span><br><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据查询条件构建查询键</span><br><span class="line">    key := queryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 根据键值查询数据</span><br><span class="line">    result, ok := mapper[key]</span><br><span class="line"></span><br><span class="line">    // 找到数据打印出来</span><br><span class="line">    if ok {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("no found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行，根据查询条件（名字、年龄）构建查询键。</li>
<li>第 8 行，直接使用查询键在 map 中查询结果。</li>
<li>第 12 行，找到结果直接打印。</li>
<li>第 14 行，没有找到结果打印 no found。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>基于哈希值的多键索引查询和利用 map 特性的多键索引查询的代码复杂程度显而易见。聪明的程序员都会利用 Go语言的特性进行快速的多键索引查询。</p>
<p>其实，利用 map 特性的例子中的 map 类型即便修改为下面的格式，也一样可以获得同样的结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var mapper = make(map[interface{}]*Profile)</span><br></pre></td></tr></tbody></table></figure>
<p>代码量大大减少的关键是：Go语言的底层会为 map 的键自动构建哈希值。能够构建哈希值的类型必须是非动态类型、非指针、函数、闭包。</p>
<ul>
<li>非动态类型：可用数组，不能用切片。</li>
<li>非指针：每个指针数值都不同，失去哈希意义。</li>
<li>函数、闭包不能作为 map 的键。</li>
</ul>
<h3 id="sync-Map（同步map"><a href="#sync-Map（同步map" class="headerlink" title="sync.Map（同步map)"></a>sync.Map（同步map)</h3><p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p>
<p>下面来看下并发情况下读写 map 时会出现的问题，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 创建一个int到int的映射</span><br><span class="line">m := make(map[int]int)</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行写入</span><br><span class="line">    for {</span><br><span class="line">        m[1] = 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行读取</span><br><span class="line">    for {</span><br><span class="line">        _ = m[1]</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 无限循环, 让并发程序在后台执行</span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码会报错，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></tbody></table></figure>
<p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p>
<p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<p>sync.Map 有以下特性：</p>
<ul>
<li>无须初始化，直接声明即可。</li>
<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
<li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li>
</ul>
<p>并发安全的 sync.Map 演示代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">      "fmt"</span><br><span class="line">      "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var scene sync.Map</span><br><span class="line"></span><br><span class="line">    // 将键值对保存到sync.Map</span><br><span class="line">    scene.Store("greece", 97)</span><br><span class="line">    scene.Store("london", 100)</span><br><span class="line">    scene.Store("egypt", 200)</span><br><span class="line"></span><br><span class="line">    // 从sync.Map中根据键取值</span><br><span class="line">    fmt.Println(scene.Load("london"))</span><br><span class="line"></span><br><span class="line">    // 根据键删除对应的键值对</span><br><span class="line">    scene.Delete("london")</span><br><span class="line"></span><br><span class="line">    // 遍历所有sync.Map中的键值对</span><br><span class="line">    scene.Range(func(k, v interface{}) bool {</span><br><span class="line"></span><br><span class="line">        fmt.Println("iterate:", k, v)</span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100 true</span><br><span class="line">iterate: egypt 200</span><br><span class="line">iterate: greece 97</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，声明 scene，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li>
<li>第 13～15 行，将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li>
<li>第 18 行，提供一个 sync.Map 的键给 scene.Load() 方法后将查询到键对应的值返回。</li>
<li>第 21 行，sync.Map 的 Delete 可以使用指定的键将对应的键值对删除。</li>
<li>第 24 行，Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li>
</ul>
<p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>
<h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h2><p>列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p>
<p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.jpg" alt="图：三人单向通知电话号码形成单链表结构"></p>
<p>如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.jpg" alt="图：三人相互通知电话号码形成双链表结构"></p>
<p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。</p>
<p>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/removelinklist.jpg" alt="图：从双链表中删除一人的电话号码"></p>
<p>在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</p>
<p>1) 通过 container/list 包的 New() 函数初始化 list</p>
<figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></tbody></table></figure>
<p>2) 通过 var 关键字声明初始化 list</p>
<figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">var 变量名 list.List</span><br></pre></td></tr></tbody></table></figure>
<p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。</p>
<h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。</p>
<p><strong><em>提示：这两个方法都会返回一个 `</em>list.Element<code>结构，如果在以后的使用中需要删除插入的元素，则只能通过</code><em>list.Element` 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。</em></strong></p>
<p>下面代码展示如何给 list 添加元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack("fist")</span><br><span class="line">l.PushFront(67)</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个列表实例。</li>
<li>第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。</li>
<li>第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。</li>
</ul>
<p>列表插入元素的方法如下表所示。</p>
<table>
  <thead><tr><th>方  法</th><th>功  能</th></tr></thead>
  <tbody>
    <tr><th>InsertAfter(v interface {}, mark * Element) * Element</th><th>在 mark 点之后插入元素，mark 点由其他插入函数提供</th></tr>
    <tr><th>InsertBefore(v interface {}, mark * Element) *Element</th><th>在 mark 点之前插入元素，mark 点由其他插入函数提供</th></tr>
    <tr><th>PushBackList(other *List)</th><th>添加 other 列表元素到尾部</th></tr>
    <tr><th>PushFrontList(other *List)</th><th>添加 other 列表元素到头部</th></tr>
  </tbody>
</table>

<h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。</p>
<p>列表操作元素：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "container/list"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    // 尾部添加</span><br><span class="line">    l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">    // 头部添加</span><br><span class="line">    l.PushFront(67)</span><br><span class="line"></span><br><span class="line">    // 尾部添加后保存元素句柄</span><br><span class="line">    element := l.PushBack("fist")</span><br><span class="line"></span><br><span class="line">    // 在fist之后添加high</span><br><span class="line">    l.InsertAfter("high", element)</span><br><span class="line"></span><br><span class="line">    // 在fist之前添加noon</span><br><span class="line">    l.InsertBefore("noon", element)</span><br><span class="line"></span><br><span class="line">    // 使用</span><br><span class="line">    l.Remove(element)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，创建列表实例。</li>
<li>第 9 行，将字符串 canon 插入到列表的尾部。</li>
<li>第 12 行，将数值 67 添加到列表的头部。</li>
<li>第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。</li>
<li>第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。</li>
<li>第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。</li>
<li>第 24 行，移除 element 变量对应的元素。</li>
</ul>
<p>下表中展示了每次操作后列表的实际元素情况。</p>
<p>列表元素操作的过程</p>
<table>
  <thead><tr><th>操作内容</th><th>列表元素</th></tr></thead>
  <tbody>
    <tr><th>l.PushBack("canon")</th><th>canon</th></tr>
    <tr><th>l.PushFront(67)</th><th>67, canon</th></tr>
    <tr><th>element := l.PushBack("fist")</th><th>67, canon, fist</th></tr>
    <tr><th>l.InsertAfter("high", element)</th><th>67, canon, fist, high</th></tr>
    <tr><th>l.InsertBefore("noon", element)</th><th>67, canon, noon, fist, high</th></tr>
    <tr><th>l.Remove(element)</th><th>67, canon, noon, high</th></tr>
  </tbody>
</table>

<h3 id="遍历列表——访问列表的每一个元素"><a href="#遍历列表——访问列表的每一个元素" class="headerlink" title="遍历列表——访问列表的每一个元素"></a>遍历列表——访问列表的每一个元素</h3><p>遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">// 尾部添加</span><br><span class="line">l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">// 头部添加</span><br><span class="line">l.PushFront(67)</span><br><span class="line"></span><br><span class="line">for i := l.Front(); i != nil; i = i.Next() {</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">67</span><br><span class="line">canon</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，创建一个列表实例。</li>
<li>第 4 行，将 canon 放入列表尾部。</li>
<li>第 7 行，在队列头部放入 67。</li>
<li>第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。</li>
<li>第 10 行，使用遍历返回的 <code>*list.Element</code> 的 Value 成员取得放入列表时的原值。</li>
</ul>
<h2 id="go-nil：空值-零值"><a href="#go-nil：空值-零值" class="headerlink" title="go nil：空值/零值"></a>go nil：空值/零值</h2><p>在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串””，而指针、切片、映射、通道、函数和接口的零值则是 nil。</p>
<p>nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。</p>
<p>下面通过几个方面来介绍一下Go语言中 nil。</p>
<h3 id="nil-标识符是不能比较的"><a href="#nil-标识符是不能比较的" class="headerlink" title="nil 标识符是不能比较的"></a>nil 标识符是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(nil==nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:8:21: invalid operation: nil == nil (operator == not defined on nil)</span><br></pre></td></tr></tbody></table></figure>
<p>这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; None == None</span><br><span class="line">True</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的运行结果不难看出，== 对于 nil 来说是一种未定义的操作。</p>
<h3 id="nil-不是关键字或保留字"><a href="#nil-不是关键字或保留字" class="headerlink" title="nil 不是关键字或保留字"></a>nil 不是关键字或保留字</h3><p>nil 并不是Go语言的关键字或者保留字，也就是说我们可以定义一个名称为 nil 的变量，比如下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var nil = errors.New("my god")</span><br></pre></td></tr></tbody></table></figure>
<p>虽然上面的声明语句可以通过编译，但是并不提倡这么做。</p>
<h3 id="nil-没有默认类型"><a href="#nil-没有默认类型" class="headerlink" title="nil 没有默认类型"></a>nil 没有默认类型</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%T", nil)</span><br><span class="line">    print(nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:9:10: use of untyped nil</span><br></pre></td></tr></tbody></table></figure>
<h3 id="不同类型-nil-的指针是一样的"><a href="#不同类型-nil-的指针是一样的" class="headerlink" title="不同类型 nil 的指针是一样的"></a>不同类型 nil 的指针是一样的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var arr []int</span><br><span class="line">    var num *int</span><br><span class="line">    fmt.Printf("%p\n", arr)</span><br><span class="line">    fmt.Printf("%p", num)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0x0</span><br><span class="line">0x0</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出 arr 和 num 的指针都是 0x0。</p>
<h3 id="不同类型的-nil-是不能比较的"><a href="#不同类型的-nil-是不能比较的" class="headerlink" title="不同类型的 nil 是不能比较的"></a>不同类型的 nil 是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    fmt.Printf(m == ptr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:20: invalid operation: arr == ptr (mismatched types []int and *int)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="两个相同类型的-nil-值也可能无法比较"><a href="#两个相同类型的-nil-值也可能无法比较" class="headerlink" title="两个相同类型的 nil 值也可能无法比较"></a>两个相同类型的 nil 值也可能无法比较</h3><p>在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的，下面的语句无法编译。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    var s2 []int</span><br><span class="line">    fmt.Printf(s1 == s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:19: invalid operation: s1 == s2 (slice can only be compared to nil)</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的错误提示可以看出，能够将上述不可比较类型的空值直接与 nil 标识符进行比较，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    fmt.Println(s1 == nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<h3 id="nil-是-map、slice、pointer、channel、func、interface-的零值"><a href="#nil-是-map、slice、pointer、channel、func、interface-的零值" class="headerlink" title="nil 是 map、slice、pointer、channel、func、interface 的零值"></a>nil 是 map、slice、pointer、channel、func、interface 的零值</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    var c chan int</span><br><span class="line">    var sl []int</span><br><span class="line">    var f func()</span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Printf("%#v\n", m)</span><br><span class="line">    fmt.Printf("%#v\n", ptr)</span><br><span class="line">    fmt.Printf("%#v\n", c)</span><br><span class="line">    fmt.Printf("%#v\n", sl)</span><br><span class="line">    fmt.Printf("%#v\n", f)</span><br><span class="line">    fmt.Printf("%#v\n", i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">map[int]string(nil)</span><br><span class="line">(*int)(nil)</span><br><span class="line">(chan int)(nil)</span><br><span class="line">[]int(nil)</span><br><span class="line">(func())(nil)</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>零值是Go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值。</p>
<h3 id="不同类型的-nil-值占用的内存大小可能是不一样的"><a href="#不同类型的-nil-值占用的内存大小可能是不一样的" class="headerlink" title="不同类型的 nil 值占用的内存大小可能是不一样的"></a>不同类型的 nil 值占用的内存大小可能是不一样的</h3><p>一个类型的所有的值的内存布局都是一样的，nil 也不例外，nil 的大小与同类型中的非 nil 类型的大小是一样的。但是不同类型的 nil 值的大小可能不同。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "unsafe"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var p *struct{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( p ) ) // 8</span><br><span class="line"></span><br><span class="line">    var s []int</span><br><span class="line">    fmt.Println( unsafe.Sizeof( s ) ) // 24</span><br><span class="line"></span><br><span class="line">    var m map[int]bool</span><br><span class="line">    fmt.Println( unsafe.Sizeof( m ) ) // 8</span><br><span class="line"></span><br><span class="line">    var c chan string</span><br><span class="line">    fmt.Println( unsafe.Sizeof( c ) ) // 8</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line">    fmt.Println( unsafe.Sizeof( f ) ) // 8</span><br><span class="line"></span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( i ) ) // 16</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">8</span><br><span class="line">24</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure>
<p>具体的大小取决于编译器和架构，上面打印的结果是在 64 位架构和标准编译器下完成的，对应 32 位的架构的，打印的大小将减半。</p>
<h2 id="make和new关键字的区别及实现原理"><a href="#make和new关键字的区别及实现原理" class="headerlink" title="make和new关键字的区别及实现原理"></a>make和new关键字的区别及实现原理</h2><p>Go语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化，下面我们就来具体介绍一下。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>在Go语言中，new 函数描述如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="line">// not a value, and the value returned is a pointer to a newly</span><br><span class="line">// allocated zero value of that type.</span><br><span class="line">func new(Type) *Type</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。</p>
<p>【示例】使用 new 函数为变量分配内存空间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var sum *int</span><br><span class="line">sum = new(int) //分配空间</span><br><span class="line">*sum = 98</span><br><span class="line">fmt.Println(*sum)</span><br></pre></td></tr></tbody></table></figure>
<p>当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Student struct {</span><br><span class="line">   name string</span><br><span class="line">   age int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var s *Student</span><br><span class="line">s = new(Student) //分配空间</span><br><span class="line">s.name ="dequan"</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure>
<p>这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277]</span><br><span class="line">goroutine 1 [running]:</span><br></pre></td></tr></tbody></table></figure>
<p>这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p>
<p>在Go语言中，make 函数的描述如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// The make built-in function allocates and initializes an object of type</span><br><span class="line">// slice, map, or chan (only). Like new, the first argument is a type, not a</span><br><span class="line">// value. Unlike new, make's return type is the same as the type of its</span><br><span class="line">// argument, not a pointer to it. The specification of the result depends on</span><br><span class="line">// the type:</span><br><span class="line">// Slice: The size specifies the length. The capacity of the slice is</span><br><span class="line">// equal to its length. A second integer argument may be provided to</span><br><span class="line">// specify a different capacity; it must be no smaller than the</span><br><span class="line">// length, so make([]int, 0, 10) allocates a slice of length 0 and</span><br><span class="line">// capacity 10.</span><br><span class="line">// Map: An empty map is allocated with enough space to hold the</span><br><span class="line">// specified number of elements. The size may be omitted, in which case</span><br><span class="line">// a small starting size is allocated.</span><br><span class="line">// Channel: The channel's buffer is initialized with the specified</span><br><span class="line">// buffer capacity. If zero, or the size is omitted, the channel is</span><br><span class="line">// unbuffered.</span><br><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></tbody></table></figure>
<p>通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。</p>
<p><strong><em>注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。</em></strong></p>
<p>Go语言中的 new 和 make 主要区别如下：</p>
<ul>
<li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；</li>
<li>new 分配返回的是指针，即类型 <code>*Type</code> 。make 返回引用，即 Type；</li>
<li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>接下来我们将分别介绍一下 make 和 new 在初始化不同<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。</p>
<h4 id="make原理"><a href="#make原理" class="headerlink" title="make原理"></a>make原理</h4><p>我们已经了解了 make 在创建 slice、map 和 channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>初始化原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/maketypecheck.gif" alt="GOLang Make TypeCheck"></p>
<p>在编译期的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。</p>
<h4 id="new原理"><a href="#new原理" class="headerlink" title="new原理"></a>new原理</h4><p>内置函数 new 会在编译期的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func callnew(t *types.Type) *Node {</span><br><span class="line">    if t.NotInHeap() {</span><br><span class="line">        yyerror("%v is go:notinheap; heap allocation disallowed", t)</span><br><span class="line">    }</span><br><span class="line">    dowidth(t)</span><br><span class="line"></span><br><span class="line">    if t.Size() == 0 {</span><br><span class="line">        z := newname(Runtimepkg.Lookup("zerobase"))</span><br><span class="line">        z.SetClass(PEXTERN)</span><br><span class="line">        z.Type = t</span><br><span class="line">        return typecheck(nod(OADDR, z, nil), ctxExpr)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fn := syslook("newobject")</span><br><span class="line">    fn = substArgTypes(fn, t)</span><br><span class="line">    v := mkcall1(fn, types.NewPtr(t), nil, typename(t))</span><br><span class="line">    v.SetNonNil(true)</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func walkstmt(n *Node) *Node {</span><br><span class="line">    switch n.Op {</span><br><span class="line">    case ODCL:</span><br><span class="line">        v := n.Left</span><br><span class="line">        if v.Class() == PAUTOHEAP {</span><br><span class="line">            if prealloc[v] == nil {</span><br><span class="line">                prealloc[v] = callnew(v.Type)</span><br><span class="line">            }</span><br><span class="line">            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])</span><br><span class="line">            nn.SetColas(true)</span><br><span class="line">            nn = typecheck(nn, ctxStmt)</span><br><span class="line">            return walkstmt(nn)</span><br><span class="line">        }</span><br><span class="line">    case ONEW:</span><br><span class="line">        if n.Esc == EscNone {</span><br><span class="line">            r := temp(n.Type.Elem())</span><br><span class="line">            r = nod(OAS, r, nil)</span><br><span class="line">            r = typecheck(r, ctxStmt)</span><br><span class="line">            init.Append(r)</span><br><span class="line">            r = nod(OADDR, r.Left, nil)</span><br><span class="line">            r = typecheck(r, ctxExpr)</span><br><span class="line">            n = r</span><br><span class="line">        } else {</span><br><span class="line">            n = callnew(n.Type.Elem())</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。</p>
<p>newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func newobject(typ *_type) unsafe.Pointer {</span><br><span class="line">    return mallocgc(typ.size, typ, true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="make-和new-总结"><a href="#make-和new-总结" class="headerlink" title="make 和new 总结"></a>make 和new 总结</h3><p>最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>容器</tag>
        <tag>集合</tag>
        <tag>数组</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>Go流程控制</title>
    <url>/posts/91175219/</url>
    <content><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<p>Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。另外，还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号{}括起来的代码块，否则就忽略该代码块继续执行后续的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">} else {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第三个分支，则可以使用下面这种三个独立分支的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if condition1 {</span><br><span class="line">    // do something</span><br><span class="line">} else if condition2 {</span><br><span class="line">    // do something else</span><br><span class="line">}else {</span><br><span class="line">    // catch-all or default</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。</p>
<p>关键字 if 和 else 之后的左大括号 <code>{</code> 必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号 <code>}</code> 必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p>
<p>非法的 Go 代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if x{</span><br><span class="line">}</span><br><span class="line">else { // 无效的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号 <code>}</code> 与对应的 if 关键字垂直对齐。</p>
<p>在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过下面的例子来了解 if 的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var ten int = 11</span><br><span class="line">if ten &gt; 10 {</span><br><span class="line">    fmt.Println("&gt;10")</span><br><span class="line">} else {</span><br><span class="line">    fmt.Println("&lt;=10")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明整型变量并赋值 11。</li>
<li>第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。</li>
<li>第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。</li>
</ul>
<h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">if err := Connect(); err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p>
<p>err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p>
<p>这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</p>
<p><strong><em>提示:在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</em></strong></p>
<h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for (循环结构)"></a>for (循环结构)</h2><p>与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 C++ 中非常接近：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    sum += i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号()括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 <code>for(;;){}</code> 和 <code>do{} while(1);</code> ，而直接简化为如下的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for {</span><br><span class="line">    sum++</span><br><span class="line">    if sum &gt; 100 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用循环语句时，需要注意的有以下几点：</p>
<ul>
<li>左花括号 <code>{</code> 必须与 for 处于同一行。</li>
<li>Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li>
<li>Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ {</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        if i &gt; 5 {</span><br><span class="line">            break JLoop</span><br><span class="line">        }</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">JLoop:</span><br><span class="line">// ...</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，break 语句终止的是 JLoop 标签处的外层循环。</p>
<h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。</p>
<p>初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">step := 2</span><br><span class="line">for ; step &gt; 0; step-- {</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p>
<h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。</p>
<h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><p>下面代码忽略条件表达式，但是保留结束语句，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for ; ; i++ {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。</li>
<li>第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。</li>
</ul>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>上面的代码还可以改写为更美观的写法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。</li>
<li>第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。</li>
</ul>
<p>无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。</p>
<h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><p>在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for i &lt;= 10 {</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在代码第 3 行中，将之前使用 <code>if i&gt;10{}</code> 判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。</p>
<p>上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p>
<h3 id="输出九九乘法表"><a href="#输出九九乘法表" class="headerlink" title="输出九九乘法表"></a>输出九九乘法表</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 遍历, 决定处理第几行</span><br><span class="line">    for y := 1; y &lt;= 9; y++ {</span><br><span class="line"></span><br><span class="line">        // 遍历, 决定这一行有多少列</span><br><span class="line">        for x := 1; x &lt;= y; x++ {</span><br><span class="line">            fmt.Printf("%d*%d=%d ", x, y, x*y)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 手动生成回车</span><br><span class="line">        fmt.Println()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2 2*2=4</span><br><span class="line">1*3=3 2*3=6 3*3=9</span><br><span class="line">1*4=4 2*4=8 3*4=12 4*4=16</span><br><span class="line">1*5=5 2*5=10 3*5=15 4*5=20 5*5=25</span><br><span class="line">1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36</span><br><span class="line">1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49</span><br><span class="line">1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64</span><br><span class="line">1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，生成 1～9 的数字，对应乘法表的每一行，也就是被乘数。</li>
<li>第 11 行，乘法表每一行中的列数随着行数的增加而增加，这一行的 x 表示该行有多少列。</li>
<li>第 16 行，打印一个空行，实际作用就是换行。</li>
</ul>
<p>这段程序按行优先打印，打印完一行，换行（第 16 行），接着执行下一行乘法表直到整个数值循环完毕。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, val := range coll {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for pos, char := range str {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每个 rune 字符和索引在 for range 循环中是一一对应的，它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。</p>
<p>通过 for range 遍历的返回值有一定的规律：</p>
<ul>
<li>数组、切片、字符串返回索引和值。</li>
<li>map 返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ul>
<h3 id="遍历数组、切片——获得索引和值"><a href="#遍历数组、切片——获得索引和值" class="headerlink" title="遍历数组、切片——获得索引和值"></a>遍历数组、切片——获得索引和值</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, value := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d  value:%d\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0  value:1</span><br><span class="line">key:1  value:2</span><br><span class="line">key:2  value:3</span><br><span class="line">key:3  value:4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历字符串——获得字符"><a href="#遍历字符串——获得字符" class="headerlink" title="遍历字符串——获得字符"></a>遍历字符串——获得字符</h3><p>Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。</p>
<p>下面这段代码展示了如何遍历字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var str = "hello 你好"</span><br><span class="line">for key, value := range str {</span><br><span class="line">    fmt.Printf("key:%d value:0x%x\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0 value:0x68</span><br><span class="line">key:1 value:0x65</span><br><span class="line">key:2 value:0x6c</span><br><span class="line">key:3 value:0x6c</span><br><span class="line">key:4 value:0x6f</span><br><span class="line">key:5 value:0x20</span><br><span class="line">key:6 value:0x4f60</span><br><span class="line">key:9 value:0x597d</span><br></pre></td></tr></tbody></table></figure>
<p>代码中的变量 value，实际类型是 rune 类型，以十六进制打印出来就是字符的编码。</p>
<h3 id="遍历-map——获得-map-的键和值"><a href="#遍历-map——获得-map-的键和值" class="headerlink" title="遍历 map——获得 map 的键和值"></a>遍历 map——获得 map 的键和值</h3><p>对于 map 类型来说，for range 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们是一对一对出现的，下面的代码演示了如何遍历 map。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for key, value := range m {</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello 100</span><br><span class="line">world 200</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</em></strong></p>
<h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p>for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。</p>
<p>下面代码为我们展示了通道的遍历：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    c &lt;- 1</span><br><span class="line">    c &lt;- 2</span><br><span class="line">    c &lt;- 3</span><br><span class="line">    close(c)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">for v := range c {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行创建了一个整型类型的通道。</li>
<li>第 3 行启动了一个 goroutine，其逻辑的实现体现在第 5～8 行，实现功能是往通道中推送数据 1、2、3，然后结束并关闭通道。</li>
<li>这段 goroutine 在声明结束后，在第 9 行马上被执行。</li>
<li>从第 11 行开始，使用 for range 对通道 c 进行遍历，其实就是不断地从通道中取数据，直到通道被关闭。</li>
</ul>
<h3 id="在遍历中选择希望获得的变量"><a href="#在遍历中选择希望获得的变量" class="headerlink" title="在遍历中选择希望获得的变量"></a>在遍历中选择希望获得的变量</h3><p>在使用 for range 循环遍历某个对象时，一般不会同时需要 key 或者 value，这个时候可以采用一些技巧，让代码变得更简单，下面将前面的例子修改一下，参考下面的代码示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, value := range m {</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子中将 key 变成了下划线 <code>_</code> ，这里的下划线就是匿名变量。</p>
<ul>
<li>可以理解为一种占位符。</li>
<li>匿名变量本身不会进行空间分配，也不会占用一个变量的名字。</li>
<li>在 for range 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li>
</ul>
<p>再看一个匿名变量的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for key, _ := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d \n", key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">key:0</span><br><span class="line">key:1</span><br><span class="line">key:2</span><br><span class="line">key:3</span><br></pre></td></tr></tbody></table></figure>
<p>在该例子中，value 被设置为匿名变量，只使用 key，而 key 本身就是切片的索引，所以例子输出索引。</p>
<p>我们总结一下 for 的功能：</p>
<ul>
<li>Go语言的 for 包含初始化语句、条件表达式、结束语句，这 3 个部分均可缺省。</li>
<li>for range 支持对数组、切片、字符串、map、通道进行遍历操作。</li>
<li>在需要时，可以使用匿名变量对 for range 的变量进行选取。</li>
</ul>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p>
<p>相对于C语言和 Java 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。</p>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = "hello"</span><br><span class="line">switch a {</span><br><span class="line">case "hello":</span><br><span class="line">    fmt.Println(1)</span><br><span class="line">case "world":</span><br><span class="line">    fmt.Println(2)</span><br><span class="line">default:</span><br><span class="line">    fmt.Println(0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。</p>
<h4 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h4><p>当出现多个 case 要放在一起的时候，可以写成下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var a = "mum"</span><br><span class="line">switch a {</span><br><span class="line">case "mum", "daddy":</span><br><span class="line">    fmt.Println("family")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不同的 case 表达式使用逗号分隔。</p>
<h4 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h4><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var r int = 11</span><br><span class="line">switch {</span><br><span class="line">case r &gt; 10 &amp;&amp; r &lt; 20:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意，这种情况的 switch 后面不再需要跟判断变量。</p>
<h3 id="跨越-case-的-fallthrough——兼容C语言的-case-设计"><a href="#跨越-case-的-fallthrough——兼容C语言的-case-设计" class="headerlink" title="跨越 case 的 fallthrough——兼容C语言的 case 设计"></a>跨越 case 的 fallthrough——兼容C语言的 case 设计</h3><p>在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">var s = "hello"</span><br><span class="line">switch {</span><br><span class="line">case s == "hello":</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">    fallthrough</span><br><span class="line">case s != "world":</span><br><span class="line">    fmt.Println("world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure>
<p>新编写的代码，不建议使用 fallthrough。</p>
<h2 id="goto语句——跳转到指定的标签"><a href="#goto语句——跳转到指定的标签" class="headerlink" title="goto语句——跳转到指定的标签"></a>goto语句——跳转到指定的标签</h2><p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p>
<h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var breakAgain bool</span><br><span class="line"></span><br><span class="line">    // 外循环</span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        // 内循环</span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            // 满足某个条件时, 退出循环</span><br><span class="line">            if y == 2 {</span><br><span class="line"></span><br><span class="line">                // 设置退出标记</span><br><span class="line">                breakAgain = true</span><br><span class="line"></span><br><span class="line">                // 退出本次循环</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 根据标记, 还需要退出一次循环</span><br><span class="line">        if breakAgain {</span><br><span class="line">                break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，构建外循环。</li>
<li>第 13 行，构建内循环。</li>
<li>第 16 行，当 y==2 时需要退出所有的 for 循环。</li>
<li>第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。</li>
<li>第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。</li>
<li>第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。</li>
<li>第 34 行，退出所有循环后，打印 done。</li>
</ul>
<p>将上面的代码使用Go语言的 goto 语句进行优化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            if y == 2 {</span><br><span class="line">                // 跳转到标签</span><br><span class="line">                goto breakHere</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 手动返回, 避免执行进入标签</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">    // 标签</span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。</li>
<li>第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。</li>
<li>第 23 行，定义 breakHere 标签。</li>
</ul>
<p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p>
<h3 id="使用-goto-集中处理错误"><a href="#使用-goto-集中处理错误" class="headerlink" title="使用 goto 集中处理错误"></a>使用 goto 集中处理错误</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = secondCheckError()</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println("done")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，执行某逻辑，返回错误。</li>
<li>第 2～6 行，如果发生错误，打印错误退出进程。</li>
<li>第 8 行，执行某逻辑，返回错误。</li>
<li>第 10～14 行，发生错误后退出流程。</li>
<li>第 16 行，没有任何错误，打印完成。</li>
</ul>
<p>在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。</p>
<p>使用 goto 语句来实现同样的逻辑：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> err := firstCheckError()</span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = secondCheckError()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。</li>
<li>第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。</li>
</ul>
<h2 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h2><p>Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。</p>
<p>跳出指定循环：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            case 3:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，外层循环的标签。</li>
<li>第 8 行和第 9 行，双层循环。</li>
<li>第 10 行，使用 switch 进行数值分支判断。</li>
<li>第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。</li>
</ul>
<h2 id="continue（继续下一次循环）"><a href="#continue（继续下一次循环）" class="headerlink" title="continue（继续下一次循环）"></a>continue（继续下一次循环）</h2><p>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line"></span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。</li>
</ul>
<h3 id="示例：聊天机器人"><a href="#示例：聊天机器人" class="headerlink" title="示例：聊天机器人"></a>示例：聊天机器人</h3><p>结合咱们之前的学习，本节带领大家来编写一个聊天机器人的雏形，下面的代码中展示了一个简单的聊天程序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 准备从标准输入读取数据。</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println("Please input your name:")</span><br><span class="line">    // 读取数据直到碰到 \n 为止。</span><br><span class="line">    input, err := inputReader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">        // 异常退出。</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    } else {</span><br><span class="line">        // 用切片操作删除最后的 \n 。</span><br><span class="line">        name := input[:len(input)-2]</span><br><span class="line">        fmt.Printf("Hello, %s! What can I do for you?\n", name)</span><br><span class="line">    }</span><br><span class="line">    for {</span><br><span class="line">        input, err = inputReader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        input = input[:len(input)-2]</span><br><span class="line">        // 全部转换为小写。</span><br><span class="line">        input = strings.ToLower(input)</span><br><span class="line">        switch input {</span><br><span class="line">        case "":</span><br><span class="line">            continue</span><br><span class="line">        case "nothing", "bye":</span><br><span class="line">            fmt.Println("Bye!")</span><br><span class="line">            // 正常退出。</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println("Sorry, I didn't catch you.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个聊天程序在问候用户之后会不断地询问“是否可以帮忙”，但是实际上它什么忙也帮不上，因为它现在什么也听不懂，除了 nothing 和 bye，一看到这两个词，它就会与用户“道别”，停止运行，现在试运行一下这个命令源码文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Please input your name:</span><br><span class="line">Robert</span><br><span class="line">Hello, Robert! What can I do for you?</span><br><span class="line">A piece of cake , please .</span><br><span class="line">Sorry, I didn't catch you.</span><br><span class="line">bye</span><br><span class="line">Bye!</span><br></pre></td></tr></tbody></table></figure>
<p>注意，其中的“-&gt;”符号之后的内容是我们输入的。</p>
<h3 id="示例：词频统计"><a href="#示例：词频统计" class="headerlink" title="示例：词频统计"></a>示例：词频统计</h3><p>从数据挖掘到语言学习本身，文本分析功能的应用非常广泛，本一节我们来分析一个例子，它是文本分析最基本的一种形式：统计出一个文件里单词出现的频率。</p>
<p>示例中频率统计后的结果以两种不同的方式显示，一种是将单词按照字母顺序把单词和频率排列出来，另一种是按照有序列表的方式把频率和对应的单词显示出来，完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">    "unicode"</span><br><span class="line">    "unicode/utf8"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader,</span><br><span class="line">    frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax ||</span><br><span class="line">                utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序的运行结果如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">go run .\main.go small-file.txt</span><br><span class="line">Word       Frequency</span><br><span class="line">ability                     1</span><br><span class="line">about                     1</span><br><span class="line">above                     3</span><br><span class="line">years                      1</span><br><span class="line">you                    128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Frequency → Words</span><br><span class="line">    1 ability, about, absence, absolute, absolutely, abuse, accessible, ...</span><br><span class="line">    2 accept, acquired, after, against, applies, arrange, assumptions, ...</span><br><span class="line">...</span><br><span class="line">128    you</span><br><span class="line">151    or</span><br><span class="line">192    to</span><br><span class="line">221    of</span><br><span class="line">345    the</span><br></pre></td></tr></tbody></table></figure>
<p>其中，small-file.txt 为待统计的文件名，它不是固定的，可以根据实际情况自行调整。由于输出的结果太多，所以上面只截取了部分内容。</p>
<p>通过上面的输出结果可以看出，第一种输出是比较直接的，我们可以使用一个map[string]int类型的结构来保存每一个单词的频率，但是要得到第二种输出结果我们需要将整个映射反转成多值类型的映射，如map[int][]string，也就是说，键是频率而值则是所有具有这个频率的单词。</p>
<p>接下来我们将从程序的 main() 函数开始，从上到下分析。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>main() 函数首先分析命令行参数，之后再进行相应处理。</p>
<p>我们使用复合语法创建一个空的映射，用来保存从文件读到的每一个单词和对应的频率，接着我们遍历从命令行得到的每一个文件，分析每一个文件后更新 frequencyForWord 的数据。</p>
<p>得到第一个映射之后，我们就可以输出第一个报告了（按照字母顺序排列的列表），然后我们创建一个反转的映射，输出第二个报告（按出现频率统计并排序的列表）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 Unix 类系统（如 Linux 或 Mac OS X 等）的命令行工具默认会自动处理通配符（也就是说，<code>*.txt</code> 能匹配任意后缀为 <code>.txt</code> 的文件，如 <code>README.txt</code> 和 <code>INSTALL.txt</code> 等），而 Windows 平台的命令行工具（CMD）不支持通配符，所以如果用户在命令行输入 <code>*.txt</code>，那么程序只能接收到 <code>*.txt</code> 。</p>
<p>为了保持平台之间的一致性，这里使用 commandLineFiles() 函数来实现跨平台的处理，当程序运行在 Windows 平台时，实现文件名通配功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>updateFrequencies() 函数纯粹就是用来处理文件的，它打开给定的文件，并使用 defer 在函数返回时关闭文件，这里我们将文件作为一个 <code>*bufio.Reader</code>（使用 bufio.NewReader() 函数创建）传给 readAndUpdateFrequencies() 函数，因为这个函数是以字符串的形式一行一行地读取数据的，所以实际的工作都是在 readAndUpdateFrequencies() 函数里完成的，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第一部分的代码我们应该很熟悉了，用了一个无限循环来一行一行地读一个文件，当读到文件结尾或者出现错误的时候就退出循环，将错误报告给用户但并不退出程序，因为还有很多其他的文件需要去处理。</p>
<p>任意一行都可能包括标点、数字、符号或者其他非单词字符，所以我们需要逐个单词地去读，将每一行分隔成若干个单词并使用 SplitOnNonLetters() 函数忽略掉非单词的字符，并且过滤掉字符串开头和结尾的空白。</p>
<p>只需要记录含有两个以上（包括两个）字母的单词，可以通过使用 if 语句，如 utf8.RuneCountlnString(word) &gt; 1 来完成。</p>
<p>上面描述的 if 语句有一点性能损耗，因为它会分析整个单词，所以在这个程序里我们增加了一个判断条件，用来检査这个单词的字节数是否大于 utf8.UTFMax（utf8.UTFMax 是一个常量，值为 4，用来表示一个 UTF-8 字符最多需要几个字节）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SplitOnNonLetters() 函数用来在非单词字符上对一个字符串进行切分，首先我们为 strings.FieldsFunc() 函数创建一个匿名函数 notALetter，如果传入的是字符那就返回 false，否则返回 true，然后返回调用函数 strings.FieldsFunc() 的结果，调用的时候将给定的字符串和 notALetter 作为它的参数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>计算出了 frequencyForWord 之后，调用 reportByWords() 将它的数据打印出来，因为我们需要将输出结果按照字母顺序排序好，所以首先要创建一个空的容量足够大的 []string 切片来保存所有在 frequencyForWord 里的单词。</p>
<p>第一个循环遍历映射里的所有项，把每个单词追加到 words 字符串切片里去，使用 append() 函数只需要把给定的单词追加到第 len(words) 个索引位置上即可，words 的长度会自动增加 1。</p>
<p>得到了 words 切片之后，对它进行排序，这个在 readAndUpdateFrequencies() 函数中已经处理好了。</p>
<p>经过排序之后我们打印两列标题，第一个是 “Word”，为了能让 Frequency 最后一个字符 y 右对齐，需要在 “Word” 后打印一些空格，通过 <code>%*s</code> 可以实现的打印固定长度的空白，也可以使用 <code>%s</code> 来打印 strings.Repeat(“ “, gap) 返回的字符串。</p>
<p>最后，我们将单词和它们的频率用两列方式按照字母顺序打印出来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的函数首先创建一个空的映射，用来保存反转的结果，但是我们并不知道它到底要保存多少个项，因此我们假设它和原来的映射容量一样大，然后简单地遍历原来的映射，将它的值作为键保存到反转的映射里，并将键增加到对应的值里去，新的映射的值就是一个字符串切片，即使原来的映射有多个键对应同一个值，也不会丢掉任何数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数的结构和 reportByWords() 函数很相似，它首先创建一个切片用来保存频率，并按照频率升序排列，然后再计算需要容纳的最大长度并以此作为第一列的宽度，之后输出报告的标题，最后，遍历输出所有的频率并按照字母升序输出对应的单词，如果一个频率有超过两个对应的单词则单词之间使用逗号分隔开。</p>
<h3 id="示例：缩进排序"><a href="#示例：缩进排序" class="headerlink" title="示例：缩进排序"></a>示例：缩进排序</h3><p>演示如何将字符串按照等级（缩进级别）进行排序，完整代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">var original = []string{</span><br><span class="line">    "Nonmetals",</span><br><span class="line">    "    Hydrogen",</span><br><span class="line">    "    Carbon",</span><br><span class="line">    "    Nitrogen",</span><br><span class="line">    "    Oxygen",</span><br><span class="line">    "Inner Transitionals",</span><br><span class="line">    "    Lanthanides",</span><br><span class="line">    "        Europium",</span><br><span class="line">    "        Cerium",</span><br><span class="line">    "    Actinides",</span><br><span class="line">    "        Uranium",</span><br><span class="line">    "        Plutonium",</span><br><span class="line">    "        Curium",</span><br><span class="line">    "Alkali Metals",</span><br><span class="line">    "    Lithium",</span><br><span class="line">    "    Sodium",</span><br><span class="line">    "    Potassium",</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("|     Original      |       Sorted      |")</span><br><span class="line">    fmt.Println("|-------------------|-------------------|")</span><br><span class="line">    sorted := SortedIndentedStrings(original) // 最初是 []string</span><br><span class="line">    for i := range original {                 // 在全局变量中设置</span><br><span class="line">        fmt.Printf("|%-19s|%-19s|\n", original[i], sorted[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意 SortedIndentedStrings() 函数有一个很重要的前提就是，字符串的缩进是通过读到的空格或缩进的个数来决定的，下面来看一下输出结果，为了方便对比，这里将排序前的结果放在左边，排序后的结果放在右边。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">|     Original      |       Sorted      |</span><br><span class="line">|-------------------|-------------------|</span><br><span class="line">|Nonmetals          |Alkali Metals      |</span><br><span class="line">|    Hydrogen       |    Lithium        |</span><br><span class="line">|    Carbon         |    Potassium      |</span><br><span class="line">|    Nitrogen       |    Sodium         |</span><br><span class="line">|    Oxygen         |Inner Transitionals|</span><br><span class="line">|Inner Transitionals|    Actinides      |</span><br><span class="line">|    Lanthanides    |        Curium     |</span><br><span class="line">|        Europium   |        Plutonium  |</span><br><span class="line">|        Cerium     |        Uranium    |</span><br><span class="line">|    Actinides      |    Lanthanides    |</span><br><span class="line">|        Uranium    |        Cerium     |</span><br><span class="line">|        Plutonium  |        Europium   |</span><br><span class="line">|        Curium     |Nonmetals          |</span><br><span class="line">|Alkali Metals      |    Carbon         |</span><br><span class="line">|    Lithium        |    Hydrogen       |</span><br><span class="line">|    Sodium         |    Nitrogen       |</span><br><span class="line">|    Potassium      |    Oxygen         |</span><br></pre></td></tr></tbody></table></figure>
<p>其中，SortedIndentedStrings() 函数和它的辅助函数使用到了递归、函数引用以及指向切片的指针等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sort.Interface 接口定义了 3 个方法 Len()、Less() 和 Swap()，它们的函数签名和 Entries 中的同名方法是一样的，这就意味着我们可以使用标准库里的 sort.Sort() 函数来对一个 Entries 进行排序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>导出的函数 SortedIndentedStrings() 就做了这个工作，虽然我们已经对它进行了重构，让它把所有东西都传递给辅助函数，函数 populateEntries() 传入一个 []string 并返回一个对应的 Entries（[]Entry 类型）。</p>
<p>而函数 sortedEntries() 需要传入一个 Entries，然后返回一个排过序的 []string（根据缩进的级别进行排序）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateEntries() 函数首先以字符串的形式得到给定切片里的一级缩进（如有 4 个空格的字符串）和它占用的字节数，然后创建一个空的 Entries，并遍历切片里的每一个字符串，判断该字符串的缩进级别，再创建一个用于排序的键。</p>
<p>下一步，调用自定义函数 addEntry()，将当前字符串的级别、键、字符串本身，以及指向 entries 的地址作为参数，这样 addEntry() 就能创建一个新的 Entry 并能够正确地将它追加到 entries 里去，最后返回 entries。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>computeIndent() 函数主要是用来判断缩进使用的是什么字符，例如空格或者缩进符等，以及一个缩进级别占用多少个这样的字符。</p>
<p>因为第一级的字符串可能没有缩进，所以函数必须迭代所有的字符串，一旦它发现某个字符串的行首是空格或者缩进，函数马上返回表示缩进的字符以及一个缩进所占用的字符数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addEntry() 是一个递归函数，它创建一个新的 Entry，如果这个 Entry 的 level 是 0，那就直接增加到 entries 里去，否则，就将它作为另一个 Entry 的子集。</p>
<p>我们必须确定这个函数传入的是一个 *Entries 而不是传递一个 entries 引用（切片的默认行为），因为我们是要将数据追加到 entries 里，追加到一个引用会导致无用的本地副本且原来的数据实际上并没有被修改。</p>
<p>如果 level 是 0，表明这个字符串是顶级项，因此必须将它直接追加到 <code>*entries</code> ，实际上情况要更复杂一些，因为 level 是相对传入的 <code>*entries</code> 而言的，第一次调用 addEntry() 时，<code>*entries</code> 是一个第一级的 Entries，但函数进入递归后，*entries 就可能是某个 Entry 的子集。</p>
<p>我们使用内置的 append() 函数来追加新的 Entry，并使用 <code>*</code> 操作符获得 entries 指针指向的值，这就保证了任何改变对调用者来说都是可见的，新增的 Entry 包含给定的 key 和 value，以及一个空的子 Entries，这是递归的结束条件。</p>
<p>如果 level 大于 0，则我们必须将它追加到上一级 Entry 的 children 字段里去，这里我们只是简单地递归调用 addEntry() 函数，最后一个参数可能是我们目前为止见到的最复杂的表达式了。</p>
<p>子表达式 entries.Len() - 1 产生一个 int 型整数，表示 <code>*entries</code> 指向的 Entries 值的最后一个条目的索引位置（注意 Entries.Len() 传入的是一个 Entries 值而不是 <code>*Entries</code> 指针，不过Go语言也可以自动对 entries 指针进行解引用并调用相应的方法）。</p>
<p>完整的表达式（&amp;(…) 除外）访问了 Entries 最后一个 Entry 的 children 字段（这也是一个 Entries 类型），所以如果把这个表达式作为一个整体，实际上我们是将 Entries 里最后一个 Entry 的 children 字段的内存地址作为递归调用的参数，因为 addEntry() 最后一个参数是 *Entries 类型的。</p>
<p>为了帮助大家弄清楚到底发生了什么，下面的代码和上述代码中 else 代码块中的那个调用是一样的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">theEntries := *entries</span><br><span class="line">lastEntry := &amp;theEntries[theEntries.Len()-1]</span><br><span class="line">addEntry(level-1, key, value, &amp;lastEntry.children)</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们创建 theEntries 变量用来保存 *entries 指针指向的值，这里没有什么开销因为不会产生复制，实际上 theEntries 相当于一个指向 Entries 值的别名。</p>
<p>然后我们取得最后一项的内存地址（即一个指针），如果不取地址的话就会取到最后一项的副本，最后递归调用 addEntry() 函数，并将最后一项的 children 字段的地址作为参数传递给它。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当调用 sortedEntries() 函数的时候，Entries 显示的结构和原先程序输出的字符串是一样的，每一个缩进的字符串都是上一级缩进的子级，而且还可能有下一级的缩进，依次类推。</p>
<p>创建了 Entries 之后，SortedIndentedStrings() 函数调用上面这个函数去生成一个排好序的字符串切片 []string，这个函数首先创建一个空的 []string 用来保存最后的结果，然后对 entries 进行排序。</p>
<p>Entries 实现了 sort.Interface 接口，因此我们可以直接使用 sort.Sort() 函数根据 Entry 的 key 字段来对 Entries 进行排序（这是 Entries.Less() 的实现方式），这个排序只是作用于第一级的 Entry，对其他未排序的子集是没有任何影响的。</p>
<p>为了能够对 children 字段以及 children 的 children 等进行递归排序，函数遍历第一级的每一个项并调用 populateIndentedStrings() 函数，传入这个 Entry 类型的项和一个指向 []string 切片的指针。</p>
<p>切片可以传递给函数并由函数更新内容（如替换切片里的某些项），但是这里需要往切片里新增一些数据，所以这里将一个指向切片的指针（也就是指针的指针）作为参数传进去，并将指针指向的内容设置为 append() 函数的返回结果，可能是一个新的切片，也可能是原先的切片。</p>
<p>另一种办法就是传入切片的值，然后返回 append() 之后的切片，但是必须将返回的结果赋值给原来的切片变量（例如 slice = function(slice)），不过这么做的话，很难正确地使用递归函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateIndentedStrings() 函数将顶级项追加到创建的切片，然后对顶级项的子项进行排序，并递归调用自身对每一个子项做同样的处理，这就相当于对每一项的子项以及子项的子项等都做了排序，所以整个字符串切片就是已经排好序的了。</p>
<h3 id="示例：二分查找算法"><a href="#示例：二分查找算法" class="headerlink" title="示例：二分查找算法"></a>示例：二分查找算法</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找算法的前提是传入的序列是有序的（降序或升序），并且有一个目标值。</p>
<p>二分查找的核心思想是将 n 个元素分成大致相等的两部分，取中间值 <code>a[n/2]</code> 与 x 做比较，如果 <code>x=a[n/2]</code> ，则找到 x ，算法中止，如果 <code>x&lt;a[n/2]</code> ，则只要在数组 a 的左半部分继续搜索 x，如果 <code>x&gt;a[n/2]</code> ，则只要在数组 a 的右半部搜索 x。</p>
<p>二分查找虽然性能比较优秀，但应用场景也比较有限，底层必须依赖数组，并且还要求数据是有序的，对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁插入、删除操作的数据。</p>
<p>程序实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">二分查找函数，假设有序数组的顺序是从小到大</span><br><span class="line">*/</span><br><span class="line">func BinaryFind(arr *[]int, leftIndex int, rightIndex int, findValue int) {</span><br><span class="line"></span><br><span class="line">    //判断leftIndex是否大于rightIndex</span><br><span class="line">    if leftIndex &gt; rightIndex {</span><br><span class="line">        fmt.Println("未找到")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //先找到中间的下标</span><br><span class="line">    middle := (leftIndex + rightIndex) / 2</span><br><span class="line"></span><br><span class="line">    if (*arr)[middle] &gt; findValue {</span><br><span class="line">        fmt.Printf("小于中间 middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, leftIndex, middle-1, findValue)</span><br><span class="line">        //要查找的数，范围应该在leftIndex与 middle-1 之间</span><br><span class="line">        BinaryFind(arr, leftIndex, middle-1, findValue)</span><br><span class="line"></span><br><span class="line">    } else if (*arr)[middle] &lt; findValue {</span><br><span class="line">        fmt.Printf("大于中间  middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, middle+1, rightIndex, findValue)</span><br><span class="line">        //要查找的数，范围应该在middle+1与 rightIndex 之间</span><br><span class="line">        BinaryFind(arr, middle+1, rightIndex, findValue)</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("找到了，下标为：%v \n", middle)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //定义一个数组</span><br><span class="line">    arr := []int{1, 3, 7, 12, 17, 20, 30, 50, 55, 75}</span><br><span class="line">    BinaryFind(&amp;arr, 0, len(arr)-1, 30)</span><br><span class="line">    fmt.Println("main arr=", arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">大于中间  middle：4, leftIndex： 0 rightIndex：9 findValue：30</span><br><span class="line">小于中间  middle：7, leftIndex： 5 rightIndex：9 findValue：30</span><br><span class="line">大于中间  middle：5, leftIndex： 5 rightIndex：6 findValue：30</span><br><span class="line">找到了，下标为：6</span><br><span class="line">main arr= [1 3 7 12 17 20 30 50 55 75]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：冒泡排序"><a href="#示例：冒泡排序" class="headerlink" title="示例：冒泡排序"></a>示例：冒泡排序</h3><p>冒泡排序法是一种最简单的交换类排序方法，它是通过相邻数据的交换逐步将无序列表排列为有序列表。</p>
<p>冒泡排序的基本原理是重复地循环遍历要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大或者首字母从 Z 到 A）错误就把两个元素的位置交换过来，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>冒泡排序的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p>下面通过一个实例来演示一下冒泡排序，完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">   "fmt"</span><br><span class="line">)</span><br><span class="line">/**</span><br><span class="line">冒泡排序</span><br><span class="line">*/</span><br><span class="line">func main() {</span><br><span class="line">    arr := [...]int{21,32,12,33,34,34,87,24}</span><br><span class="line">    var n = len(arr)</span><br><span class="line">    fmt.Println("--------没排序前--------\n",arr)</span><br><span class="line">    for i := 0; i &lt;= n-1; i++ {</span><br><span class="line">        fmt.Println("--------第",i+1,"次冒泡--------")</span><br><span class="line">        for j := i; j &lt;= n-1; j++ {</span><br><span class="line">            if arr[i] &gt; arr[j] {</span><br><span class="line">                t := arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = t</span><br><span class="line">            }</span><br><span class="line">            fmt.Println(arr)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("--------最终结果--------\n",arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">--------没排序前--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">--------第 1 次冒泡--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">--------第 2 次冒泡--------</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">--------第 3 次冒泡--------</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">--------第 4 次冒泡--------</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">--------第 5 次冒泡--------</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 6 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 7 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------第 8 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------最终结果--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="四种冒泡排序写法"><a href="#四种冒泡排序写法" class="headerlink" title="四种冒泡排序写法"></a>四种冒泡排序写法</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//用于计数排序中访问了多少次序列</span><br><span class="line">var cnt int= 0</span><br><span class="line"></span><br><span class="line">//最原始的冒泡排序</span><br><span class="line">func buble_sort(a []int){</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{//相邻元素两两比较</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//增加标志判断是否发生交换，如果没有发生交换，表明序列有序，结束比较，直接退出</span><br><span class="line">func flag_sort(a []int){</span><br><span class="line">    flag := true//默认序列有序</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false//发生交换--表明序列无序--需要进行下一次比较</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//除了标志位以外，记录最后一次发生交换的下标，更能减少不必要的比较</span><br><span class="line">func better_sort(a []int){</span><br><span class="line">    flag := true</span><br><span class="line">    k := len(a)-1//控制内部比较循环</span><br><span class="line">    n := 0//记录最后一次发生交换的下标</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        n = 0//每次访问待排序序列之初默认序列有序，没有发生交换，最后交换的下标就是0</span><br><span class="line">        for j := 0; j &lt; k; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false</span><br><span class="line">                n = j//保存最后一次交换的下标</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        if flag {//如果这趟走完，没有发生交换，则原数组有序</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        k = n//最后一次交换的位置给k，减少比较的次数</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//鸡尾酒冒泡排序--先从低到高，再从高到低--分为两大步骤，结合标志判断</span><br><span class="line">func cocktail_sort(a []int) {</span><br><span class="line">    left := 0</span><br><span class="line">    right := len(a) - 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    flag := true</span><br><span class="line">    for(left &lt; right){</span><br><span class="line">        flag = true</span><br><span class="line">        for i :=left; i &lt; right; i++{// 前半轮,将最大元素放到后面</span><br><span class="line">            if (a[i] &gt; a[i+1]) {</span><br><span class="line">                a[i], a[i+1] = a[i+1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        right--</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for i :=right; i &gt; left; i--{// 后半轮,将最小元素放到前面</span><br><span class="line">            if (a[i] &lt; a[i-1]) {</span><br><span class="line">                a[i], a[i-1] = a[i-1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        left++</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    b := [...]int{8,7,6,1,4,3,2,5}</span><br><span class="line">    buble_sort(b[:])</span><br><span class="line">    fmt.Println(b,cnt)</span><br><span class="line"></span><br><span class="line">    c := []int{2,3,4,5,6,1}</span><br><span class="line">    cocktail_sort(c)</span><br><span class="line">    fmt.Println(c,cnt)</span><br><span class="line"></span><br><span class="line">    d := []int{8,7,6,1,4,3,2,5}</span><br><span class="line">    flag_sort(d)</span><br><span class="line">    fmt.Println(d,cnt)</span><br><span class="line"></span><br><span class="line">    e := []int{2,3,4,5,6,1}</span><br><span class="line">    better_sort(e)</span><br><span class="line">    fmt.Println(e,cnt)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Go语言分布式id生成器"><a href="#Go语言分布式id生成器" class="headerlink" title="Go语言分布式id生成器"></a>Go语言分布式id生成器</h3><p>有时我们需要能够⽣成类似 MySQL 自增 ID 这样不断增大，同时又不会重复的 ID。以支持业务中的⾼并发场景。比较典型的是电商促销时短时间内会有大量的订单涌入到系统，比如每秒 10w+。明星出轨时会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。</p>
<p>在插入数据库之前，我们需要给这些消息、订单先打上一个 ID，然后再插⼊到我们的数据库。对这个 ID 的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进⾏排序。</p>
<p>Twitter 的 snowflake 算法是这种场景下的一个典型解法。先来看看 snowflake 是怎么回事，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/snowflake.gif" alt="图：snowflake 中的比特位分布"></p>
<p>⾸先确定我们的数值是 64 位的 int64 类型，被划分为了四部分，不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的 ID，然后再五位来表示机器的实例 ID，最后是 12 位的循环自增 ID（到达 1111,1111,1111 后会归 0）。</p>
<p>这样的机制可以⽀持我们在同一台机器上，同一毫秒内产⽣ 2 ^ 12 = 4096 条消息。一秒共 409.6 万条消息。从值域上来讲完全够⽤了。</p>
<p>数据中心加上实例 ID 共有 10 位，可以⽀持我们每数据中心部署 32 台机器，所有数据中心共 1024 台实例。</p>
<p>表示 timestamp 的 41 位，可以⽀持我们使用 69 年。当然，我们的时间毫秒计数不会真的从 1970 年开始记，那样我们的系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的 timestamp 实际上只是相对于某个时间的增量，比如我们的系统上线是 2018-08-01，那么我们可以把这个 timestamp 当作是从 2018-08-01 00:00:00.000 的偏移量。</p>
<h4 id="worker-id-分配"><a href="#worker-id-分配" class="headerlink" title="worker_id 分配"></a>worker_id 分配</h4><p>timestamp、datacenter_id、worker_id 和 sequence_id 这四个字段中，timestamp 和 sequence_id 是由程序在运⾏期⽣成的。但 datacenter_id 和 worker_id 需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的 ID 有冲突）。</p>
<p>一般不同数据中⼼的机器，会提供对应的获取数据中心 ID 的 API，所以 datacenter_id 我们可以在部署阶段轻松地获取到。而 worker_id 是我们逻辑上给机器分配的一个 ID，这个要怎么办呢？比较简单的想法是由能够提供这种自增 ID 功能的工具来支持，比如 MySQL:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt; insert into a (ip) values("10.1.2.101");</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select last_insert_id();</span><br><span class="line">+------------------+</span><br><span class="line">| last_insert_id()     |</span><br><span class="line">+------------------+</span><br><span class="line">| 2                          |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<p>从 MySQL 中获取到 worker_id 之后，就把这个 worker_id 直接持久化到本地，以避免每次上线时都需要获取新的 worker_id，让单实例的 worker_id 可以始终保持不变。</p>
<p>当然，使用 MySQL 相当于给我们简单的 id 生成服务增加了一个外部依赖，依赖越多，我们的服务的可运维性就越差。</p>
<p>考虑到集群中即使有单个 ID 生成服务的实例挂了，也就是损失一段时间的一部分 ID，所以我们也可以更简单暴力一些，把 worker_id 直接写在 worker 的配置中，上线时由部署脚本完成 worker_id 字段替换</p>
<h4 id="标准-snowflake-实现"><a href="#标准-snowflake-实现" class="headerlink" title="标准 snowflake 实现"></a>标准 snowflake 实现</h4><p>github.com/bwmarrin/snowflake 是一个相当轻量化的 snowflake 的 Go 实现。其文档对各位使用的定义如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosnowflake.gif" alt="图：snowflake库"></p>
<p>和标准的 snowflake 完全一致。使用上比较简单：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "github.com/bwmarrin/snowflake"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    n, err := snowflake.NewNode(1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        id := n.Generate()</span><br><span class="line">        fmt.Println("id", id)</span><br><span class="line">        fmt.Println(</span><br><span class="line">            "node: ", id.Node(),</span><br><span class="line">            "step: ", id.Step(),</span><br><span class="line">            "time: ", id.Time(),</span><br><span class="line">            "\n",</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">go: finding module for package github.com/bwmarrin/snowflake</span><br><span class="line">go: downloading github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">go: found github.com/bwmarrin/snowflake in github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">id 1318484268032200704</span><br><span class="line">node:  1 step:  0 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200705</span><br><span class="line">node:  1 step:  1 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200706</span><br><span class="line">node:  1 step:  2 time:  1603186120409</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC</span><br><span class="line">// You may customize this to set a different epoch for your application.</span><br><span class="line">Epoch int64 = 1288834974657</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Node</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">NodeBits uint8 = 10</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Step</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">StepBits uint8 = 12</span><br></pre></td></tr></tbody></table></figure>
<p>Epoch 就是本节开头讲的起始时间，NodeBits 指的是机器编号的位⻓，StepBits 指的是自增序列的位⻓。</p>
<h4 id="sonyflake"><a href="#sonyflake" class="headerlink" title="sonyflake"></a>sonyflake</h4><p>sonyflake 是 Sony 公司的一个开源项目，基本思路和 snowflake 差不多，不过位分配上稍有不同，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sonyflake.gif" alt="图：sonyflake"></p>
<p>这⾥的时间只用了 39 个 bit，但时间的单位变成了 10ms，所以理论上比 41 位表示的时间还要久（174 年）。</p>
<p>Sequence ID 和之前的定义一致，Machine ID 其实就是节点 ID。sonyflake 与众不同的地方在于其在启动阶段的参数配置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">func NewSonyflake(st Settings) *Sonyflake</span><br></pre></td></tr></tbody></table></figure>
<p>Settings 数据结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type Settings struct {</span><br><span class="line">    StartTime time.Time</span><br><span class="line">    MachineID func() (uint16, error)</span><br><span class="line">    CheckMachineID func(uint16) bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>StartTime 选项和我们之前的 Epoch 差不多，如果不设置的话，默认是从 2014-09-01 00:00:00 +0000 UTC 开始。</p>
<p>MachineID 可以由用户自定义的函数，如果用户不定义的话，会默认将本机 IP 的低 16 位作为 machineid。</p>
<p>CheckMachineID 是由用户提供的检查 MachineID 是否冲突的函数。这里的设计还是比较巧秒的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查 MachineID 是否冲突的逻辑。如果公司有现成的 Redis 集群，那么我们可以很轻松地用 Redis 的集合类型来检查冲突。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure>
<p>使用起来也比较简单，这里省略了一些逻辑简单的函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">    "github.com/sony/sonyflake"</span><br><span class="line">)</span><br><span class="line">func getMachineID() (uint16, error) {</span><br><span class="line">    var machineID uint16</span><br><span class="line">    var err error</span><br><span class="line">    machineID = readMachineIDFromLocalFile()</span><br><span class="line">    if machineID == 0 {</span><br><span class="line">        machineID, err = generateMachineID()</span><br><span class="line">        if err != nil {</span><br><span class="line">            return 0, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return machineID, nil</span><br><span class="line">}</span><br><span class="line">func checkMachineID(machineID uint16) bool {</span><br><span class="line">    saddResult, err := saddMachineIDToRedisSet()</span><br><span class="line">    if err != nil || saddResult == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    err := saveMachineIDToLocalFile(machineID)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return false</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    t, _ := time.Parse("2006-01-02", "2018-01-01")</span><br><span class="line">    settings := sonyflake.Settings{</span><br><span class="line">        StartTime: t,</span><br><span class="line">        MachineID: getMachineID,</span><br><span class="line">        CheckMachineID: checkMachineID,</span><br><span class="line">    }</span><br><span class="line">    sf := sonyflake.NewSonyflake(settings)</span><br><span class="line">    id, err := sf.NextID()</span><br><span class="line">    if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
</search>
