<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go接口</title>
      <link href="posts/d3175357/"/>
      <url>posts/d3175357/</url>
      
        <content type="html"><![CDATA[<p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p><p>Go 语言中使用组合实现对象特性的描述。对象的内部使用结构体内嵌组合对象应该具有的特性，对外通过接口暴露能使用的特性。</p><p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p><p>其它编程语言中的接口</p><p>接口是一种较为常见的特性，很多语言都有接口特性。C/C++、C# 语言中的接口都可以多重派生实现接口组合；在苹果的 Objective C 中与接口类似的功能被称为 Protocol，这种叫法比接口更形象、具体。</p><p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p><h2 id="接口声明（定义）"><a href="#接口声明（定义）" class="headerlink" title="接口声明（定义）"></a>接口声明（定义）</h2><p>Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。</p><p>但是Go语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</p><p>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</p><p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p><p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p><h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成。接口的形式代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface{</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对各个部分的说明：</p><ul><li>接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。</li><li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type writer interface{</span><br><span class="line">    Write([]byte) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="开发中常见的接口及写法"><a href="#开发中常见的接口及写法" class="headerlink" title="开发中常见的接口及写法"></a>开发中常见的接口及写法</h3><p>Go语言提供的很多包中都有接口，例如 io 包中提供的 Writer 接口：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个接口可以调用 Write() 方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。</p><p>类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用 String() 方法时，都可以获得对象对应的字符串。在 fmt 包中定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Stringer 接口在Go语言中的使用频率非常高，功能类似于 Java 或者 C# 语言里的 ToString 的操作。</p><p>Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。</p><p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p><p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p><h3 id="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><a href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致" class="headerlink" title="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"></a>接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><p>为了抽象数据写入的过程，定义 DataWriter 接口来描述数据写入需要实现的方法，接口中的 WriteData() 方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现 WriteData 方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现 DataWriter 接口的 WriteData 方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考下面的代码。</p><p>数据写入器的抽象：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义文件结构，用于实现DataWriter</span><br><span class="line">type file struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现DataWriter接口的WriteData方法</span><br><span class="line">func (d *file) WriteData(data interface{}) error {</span><br><span class="line"></span><br><span class="line">    // 模拟写入数据</span><br><span class="line">    fmt.Println("WriteData:", data)</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化file</span><br><span class="line">    f := new(file)</span><br><span class="line"></span><br><span class="line">    // 声明一个DataWriter的接口</span><br><span class="line">    var writer DataWriter</span><br><span class="line"></span><br><span class="line">    // 将接口赋值f，也就是*file类型</span><br><span class="line">    writer = f</span><br><span class="line"></span><br><span class="line">    // 使用DataWriter接口进行数据写入</span><br><span class="line">    writer.WriteData("data")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，输入一个 interface{} 类型的 data，返回一个 error 结构表示可能发生的错误。</li><li>第 17 行，file 的 WriteData() 方法使用指针接收器。输入一个 interface{} 类型的 data，返回 error。</li><li>第 27 行，实例化 file 赋值给 f，f 的类型为 <code>*file</code> 。</li><li>第 30 行，声明 DataWriter 类型的 writer 接口变量。</li><li>第 33 行，将 <code>*file</code> 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</li><li>第 36 行，DataWriter 接口类型的 writer 使用 WriteData() 方法写入一个字符串。</li></ul><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteData: data</span><br></pre></td></tr></tbody></table></figure><p>本例中调用及实现关系如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writewriter.jpg" alt="图：WriteWriter的实现过程"></p><p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p><p>1)函数名不一致导致的报错</p><p>在以上代码的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改 file 结构的 WriteData() 方法名，将这个方法签名（第17行）修改为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (d *file) WriteDataX(data interface{}) error {</span><br></pre></td></tr></tbody></table></figure><p>编译代码，报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing WriteData method)</span><br></pre></td></tr></tbody></table></figure><p>报错的位置在第 33 行。报错含义是：不能将 f 变量（类型 <code>*file</code>）视为 DataWriter 进行赋值。原因：<code>*file</code> 类型未实现 DataWriter 接口（丢失 WriteData 方法）。</p><p>WriteDataX 方法的签名本身是合法的。但编译器扫描到第 33 行代码时，发现尝试将 <code>*file</code> 类型赋值给 DataWriter 时，需要检查 <code>*file</code> 类型是否完全实现了 DataWriter 接口。显然，编译器因为没有找到 DataWriter 需要的 WriteData() 方法而报错。</p><p>2)实现接口的方法签名不一致导致的报错</p><p>将修改的代码恢复后，再尝试修改 WriteData() 方法，把 data 参数的类型从 interface{} 修改为 int 类型，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (d *file) WriteData(data int) error {</span><br></pre></td></tr></tbody></table></figure><p>编译代码，报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (wrong type for WriteData method)</span><br><span class="line">                have WriteData(int) error</span><br><span class="line">                want WriteData(interface {}) error</span><br></pre></td></tr></tbody></table></figure><p>这次未实现 DataWriter 的理由变为（错误的 WriteData() 方法类型）发现 <code>WriteData(int)error</code> ，期望 <code>WriteData(interface{})error</code> 。</p><p>这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。</p><h3 id="接口被实现的条件二：接口中所有方法均被实现"><a href="#接口被实现的条件二：接口中所有方法均被实现" class="headerlink" title="接口被实现的条件二：接口中所有方法均被实现"></a>接口被实现的条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p><p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line"></span><br><span class="line">    // 能否写入</span><br><span class="line">    CanWrite() bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></tbody></table></figure><p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p><p>Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p><p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p><p><strong><em>提示:传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。</em></strong></p><p>对于Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。</p><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><p>在Go语言中类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系</p><h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p><p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p><p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Socket struct {</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Socket 结构的 Write() 方法实现了 io.Writer 接口：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时，Socket 结构也实现了 io.Closer 接口：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosocket.jpg" alt="图：接口的使用和实现过程"></p><p>在代码中使用 Socket 结构实现的 Writer 接口和 Closer 接口代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用io.Writer的代码, 并不知道Socket和io.Closer的存在</span><br><span class="line">func usingWriter( writer io.Writer){</span><br><span class="line">    writer.Write( nil )</span><br><span class="line">}</span><br><span class="line">// 使用io.Closer, 并不知道Socket和io.Writer的存在</span><br><span class="line">func usingCloser( closer io.Closer) {</span><br><span class="line">    closer.Close()</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    // 实例化Socket</span><br><span class="line">    s := new(Socket)</span><br><span class="line">    usingWriter(s)</span><br><span class="line">    usingCloser(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。</p><h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p><p>Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 一个服务需要满足能够开启和写日志的功能</span><br><span class="line">type Service interface {</span><br><span class="line">    Start()  // 开启服务</span><br><span class="line">    Log(string)  // 日志输出</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 日志器</span><br><span class="line">type Logger struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Log()方法</span><br><span class="line">func (g *Logger) Log(l string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 游戏服务</span><br><span class="line">type GameService struct {</span><br><span class="line">    Logger  // 嵌入日志器</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Start()方法</span><br><span class="line">func (g *GameService) Start() {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，定义服务接口，一个服务需要实现 Start() 方法和日志方法。</li><li>第 8 行，定义能输出日志的日志器结构。</li><li>第 12 行，为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</li><li>第 17 行，定义 GameService 结构。</li><li>第 18 行，在 GameService 中嵌入 Logger 日志器，以实现日志功能。</li><li>第 22 行，GameService 的 Start() 方法实现了 Service 的 Start() 方法。</li></ul><p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s Service = new(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></tbody></table></figure><p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p><h2 id="接口的nil判断"><a href="#接口的nil判断" class="headerlink" title="接口的nil判断"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/128.html">接口的nil判断</a></h2><p>nil 在 Go 语言中只能被赋值给指针和接口。接口在底层的实现有两个部分：type 和 data。在源码中，显式地将 nil 赋值给接口时，接口的 type 和 data 都将为 nil。此时，接口与 nil 值判断是相等的。但如果将一个带有类型的 nil 赋值给接口时，只有 data 为 nil，而 type 为 nil，此时，接口与 nil 判断将不相等。</p><h3 id="接口与-nil-不相等"><a href="#接口与-nil-不相等" class="headerlink" title="接口与 nil 不相等"></a>接口与 nil 不相等</h3><p>下面代码使用 MyImplement() 实现 fmt 包中的 Stringer 接口，这个接口的定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 GetStringer() 函数中将返回这个接口。通过 *MyImplement 指针变量置为 nil 提供 GetStringer 的返回值。在 main() 中，判断 GetStringer 与 nil 是否相等，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义一个结构体</span><br><span class="line">type MyImplement struct{}</span><br><span class="line"></span><br><span class="line">// 实现fmt.Stringer的String方法</span><br><span class="line">func (m *MyImplement) String() string {</span><br><span class="line"></span><br><span class="line">    return "hi"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在函数中返回fmt.Stringer接口</span><br><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    // 赋nil</span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    // 返回变量</span><br><span class="line">    return s</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 判断返回值是否为nil</span><br><span class="line">    if GetStringer() == nil {</span><br><span class="line">        fmt.Println("GetStringer() == nil")</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("GetStringer() != nil")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 9 行，实现 fmt.Stringer 的 String() 方法。</li><li>第 21 行，s 变量此时被 fmt.Stringer 接口包装后，实际类型为 *MyImplement，值为 nil 的接口。</li><li>第 27 行，使用 GetStringer() 的返回值与 nil 判断时，虽然接口里的 value 为 nil，但 type 带有 *MyImplement 信息，使用 == 判断相等时，依然不为 nil。</li></ul><h3 id="发现-nil-类型值返回时直接返回-nil"><a href="#发现-nil-类型值返回时直接返回-nil" class="headerlink" title="发现 nil 类型值返回时直接返回 nil"></a>发现 nil 类型值返回时直接返回 nil</h3><p>为了避免这类误判的问题，可以在函数返回时，发现带有 nil 的指针时直接返回 nil，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    if s == nil {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类型断言简述"><a href="#类型断言简述" class="headerlink" title="类型断言简述"></a>类型断言简述</h2><p>类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><p>在Go语言中类型断言的语法格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></tbody></table></figure><p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p><p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：</p><ul><li>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。</li><li>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。</li><li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</li></ul><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = 10</span><br><span class="line">    value, ok := x.(int)</span><br><span class="line">    fmt.Print(value, ",", ok)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10,true</span><br></pre></td></tr></tbody></table></figure><p>需要注意如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = "Hello"</span><br><span class="line">    value := x.(int)</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface {} is string, not int</span><br></pre></td></tr></tbody></table></figure><p>类型断言还可以配合 switch 使用，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a int</span><br><span class="line">    a = 10</span><br><span class="line">    getType(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func getType(a interface{}) {</span><br><span class="line">    switch a.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println("the type of a is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println("the type of a is string")</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Println("the type of a is float")</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println("unknown type")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the type of a is int</span><br></pre></td></tr></tbody></table></figure><h2 id="实现日志系统（支持多种输出方式）"><a href="#实现日志系统（支持多种输出方式）" class="headerlink" title="实现日志系统（支持多种输出方式）"></a>实现日志系统（支持多种输出方式）</h2><p>日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，如命令行、文件、网络等。</p><p>本例将搭建一个支持多种写入器的日志系统，可以自由扩展多种日志写入设备。</p><h3 id="日志对外接口"><a href="#日志对外接口" class="headerlink" title="日志对外接口"></a>日志对外接口</h3><p>本例中定义一个日志写入器接口（LogWriter），要求写入设备必须遵守这个接口协议才能被日志器（Logger）注册。日志器有一个写入器的注册方法（Logger的RegisterWriter()方法）。</p><p>日志器还有一个Log()方法，进行日志的输出，这个函数会将日志写入到所有已经注册的日志写入器（LogWriter）中，详细代码实现请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//声明日志写入器接口</span><br><span class="line">type LogWriter interface{</span><br><span class="line">    Write(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//日志器</span><br><span class="line">type Logger struct{</span><br><span class="line">    //这个日志器用到的日志写入器</span><br><span class="line">    writerList []LogWriter</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//注册一个日志写入器</span><br><span class="line">func(l *Logger) RegisterWriter ( writer LogWriter ) {</span><br><span class="line">    l.writerList = append(l.writerList , writer )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//将一个data类型的数据写入日志</span><br><span class="line">func(l *Logger) Log ( data interface{}){</span><br><span class="line"></span><br><span class="line">    //遍历所有注册的写入器</span><br><span class="line">    for _ , writer := range l.writerList {</span><br><span class="line"></span><br><span class="line">        //将日志输出到每一个写入器中</span><br><span class="line">        writer.Write(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建日志器的实例</span><br><span class="line">func NewLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    return &amp;Logger{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行，声明日志写入器接口。这个接口可以被外部使用。日志的输出可以有多种设备，这个写入器就是用来实现一个日志的输出设备。</li><li>第9行，声明日志器结构。日志器使用writeList记录输出到哪些设备上。</li><li>第15行，使用日志器方法RegisterWriter()将一个日志写入器（LogWriter）注册到日志器（Logger）中。注册的意思就是将日志写入器的接口添加到writeList中。</li><li>第20行，日志器的Log()方法可以将interface{}类型的data写入到注册过的日志写入器中。</li><li>第23行，遍历日志器拥有的所有日志写入器。</li><li>第26行，将本次日志的内容写入日志写入器。</li><li>第31行，创建日志器的实例。</li></ul><p>这个例子中，为了最大程度地展示接口的用法，仅仅只是将数据直接写入日志写入器中。复杂一些的日志器还可以将日期、级别等信息合并到数据中一并写入日志。</p><h3 id="文件写入器"><a href="#文件写入器" class="headerlink" title="文件写入器"></a>文件写入器</h3><p>文件写入器（fileWriter）是众多日志写入器（LogWriter）中的一种。文件写入器的功能是根据一个文件名创建日志文件（fileWriter的SetFile方法）。在有日志写入时，将日志写入文件中。</p><p>文件写入器代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明文件写入器</span><br><span class="line">type fileWriter struct{</span><br><span class="line">    file *os.File</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//设置文件写入器写入的文件名</span><br><span class="line">func(f *fileWriter) SetFile ( filename string ) (err error ) {</span><br><span class="line"></span><br><span class="line">    //如果文件已经打开,关闭前一个文件</span><br><span class="line">    if f.file != nil {</span><br><span class="line">        f.file.Close()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个文件并保存文件句柄</span><br><span class="line">    f.file , err = os.Create(filename)</span><br><span class="line"></span><br><span class="line">    //如果创建的过程出现错误,则返回错误</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *fileWriter) Write ( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //日志文件可能没有创建成功</span><br><span class="line">    if f.file == nil {</span><br><span class="line"></span><br><span class="line">        //日志文件没有准备好</span><br><span class="line">        return errors.New("file not created")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入文件中</span><br><span class="line">    _ , err := f.file.Write([]byte(str))</span><br><span class="line"></span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建文件写入器实例</span><br><span class="line">func newFileWriter() *fileWriter {</span><br><span class="line">    return &amp;fileWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第10行，声明文件写入器，在结构体中保存一个文件句柄，以方便每次写入时操作。</li><li>第15行，文件写入器通过文件名创建文件，这里通过SetFile的参数提供一个文件名，并创建文件。</li><li>第18行，考虑到SetFile()方法可以被多次调用（函数可重入性），假设之前已经调用过SetFile()后再次调用，此时的f.file不为空，就需要关闭之前的文件，重新创建新的文件。</li><li>第23行，根据文件名创建文件，如果发生错误，通过SetFile的返回值返回。</li><li>第30行，fileWriter的Write()方法实现了LogWriter接口的Write()方法。</li><li>第33行，如果文件没有准备好，文件句柄为nil，此时使用errors包的New()函数返回一个错误对象，包含一个字符串“filenotcreated”。</li><li>第40行，通过Write()方法传入的data参数是interface{}类型，而f.file的Write()方法需要的是[]byte类型。使用fmt.Sprintf将data转换为字符串，这里使用的格式化参数是%v，意思是将data按其本来的值转换为字符串。</li><li>第43行，通过f.file的Write()方法，将str字符串转换为[]byte字节数组，再写入到文件中。如果发生错误，则返回。</li></ul><p>在操作文件时，会出现文件无法创建、无法写入等错误。开发中尽量不要忽略这些底层报出的错误，应该处理可能发生的所有错误。</p><p>文件使用完后，要注意使用os.File的Close()方法进行及时关闭，否则文件再次访问时会因为其属性出现无法读取、无法写入等错误。</p><p><strong>提示:</strong></p><p>一个完备的文件写入器会提供多种写入文件的模式，例子中使用的模式是将日志添加到日志文件的尾部。随着文件越来越大，文件的访问效率和查看便利性也会大大降低。此时，就需要另外一种写入模式：滚动写入文件。</p><p>滚动写入文件模式也是将日志添加到文件的尾部，但当文件达到设定的期望大小时，会自动开启一个新的文件继续写入文件，最终将获得多个日志文件。</p><p>日志文件名不仅可以按照文件大小进行分割，还可以按照日期范围进行分割。在到达设定的日期范围，如每天、每小时的周期范围时，日志器会自动创建新的日志文件。这种日志文件创建方法也能方便开发者按日志查看日志。</p><h3 id="命令行写入器"><a href="#命令行写入器" class="headerlink" title="命令行写入器"></a>命令行写入器</h3><p>在UNIX的思想中，一切皆文件。文件包括内存、磁盘、网络和命令行等。这种抽象方法方便我们访问这些看不见摸不着的虚拟资源。命令行在Go语言中也是一种文件，os.Stdout对应标准输出，一般表示屏幕，也就是命令行，也可以被重定向为打印机或者磁盘文件；os.Stderr对应标准错误输出，一般将错误输出到日志中，不过大多数情况，os.Stdout会与os.Stderr合并输出；os.Stdin对应标准输入，一般表示键盘。os.Stdout、os.Stderr、os.Stdin都是 <code>*os.File</code> 类型，和文件一样实现了io.Writer接口的Write()方法。</p><p>下面的代码展示如何将命令行抽象为日志写入器：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//命令行写入器</span><br><span class="line">type consoleWriter struct {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *consoleWriter) Write( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入命令行中</span><br><span class="line">    _ , err := os.Stdout.Write([]byte(str))</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建命令行写入器实例</span><br><span class="line">func newConsoleWriter() *consoleWriter {</span><br><span class="line">    return &amp;consoleWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第9行，声明consoleWriter结构，以实现命令行写入器。</li><li>第13行，consoleWriter的Write()方法实现了日志写入接口（LogWriter）的Write()方法。</li><li>第16行，与fileWriter类似，这里也将data通过fmt.Sprintf序列化为字符串。</li><li>第19行，与fileWriter类似，这里也将str字符串转换为字节数组并写入标准输出os.Stdout。写入后的内容就会显示在命令行中。</li><li>第25行，创建命令行写入器的实例。</li></ul><p>除了命令行写入器（consoleWriter）和文件写入器（fileWriter），读者还可以自行使用net包中的Socket封装实现网络写入器socketWriter，让日志可以写入远程的服务器中或者可以跨进程进行日志保存和分析。</p><h3 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h3><p>在程序中使用日志器一般会先通过代码创建日志器（Logger），为日志器添加输出设备（fileWriter、consoleWriter等）。这些设备中有一部分需要一些参数设定，如文件日志写入器需要提供文件名（fileWriter的SetFile()方法）。</p><p>下面代码中展示了使用日志器的过程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">//创建日志器</span><br><span class="line">func createLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    //创建日志器</span><br><span class="line">    l := NewLogger()</span><br><span class="line"></span><br><span class="line">    //创建命令行写入器</span><br><span class="line">    cw := newConsoleWriter()</span><br><span class="line"></span><br><span class="line">    //注册命令行写入器到日志器中</span><br><span class="line">    l.RegisterWriter(cw)</span><br><span class="line"></span><br><span class="line">    //创建文件写入器</span><br><span class="line">    fw := newFileWriter()</span><br><span class="line"></span><br><span class="line">    //设置文件名</span><br><span class="line">    if err := fw.SetFile("log.log"); err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //注册文件写入器到日志器中</span><br><span class="line">    l.RegisterWriter(fw)</span><br><span class="line"></span><br><span class="line">    return l</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备日志器</span><br><span class="line">    l := createLogger()</span><br><span class="line"></span><br><span class="line">    //写一个日志</span><br><span class="line">    l.Log("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第6行，一个创建日志的过程。这个过程一般隐藏在系统初始化中。程序启动时初始化一次。</li><li>第9行，创建一个日志器的实例，后面的代码会使用到它。</li><li>第12行，创建一个命令行写入器。如果全局有很多日志器，命令行写入器可以被共享，全局只会有一份。</li><li>第18行，创建一个文件写入器。一个程序的日志一般只有一个，因此不同的日志器也应该共享一个文件写入器。</li><li>第21行，创建好的文件写入器需要初始化写入的文件，通过文件名确定写入的文件。设置的过程可能会发生错误，发生错误时会输出错误信息。</li><li>第26行，将文件写入器注册到日志器中。</li><li>第34行，在程序一开始创建日志器。</li><li>第37行，往创建好的日志器中写入日志。</li></ul><p>编译整个代码并运行，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></tbody></table></figure><p>同时，当前目录的log.log文件中也会出现hello字符。</p><p><strong>提示:</strong></p><p>Go语言的log包实现了一个小型的日志系统。这个日志系统可以在创建日志器时选择输出设备、日志前缀及flag，函数定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func New(out io.Writer,prefix string,flag int) *Logger { return &amp;Logger{out:out,prefix:prefix,flag:flag }}</span><br></pre></td></tr></tbody></table></figure><p>在flag中，还可以定制日志中是否输出日期、日期精度和详细文件名等。</p><p>这个日志器在编写时，也最大程度地保证了输出的效率，如果读者对日志器的编写比较感兴趣，可以在log包的基础上进行扩展，形成方便自己使用的日志库。</p><h2 id="排序（借助sort-Interface接口）"><a href="#排序（借助sort-Interface接口）" class="headerlink" title="排序（借助sort.Interface接口）"></a>排序（借助sort.Interface接口）</h2><p>排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要 15 行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。</p><p>幸运的是，sort 包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。</p><p>相比之下，Go语言的 sort.Sort 函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型 sort.Interface 来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p><p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 的三个方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package sort</span><br><span class="line">type Interface interface {</span><br><span class="line">    Len() int            // 获取元素数量</span><br><span class="line">    Less(i, j int) bool // i，j是序列元素的指数。</span><br><span class="line">    Swap(i, j int)        // 交换元素</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用 sort.Sort 函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型 MyStringList  和它的 Len，Less 和 Swap 方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyStringList  []string</span><br><span class="line">func (p MyStringList ) Len() int { return len(m) }</span><br><span class="line">func (p MyStringList ) Less(i, j int) bool { return m[i] &lt; m[j] }</span><br><span class="line">func (p MyStringList ) Swap(i, j int) { m[i], m[j] = m[j], m[i] }</span><br></pre></td></tr></tbody></table></figure><h3 id="使用sort-Interface接口进行排序"><a href="#使用sort-Interface接口进行排序" class="headerlink" title="使用sort.Interface接口进行排序"></a>使用sort.Interface接口进行排序</h3><p>对一系列字符串进行排序时，使用字符串切片（ <code>[]string</code> ）承载多个字符串。使用 type 关键字，将字符串切片（ <code>[]string</code> ）定义为自定义类型 MyStringList。为了让 sort 包能识别 MyStringList，能够对 MyStringList 进行排序，就必须让 MyStringList 实现 sort.Interface 接口。</p><p>下面是对字符串排序的详细代码（代码1）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将[]string定义为MyStringList类型</span><br><span class="line">type MyStringList []string</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的获取元素数量方法</span><br><span class="line">func (m MyStringList) Len() int {</span><br><span class="line">    return len(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的比较元素方法</span><br><span class="line">func (m MyStringList) Less(i, j int) bool {</span><br><span class="line">    return m[i] &lt; m[j]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的交换元素方法</span><br><span class="line">func (m MyStringList) Swap(i, j int) {</span><br><span class="line">    m[i], m[j] = m[j], m[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个内容被打乱顺序的字符串切片</span><br><span class="line">    names := MyStringList{</span><br><span class="line">        "3. Triple Kill",</span><br><span class="line">        "5. Penta Kill",</span><br><span class="line">        "2. Double Kill",</span><br><span class="line">        "4. Quadra Kill",</span><br><span class="line">        "1. First Blood",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(names)</span><br><span class="line"></span><br><span class="line">    // 遍历打印结果</span><br><span class="line">    for _, v := range names {</span><br><span class="line">            fmt.Printf("%s\n", v)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First Blood</span><br><span class="line">2. Double Kill</span><br><span class="line">3. Triple Kill</span><br><span class="line">4. Quadra Kill</span><br><span class="line">5. Penta Kill</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 9 行，接口实现不受限于结构体，任何类型都可以实现接口。要排序的字符串切片 <code>[]string</code> 是系统定制好的类型，无法让这个类型去实现 sort.Interface 排序接口。因此，需要将 <code>[]string</code> 定义为自定义的类型。</li><li>第 12 行，实现获取元素数量的 Len() 方法，返回字符串切片的元素数量。</li><li>第 17 行，实现比较元素的 Less() 方法，直接取 m 切片的 i 和 j 元素值进行小于比较，并返回比较结果。</li><li>第 22 行，实现交换元素的 Swap() 方法，这里使用Go语言的多变量赋值特性实现元素交换。</li><li><p>第 29 行，由于将 <code>[]string</code> 定义成 MyStringList 类型，字符串切片初始化的过程等效于下面的写法</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names := []string {</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>第 38 行，使用 sort 包的 Sort() 函数，将 names（MyStringList类型）进行排序。排序时，sort 包会通过 MyStringList 实现的 Len()、Less()、Swap() 这 3 个方法进行数据获取和修改。</p></li><li>第 41 行，遍历排序好的字符串切片，并打印结果。</li></ul><h3 id="常见类型的便捷排序"><a href="#常见类型的便捷排序" class="headerlink" title="常见类型的便捷排序"></a>常见类型的便捷排序</h3><p>通过实现 sort.Interface 接口的排序过程具有很强的可定制性，可以根据被排序对象比较复杂的特性进行定制。例如，需要多种排序逻辑的需求就适合使用 sort.Interface 接口进行排序。但大部分情况中，只需要对字符串、整型等进行快速排序。Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。</p><p>1)字符串切片的便捷排序</p><p>sort 包中有一个 StringSlice 类型，定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type StringSlice []string</span><br><span class="line"></span><br><span class="line">func (p StringSlice) Len() int           { return len(p) }</span><br><span class="line">func (p StringSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p StringSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure><p>sort 包中的 StringSlice 的代码与 MyStringList 的实现代码几乎一样。因此，只需要使用 sort 包的 StringSlice 就可以更简单快速地进行字符串排序。将代码1中的排序代码简化后如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names := sort.StringSlice{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Sort(names)</span><br></pre></td></tr></tbody></table></figure><p>简化后，只要两句代码就实现了字符串排序的功能。</p><p>2)对整型切片进行排序</p><p>除了字符串可以使用 sort 包进行便捷排序外，还可以使用 sort.IntSlice 进行整型切片的排序。sort.IntSlice 的定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line"></span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p IntSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure><p>sort 包在 sort.Interface 对各类型的封装上还有更进一步的简化，下面使用 sort.Strings 继续对代码1进行简化，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">names := []string{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Strings(names)</span><br><span class="line"></span><br><span class="line">// 遍历打印结果</span><br><span class="line">for _, v := range names {</span><br><span class="line">    fmt.Printf("%s\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，需要排序的字符串切片。</li><li>第 9 行，使用 sort.Strings 直接对字符串切片进行排序。</li></ul><p>3)sort包内建的类型排序接口一览</p><p>Go语言中的 sort 包中定义了一些常见类型的排序方法，如下表所示。</p><table>    <thead><tr><th>类  型</th><th>实现 sort.lnterface的类型</th><th>直接排序方法</th><th>说  明</th></tr></thead>    <tbody>        <tr><th>字符串（String）</th><th>StringSlice</th><th>sort.Strings(a [] string)</th><th>字符 ASCII 值升序</th></tr>        <tr><th>整型（int）</th><th>IntSlice</th><th>sort.Ints(a []int)</th><th>数值升序</th></tr>        <tr><th>双精度浮点（float64）</th><th>Float64Slice</th><th>sort.Float64s(a []float64)</th><th>数值升序</th></tr>    </tbody></table><p>编程中经常用到的 int32、int64、float32、bool 类型并没有由 sort 包实现，使用时依然需要开发者自己编写。</p><h3 id="对结构体数据进行排序"><a href="#对结构体数据进行排序" class="headerlink" title="对结构体数据进行排序"></a>对结构体数据进行排序</h3><p>除了基本类型的排序，也可以对结构体进行排序。结构体比基本类型更为复杂，排序时不能像数值和字符串一样拥有一些固定的单一原则。结构体的多个字段在排序中可能会存在多种排序的规则，例如，结构体中的名字按字母升序排列，数值按从小到大的顺序排序。一般在多种规则同时存在时，需要确定规则的优先度，如先按名字排序，再按年龄排序等。</p><p>1)完整实现sort.Interface进行结构体排序</p><p>将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程如下。</p><p>结构体排序代码（代码2）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明英雄的分类</span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">// 定义HeroKind常量, 类似于枚举</span><br><span class="line">const (</span><br><span class="line">    None HeroKind = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义英雄名单的结构</span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string  // 英雄的名字</span><br><span class="line">    Kind HeroKind  // 英雄的种类</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将英雄指针的切片定义为Heros类型</span><br><span class="line">type Heros []*Hero</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口取元素数量方法</span><br><span class="line">func (s Heros) Len() int {</span><br><span class="line">    return len(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口比较元素方法</span><br><span class="line">func (s Heros) Less(i, j int) bool {</span><br><span class="line"></span><br><span class="line">    // 如果英雄的分类不一致时, 优先对分类进行排序</span><br><span class="line">    if s[i].Kind != s[j].Kind {</span><br><span class="line">        return s[i].Kind &lt; s[j].Kind</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 默认按英雄名字字符升序排列</span><br><span class="line">    return s[i].Name &lt; s[j].Name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口交换元素方法</span><br><span class="line">func (s Heros) Swap(i, j int) {</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备英雄列表</span><br><span class="line">    heros := Heros{</span><br><span class="line">        &amp;Hero{"吕布", Tank},</span><br><span class="line">        &amp;Hero{"李白", Assassin},</span><br><span class="line">        &amp;Hero{"妲己", Mage},</span><br><span class="line">        &amp;Hero{"貂蝉", Assassin},</span><br><span class="line">        &amp;Hero{"关羽", Tank},</span><br><span class="line">        &amp;Hero{"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(heros)</span><br><span class="line"></span><br><span class="line">    // 遍历英雄列表打印排序结果</span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;{Name:关羽 Kind:1}</span><br><span class="line">&amp;{Name:吕布 Kind:1}</span><br><span class="line">&amp;{Name:李白 Kind:2}</span><br><span class="line">&amp;{Name:貂蝉 Kind:2}</span><br><span class="line">&amp;{Name:妲己 Kind:3}</span><br><span class="line">&amp;{Name:诸葛亮 Kind:3}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 9 行，将 int 声明为 HeroKind 英雄类型，后面会将这个类型当做枚举来使用。</li><li>第 13 行，定义一些英雄类型常量，可以理解为枚举的值。</li><li>第 26 行，为了方便实现 sort.Interface 接口，将 <code>[]*Hero</code> 定义为 Heros 类型。</li><li>第 29 行，Heros 类型实现了 sort.Interface 的 Len() 方法，返回英雄的数量。</li><li>第 34 行，Heros 类型实现了 sort.Interface 的 Less() 方法，根据英雄字段的比较结果决定如何排序。</li><li>第 37 行，当英雄的分类不一致时，优先按分类的枚举数值从小到大排序。</li><li>第 42 行，英雄分类相等的情况下，默认根据英雄的名字字符升序排序。</li><li>第 46 行，Heros 类型实现了 sort.Interface 的 Swap() 方法，交换英雄元素的位置。</li><li>第 53～60 行，准备一系列英雄数据。</li><li>第 63 行，使用 sort 包进行排序。</li><li>第 66 行，遍历所有排序完成的英雄数据。</li></ul><p>2)使用sort.Slice进行切片元素排序</p><p>从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice() 函数进行更为简便的排序方法。sort.Slice() 函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为 <code>func(i,j int) bool</code>，sort.Slice() 函数的定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Slice(slice interface{}, less func(i, j int) bool)</span><br></pre></td></tr></tbody></table></figure><p>使用 sort.Slice() 函数，对代码2重新优化的完整代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string</span><br><span class="line">    Kind HeroKind</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    heros := []*Hero{</span><br><span class="line">        {"吕布", Tank},</span><br><span class="line">        {"李白", Assassin},</span><br><span class="line">        {"妲己", Mage},</span><br><span class="line">        {"貂蝉", Assassin},</span><br><span class="line">        {"关羽", Tank},</span><br><span class="line">        {"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sort.Slice(heros, func(i, j int) bool {</span><br><span class="line">        if heros[i].Kind != heros[j].Kind {</span><br><span class="line">            return heros[i].Kind &lt; heros[j].Kind</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return heros[i].Name &lt; heros[j].Name</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 33 行到第 39 行部分是新添加的 sort.Slice() 及回调函数部分。对比前面的代码，这里去掉了 Heros 及接口实现部分的代码。</p><p>使用 sort.Slice() 不仅可以完成结构体切片排序，还可以对各种切片类型进行自定义排序。</p><h2 id="接口的嵌套组合"><a href="#接口的嵌套组合" class="headerlink" title="接口的嵌套组合"></a>接口的嵌套组合</h2><p>在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。</p><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。</p><h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go语言的 io 包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3 个接口，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type WriteCloser interface {</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行定义了写入器（Writer），如这个接口较为常用，常用于 I/O 设备的数据写入。</li><li>第 5 行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。</li><li>第 9 行定义了写入关闭器（WriteCloser），这个接口由 Writer 和 Closer 两个接口嵌入。也就是说，WriteCloser 同时拥有了 Writer 和 Closer 的特性。</li></ul><h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><p>在代码中使用 io.Writer、io.Closer 和 io.WriteCloser 这 3 个接口时，只需要按照接口实现的规则实现 io.Writer 接口和 io.Closer 接口即可。而 io.WriteCloser 接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了 io.Writer 和 io.Closer 接口，详细实现代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个设备结构</span><br><span class="line">type device struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Writer的Write()方法</span><br><span class="line">func (d *device) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Closer的Close()方法</span><br><span class="line">func (d *device) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明写入关闭器, 并赋予device的实例</span><br><span class="line">    var wc io.WriteCloser = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    wc.Write(nil)</span><br><span class="line"></span><br><span class="line">    // 关闭设备</span><br><span class="line">    wc.Close()</span><br><span class="line"></span><br><span class="line">    // 声明写入器, 并赋予device的新实例</span><br><span class="line">    var writeOnly io.Writer = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    writeOnly.Write(nil)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行定义了 device 结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的 3 种接口。</li><li>第 12 行，实现了 io.Writer 的 Write() 方法。</li><li>第 17 行，实现了 io.Closer 的 Close() 方法。</li><li>第 24 行，对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</li><li>第 27 行，调用了 wc（io.WriteCloser接口）的 Write() 方法，由于 wc 被赋值 <code>*device</code> ，因此最终会调用 device 的 Write() 方法。</li><li>第 30 行，与 27 行类似，最终调用 device 的 Close() 方法。</li><li>第 33 行，再次创建一个 device 的实例，writeOnly 是一个 io.Writer 接口，这个接口只有 Write() 方法。</li><li>第 36 行，writeOnly 只能调用 Write() 方法，没有 Close() 方法。</li></ul><p>为了整理思路，将上面的实现、调用关系使用图方式来展现，参见图 1 和图 2。</p><p>1)io.WriteCloser的实现及调用过程如图 1 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writecloser.jpg" alt="图1：io.WriteCloser 的实现及调用过程"></p><p>2)io.Writer 的实现调用过程如图 2 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writer.jpg" alt="图2：io.Write 的实现及调用过程"></p><p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p><h2 id="接口和类型之间的转换"><a href="#接口和类型之间的转换" class="headerlink" title="接口和类型之间的转换"></a>接口和类型之间的转换</h2><p>Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。</p><h3 id="类型断言的格式"><a href="#类型断言的格式" class="headerlink" title="类型断言的格式"></a>类型断言的格式</h3><p>类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p><p>类型断言的基本格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></tbody></table></figure><p>其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量。</p><p>这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File) // 成功: f == os.Stdout</span><br><span class="line">c := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer</span><br></pre></td></tr></tbody></table></figure><p>第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 i 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。</p><p>在下面的第一个类型断言后，w 和 rw 都持有 os.Stdout 因此它们每个有一个动态类型 *os.File，但是变量 w 是一个 io.Writer 类型只对外公开出文件的 Write 方法，然而 rw 变量也只公开它的 Read 方法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) // 成功：*os.file具有读写功能</span><br><span class="line">w = new(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) // 死机：*字节计数器没有读取方法</span><br></pre></td></tr></tbody></table></figure><p>如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于 nil 接口值的情况。</p><p>如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t,ok := i.(T)</span><br></pre></td></tr></tbody></table></figure><p>这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true。这里 ok 可以被认为是：i 接口是否实现 T 类型的结果。</p><h3 id="将接口转换为其他接口"><a href="#将接口转换为其他接口" class="headerlink" title="将接口转换为其他接口"></a>将接口转换为其他接口</h3><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p><p>鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的 Fly() 和 Walk() 方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。</p><p>将鸟和猪的实例创建后，被保存到 interface{} 类型的 map 中。interface{} 类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的 interface{} 变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回 false。例如下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj interface = new(bird)</span><br><span class="line">f, isFlyer := obj.(Flyer)</span><br></pre></td></tr></tbody></table></figure><p>代码中，new(bird) 产生 <code>*bird</code> 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。</p><p>下面是详细的代码（代码1）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义飞行动物接口</span><br><span class="line">type Flyer interface {</span><br><span class="line">    Fly()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义行走动物接口</span><br><span class="line">type Walker interface {</span><br><span class="line">    Walk()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义鸟类</span><br><span class="line">type bird struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现飞行动物接口</span><br><span class="line">func (b *bird) Fly() {</span><br><span class="line">    fmt.Println("bird: fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为鸟添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (b *bird) Walk() {</span><br><span class="line">    fmt.Println("bird: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义猪</span><br><span class="line">type pig struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为猪添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (p *pig) Walk() {</span><br><span class="line">    fmt.Println("pig: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建动物的名字到实例的映射</span><br><span class="line">    animals := map[string]interface{}{</span><br><span class="line">        "bird": new(bird),</span><br><span class="line">        "pig":  new(pig),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历映射</span><br><span class="line">    for name, obj := range animals {</span><br><span class="line"></span><br><span class="line">        // 判断对象是否为飞行动物</span><br><span class="line">        f, isFlyer := obj.(Flyer)</span><br><span class="line">        // 判断对象是否为行走动物</span><br><span class="line">        w, isWalker := obj.(Walker)</span><br><span class="line"></span><br><span class="line">        fmt.Printf("name: %s isFlyer: %v isWalker: %v\n", name, isFlyer, isWalker)</span><br><span class="line">        // 如果是飞行动物则调用飞行动物接口</span><br><span class="line">        if isFlyer {</span><br><span class="line">            f.Fly()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 如果是行走动物则调用行走动物接口</span><br><span class="line">        if isWalker {</span><br><span class="line">            w.Walk()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行定义了飞行动物的接口。</li><li>第 11 行定义了行走动物的接口。</li><li>第 16 和 30 行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。</li><li>第 41 行是一个 map，映射对象名字和对象实例，实例是鸟和猪。</li><li>第 47 行开始遍历 map，obj 为 interface{} 接口类型。</li><li>第 50 行中，使用类型断言获得 f，类型为 Flyer 及 isFlyer 的断言成功的判定。</li><li>第 52 行中，使用类型断言获得 w，类型为 Walker 及 isWalker 的断言成功的判定。</li><li>第 57 和 62 行，根据飞行动物和行走动物两者是否断言成功，调用其接口。</li></ul><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name: pig isFlyer: false isWalker: true</span><br><span class="line">pig: walk</span><br><span class="line">name: bird isFlyer: true isWalker: true</span><br><span class="line">bird: fly</span><br><span class="line">bird: walk</span><br></pre></td></tr></tbody></table></figure><h3 id="将接口转换为其他类型"><a href="#将接口转换为其他类型" class="headerlink" title="将接口转换为其他类型"></a>将接口转换为其他类型</h3><p>在代码 1 中，可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 <code>*pig</code> 类型，请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*pig)</span><br><span class="line"></span><br><span class="line">fmt.Printf("p1=%p p2=%p", p1, p2)</span><br></pre></td></tr></tbody></table></figure><p>对代码的说明如下：</p><ul><li>第 3 行，由于 pig 实现了 Walker 接口，因此可以被隐式转换为 Walker 接口类型保存于 a 中。</li><li>第 4 行，由于 a 中保存的本来就是 <code>*pig</code> 本体，因此可以转换为 <code>*pig</code> 类型。</li><li>第 6 行，对比发现，p1 和 p2 指针是相同的。</li></ul><p>如果尝试将上面这段代码中的 Walker 类型的 a 转换为 <code>*bird</code> 类型，将会发出运行时错误，请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*bird)</span><br></pre></td></tr></tbody></table></figure><p>运行时报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: main.Walker is *main.pig, not *main.bird</span><br></pre></td></tr></tbody></table></figure><p>报错意思是：接口转换时，main.Walker 接口的内部保存的是 <code>*main.pig</code> ，而不是 <code>*main.bird</code> 。</p><p>因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p><p><strong>总结:</strong></p><p>接口和其他类型的转换可以在Go语言中自由进行，前提是已经完全实现。</p><p>接口断言类似于流程控制中的 if。但大量类型断言出现时，应使用更为高效的类型分支 switch 特性。</p><h2 id="空接口类型（interface-）"><a href="#空接口类型（interface-）" class="headerlink" title="空接口类型（interface{}）"></a>空接口类型（interface{}）</h2><p>空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。</p><p><strong>提示:</strong></p><p>空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。</p><p>空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。</p><h3 id="将值保存到空接口"><a href="#将值保存到空接口" class="headerlink" title="将值保存到空接口"></a>将值保存到空接口</h3><p>空接口的赋值如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var any interface{}</span><br><span class="line"></span><br><span class="line">any = 1</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = "hello"</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = false</span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">hello</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure><p>对代码的说明：</p><ul><li>第 1 行，声明 any 为 interface{} 类型的变量。</li><li>第 3 行，为 any 赋值一个整型 1。</li><li>第 4 行，打印 any 的值，提供给 fmt.Println 的类型依然是 interface{}。</li><li>第 6 行，为 any 赋值一个字符串 hello。此时 any 内部保存了一个字符串。但类型依然是 interface{}。</li><li>第 9 行，赋值布尔值。</li></ul><h3 id="从空接口获取值"><a href="#从空接口获取值" class="headerlink" title="从空接口获取值"></a>从空接口获取值</h3><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明a变量, 类型int, 初始值为1</span><br><span class="line">var a int = 1</span><br><span class="line"></span><br><span class="line">// 声明i变量, 类型为interface{}, 初始值为a, 此时i的值变为1</span><br><span class="line">var i interface{} = a</span><br><span class="line"></span><br><span class="line">// 声明b变量, 尝试赋值i</span><br><span class="line">var b int = i</span><br></pre></td></tr></tbody></table></figure><p>第8行代码编译报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use i (type interface {}) as type int in assignment: need type assertion</span><br></pre></td></tr></tbody></table></figure><p>编译器告诉我们，不能将i变量视为int类型赋值给b。</p><p>在代码第 5 行中，将 a 的值赋值给 i 时，虽然 i 在赋值完成后的内部值为 int，但 i 还是一个 interface{} 类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。</p><p>为了让第 8 行的操作能够完成，编译器提示我们得使用 <code>type assertion</code> ，意思就是类型断言。</p><p>使用类型断言修改第 8 行代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b int = i.(int)</span><br></pre></td></tr></tbody></table></figure><p>修改后，代码可以编译通过，并且 b 可以获得 i 变量保存的 a 变量的值：1。</p><h3 id="空接口的值比较"><a href="#空接口的值比较" class="headerlink" title="空接口的值比较"></a>空接口的值比较</h3><p>空接口在保存不同的值后，可以和其他变量值一样使用 <code>==</code> 进行比较操作。空接口的比较有以下几种特性。</p><p>1)类型不同的空接口间的比较结果不相同</p><p>保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a保存整型</span><br><span class="line">var a interface{} = 100</span><br><span class="line"></span><br><span class="line">// b保存字符串</span><br><span class="line">var b interface{} = "hi"</span><br><span class="line"></span><br><span class="line">// 两个空接口不相等</span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></tbody></table></figure><p>2)不能比较空接口中的动态值</p><p>当接口中保存有动态类型的值时，运行时将触发错误，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c保存包含10的整型切片</span><br><span class="line">var c interface{} = []int{10}</span><br><span class="line"></span><br><span class="line">// d保存包含20的整型切片</span><br><span class="line">var d interface{} = []int{20}</span><br><span class="line"></span><br><span class="line">// 这里会发生崩溃</span><br><span class="line">fmt.Println(c == d)</span><br></pre></td></tr></tbody></table></figure><p>代码运行到第8行时发生崩溃：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: comparing uncomparable type []int</span><br></pre></td></tr></tbody></table></figure><p>这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。</p><table>    <thead><tr><th>类  型</th><th>说  明</th></tr></thead>    <tbody>        <tr><th>map</th><th>宕机错误，不可比较</th></tr>        <tr><th>切片（[]T）</th><th>宕机错误，不可比较</th></tr>        <tr><th>通道（channel）</th><th>可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false</th></tr>        <tr><th>数组（[容量]T）</th><th>可比较，编译期知道两个数组是否一致</th></tr>        <tr><th>结构体</th><th>可比较，可以逐个比较结构体的值</th></tr>         <tr><th>函数</th><th>可比较</th></tr>    </tbody></table><h2 id="使用空接口实现可以保存任意值的字典"><a href="#使用空接口实现可以保存任意值的字典" class="headerlink" title="使用空接口实现可以保存任意值的字典"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/85.html">使用空接口实现可以保存任意值的字典</a></h2><p>空接口可以保存任何类型这个特性可以方便地用于容器的设计。下面例子使用 map 和 interface{} 实现了一个字典。字典在其他语言中的功能和 map 类似，可以将任意类型的值做成键值对保存，然后进行找回、遍历操作。详细实现过程请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{} // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line"></span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 遍历所有的键值，如果回调返回值为false，停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型，并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出很贵</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出很便宜</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="值设置和获取"><a href="#值设置和获取" class="headerlink" title="值设置和获取"></a>值设置和获取</h3><p>字典内部拥有一个 data 字段，其类型为 map。这个 map 的键和值都是 interface{} 类型，也就是实现任意类型关联任意类型。字典的值设置和获取通过 Set() 和 Get() 两个方法来完成，参数都是 interface{}。详细实现代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{}  // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，Dictionary 的内部实现是一个键值均为 interface{} 类型的 map，map 也具备与 Dictionary 一致的功能。</li><li>第 8 行，通过 map 直接获取值，如果键不存在，将返回 nil。</li><li>第 13 行，通过 map 设置键值。</li></ul><h3 id="遍历字段的所有键值关联数据"><a href="#遍历字段的所有键值关联数据" class="headerlink" title="遍历字段的所有键值关联数据"></a>遍历字段的所有键值关联数据</h3><p>每个容器都有遍历操作。遍历时，需要提供一个回调返回需要遍历的数据。为了方便在必要时终止遍历操作，可以将回调的返回值设置为 bool 类型，外部逻辑在回调中不需要遍历时直接返回 false 即可终止遍历。</p><p>Dictionary 的 Visit() 方法需要传入回调函数，回调函数的类型为 <code>func(k,v interface{}) bool</code>。每次遍历时获得的键值关联数据通过回调函数的 k 和 v 参数返回。Visit 的详细实现请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 遍历所有的键值, 如果回调返回值为false, 停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，定义回调，类型为 <code>func(k,v interface{}) bool</code>，意思是返回键值数据（k、v）。bool 表示遍历流程控制，返回 true 时继续遍历，返回 false 时终止遍历。</li><li>第 4 行，当 callback 为空时，退出遍历，避免后续代码访问空的 callback 而导致的崩溃。</li><li>第 8 行，遍历字典结构的 data 成员，也就是遍历 map 的所有元素。</li><li>第 9 行，根据 callback 的返回值，决定是否继续遍历。</li></ul><h3 id="初始化和清除"><a href="#初始化和清除" class="headerlink" title="初始化和清除"></a>初始化和清除</h3><p>字典结构包含有 map，需要在创建 Dictionary 实例时初始化 map。这个过程通过 Dictionary 的 Clear() 方法完成。在 NewDictionary 中调用 Clear() 方法避免了 map 初始化过程的代码重复问题。请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，map 没有独立的复位内部元素的操作，需要复位元素时，使用 make 创建新的实例。Go语言的垃圾回收是并行的，不用担心 map 清除的效率问题。</li><li>第 7 行，实例化一个 Dictionary。</li><li>第 11 行，在初始化时调用 Clear 进行 map 初始化操作。</li></ul><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>字典实现完成后，需要经过一个测试过程，查看这个字典是否存在问题。</p><p>将一些字符串和数值组合放入到字典中，然后再从字典中根据键查询出对应的值，接着再遍历一个字典中所有的元素。详细实现过程请参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型, 并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出“很贵”</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出“很便宜”</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 4 行创建字典的实例。</li><li>第 7～9 行，将 3 组键值对通过字典的 Set() 方法设置到字典中。</li><li>第 12 行，根据字符串键查找值，将结果保存在 favorite 中。</li><li>第 13 行，打印 favorite 的值。</li><li>第 16 行，遍历字典的所有键值对。遍历的返回数据通过回调提供，key 是键，value 是值。</li><li>第 19 行，遍历返回的 key 和 value 的类型都是 interface{}，这里确认 value 只有 int 类型，所以将 value 转换为 int 类型判断是否大于 40。</li><li>第 23 和 29 行，继续遍历，返回 true</li><li>第 23 行，打印键。</li></ul><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite: 36</span><br><span class="line">My Factory is expensive</span><br><span class="line">Terra Craft is cheap</span><br><span class="line">Don't Hungry is cheap</span><br></pre></td></tr></tbody></table></figure><h2 id="类型分支（switch判断空接口中变量的类型）"><a href="#类型分支（switch判断空接口中变量的类型）" class="headerlink" title="类型分支（switch判断空接口中变量的类型）"></a>类型分支（switch判断空接口中变量的类型）</h2><p>type-switch 流程控制的语法或许是Go语言中最古怪的语法。 它可以被看作是类型断言的增强版。它和 switch-case 流程控制代码块有些相似。 一个 type-switch 流程控制代码块的语法如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch t := areaIntf.(type) {</span><br><span class="line">case *Square:</span><br><span class="line">    fmt.Printf("Type Square %T with value %v\n", t, t)</span><br><span class="line">case *Circle:</span><br><span class="line">    fmt.Printf("Type Circle %T with value %v\n", t, t)</span><br><span class="line">case nil:</span><br><span class="line">    fmt.Printf("nil value: nothing to check?\n")</span><br><span class="line">default:</span><br><span class="line">    fmt.Printf("Unexpected type %T\n", t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结构如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type Square *main.Square with value &amp;{5}</span><br></pre></td></tr></tbody></table></figure><p>变量 t 得到了 areaIntf 的值和类型， 所有 case 语句中列举的类型（nil 除外）都必须实现对应的接口，如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。</p><p>如果跟随在某个 case 关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值 x 的（接口）类型。</p><h3 id="类型断言的书写格式"><a href="#类型断言的书写格式" class="headerlink" title="类型断言的书写格式"></a>类型断言的书写格式</h3><p>switch 实现类型分支时的写法格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch 接口变量.(type) {</span><br><span class="line">    case 类型1:</span><br><span class="line">        // 变量是类型1时的处理</span><br><span class="line">    case 类型2:</span><br><span class="line">        // 变量是类型2时的处理</span><br><span class="line">    …</span><br><span class="line">    default:</span><br><span class="line">        // 变量不是所有case中列举的类型时的处理</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对各个部分的说明：</p><ul><li>接口变量：表示需要判断的接口类型的变量。</li><li>类型1、类型2……：表示接口变量可能具有的类型列表，满足时，会指定 case 对应的分支进行处理。</li></ul><h3 id="使用类型分支判断基本类型"><a href="#使用类型分支判断基本类型" class="headerlink" title="使用类型分支判断基本类型"></a>使用类型分支判断基本类型</h3><p>下面的例子将一个 interface{} 类型的参数传给 printType() 函数，通过 switch 判断 v 的类型，然后：打印对应类型的提示，代码如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printType(v interface{}) {</span><br><span class="line"></span><br><span class="line">    switch v.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(v, "is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(v, "is string")</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Println(v, "is bool")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    printType(1024)</span><br><span class="line">    printType("pig")</span><br><span class="line">    printType(true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1024 is int</span><br><span class="line">pig is string</span><br><span class="line">true is bool</span><br></pre></td></tr></tbody></table></figure><p>代码第 9 行中，<code>v.(type)</code> 就是类型分支的典型写法。通过这个写法，在 switch 的每个 case 中写的将是各种类型分支。</p><p>代码经过 switch 时，会判断 v 这个 interface{} 的具体类型从而进行类型分支跳转。</p><p>switch 的 default 也是可以使用的，功能和其他的 switch 一致。</p><h3 id="使用类型分支判断接口类型"><a href="#使用类型分支判断接口类型" class="headerlink" title="使用类型分支判断接口类型"></a>使用类型分支判断接口类型</h3><p>多个接口进行类型断言时，可以使用类型分支简化判断过程。</p><p>现在电子支付逐渐成为人们普遍使用的支付方式，电子支付相比现金支付具备很多优点。例如，电子支付能够刷脸支付，而现金支付容易被偷等。使用类型分支可以方便地判断一种支付方法具备哪些特性，具体请参考下面的代码。</p><p>电子支付和现金支付：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 电子支付方式</span><br><span class="line">type Alipay struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Alipay添加CanUseFaceID()方法, 表示电子支付方式支持刷脸</span><br><span class="line">func (a *Alipay) CanUseFaceID() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 现金支付方式</span><br><span class="line">type Cash struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Cash添加Stolen()方法, 表示现金支付方式会出现偷窃情况</span><br><span class="line">func (a *Cash) Stolen() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备刷脸特性的接口</span><br><span class="line">type CantainCanUseFaceID interface {</span><br><span class="line">    CanUseFaceID()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备被偷特性的接口</span><br><span class="line">type ContainStolen interface {</span><br><span class="line">    Stolen()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印支付方式具备的特点</span><br><span class="line">func print(payMethod interface{}) {</span><br><span class="line">    switch payMethod.(type) {</span><br><span class="line">    case CantainCanUseFaceID:  // 可以刷脸</span><br><span class="line">        fmt.Printf("%T can use faceid\n", payMethod)</span><br><span class="line">    case ContainStolen:  // 可能被偷</span><br><span class="line">        fmt.Printf("%T may be stolen\n", payMethod)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用电子支付判断</span><br><span class="line">    print(new(Alipay))</span><br><span class="line"></span><br><span class="line">    // 使用现金判断</span><br><span class="line">    print(new(Cash))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6～19 行，分别定义 Alipay 和 Cash 结构，并为它们添加具备各自特点的方法。</li><li>第 22～29 行，定义两种特性，即刷脸和被偷。</li><li>第 32 行，传入支付方式的接口。</li><li>第 33 行，使用类型分支进行支付方法的特性判断。</li><li>第 34～37 行，分别对刷脸和被偷的特性进行打印。</li></ul><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*main.Alipay can use faceid</span><br><span class="line">*main.Cash may be stolen</span><br></pre></td></tr></tbody></table></figure><h2 id="error接口：返回错误信息"><a href="#error接口：返回错误信息" class="headerlink" title="error接口：返回错误信息"></a>error接口：返回错误信息</h2><p>错误处理在每个编程语言中都是一项重要内容，通常开发中遇到的分为异常与错误两种，Go语言中也不例外。本节我们主要来学习一下Go语言中的错误处理。</p><p>在C语言中通过返回 -1 或者 NULL 之类的信息来表示错误，但是对于使用者来说，如果不查看相应的 API 说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如返回 0 是成功还是失败？</p><p>针对这样的情况，Go语言中引入 error 接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含 error。error 处理过程类似于C语言中的错误码，可逐层返回，直到被处理。</p><h3 id="error-基本用法"><a href="#error-基本用法" class="headerlink" title="error 基本用法"></a>error 基本用法</h3><p>Go语言中返回的 error 类型究竟是什么呢？查看Go语言的源码就会发现 error 类型是一个非常简单的接口类型，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The error built-in interface type is the conventional interface for</span><br><span class="line">// representing an error condition, with the nil value representing no error.</span><br><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>error 接口有一个签名为 Error() string 的方法，所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述，在使用 fmt.Println 打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。</p><p>一般情况下，如果函数需要返回错误，就将 error 作为多个返回值中的最后一个（但这并非是强制要求）。</p><p>创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, errors.New("math: square root of negative number")</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math: square root of negative number</span><br></pre></td></tr></tbody></table></figure><p>上面代码中简单介绍了使用 errors.New 来返回一个错误信息，与其他语言的异常相比，Go语言的方法相对更加容易、直观。</p><h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>除了上面的 errors.New 用法之外，我们还可以使用 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type dualError struct {</span><br><span class="line">    Num     float64</span><br><span class="line">    problem string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (e dualError) Error() string {</span><br><span class="line">    return fmt.Sprintf("Wrong!!!,because \"%f\" is a negative number", e.Num)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, dualError{Num: f}</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wrong!!!,because "-13.000000" is a negative number</span><br></pre></td></tr></tbody></table></figure><h2 id="接口内部实现"><a href="#接口内部实现" class="headerlink" title="接口内部实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5116.html">接口内部实现</a></h2><p>前几节我们介绍了接口的基本概念和用法，定义接口只需简单声明一个方法集合即可，定义新类型时不需要显式地声明要实现的接口，接口的使用也很简单。</p><p>那么接口的底层是如何实现的呢？如何实现动态调用的呢？接口的动态调用到底有多大的额外开销？本节我们就来深入讲解一下接口的底层实现。</p><p>阅读本节需要读者了解Go语言接口的基础知识和Go语言汇编基础和函数调用规约，以及对 ELF 可执行文件格式有基本了解。本节内容有点偏底层，有一定的难度，如果阅读起来有困难，可以先跳过去，有时间再慢慢读。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a></h3><p>从前面章节了解到，接口变量必须初始化才有意义，没有初始化的接口变量的默认值是 nil，没有任何意义。具体类型实例传递给接口称为接口的实例化。在接口的实例化的过程中，编译器通过特定的数据结构描述这个过程。</p><p>首先介绍非空接口的内部数据结构，空接口的底层更简单，放到最后介绍。非空接口的底层数据结构是 iface，代码位于Go语言安装目录的 <code>src/runtime/runtime2.go</code> 文件中。</p><h4 id="iface-数据结构"><a href="#iface-数据结构" class="headerlink" title="iface 数据结构"></a>iface 数据结构</h4><p>非空接口初始化的过程就是初始化一个 iface 类型的结构，示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type iface struct {</span><br><span class="line">    tab *itab                //itab 存放类型及方法指针信息</span><br><span class="line">    data unsafe.Pointer      //数据信息</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到 iface 结构很简单，有两个指针类型字段。</p><ul><li>itab：用来存放接口自身类型和绑定的实例类型及实例相关的函数指针，具体内容后面有详细介绍。</li><li>数据指针 data：指向接口绑定的实例的副本，接口的初始化也是一种值拷贝。</li></ul><p>data 指向具体的实例数据，如果传递给接口的是值类型，则 data 指向的是实例的副本；如果传递给接口的是指针类型，则 data 指向指针的副本。总而言之，无论接口的转换，还是函数调用，Go 遵循一样的规则——值传递。</p><p>接下来看一下 itab 数据结构，itab 是接口内部实现的核心和基础。示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype      //接口自身的静态类型</span><br><span class="line">    _type *_type              //_type 就是接口存放的具体实例的类型（动态类型）</span><br><span class="line">    //hash 存放具体类型的 Hash 值</span><br><span class="line">    hash uint32               // copy of _type.hash. Used for type switches.</span><br><span class="line">    _   [4]byte</span><br><span class="line">    fun [1]uintptr            // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>itab 有 5 个字段：</p><ul><li>inter：是指向接口类型元信息的指针。</li><li>_type：是指向接口存放的具体类型元信息的指针，iface 里的 data 指针指向的是该类型的值。一个是类型信息，另一个是类型的值。</li><li>hash：是具体类型的 Hash 值，_type 里面也有 hash，这里冗余存放主要是为了接口断言或类型查询时快速访问。</li><li>fun：是一个函数指针，可以理解为 C++ 对象模型里面的虚拟函数指针，这里虽然只有一个元素，实际上指针数组的大小是可变的，编译器负责填充，运行时使用底层指针进行访问，不会受 struct 类型越界检查的约束，这些指针指向的是具体类型的方法。</li></ul><p>itab 这个数据结构是非空接口实现动态调用的基础，itab 的信息被编译器和链接器保存了下来，存放在可执行文件的只读存储段（ <code>.rodata</code> ）中。itab 存放在静态分配的存储空间中，不受 GC 的限制，其内存不会被回收。</p><p>接下来介绍 <code>_type</code> 数据结构，Go语言是一种强类型的语言，编译器在编译时会做严格的类型校验。所以 Go 必然为每种类型维护一个类型的元信息，这个元信息在运行和反射时都会用到，Go语言的类型元信息的通用结构是 <code>_type</code>（代码位于 <code>src/runtime/type.go</code>）， 其他类型都是以 <code>_type</code> 为内嵌宇段封装而成的结构体。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">type type struct {</span><br><span class="line">    size uintptr     // 大小</span><br><span class="line">    ptrdata uintptr  //size of memory prefix holding all pointers</span><br><span class="line">    hash uint32      //类型Hash</span><br><span class="line">    tflag tflag      //类型的特征标记</span><br><span class="line">    align uint8      //_type 作为整体交量存放时的对齐字节数</span><br><span class="line">    fieldalign uint8 //当前结构字段的对齐字节数</span><br><span class="line">    kind uint8       //基础类型枚举值和反射中的 Kind 一致，kind 决定了如何解析该类型</span><br><span class="line">    alg *typeAlg     //指向一个函数指针表，该表有两个函数，一个是计算类型 Hash 函</span><br><span class="line">                     //数，另一个是比较两个类型是否相同的 equal 函数</span><br><span class="line">    //gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    //If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    //Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata *byte      //GC 相关信息</span><br><span class="line">    str nameOff       //str 用来表示类型名称字符串在编译后二进制文件中某个 section</span><br><span class="line">                      //的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">    ptrToThis typeOff //ptrToThis 用来表示类型元信息的指针在编译后二进制文件中某个</span><br><span class="line">                      //section 的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>_type</code> 包含所有类型的共同元信息，编译器和运行时可以根据该元信息解析具体类型、类型名存放位置、类型的 Hash 值等基本信息。</p><p>这里需要说明一下：<code>＿type</code> 里面的 nameOff 和 typeOff 最终是由链接器负责确定和填充的，它们都是一个偏移量（offset），类型的名称和类型元信息实际上存放在连接后可执行文件的某个段（section）里，这两个值是相对于段内的偏移量，运行时提供两个转换查找函数。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">//获取 _type 的 name</span><br><span class="line">func resolveNameOff(ptrInModule unsafe.Pointer , off nameOff) name {}</span><br><span class="line">//获取 _type 的副本</span><br><span class="line">func resolveTypeOff(ptrInModule unsafe.Pointer , off typeOff) *_type {}</span><br></pre></td></tr></tbody></table></figure><p><strong><em>注意：Go语言类型元信息最初由编译器负责构建，并以表的形式存放在编译后的对象文件中，再由链接器在链接时进行段合并、符号重定向（填充某些值）。这些类型信息在接口的动态调用和反射中被运行时引用。</em></strong></p><p>接下来看一下接口的类型元信息的数据结构。示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//描述接口的类型</span><br><span class="line">type interfacetype struct {</span><br><span class="line">    typ _type       //类型通用部分</span><br><span class="line">    pkgpath name    //接口所属包的名字信息， name 内存放的不仅有名称，还有描述信息</span><br><span class="line">    mhdr []imethod  //接口的方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//接口方法元信息</span><br><span class="line">type imethod struct {</span><br><span class="line">    name nameOff //方法名在编译后的 section 里面的偏移量</span><br><span class="line">    ityp typeOff //方法类型在编译后的 section 里面的偏移量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口调用过程分析"><a href="#接口调用过程分析" class="headerlink" title="接口调用过程分析"></a>接口调用过程分析</h3><p>前面讨论了接口内部的基本数据结构，下面就来通过跟踪接口实例化和动态调用过程，使用 Go 源码和反汇编代码相结合的方式进行研究。下面是一段非常简单的接口调用代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//iface.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Caler interface {</span><br><span class="line">    Add (a , b int) int</span><br><span class="line">    Sub (a , b int) int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Adder struct ｛id int }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int) int { return a + b }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a , b int) int { return a - b }</span><br><span class="line"></span><br><span class="line">func main () {</span><br><span class="line">    var m Caler=Adder{id: 1234}</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生成汇编代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags= "-S - N -l" iface.go &gt;iface.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p>接下来分析 main 函数的汇编代码，非关键逻辑已经去掉：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"".main STEXT size=151 args=0x0 locals=0x40</span><br><span class="line">    ...</span><br><span class="line">    0x000f 00015 (src/iface.go:16) SUBQ $64, SP</span><br><span class="line">    0x0013 00019 (src/iface.go:16) MOVQ BP, 56(SP)</span><br><span class="line">    0x0018 00024 (src/iface.go:16) LEAQ 56(SP), BP</span><br></pre></td></tr></tbody></table></figure><p>为 main 函数堆栈开辟空间并保存原来的 BP 指针，这是函数调用前编译器的固定动作。</p><p>var m Caler = Adder {id: 1234} 语句汇编代码分析：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00ld 00029 (src/iface.go:17) MOVQ    $0, ""..autotmp_1+32(SP)</span><br><span class="line">0x0026 00038 (src/iface.go:17) MOVQ    $1234, ""..autotmp_1+32(SP)</span><br></pre></td></tr></tbody></table></figure><p>在堆上初始化局部对象 Adder，先初始化为 0，后初始化为 1234。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x002f 00047 (src/iface.go:17) LEAQ    go.itab."".Adder,"".Caler(SB),AX</span><br><span class="line">0x0036 00054 (src/iface.go:17) MOVQ    AX, (SP)</span><br></pre></td></tr></tbody></table></figure><p>这两条语句非常关键，首先 LEAQ 指令是一个获取地址的指令，<code>go.itab."".Adder,"".Caler(SB)</code> 是一个全局符号引用，通过该符号能够获取接口初始化时 itab 数据结构的地址。</p><p>注意：这个标号在链接器链接的过程中会替换为具体的地址。我们知道 (SP) 里面存放的是指向 <code>itab(Caler,Adder)</code> 的元信息的地址，这里 (SP) 是函数调用第一个参数的位置。示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x003a 00058 (src/iface.go:17) LEAQ ""..autotmp_1+32(SP), AX</span><br><span class="line">0x003f 00063 (src/iface.go:17) MOVQ AX, 8(SP)</span><br><span class="line">0x0044 00068 (src/iface.go:17) PCDATA $0, $0</span><br></pre></td></tr></tbody></table></figure><p>复制刚才的 Adder 类型对象的地址到 8(SP)，8(SP) 是函数调用的第二个参数位置。示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0044 00068 (src/iface.go:17) CALL    runtime.convT2I64(SB)</span><br></pre></td></tr></tbody></table></figure><p>runtime.convT2I64 函数是运行时接口动态调用的核心函数。runtime 中有一类这样的函数，看一下 runtime.convT2I64 的源码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {</span><br><span class="line">    t := tab._type</span><br><span class="line">    if raceenabled {</span><br><span class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I64))</span><br><span class="line">    }</span><br><span class="line">    if msanenabled {</span><br><span class="line">        msanread (elem, t.size)</span><br><span class="line">    }</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(uint64) (elem) == 0 {</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    } else {</span><br><span class="line">        x = mallocgc(8, t, false)</span><br><span class="line">        *(*uint64) (x) = *(*uint64) (elem)</span><br><span class="line">    }</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上述源码可以清楚地看出，<code>runtime.convT2I64</code> 的两个参数分别是 <code>*itab</code> 和 <code>unsafe.Pointer</code> 类型，这两个参数正是上文传递进去的两个参数值：<code>go.itab."".Adder, "".Caler(SB)</code> 和指向 Adder 对象复制的指针。</p><p><code>runtime.convT2I64</code> 的返回值是一个 iface 数据结构，其意义就是根据 itab 元信息和对象值复制的指针构建和初始化 iface 数据结构，iface 数据结构是实现接口动态调用的关键。至此己经完成了接口初始化的工作，即完成了 iface 数据结构的构建过程。下一步就是接口方法调用了。示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0049 00073 (src/iface.go:17) MOVQ 24(SP), AX</span><br><span class="line">0x004e 00078 (src/iface.go:17) MOVQ 16(SP), CX</span><br><span class="line">0x0053 00083 (src/iface.go:17 ) MOVQ CX, "".m+40(SP)</span><br><span class="line">0x0058 00088 (src/iface.go:17 ) MOVQ AX, "".m+48(SP)</span><br></pre></td></tr></tbody></table></figure><p>16(SP) 和 24(SP) 存放的是函数 runtime.convT2I64 的返回值，分别是指向 itab 和 data 的指针，将指向 itab 的指针复制到 40(SP)，将指向对象 data 的指针复制到 48(SP) 位置。</p><p>m.Add(10, 32) 对应的汇编代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00Sd 00093 (src/iface.go:18) MOVQ "".m+40(SP), AX</span><br><span class="line">0x0062 00098 (src/iface.go:18) MOVQ 32(AX), AX</span><br><span class="line">0x0066 00102 (src/iface.go:18) MOVQ "".m+48(SP), ex</span><br><span class="line">0x006b 00107 (src/iface.go:18) MOVQ $10, 8(SP)</span><br><span class="line">0x0074 00116 (src/iface.go:18) MOVQ $32, 16(SP)</span><br><span class="line">0x007d 00125 (src/iface.go:18) MOVQ CX, (SP)</span><br><span class="line">0x0081 00129 (src/iface.go:18) PCDATA $0, $0</span><br><span class="line">0x0081 00129 (src/iface.go:18) CALL AX</span><br></pre></td></tr></tbody></table></figure><p>第 1 条指令是将 itab 的指针（位于 40(SP)）复制到 AX 寄存器。第 2 条指令是 AX 将 itab 的偏移 32 字节的值复制到 AX。再来看一下 itab 的数据结构：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *type</span><br><span class="line">    link *itab</span><br><span class="line">    hash uint32 //copy of _type.hash.Used for type switches.</span><br><span class="line">    bad bool    //type does not implement interface</span><br><span class="line">    inhash bool //has this itab been added to hash?</span><br><span class="line">    unused [2]byte</span><br><span class="line">    fun [1] uintptr //variable sized</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>32(AX) 正好是函数指针的位置， 即存放 <code>Adder *Add()</code> 方法指针的地址（注意：编译器将接收者为值类型的 Add 方法转换为指针的 Add 方法，编译器的这种行为是为了方便调用和优化）。</p><p>第 3 条指令和第 6 条指令是将对象指针作为接下来函数调用的第 1 个参数。</p><p>第 4 条和第 5 条指令是准备函数的第 2、第 3 个参数。</p><p>第 8 条指令是调用 Adder 类型的 Add 方法。</p><p>此函数调用时，对象的值的副本作为第 1 个参数，调用格式可以表述为 <code>func(reciver, param1, param2)</code>。</p><p>至此，整个接口的动态调用完成。从中可以清楚地看到，接口的动态调用分为两个阶段：</p><ul><li>第一阶段就是构建 iface 动态数据结构，这一阶段是在接口实例化的时候完成的，映射到 Go 语句就是 <code>var m Caler = Adder{id: 1234}</code>。</li><li>第二阶段就是通过函数指针间接调用接口绑定的实例方法的过程，映射到 Go 语句就是 <code>m.Add(10, 32)</code> 。</li></ul><p>接下来看一下 <code>go.itab. "".Adder, "".Caler(SB)</code> 这个符号在哪里？我们使用 readelf 工具来静态地分析编译后的 ELF 格式的可执行程序。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#编译</span><br><span class="line">#go build -gcflag s= "-N -l" iface.go</span><br><span class="line">#readelf -s -W iface legrep 'itab'</span><br><span class="line">    60:000000000047b220 0 OBJECT LOCAL DEFAULT 5 runtime.itablink</span><br><span class="line">    61:000000000047b230 0 OBJECT LOCAL DEFAULT 5 runtime.eitablink</span><br><span class="line">    88:00000000004aa100 48 OBJECT GLOBAL DEFAULT 8 go.itab.main.Adder, main.Caler</span><br><span class="line">    214:00000000004aa080 40 OBJECT GLOBAL DEFAULT 8 go.itab.runtime.errorString, error</span><br><span class="line">    418:00000000004095e0 1129 FUNC GLOBAL DEFAULT 1 runtime.getitab</span><br><span class="line">    419:0000000000409a50 1665 FUNC GLOBAL DEFAULT 1 runtime.additab</span><br><span class="line">    420:000000000040a0e0 257 FUNC GLOBAL DEFAULT 1 runtime.itabsinit</span><br></pre></td></tr></tbody></table></figure><p>可以看到符号表里面 <code>go.itab.main.Adder, main.Caler</code> 对应本程序里面 itab 的元信息，它被存放在第 8 个段中。我们来看一下第 8 个段是什么段？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#readelf -S -W iface |egrep '＼[8\] | I Nr'</span><br><span class="line">[Nr] Name Type Address Off Size ES Flg Lk Inf Al</span><br><span class="line">[8]. noptrdata PROGBITS 00000000004aa000 OaaOOO 000a78 00 WA 0 0 32</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个接口动态转换的数据元信息存放在 .noptrdata 段中，它是由链接器负责初始化的。可以进一步使用 dd 工具读取井分析其内容，这里就不再继续深入这个细节，留给感兴趣的读者继续分析。</p><h3 id="接口调用代价"><a href="#接口调用代价" class="headerlink" title="接口调用代价"></a>接口调用代价</h3><p>前面讨论了接口动态调用过程，这个过程有两部分多余时耗，一个是接口实例化的过程，也就是 iface 结构建立的过程，一旦实例化后，这个接口和具体类型的 itab 数据结构是可以复用的；另一个是接口的方法调用，它是一个函数指针的间接调用。</p><p>同时我们应考虑到接口调用是一种动态的计算后的跳转调用，这对现代的计算机 CPU 的执行很不友好，会导致 CPU 缓存失效和分支预测失败，这也有一部分的性能损失。当然最直接的办法就是对比测试，看看接口动态调用的性能损失到底有多大。</p><p><strong>测试用例：</strong></p><p>直接选用 GitHub 上的一个测试用例，稍作改写，代码如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "testing"</span><br><span class="line">)</span><br><span class="line">type identifier interface {</span><br><span class="line">    idInline() int32</span><br><span class="line">    idNoInline() int32</span><br><span class="line">}</span><br><span class="line">type id32 struct{ id int32 }</span><br><span class="line">func (id *id32) idinline() int32 { return id.id }</span><br><span class="line">//go:noinline</span><br><span class="line">func (id *id32) idNoinline() int32 { return id.id }</span><br><span class="line">var escapeMePlease *id32</span><br><span class="line">//主要作用是强制变量内存在 heap 上分配</span><br><span class="line">//go:noinline</span><br><span class="line">func escapeToHeap(id *id32) identifier {</span><br><span class="line">    escapeMePlease = id</span><br><span class="line">    return escapeMePlease</span><br><span class="line">}</span><br><span class="line">//直接调用</span><br><span class="line">func BenchmarkMethodCall_direct(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer ()</span><br><span class="line">        for i :＝ 0; i ＜ b.N; i++ {</span><br><span class="line">            //CALL "".(*id32).idNoinline(SB)</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "".&amp;myID+40(SP), CX</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    b.Run ("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i: ＝ 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVL (DX), SI</span><br><span class="line">            //MOVL SI, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line">//接口调用</span><br><span class="line">func BenchmarkMethodCall_interface(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N ; i++ {</span><br><span class="line">            // MOVQ 32(AX), CX</span><br><span class="line">            // MOVQ "".m.data+40(SP), DX</span><br><span class="line">            // MOVQ DX, (SP)</span><br><span class="line">            // CALL CX</span><br><span class="line">            // MOVL 8(SP), AX</span><br><span class="line">            // MOVQ "".&amp;myID+48(SP), CX</span><br><span class="line">            // MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    b.Run("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVQ 24(AX), CX</span><br><span class="line">            //MOVQ "".m.data+40(SP), DX</span><br><span class="line">            //MOVQ DX, (SP)</span><br><span class="line">            //CALL CX</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "". &amp;myID+48(SP), ex</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">} //</span><br><span class="line">func main() {}</span><br></pre></td></tr></tbody></table></figure><p><strong>测试过程和结果：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//直接调用</span><br><span class="line">#go test -bench= 'BenchmarkMethodCall_direct/single/noinline' -cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 2.00 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.94 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 20.682s</span><br><span class="line">//接口调用</span><br><span class="line">#go test -bench='BenchmarkMethodCall_interface/single/noinline' －cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.18 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.17 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.15 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 11.930s</span><br></pre></td></tr></tbody></table></figure><p><strong>结果分析：</strong></p><p>直接调用平均时耗为 1.97ns/op，接口调用的平均时耗为 2.16ns/op, (2.16-1.97)/1.97 约等于 9.64%。可以看到测试结果符合预期，每次迭代接口要慢 0.19ns，大约有 9% 的性能损失。</p><p>但是要清楚这个百分比并不能真实地反映接口的效率问题，首先调用的方法是一个很简单的方法，方法的耗时占比很小，无形中放大了接口调用的耗时。如果方法里面有复杂的逻辑，则真实的性能损失远远小于9%。</p><p>从绝对值的角度来看更合理，那就是每次接口调用大约比直接调用慢 0.2ns ，从这个角度看，动态调用的性能损失几乎可以忽略不计。</p><h3 id="空接口数据结构"><a href="#空接口数据结构" class="headerlink" title="空接口数据结构"></a>空接口数据结构</h3><p>前面我们了解到空接口 interface{} 是没有任何方法集的接口，所以空接口内部不需要维护和动态内存分配相关的数据结构 itab 。空接口只关心存放的具体类型是什么，具体类型的值是什么，所以空接口的底层数据结构也很简单，具体如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//go/src/runtime/runtime2.go</span><br><span class="line">//空接口</span><br><span class="line">type eface struct {</span><br><span class="line">    _type *_type</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 eface 的数据结构可以看出，空接口不是真的为空，其保留了具体实例的类型和值拷贝，即便存放的具体类型是空的，空接口也不是空的。</p><p>由于空接口自身没有方法集，所以空接口变量实例化后的真正用途不是接口方法的动态调用。空接口在Go语言中真正的意义是支持多态，有如下几种方式使用了空接口（将空接口类型还原）：</p><ul><li>通过接口类型断言</li><li>通过接口类型查询</li><li>通过反射</li></ul><p>至此，接口内部实现原理全部讲完，大家在了解和学习接口内部实现的知识的同时，更应该学习和思考分析过程中的方法和技巧，使用该方法可以继续分析接口断言、接口查询和接口赋值的内部实现机制。</p><h2 id="表达式求值器"><a href="#表达式求值器" class="headerlink" title="表达式求值器"></a>表达式求值器</h2><p>在本节中，我们将创建简单算术表达式的一个求值器。我们将使用一个接口 Expr 来代表这种语言中的任意一个表达式。现在，这个接口没有任何方法，但稍后我们会逐个添加。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Expr：算术表达式</span><br><span class="line">type Expr interface{}</span><br></pre></td></tr></tbody></table></figure><p>我们的表达式语言包括浮点数字面量，二元操作符 +、-、*、/，一元操作符 -x 和 +x，函数调用 pow(x,y)、sin(x) 和 sqrt(x)，变量（比如 x 和 pi），当然，还有圆括号和标准的操作符优先级。所有的值都是 float64 类型。下面是几个示例表达式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">(F - 32) * 5 / 9</span><br></pre></td></tr></tbody></table></figure><p>下面 5 种具体类型代表特定类型的表达式。Var 代表变量应用（很快我们将了解到为什么这个类型需要导岀）。literal 代表浮点数常量。unary 和 binary 类型代表有一个或者两个操作数的操作符表达式，而操作数则可以任意的 Expr。call 代表函数调用，这里限制它的 fn 字段只能是 pow、sin 和 sqrt。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Var 表示一个变量，比如 x</span><br><span class="line">type Var string</span><br><span class="line">// literal 是一个数字常量，比如 3.141</span><br><span class="line">type literal float64</span><br><span class="line">// unary 表示一元操作符表达式，比如-x</span><br><span class="line">type unary struct {</span><br><span class="line">    op rune // '+', '-' 中的一个</span><br><span class="line">    x Expr</span><br><span class="line">}</span><br><span class="line">// binary 表示二元操作符表达式，比如 x+y</span><br><span class="line">type binary struct {</span><br><span class="line">    op rune // '+', '-', '*', '/' 中的一个</span><br><span class="line">    x, y Expr</span><br><span class="line">}</span><br><span class="line">// call 表示函数调用表达式，比如 sin(x)</span><br><span class="line">type call struct {</span><br><span class="line">    fn string // one of "pow", "sin", "sqrt" 中的一个</span><br><span class="line">    args []Expr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要对包含变量的表达式进行求值，需要一个上下文 (environment) 来把变量映射到数值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Env map[Var]float64</span><br></pre></td></tr></tbody></table></figure><p>我们还需要为每种类型的表达式定义一个 Eval 方法来返回表达式在一个给定上下文下的值。既然每个表达式都必须提供这个方法，那么可以把它加到 Expr 接口中。这个包只导出了类型 Expr、Env 和 Var。客户端可以在不接触其他表达式类型的情况下使用这个求值器。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    // Eval 返回表达式在 env 上下文下的值</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是具体的 Eval 方法。Var 的 Eval 方法从上下文中查询结果，如果变量不存在则返回 0 literal 的 Eval 方法则直接返冋本身的值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (v Var) Eval(env Env) float64 {</span><br><span class="line">    return env[v]</span><br><span class="line">}</span><br><span class="line">func (l literal) Eval(_ Env) float64 {</span><br><span class="line">    return float64(l)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>unary 和 binary 的 Eval 方法首先对它们的操作数递归求值，然后应用 op 操作。我们不把除以 0 或者无穷大当做错误（尽管它们生成的结果显然不是有穷数）。最后，call 方法先对 pow、sin 或者 sqrt 函数的参数求值，再调用 math 包中的对应函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (u unary) Eval(env Env) float64 {</span><br><span class="line">    switch u.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return +u.x.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return -u.x.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported unary operator: %q", u.op))</span><br><span class="line">}</span><br><span class="line">func (b binary) Eval(env Env) float64 {</span><br><span class="line">    switch b.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return b.x.Eval(env) + b.y.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return b.x.Eval(env) - b.y.Eval(env)</span><br><span class="line">    case '*1:</span><br><span class="line">        return b.x.Eval(env) * b.y.Eval(env)</span><br><span class="line">    case '/':</span><br><span class="line">        return b.x.Eval(env) / b.y.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported binary operator: %q", b.op))</span><br><span class="line">}</span><br><span class="line">func (c call) Eval(env Env) float64 {</span><br><span class="line">    switch c.fn {</span><br><span class="line">    case "pow":</span><br><span class="line">        return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env)</span><br><span class="line">    case "sin":</span><br><span class="line">        return math.Sin(c.args[0].Eval(erw))</span><br><span class="line">    case "sqrt":</span><br><span class="line">        return math.Sqrt(c.args[0].Eval(env))</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported function call: %s", c.fn))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>某些方法可能会失败，比如 call 表达式可能会遇到未知的函数，或者参数数量不对。也有可能用“!”或者“&lt;”这类无效的操作符构造了一个 unary 或 binary 表达式（尽管后面的 Parse 函数不会产生这样的结果）。这些错误都会导致 Eval 崩溃。</p><p>其他错误（比如对一个上下文中没有定义的变量求值）仅会导致返回不正确的结果。所有这些错误都可以在求值之前做检查来发现。后面的 Check 方法就负责完成这个任务，但我们先测试 Eval。</p><p>下面的 TestEval 函数用于测试求值器，它使用 testing 包。我们知道调用 t.Errorf 来报告错误。这个函数遍历一个表格，表格中定义了三个表达式并为每个表达式准备了不同上下文。第一个表达式用于根据圆面积 A 求半径，第二个用于计算两个变量 x 和 y 的立方和，第三个把华氏温度 F 转为摄氏温度。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func TestEval(t *testing.T) {</span><br><span class="line">    tests := []struct {</span><br><span class="line">        expr string</span><br><span class="line">        env Env</span><br><span class="line">        want string</span><br><span class="line">    }{</span><br><span class="line">        {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": -40}, "-40"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 32}, "0"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 212}, "100"},</span><br><span class="line">    }</span><br><span class="line">    var prevExpr string</span><br><span class="line">    for _, test := range tests {</span><br><span class="line">        // 仅在表达式变更时才输出</span><br><span class="line">        if test.expr != prevExpr {</span><br><span class="line">            fmt.Printf("\n%s\n", test.expr)</span><br><span class="line">            prevExpr = test.expr</span><br><span class="line">        }</span><br><span class="line">        expr, err := Parse(test.expr)</span><br><span class="line">        if err != nil {</span><br><span class="line">            t.Error(err) // 解析出错</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        got := fmt.Sprintf("%.6g", expr.Eval(test.env))</span><br><span class="line">        fmt.Printf("\t%v =&gt; %s\n", test.env, got)</span><br><span class="line">        if got != test.want {</span><br><span class="line">            t.Errorf("%s.Eval() in %v = %q, want %q\n", test.expr, test.env, got, test.want)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于表格中的每一行记录，该测试先解析表达式，在上下文中求值，再输出表达式。这里没有足够的空间来显示 Parse 函数，但可以通过 go get 来下载源码，自行查看。</p><p>go test 命令可用于运行包的测试：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v gopl.io/ch7/eval</span><br></pre></td></tr></tbody></table></figure><p>启用 -v 选项后可以看到测试的输出，通常情况下对于结果正确的测试输出就不显示了。下面就是测试中 fmt.Printf 语句输岀的内容。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">    map[A:87616 pi:3.141592653589793] =&gt; 167</span><br><span class="line"></span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">    map[x:12 y:1] =&gt; 1729</span><br><span class="line">    map[x:9 y:10] =&gt; 1729</span><br><span class="line">5 / 9 * (F - 32)</span><br><span class="line">    map[F:-40] =&gt; -40</span><br><span class="line">    map[F:32] =&gt; 0</span><br><span class="line">    map[F:212] =&gt; 100</span><br></pre></td></tr></tbody></table></figure><p>幸运的是，到现在为止所有的输入都是合法的，但这种幸运是不能持久的。即使在解释性语言中，通过语法检查来发现静态错误（即不用运行程序也能检测出来的错误）也是很常见的。通过分离静态检查和动态检查，我们可以更快发现错误，也可以只在运行前检查一次，而不用在表达式求值时每次都检查。</p><p>让我们给 Expr 方法加上另外一个方法。Check 方法用于在表达式语法树上检查静态错误。它的 vars 参数将稍后解释。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">    // Check 方法报告表达式中的错误，并把表达式中的变量加入 Vars 中</span><br><span class="line">    Check(vars map[Var]bool) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体的 Check 方法如下所示。literal 和 Var 的求值不可能出错，所以 Check 方法返回 nil。unary 和 binary 的方法首先检查操作符是否合法，再递归地检查操作数。类似地，call 的方法首先检查函数是否是已知的，然后检查参数个数是否正确，最后递归检查每个参数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func (v Var) Check(vars map[Var]bool) error {</span><br><span class="line">    vars[v] = true</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (literal) Check(vars map[Var]bool) error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (u unary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-", u.op) {</span><br><span class="line">        return fmt.Errorf("unexpected unary op %q", u.op)</span><br><span class="line">    }</span><br><span class="line">    return u.x.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (b binary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-*/", b.op) {</span><br><span class="line">        return fmt.Errorf("unexpected binary op %q", b.op)</span><br><span class="line">    }</span><br><span class="line">    if err := b.x.Check(vars); err != nil {</span><br><span class="line">        return err</span><br><span class="line">    }</span><br><span class="line">    return b.y.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (c call) Check(vars map[Var]bool) error {</span><br><span class="line">    arity, ok := numParams[c.fn]</span><br><span class="line">    if !ok {</span><br><span class="line">        return fmt.Errorf("unknown function %q", c.fn)</span><br><span class="line">    }</span><br><span class="line">    if len(c.args) != arity {</span><br><span class="line">        return fmt.Errorf("call to %s has %d args, want %d", c.fn, len(c.args), arity)</span><br><span class="line">    }</span><br><span class="line">    for _, arg := range c.args {</span><br><span class="line">        if err := arg.Check(vars); err != nil {</span><br><span class="line">            return err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">var numParams = map[string]int{"pow",: 2, "sin": 1, "sqrt": 1}</span><br></pre></td></tr></tbody></table></figure><p>下面分两列展示了一些有错误的输入，以及它们触发的错误。Parse 函数（没有显示）报告了语法错误，Check 方法报告了语义错误。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x % 2  unexpected '%'</span><br><span class="line">math.Pi unexpected '.'</span><br><span class="line">!true  unexpected '!'</span><br><span class="line">"hello" unexpected '"'</span><br><span class="line">log(10) unknown function "log"</span><br><span class="line">sqrt(1, 2) call to sqrt has 2 args, want 1</span><br></pre></td></tr></tbody></table></figure><p>Check 的输入参数是一个 Ver 集合，它收集在表达中发现的变量名。要让表达式能成功求值，上下文必须包含所有的这些变量。从逻辑上来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归调用的，在这种情况下使用参数更为方便。调用方在最初调用时需要提供一个空的集合。</p><p>既然我们可以对字符串形式的表达式进行解析、检查和求值，那么就可以构建一个 Web 应用，在运行时从客户端接收一个表达式，并绘制函数的曲面图。可以使用 vars 集合来检查表达式是一个只有两个变量 x、y 的函数（为了简单起见，还提供了半径 r，所以实际上是 3 个变量）。使用 Check 方法来拒绝掉不规范的表达式，避免了在接下来的 40000 次求值中重复检查（4 个象限中 100 x 100 的格子）。</p><p>下面的 parseAndCheck 函数组合了解析和检查步骤：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import "gopl.io/ch7/eval"</span><br><span class="line">func parseAndCheck(s string) (eval.Expr, error) {</span><br><span class="line">    if s == "" {</span><br><span class="line">        return nil, fmt.Errorf("empty expression")</span><br><span class="line">    }</span><br><span class="line">    expr, err := eval.Parse(s)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    vars := make(map[eval.Var]bool)</span><br><span class="line">    if err := expr.Check(vars); err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    for v := range vars {</span><br><span class="line">        if v != "x" &amp;&amp; v != "y" &amp;&amp; v != "r" {</span><br><span class="line">            return nil, fmt.Errorf("undefined variable: %s", v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return expr, nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要构造完这个 Web 应用，仅需要增加下面的 plot 函数，其函数签名与 http.HandlerFunc 类似：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func plot(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    expr, err := parseAndCheck(r.Form.Get("expr"))</span><br><span class="line">    if err != nil {</span><br><span class="line">        http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    w.Header().Set("Content-Type", "image/syg+xml")</span><br><span class="line">    surface(w, func(x, y float64) float64 {</span><br><span class="line">        r := math.Hypot(x, y)   // 与(0,0)之间的距离</span><br><span class="line">        return expr.Eval(eval.Env{"x": x, "y": y, "r" : r})</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>plot 函数解析并检查 HTTP 请求中的表达式，并用它来创建一个有两个变量的匿名函数。这个匿名函数与原始曲面图绘制程序中的f有同样的签名，且能对用户提供的表达式进行求值。上下文定义了 x、y 和半径 r。</p><p>最后，plot 调用了 surface 函数，surface 函数来自 gop1.io/ch3/surface 中的 main 函数，略做修改，加了参数用于接受绘制函数和输出用的 io.Writer，原始版本直接使用了函数 f 和 os.Stdout。下图显示了用这个程序绘制的三张曲面图。</p><p>a) <code>sin(-x)*pow(1.5, -r)</code></p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-a.gif" alt="a"></p><p>b) <code>pow(2, sin(y))*pow(2, sin(x))/12</code></p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-b.gif" alt="b"></p><p>c) <code>sin (x*y/10)/10</code></p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-c.gif" alt="c"></p><h2 id="实现Web服务器"><a href="#实现Web服务器" class="headerlink" title="实现Web服务器"></a>实现Web服务器</h2><p>Go语言里面提供了一个完善的 net/http 包，通过 net/http 包我们可以很方便的搭建一个可以运行的 Web 服务器。同时使用 net/http 包能很简单地对 Web 的路由，静态文件，模版，cookie 等数据进行设置和操作。</p><h3 id="Web服务器的工作方式"><a href="#Web服务器的工作方式" class="headerlink" title="Web服务器的工作方式"></a>Web服务器的工作方式</h3><p>我们平时浏览网页的时候，会打开浏览器，然后输入网址后就可以显示出想要浏览的内容。这个看似简单的过程背后却隐藏了非常复杂的操作。</p><p>对于普通的上网过程，系统其实是这样做的：</p><ul><li>浏览器本身是一个客户端，当在浏览器中输入 URL （网址）的时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到对应的服务器后，要求建立 TCP 连接；</li><li>与服务器建立连接后，浏览器会向服务器发送 HTTP Request （请求）包；</li><li>服务器接收到请求包之后开始处理请求包，并调用自身服务，返回 HTTP Response（响应）包；</li><li>客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容后断开与该服务器之间的 TCP 连接。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/webserver.gif" alt="图：用户访问一个站点的过程"></p><p>通过上图可以将 Web 服务器的工作原理简单地归纳为：</p><ul><li>客户机通过 TCP/IP 协议与服务器建立 TCP 连接；</li><li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档；</li><li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端；</li><li>客户机与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</li></ul><h3 id="搭建一个简单的-Web-服务器"><a href="#搭建一个简单的-Web-服务器" class="headerlink" title="搭建一个简单的 Web 服务器"></a>搭建一个简单的 Web 服务器</h3><p>前面简单介绍了 Web 服务器的工作原理，那么如何用Go语言搭建一个 Web 服务器呢？示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", index) // index 为向 url发送请求时，调用的函数</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>go run</code> 命令运行上面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure><p>运行之后并没有什么提示信息，但是命令行窗口会被占用（不能再输入其它命令）。这时我们在浏览器中输入 localhost:8000 可以看到下图所示的内容，则说明我们的服务器成功运行了。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhost.gif" alt="图：localhost:8000"></p><p><strong><em>提示：运行 Web 服务器会占用命令行窗口，我们可以使用 Ctrl+C 组合键来退出。</em></strong></p><p>上面的代码只是展示了 Web 服务器的简单应用，下面我们来完善一下，为这个服务器添加一个页面并设置访问的路由。</p><p>首先我们准备一个 html 文件，并命名为 index.html，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;C语言中文网&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;C语言中文网&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p>然后将我们上面写的 Web 服务器的代码简单修改一下，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 在/后面加上 index ，来指定访问路径</span><br><span class="line">    http.HandleFunc("/index", index)</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    content, _ := ioutil.ReadFile("./index.html")</span><br><span class="line">    w.Write(content)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>go run</code> 命令运行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure><p>运行成功后，在浏览器中输入 localhost:8000/index 就可以看到我们所添加的页面了，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhostindex.gif" alt="图：浏览 localhost:8000/index 页面"></p><h2 id="部署程序到Linux服务器"><a href="#部署程序到Linux服务器" class="headerlink" title="部署程序到Linux服务器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5725.html">部署程序到Linux服务器</a></h2><p>通过前面的学习相信大家对Go语言已经有了一定的了解，平时我们都是在本地进行开发调试访问的。那要怎么打包到服务器上呢？下面通过一个简单的实例来给大家介绍一下如何把我们写好的Go语言程序发布到服务 Linux 服务器上。</p><p>下面所示的是我们在 Windows 系统下开发的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sayHello(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", sayHello)</span><br><span class="line">    log.Println("启动成功，可以通过 localhost:9000 访问")</span><br><span class="line">    err := http.ListenAndServe(":9000", nil)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal("List 9000")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码已经写好了，现在需要编译了，由于是 window 环境编译到 linux 下运行，所有涉及到跨平台编译。</p><p>编译代码命令如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set GOARCH=amd64   //设置目标可执行程序操作系统构架，包括 386，amd64，arm</span><br><span class="line">set GOOS=linux           //设置可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">go build ./main.go       //打包</span><br></pre></td></tr></tbody></table></figure><p><strong><em>注意：使用 Window 10 系统的小伙伴必须用 cmd 工具执行上述命令，不能使用 powershell。</em></strong></p><p>OK，编译完成后会生成一个 main 可执行文件，没有后缀，这时只需要把这个文件上传到你的虚拟机，直接运行就好了。</p><p>运行后如果出现上图的效果，就说明已经运行起来了。这时打开你的浏览器访问服务器的 IP:9000 就能看到如下图的内容了</p><p>好啦！就这么简单，不需要任何语言环境，像 java 程序需要在服务器安装 java，php 需要安装 Apache，PHP 等运行环境，go 统统不需要，只需要一个 linux 系统将编译好的代码扔上去就可以了。</p><h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5397.html">音乐播放器</a></h2><h2 id="实现有限状态机（FSM）"><a href="#实现有限状态机（FSM）" class="headerlink" title="实现有限状态机（FSM）"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5400.html">实现有限状态机（FSM）</a></h2><h2 id="二叉树数据结构的应用"><a href="#二叉树数据结构的应用" class="headerlink" title="二叉树数据结构的应用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5570.html">二叉树数据结构的应用</a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 接口 </tag>
            
            <tag> 面向接口编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go结构体</title>
      <link href="posts/e56582fa/"/>
      <url>posts/e56582fa/</url>
      
        <content type="html"><![CDATA[<p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。</p><p>Go 语言中的类型可以被实例化，使用 <code>new</code> 或 <code>&amp;</code> 构造的类型实例的类型是类型的指针。</p><p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p><ul><li>字段拥有自己的类型和值。</li><li>字段名必须唯一。</li><li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li></ul><h2 id="关于-Go-语言的类（class）"><a href="#关于-Go-语言的类（class）" class="headerlink" title="关于 Go 语言的类（class）"></a>关于 Go 语言的类（class）</h2><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p><p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。</p><p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。</p><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。</p><p>结构体成员也可以称为“字段”，这些字段有以下特性：</p><ul><li>字段拥有自己的类型和值；</li><li>字段名必须唯一；</li><li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li></ul><p>使用关键字 type 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。</p><p>结构体的定义格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct {</span><br><span class="line">    字段1 字段1类型</span><br><span class="line">    字段2 字段2类型</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对各个部分的说明：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>struct{}：表示结构体类型，<code>type 类型名 struct{}</code> 可以理解为将 struct{} 结构体定义为类型名的类型。</li><li>字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。</li><li>字段1类型、字段2类型……：表示结构体各个字段的类型。</li></ul><p>使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Color struct {</span><br><span class="line">    R, G, B byte</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="实例化结构体"><a href="#实例化结构体" class="headerlink" title="实例化结构体"></a>实例化结构体</h2><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。</p><p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。</p><p>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p><h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。</p><p>基本实例化格式如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ins T</span><br></pre></td></tr></tbody></table></figure><p>其中，T 为结构体类型，ins 为结构体的实例。</p><p>用结构体表示的点结构（Point）的实例化过程请参见下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var p Point</span><br><span class="line">p.X = 10</span><br><span class="line">p.Y = 20</span><br></pre></td></tr></tbody></table></figure><p>在例子中，使用 <code>.</code> 来访问结构体的成员变量，如 <code>p.X</code> 和 <code>p.Y</code> 等，结构体成员变量的赋值方法与普通变量一致。</p><h3 id="创建指针类型的结构体"><a href="#创建指针类型的结构体" class="headerlink" title="创建指针类型的结构体"></a>创建指针类型的结构体</h3><p>Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</p><p>使用 new 的格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := new(T)</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li>T 为类型，可以是结构体、整型、字符串等。</li><li>ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。</li></ul><p>Go语言让我们可以像访问普通结构体一样使用 <code>.</code> 来访问结构体指针的成员。</p><p>下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Player struct{</span><br><span class="line">    Name string</span><br><span class="line">    HealthPoint int</span><br><span class="line">    MagicPoint int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tank := new(Player)</span><br><span class="line">tank.Name = "Canon"</span><br><span class="line">tank.HealthPoint = 300</span><br></pre></td></tr></tbody></table></figure><p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p><h4 id="Go语言和-C-C"><a href="#Go语言和-C-C" class="headerlink" title="Go语言和 C/C++"></a>Go语言和 C/C++</h4><p>在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用 <code>-&gt;</code> 操作符。</p><p>在Go语言中，访问结构体指针的成员变量时可以继续使用 <code>.</code> ，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖 <code>（Syntactic sugar）</code> 技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code> 。</p><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <code>&amp;</code> 取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T{}</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li>T 表示结构体类型。</li><li>ins 为结构体的实例，类型为 <code>*T</code> ，是指针类型。</li></ul><p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ype Command struct {</span><br><span class="line">    Name    string    // 指令名称</span><br><span class="line">    Var     *int      // 指令绑定的变量</span><br><span class="line">    Comment string    // 指令的注释</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var version int = 1</span><br><span class="line"></span><br><span class="line">cmd := &amp;Command{}</span><br><span class="line">cmd.Name = "version"</span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = "show version"</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，定义 Command 结构体，表示命令行指令</li><li>第 3 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步。</li><li>第 7 行，命令绑定的目标整型变量：版本号。</li><li>第 9 行，对结构体取地址实例化。</li><li>第 10～12 行，初始化成员字段。</li></ul><p>取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func newCommand(name string, varref *int, comment string) *Command {</span><br><span class="line">    return &amp;Command{</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cmd = newCommand(</span><br><span class="line">    "version",</span><br><span class="line">    &amp;version,</span><br><span class="line">    "show version",</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="初始化结构体的成员变量"><a href="#初始化结构体的成员变量" class="headerlink" title="初始化结构体的成员变量"></a>初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。</p><h3 id="使用“键值对”初始化结构体"><a href="#使用“键值对”初始化结构体" class="headerlink" title="使用“键值对”初始化结构体"></a>使用“键值对”初始化结构体</h3><p>结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。</p><p>键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。</p><p>结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。</p><p>1)键值对初始化结构体的书写格式</p><p>键值对初始化的格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1: 字段1的值,</span><br><span class="line">    字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是对各个部分的说明：</p><ul><li>结构体类型：定义结构体时的类型名称。</li><li>字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。</li><li>字段1的值、字段2的值：结构体成员字段的初始值。</li></ul><p>键值之间以 <code>:</code> 分隔，键值对之间以 <code>,</code> 分隔。</p><p>2)使用键值对填充结构体的例子</p><p>下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type People struct {</span><br><span class="line">    name  string</span><br><span class="line">    child *People</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">relation := &amp;People{</span><br><span class="line">    name: "爷爷",</span><br><span class="line">    child: &amp;People{</span><br><span class="line">        name: "爸爸",</span><br><span class="line">        child: &amp;People{</span><br><span class="line">                name: "我",</span><br><span class="line">        },</span><br><span class="line">    },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，定义 People 结构体。</li><li>第 2 行，结构体的字符串字段。</li><li>第 3 行，结构体的结构体指针字段，类型是 *People。</li><li>第 6 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。</li><li>第 8 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。</li></ul><p><strong><em>提示：结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</em></strong></p><h3 id="使用多个值的列表初始化结构体"><a href="#使用多个值的列表初始化结构体" class="headerlink" title="使用多个值的列表初始化结构体"></a>使用多个值的列表初始化结构体</h3><p>Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。</p><p>1)多个值列表初始化结构体的书写格式</p><p>多个值使用逗号分隔初始化结构体，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1的值,</span><br><span class="line">    字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用这种格式初始化时，需要注意：</p><ul><li>必须初始化结构体的所有字段。</li><li>每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>键值对与值列表的初始化形式不能混用。</li></ul><p>2)多个值列表初始化结构体的例子</p><p>下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Address struct {</span><br><span class="line">    Province    string</span><br><span class="line">    City        string</span><br><span class="line">    ZipCode     int</span><br><span class="line">    PhoneNumber string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">addr := Address{</span><br><span class="line">    "四川",</span><br><span class="line">    "成都",</span><br><span class="line">    610000,</span><br><span class="line">    "0",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(addr)</span><br></pre></td></tr></tbody></table></figure><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{四川 成都 610000 0}</span><br></pre></td></tr></tbody></table></figure><h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。</p><p>1)匿名结构体定义格式和初始化写法</p><p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    // 匿名结构体字段定义</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}{</span><br><span class="line">    // 字段值初始化</span><br><span class="line">    初始化字段1: 字段1的值,</span><br><span class="line">    初始化字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是对各个部分的说明：</p><ul><li>字段1、字段2……：结构体定义的字段名。</li><li>初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。</li><li>字段类型1、字段类型2……：结构体定义字段的类型。</li><li>字段1的值、字段2的值……：结构体初始化字段的初始值。</li></ul><p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2)使用匿名结构体的例子</p><p>在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 打印消息类型, 传入匿名结构体</span><br><span class="line">func printMsgType(msg *struct {</span><br><span class="line">    id   int</span><br><span class="line">    data string</span><br><span class="line">}) {</span><br><span class="line"></span><br><span class="line">    // 使用动词%T打印msg的类型</span><br><span class="line">    fmt.Printf("%T\n", msg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个匿名结构体</span><br><span class="line">    msg := &amp;struct {  // 定义部分</span><br><span class="line">        id   int</span><br><span class="line">        data string</span><br><span class="line">    }{  // 值初始化部分</span><br><span class="line">        1024,</span><br><span class="line">        "hello",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printMsgType(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*struct { id int; data string }</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义 printMsgType() 函数，参数为 msg，类型为 <code>*struct{id int data string}</code> ，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。</li><li>第 14 行，使用字符串格式化中的 <code>%T</code> 动词，将 msg 的类型名打印出来。</li><li>第 20 行，对匿名结构体进行实例化，同时初始化成员。</li><li>第 21 和 22 行，定义匿名结构体的字段。</li><li>第 24 和 25 行，给匿名结构体字段赋予初始值。</li><li>第 28 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li></ul><p>匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。</p><p>其他编程语言构造函数的一些常见功能及特性如下：</p><ul><li>每个类可以添加构造函数，多个构造函数使用函数重载实现。</li><li>构造函数一般与类名同名，且没有返回值。</li><li>构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。</li><li>对于 C++ 来说，还有默认构造函数、拷贝构造函数等。</li></ul><h3 id="多种方式创建和初始化结构体——模拟构造函数重载"><a href="#多种方式创建和初始化结构体——模拟构造函数重载" class="headerlink" title="多种方式创建和初始化结构体——模拟构造函数重载"></a>多种方式创建和初始化结构体——模拟构造函数重载</h3><p>如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByName(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByColor(color string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Color: color,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行定义 Cat 结构，包含颜色和名字字段。</li><li>第 6 行定义用名字构造猫结构的函数，返回 Cat 指针。</li><li>第 7 行取地址实例化猫的结构体。</li><li>第 8 行初始化猫的名字字段，忽略颜色字段。</li><li>第 12 行定义用颜色构造猫结构的函数，返回 Cat 指针。</li></ul><p>在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。</p><h3 id="带有父子关系的结构体的构造和初始化——模拟父级构造调用"><a href="#带有父子关系的结构体的构造和初始化——模拟父级构造调用" class="headerlink" title="带有父子关系的结构体的构造和初始化——模拟父级构造调用"></a>带有父子关系的结构体的构造和初始化——模拟父级构造调用</h3><p>黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type BlackCat struct {</span><br><span class="line">    Cat  // 嵌入Cat, 类似于派生</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造基类”</span><br><span class="line">func NewCat(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造子类”</span><br><span class="line">func NewBlackCat(color string) *BlackCat {</span><br><span class="line">    cat := &amp;BlackCat{}</span><br><span class="line">    cat.Color = color</span><br><span class="line">    return cat</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。</li><li>第 11 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。</li><li>第 18 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。</li><li>第 19 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。</li><li>第 20 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。</li></ul><p>这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。</p><p>总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。</p><h2 id="方法和接收器"><a href="#方法和接收器" class="headerlink" title="方法和接收器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/69.html">方法和接收器</a></h2><p>在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。</p><p>接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误 <code>invalid receiver type…</code> 。</p><p>接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。</p><p>类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。</p><p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。</p><p><strong><em>提示:在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</em></strong></p><h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><p>本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。</p><p>1)面向过程实现方法<br>面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将一个物品放入背包的过程</span><br><span class="line">func Insert(b *Bag, itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    bag := new(Bag)</span><br><span class="line"></span><br><span class="line">    Insert(bag, 1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。</li><li>第 6 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。</li><li>第 7 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。</li><li>第 12 行，创建背包实例 bag。</li><li>第 14 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。</li></ul><p>Insert() 函数将 <code>*Bag</code> 参数放在第一位，强调 Insert 会操作 <code>*Bag</code> 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p><p>2)Go语言的结构体方法</p><p>将背包及放入背包的物品中使用Go语言的结构体和方法方式编写，为 <code>*Bag</code> 创建一个方法，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (b *Bag) Insert(itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    b := new(Bag)</span><br><span class="line"></span><br><span class="line">    b.Insert(1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 5 行中，<code>Insert(itemid int)</code> 的写法与函数一致，<code>(b *Bag)</code> 表示接收器，即 Insert 作用的对象实例。</p><p>每个方法只能有一个接收器，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goreceiver.jpg" alt="图：接收器"></p><p>第 13 行中，在 Insert() 转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用 b 的 Insert。</p><h3 id="接收器——方法作用的目标"><a href="#接收器——方法作用的目标" class="headerlink" title="接收器——方法作用的目标"></a>接收器——方法作用的目标</h3><p>接收器的格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对各部分的说明：</p><ul><li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li><li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：格式与函数定义一致。</li></ul><p>接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p><p>1)理解指针类型的接收器</p><p>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。</p><p>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p><p>在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义属性结构</span><br><span class="line">type Property struct {</span><br><span class="line">    value int  // 属性值</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置属性值</span><br><span class="line">func (p *Property) SetValue(v int) {</span><br><span class="line"></span><br><span class="line">    // 修改p的成员变量</span><br><span class="line">    p.value = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 取属性值</span><br><span class="line">func (p *Property) Value() int {</span><br><span class="line">    return p.value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化属性</span><br><span class="line">    p := new(Property)</span><br><span class="line"></span><br><span class="line">    // 设置值</span><br><span class="line">    p.SetValue(100)</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(p.Value())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行程序，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，定义一个属性结构，拥有一个整型的成员变量。</li><li>第 11 行，定义属性值的方法。</li><li>第 14 行，设置属性值方法的接收器类型为指针，因此可以修改成员值，即便退出方法，也有效。</li><li>第 18 行，定义获取值的方法。</li><li>第 25 行，实例化属性结构。</li><li>第 28 行，设置值，此时成员变量变为 100。</li><li>第 31 行，获取成员变量。</li></ul><p>2)理解非指针类型的接收器</p><p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p><p>点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义点结构</span><br><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 非指针接收器的加方法</span><br><span class="line">func (p Point) Add(other Point) Point {</span><br><span class="line"></span><br><span class="line">    // 成员值与参数相加后返回新的结构</span><br><span class="line">    return Point{p.X + other.X, p.Y + other.Y}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 初始化点</span><br><span class="line">    p1 := Point{1, 1}</span><br><span class="line">    p2 := Point{2, 2}</span><br><span class="line"></span><br><span class="line">    // 与另外一个点相加</span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    fmt.Println(result)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{3 3}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义一个点结构，拥有 X 和 Y 两个整型分量。</li><li>第 14 行，为 Point 结构定义一个 Add() 方法，传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如P4 := P1.Add( P2 ).Add( P3 )</li><li>第 23 和 24 行，初始化两个点 p1 和 p2。</li><li>第 27 行，将 p1 和 p2 相加后返回结果。</li><li>第 30 行，打印结果。</li></ul><p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改。</p><p>3)指针和非指针接收器的使用</p><p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p><h3 id="示例：二维矢量模拟玩家移动"><a href="#示例：二维矢量模拟玩家移动" class="headerlink" title="示例：二维矢量模拟玩家移动"></a>示例：二维矢量模拟玩家移动</h3><p>在游戏中，一般使用二维矢量保存玩家的位置，使用矢量运算可以计算出玩家移动的位置，本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。</p><p>1)实现二维矢量结构</p><p>矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算，在计算机中，使用拥有 X 和 Y 两个分量的 Vec2 结构体实现数学中二维向量的概念，详细实现请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "math"</span><br><span class="line"></span><br><span class="line">type Vec2 struct {</span><br><span class="line">    X, Y float32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 加</span><br><span class="line">func (v Vec2) Add(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X + other.X,</span><br><span class="line">        v.Y + other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 减</span><br><span class="line">func (v Vec2) Sub(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X - other.X,</span><br><span class="line">        v.Y - other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 乘</span><br><span class="line">func (v Vec2) Scale(s float32) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{v.X * s, v.Y * s}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 距离</span><br><span class="line">func (v Vec2) DistanceTo(other Vec2) float32 {</span><br><span class="line">    dx := v.X - other.X</span><br><span class="line">    dy := v.Y - other.Y</span><br><span class="line"></span><br><span class="line">    return float32(math.Sqrt(float64(dx*dx + dy*dy)))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 插值</span><br><span class="line">func (v Vec2) Normalize() Vec2 {</span><br><span class="line">    mag := v.X*v.X + v.Y*v.Y</span><br><span class="line">    if mag &gt; 0 {</span><br><span class="line">        oneOverMag := 1 / float32(math.Sqrt(float64(mag)))</span><br><span class="line">        return Vec2{v.X * oneOverMag, v.Y * oneOverMag}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return Vec2{0, 0}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 5 行声明了一个 Vec2 结构体，包含两个方向的单精度浮点数作为成员。</li><li>第 10～16 行定义了 Vec2 的 Add() 方法，使用自身 Vec2 和通过 Add() 方法传入的 Vec2 进行相加，相加后，结果以返回值形式返回，不会修改 Vec2 的成员。</li><li>第 20 行定义了 Vec2 的减法操作。</li><li>第 29 行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale() 方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。</li><li>第 35 行定义了计算两个矢量的距离，math.Sqrt() 是开方函数，参数是 float64，在使用时需要转换，返回值也是 float64，需要转换回 float32。</li><li>第 43 行定义矢量单位化。</li></ul><p>2)实现玩家对象</p><p>玩家对象负责存储玩家的当前位置、目标位置和速度，使用 MoveTo() 方法为玩家设定移动的目标，使用 Update() 方法更新玩家位置，在 Update() 方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。</p><p>① 使用矢量减法，将目标位置（targetPos）减去当前位置（currPos）即可计算出位于两个位置之间的新矢量，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/targetpos.jpg" alt="图：计算玩家方向矢量"></p><p>② 使用 Normalize() 方法将方向矢量变为模为 1 的单位化矢量，这里需要将矢量单位化后才能进行后续计算，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/normalize.jpg" alt="图：单位化方向矢量"></p><p>③ 获得方向后，将单位化方向矢量根据速度进行等比缩放，速度越快，速度数值越大，乘上方向后生成的矢量就越长（模很大），如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/scale.jpg" alt="图：根据速度缩放方向"></p><p>④ 将缩放后的方向添加到当前位置后形成新的位置，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/addpost.jpg" alt="图：缩放后的方向叠加位置形成新位置"></p><p>下面是玩家对象的具体代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Player struct {</span><br><span class="line">    currPos   Vec2    // 当前位置</span><br><span class="line">    targetPos Vec2    // 目标位置</span><br><span class="line">    speed     float32 // 移动速度</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 移动到某个点就是设置目标位置</span><br><span class="line">func (p *Player) MoveTo(v Vec2) {</span><br><span class="line"></span><br><span class="line">    p.targetPos = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取当前的位置</span><br><span class="line">func (p *Player) Pos() Vec2 {</span><br><span class="line">    return p.currPos</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 是否到达</span><br><span class="line">func (p *Player) IsArrived() bool {</span><br><span class="line"></span><br><span class="line">    // 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点</span><br><span class="line">    return p.currPos.DistanceTo(p.targetPos) &lt; p.speed</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 逻辑更新</span><br><span class="line">func (p *Player) Update() {</span><br><span class="line">    if !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 计算出当前位置指向目标的朝向</span><br><span class="line">        dir := p.targetPos.Sub(p.currPos).Normalize()</span><br><span class="line"></span><br><span class="line">        // 添加速度矢量生成新的位置</span><br><span class="line">        newPos := p.currPos.Add(dir.Scale(p.speed))</span><br><span class="line"></span><br><span class="line">        // 移动完成后，更新当前位置</span><br><span class="line">        p.currPos = newPos</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建新玩家</span><br><span class="line">func NewPlayer(speed float32) *Player {</span><br><span class="line"></span><br><span class="line">    return &amp;Player{</span><br><span class="line">        speed: speed,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，结构体 Player 定义了一个玩家的基本属性和方法，结构体的 currPos 表示当前位置，speed 表示速度。</li><li>第 10 行，定义玩家的移动方法，逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由 Update() 方法负责。</li><li>第 16 行，使用 Pos 方法实现玩家 currPos 的属性访问封装。</li><li>第 21 行，判断玩家是否到达目标点，玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。</li><li>第 28 行，玩家移动时位置更新的主要实现。</li><li>第 29 行，如果已经到达，则不必再更新。</li><li>第 32 行，数学中，两矢量相减将获得指向被减矢量的新矢量，Sub() 方法返回的新矢量使用 Normalize() 方法单位化，最终返回的 dir 矢量就是移动方向。</li><li>第 35 行，在当前的位置上叠加根据速度缩放的方向计算出新的位置 newPos。</li><li>第 38 行，将新位置更新到 currPos，为下一次移动做准备。</li><li>第 44 行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。</li></ul><p>3)处理移动逻辑</p><p>将 Player 实例化后，设定玩家移动的最终目标点，之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化玩家对象，并设速度为0.5</span><br><span class="line">    p := NewPlayer(0.5)</span><br><span class="line"></span><br><span class="line">    // 让玩家移动到3,1点</span><br><span class="line">    p.MoveTo(Vec2{3, 1})</span><br><span class="line"></span><br><span class="line">    // 如果没有到达就一直循环</span><br><span class="line">    for !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 更新玩家位置</span><br><span class="line">        p.Update()</span><br><span class="line"></span><br><span class="line">        // 打印每次移动后的玩家位置</span><br><span class="line">        fmt.Println(p.Pos())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，使用 NewPlayer() 函数构造一个 <code>*Player</code> 玩家对象，并设移动速度为 <code>0.5</code> ，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。</li><li>第 11 行，设定玩家移动的最终目标为 X 为 3，Y 为 1。</li><li>第 14 行，构造一个循环，条件是没有到达时一直循环。</li><li>第 17 行，不停地更新玩家位置，如果玩家到达目标，p.IsArrived 将会变为 true。</li><li>第 20 行，打印每次更新后玩家的位置。</li></ul><p>本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。</p><h2 id="为任意类型添加方法"><a href="#为任意类型添加方法" class="headerlink" title="为任意类型添加方法"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/70.html">为任意类型添加方法</a></h2><p>Go语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。</p><h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  v == 0 {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  v.IsZero() {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为基本类型添加方法的详细实现流程如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将int定义为MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">// 为MyInt添加IsZero()方法</span><br><span class="line">func (m MyInt) IsZero() bool {</span><br><span class="line">    return m == 0</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为MyInt添加Add()方法</span><br><span class="line">func (m MyInt) Add(other int) int {</span><br><span class="line">    return other + int(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.IsZero())</span><br><span class="line"></span><br><span class="line">    b = 1</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.Add(2))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，使用 type MyInt int 将 int 定义为自定义的 MyInt 类型。</li><li>第 11 行，为 MyInt 类型添加 IsZero() 方法，该方法使用了 (m MyInt) 的非指针接收器，数值类型没有必要使用指针接收器。</li><li>第 16 行，为 MyInt 类型添加 Add() 方法。</li><li>第 17 行，由于 m 的类型是 MyInt 类型，但其本身是 int 类型，因此可以将 m 从 MyInt 类型转换为 int 类型再进行计算。</li><li>第 24 行，调用 b 的 IsZero() 方法，由于使用非指针接收器，b的值会被复制进入 IsZero() 方法进行判断。</li><li>第 28 行，调用 b 的 Add() 方法，同样也是非指针接收器，结果直接通过 Add() 方法返回。</li></ul><h3 id="http包中的类型方法"><a href="#http包中的类型方法" class="headerlink" title="http包中的类型方法"></a>http包中的类型方法</h3><p>Go语言提供的 http 包里也大量使用了类型方法，Go语言使用 http 包进行 HTTP 的请求，使用 http 包的 NewRequest() 方法可以创建一个 HTTP 请求，填充请求中的 http 头（req.Header），再调用 http.Client 的 Do 方法，将传入的 HTTP 请求发送出去。</p><p>下面代码演示创建一个 HTTP 请求，并且设定 HTTP 头。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "net/http"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    client := &amp;http.Client{}</span><br><span class="line"></span><br><span class="line">    // 创建一个http请求</span><br><span class="line">    req, err := http.NewRequest("POST", "http://www.163.com/", strings.NewReader("key=value"))</span><br><span class="line"></span><br><span class="line">    // 发现错误就打印并退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 为请求头添加信息</span><br><span class="line">    req.Header.Add("User-Agent", "myClient")</span><br><span class="line"></span><br><span class="line">    // 开始请求</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line">    // 处理请求的错误</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(string(data))</span><br><span class="line"></span><br><span class="line">    defer resp.Body.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;405 Not Allowed&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor="white"&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;405 Not Allowed&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 11 行，实例化 HTTP 的客户端，请求需要通过这个客户端实例发送。</li><li>第 14 行，使用 POST 方式向网易的服务器创建一个 HTTP 请求，第三个参数为 HTTP 的 Body 部分，Body 部分的内容来自字符串，但参数只能接受 io.Reader 类型，因此使用 strings.NewReader() 创建一个字符串的读取器，返回的 io.Reader 接口作为 http 的 Body 部分供 NewRequest() 函数读取，创建请求只是构造一个请求对象，不会连接网络。</li><li>第 24 行，为创建好的 HTTP 请求的头部添加 User-Agent，作用是表明用户的代理特性。</li><li>第 27 行，使用客户端处理请求，此时 client 将 HTTP 请求发送到网易服务器，服务器响应请求后，将信息返回并保存到 resp 变量中。</li><li>第 37 行，读取响应的 Body 部分并打印。</li></ul><p>由于我们构造的请求不是网易服务器所支持的类型，所以服务器返回操作不被运行的 405 错误。</p><p>在本例子第 24 行中使用的 req.Header 的类型为 http.Header，就是典型的自定义类型，并且拥有自己的方法，http.Header 的部分定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Header map[string][]string</span><br><span class="line"></span><br><span class="line">func (h Header) Add(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (h Header) Set(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (h Header) Get(key string) string {</span><br><span class="line">    return textproto.MIMEHeader(h).Get(key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，Header 实际是一个以字符串为键、字符串切片为值的映射。</li><li>第 3 行，Add() 为 Header 的方法，map 是一个引用类型，因此即便使用 (h Header) 的非指针接收器，也可以修改 map 的值。</li></ul><p>为类型添加方法的过程是一个语言层特性，使用类型方法的代码经过编译器编译后的代码运行效率与传统的面向过程或面向对象的代码没有任何区别，因此，为了代码便于理解，可以在编码时使用Go语言的类型方法特性。</p><h3 id="time-包中的类型方法"><a href="#time-包中的类型方法" class="headerlink" title="time 包中的类型方法"></a>time 包中的类型方法</h3><p>Go语言提供的 time 包主要用于时间的获取和计算等，在这个包中，也使用了类型方法，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(time.Second.String())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 9 行的 time.Second 是一个常量，下面代码的加粗部分就是 time.Second 的定义：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond  = 1000 * Nanosecond</span><br><span class="line">    Millisecond  = 1000 * Microsecond</span><br><span class="line">    Second       = 1000 * Millisecond</span><br><span class="line">    Minute       = 60 * Second</span><br><span class="line">    Hour         = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Second 的类型为 Duration，而 Duration 实际是一个 int64 的类型，定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></tbody></table></figure><p>它拥有一个 String 的方法，部分定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (d Duration) String() string {</span><br><span class="line">    // 一系列生成buf的代码</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    return string(buf[w:])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Duration.String 可以将 Duration 的值转为字符串。</p><h2 id="使用事件系统实现事件的响应和处理"><a href="#使用事件系统实现事件的响应和处理" class="headerlink" title="使用事件系统实现事件的响应和处理"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/71.html">使用事件系统实现事件的响应和处理</a></h2><p>Go语言可以将类型的方法与普通函数视为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。这个特性和 C# 中的代理（delegate）类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数或类型的方法。</p><p>本节中，首先将用简单的例子了解Go语言是如何将方法与函数视为一个概念，接着会实现一个事件系统，事件系统能有效地将事件触发与响应两端代码解耦。</p><h3 id="方法和函数的统一调用"><a href="#方法和函数的统一调用" class="headerlink" title="方法和函数的统一调用"></a>方法和函数的统一调用</h3><p>本节的例子将让一个结构体的方法（class.Do）的参数和一个普通函数（funcDo）的参数完全一致，也就是方法与函数的签名一致。然后使用与它们签名一致的函数变量（delegate）分别赋值方法与函数，接着调用它们，观察实际效果。</p><p>详细实现请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明一个结构体</span><br><span class="line">type class struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 给结构体添加Do方法</span><br><span class="line">func (c *class) Do(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call method do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 普通函数的Do</span><br><span class="line">func funcDo(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call function do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个函数回调</span><br><span class="line">    var delegate func(int)</span><br><span class="line"></span><br><span class="line">    // 创建结构体实例</span><br><span class="line">    c := new(class)</span><br><span class="line"></span><br><span class="line">    // 将回调设为c的Do方法</span><br><span class="line">    delegate = c.Do</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line"></span><br><span class="line">    // 将回调设为普通函数</span><br><span class="line">    delegate = funcDo</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 10 行，为结构体添加一个 Do() 方法，参数为整型。这个方法的功能是打印提示和输入的参数值。</li><li>第 16 行，声明一个普通函数，参数也是整型，功能是打印提示和输入的参数值。</li><li>第 24 行，声明一个 delegate 的变量，类型为 <code>func(int)</code> ，与 funcDo 和 class 的 Do() 方法的参数一致。</li><li>第 30 行，将 c.Do 作为值赋给 delegate 变量。</li><li>第 33 行，调用 delegate() 函数，传入 100 的参数。此时会调用 c 实例的 Do() 方法。</li><li>第 36 行，将 funcDo 赋值给 delegate。</li><li>第 39 行，调用 delegate()，传入 100 的参数。此时会调用 funcDo() 方法。</li></ul><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call method do: 100</span><br><span class="line">call function do: 100</span><br></pre></td></tr></tbody></table></figure><p>这段代码能运行的基础在于：无论是普通函数还是结构体的方法，只要它们的签名一致，与它们签名一致的函数变量就可以保存普通函数或是结构体方法。</p><p>了解了Go语言的这一特性后，我们就可以将这个特性用在事件中。</p><h3 id="事件系统基本原理"><a href="#事件系统基本原理" class="headerlink" title="事件系统基本原理"></a>事件系统基本原理</h3><p>事件系统可以将事件派发者与事件处理者解耦。例如，网络底层可以生成各种事件，在网络连接上后，网络底层只需将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。或者再比如，你注册、关注或者订阅某“大V”的社交消息后，“大V”发生的任何事件都会通知你，但他并不用了解粉丝们是如何为她喝彩或者疯狂的。如下图所示为事件系统基本原理图。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goeventbus.jpg" alt="图：事件系统基本原理"></p><p>一个事件系统拥有如下特性：</p><ul><li>能够实现事件的一方，可以根据事件 ID 或名字注册对应的事件。</li><li>事件发起者，会根据注册信息通知这些注册者。</li><li>一个事件可以有多个实现方响应。</li></ul><p>通过下面的步骤详细了解事件系统的构成及使用。</p><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>事件系统需要为外部提供一个注册入口。这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来，详细实现请参考下面代码的 RegisterEvent() 函数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 实例化一个通过字符串映射函数切片的map</span><br><span class="line">var eventByName = make(map[string][]func(interface{}))</span><br><span class="line"></span><br><span class="line">// 注册事件，提供事件名和回调函数</span><br><span class="line">func RegisterEvent(name string, callback func(interface{})) {</span><br><span class="line"></span><br><span class="line">    // 通过名字查找事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 在列表切片中添加函数</span><br><span class="line">    list = append(list, callback)</span><br><span class="line"></span><br><span class="line">    // 将修改的事件列表切片保存回去</span><br><span class="line">    eventByName[name] = list</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用事件</span><br><span class="line">func CallEvent(name string, param interface{}) {</span><br><span class="line"></span><br><span class="line">    // 通过名字找到事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 遍历这个事件的所有回调</span><br><span class="line">    for _, callback := range list {</span><br><span class="line"></span><br><span class="line">        // 传入参数调用回调</span><br><span class="line">        callback(param)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 4 行，创建一个 map 实例，这个 map 通过事件名（string）关联回调列表 <code>（[]func(interface{}）</code> ，同一个事件名称可能存在多个事件回调，因此使用回调列表保存。回调的函数声明为 <code>func(interface{})</code> 。</li><li>第 7 行，提供给外部的通过事件名注册响应函数的入口。</li><li>第 10 行，eventByName 通过事件名（name）进行查询，返回回调列表 <code>（[]func(interface{}）</code>。</li><li>第 13 行，为同一个事件名称在已经注册的事件回调的列表中再添加一个回调函数。</li><li>第 16 行，将修改后的函数列表设置到 map 的对应事件名中。</li></ul><p>拥有事件名和事件回调函数列表的关联关系后，就需要开始准备事件调用的入口了。</p><h3 id="事件调用"><a href="#事件调用" class="headerlink" title="事件调用"></a>事件调用</h3><p>事件调用方和注册方是事件处理中完全不同的两个角色。事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理；事件注册方通过事件系统注册应该响应哪些事件及如何使用回调函数处理这些事件。事件调用的详细实现请参考上面代码的 CallEvent() 函数。</p><p>代码说明如下：</p><ul><li>第 20 行，调用事件的入口，提供事件名称 name 和参数 param。事件的参数表示描述事件具体的细节，例如门打开的事件触发时，参数可以传入谁进来了。</li><li>第 23 行，通过注册事件回调的 eventByName 和事件名字查询处理函数列表 list。</li><li>第 26 行，遍历这个事件列表，如果没有找到对应的事件，list 将是一个空切片。</li><li>第 29 行，将每个函数回调传入事件参数并调用，就会触发事件实现方的逻辑处理。</li></ul><h3 id="使用事件系统"><a href="#使用事件系统" class="headerlink" title="使用事件系统"></a>使用事件系统</h3><p>例子中，在 main() 函数中调用事件系统的 CallEvent 生成 OnSkill 事件，这个事件有两个处理函数，一个是角色的 OnEvent() 方法，还有一个是函数 GlobalEvent()，详细代码实现过程请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明角色的结构体</span><br><span class="line">type Actor struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为角色添加一个事件处理函数</span><br><span class="line">func (a *Actor) OnEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("actor event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 全局事件</span><br><span class="line">func GlobalEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("global event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个角色</span><br><span class="line">    a := new(Actor)</span><br><span class="line"></span><br><span class="line">    // 注册名为OnSkill的回调</span><br><span class="line">    RegisterEvent("OnSkill", a.OnEvent)</span><br><span class="line"></span><br><span class="line">    // 再次在OnSkill上注册全局事件</span><br><span class="line">    RegisterEvent("OnSkill", GlobalEvent)</span><br><span class="line">    // 调用事件，所有注册的同名函数都会被调用</span><br><span class="line">    CallEvent("OnSkill", 100)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，声明一个角色的结构体。在游戏中，角色是常见的对象，本例中，角色也是 OnSkill 事件的响应处理方。</li><li>第 10 行，为角色结构添加一个 OnEvent() 方法，这个方法拥有 param 参数，类型为 interface{}，与事件系统的函数（func(interface{})）签名一致。</li><li>第 16 行为全局事件响应函数。有时需要全局进行侦听或者处理一些事件，这里使用普通函数实现全局事件的处理。</li><li>第 27 行，注册一个 OnSkill 事件，实现代码由 a 的 OnEvent 进行处理。也就是 Actor的OnEvent() 方法。</li><li>第 30 行，注册一个 OnSkill 事件，实现代码由 GlobalEvent 进行处理，虽然注册的是同一个名字的事件，但前面注册的事件不会被覆盖，而是被添加到事件系统中，关联 OnSkill 事件的函数列表中。</li><li>第 33 行，模拟处理事件，通过 CallEvent() 函数传入两个参数，第一个为事件名，第二个为处理函数的参数。</li></ul><p>整个例子运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor event: 100</span><br><span class="line">global event: 100</span><br></pre></td></tr></tbody></table></figure><p>结果演示，角色和全局的事件会按注册顺序顺序地触发。</p><p>一般来说，事件系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统认为所有实现函数都是平等的。也就是说，无论例子中的 a.OnEvent 先注册，还是 GlobalEvent() 函数先注册，最终谁先被调用，都是无所谓的，开发者不应该去关注和要求保证调用的顺序。</p><p>一个完善的事件系统还会提供移除单个和所有事件的方法。</p><h2 id="类型内嵌和结构体内嵌"><a href="#类型内嵌和结构体内嵌" class="headerlink" title="类型内嵌和结构体内嵌"></a>类型内嵌和结构体内嵌</h2><p>结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。</p><p>可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go语言中的继承是通过内嵌或组合来实现的，所以可以说，在Go语言中，相比较于继承，组合更受青睐。</p><p>考虑如下的程序：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type innerS struct {</span><br><span class="line">    in1 int</span><br><span class="line">    in2 int</span><br><span class="line">}</span><br><span class="line">type outerS struct {</span><br><span class="line">    b int</span><br><span class="line">    c float32</span><br><span class="line">    int // anonymous field</span><br><span class="line">    innerS //anonymous field</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    outer := new(outerS)</span><br><span class="line">    outer.b = 6</span><br><span class="line">    outer.c = 7.5</span><br><span class="line">    outer.int = 60</span><br><span class="line">    outer.in1 = 5</span><br><span class="line">    outer.in2 = 10</span><br><span class="line">    fmt.Printf("outer.b is: %d\n", outer.b)</span><br><span class="line">    fmt.Printf("outer.c is: %f\n", outer.c)</span><br><span class="line">    fmt.Printf("outer.int is: %d\n", outer.int)</span><br><span class="line">    fmt.Printf("outer.in1 is: %d\n", outer.in1)</span><br><span class="line">    fmt.Printf("outer.in2 is: %d\n", outer.in2)</span><br><span class="line">    // 使用结构体字面量</span><br><span class="line">    outer2 := outerS{6, 7.5, 60, innerS{5, 10}}</span><br><span class="line">    fmt.Printf("outer2 is:", outer2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer.b is: 6</span><br><span class="line">outer.c is: 7.500000</span><br><span class="line">outer.int is: 60</span><br><span class="line">outer.in1 is: 5</span><br><span class="line">outer.in2 is: 10</span><br><span class="line">outer2 is:{6 7.5 60 {5 10}}</span><br></pre></td></tr></tbody></table></figure><p>通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。</p><h3 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h3><p>同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。</p><p>示例代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type A struct {</span><br><span class="line">    ax, ay int</span><br><span class="line">}</span><br><span class="line">type B struct {</span><br><span class="line">    A</span><br><span class="line">    bx, by float32</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    b := B{A{1, 2}, 3.0, 4.0}</span><br><span class="line">    fmt.Println(b.ax, b.ay, b.bx, b.by)</span><br><span class="line">    fmt.Println(b.A)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">{1 2}</span><br></pre></td></tr></tbody></table></figure><h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go语言的结构体内嵌有如下特性。</p><p>1)内嵌的结构体可以直接访问其成员变量</p><p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p><p>2)内嵌结构体的字段名是它的类型名</p><p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c Color</span><br><span class="line">c.BasicColor.R = 1</span><br><span class="line">c.BasicColor.G = 1</span><br><span class="line">c.BasicColor.B = 0</span><br></pre></td></tr></tbody></table></figure><p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p><h2 id="结构体内嵌模拟类的继承"><a href="#结构体内嵌模拟类的继承" class="headerlink" title="结构体内嵌模拟类的继承"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/73.html">结构体内嵌模拟类的继承</a></h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p><p>面向对象的设计原则中也建议对象最好不要使用多重继承，有些面向对象语言从语言层面就禁止了多重继承，如 C# 和 Java 语言。鸟类同时继承自可行走类和飞行类，这显然是存在问题的。在面向对象思想中要正确地实现对象的多重特性，只能使用一些精巧的设计来补救。</p><p>Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p><p>下面的代码使用Go语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p><p>人和鸟的特性：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 可飞行的</span><br><span class="line">type Flying struct{}</span><br><span class="line"></span><br><span class="line">func (f *Flying) Fly() {</span><br><span class="line">    fmt.Println("can fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 可行走的</span><br><span class="line">type Walkable struct{}</span><br><span class="line"></span><br><span class="line">func (f *Walkable) Walk() {</span><br><span class="line">    fmt.Println("can calk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 人类</span><br><span class="line">type Human struct {</span><br><span class="line">    Walkable // 人类能行走</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 鸟类</span><br><span class="line">type Bird struct {</span><br><span class="line">    Walkable // 鸟类能行走</span><br><span class="line">    Flying   // 鸟类能飞行</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化鸟类</span><br><span class="line">    b := new(Bird)</span><br><span class="line">    fmt.Println("Bird: ")</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line"></span><br><span class="line">    // 实例化人类</span><br><span class="line">    h := new(Human)</span><br><span class="line">    fmt.Println("Human: ")</span><br><span class="line">    h.Walk()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，声明可飞行结构（Flying）。</li><li>第 8 行，为可飞行结构添加飞行方法 Fly()。</li><li>第 13 行，声明可行走结构（Walkable）。</li><li>第 15 行，为可行走结构添加行走方法 Walk()。</li><li>第 20 行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备“可行走”特性</li><li>第 25 行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。</li><li>第 33 行，实例化鸟类结构。</li><li>第 35 和 36 行，调用鸟类可以使用的功能，如飞行和行走。</li><li>第 39 行，实例化人类结构。</li><li>第 41 行，调用人类能使用的功能，如行走。</li></ul><p>运行代码，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></tbody></table></figure><p>使用Go语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go语言会在编译时检查能否使用这些特性。</p><h2 id="初始化内嵌结构体"><a href="#初始化内嵌结构体" class="headerlink" title="初始化内嵌结构体"></a>初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p><p>车辆结构的组装和初始化：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 引擎</span><br><span class="line">type Engine struct {</span><br><span class="line">    Power int    // 功率</span><br><span class="line">    Type  string // 类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: Engine{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行定义车轮结构。</li><li>第 11 行定义引擎结构。</li><li>第 17 行定义车结构，由车轮和引擎结构体嵌入。</li><li>第 27 行，将 Car 的 Wheel 字段使用 Wheel 结构体进行初始化。</li><li>第 32 行，将 Car 的 Engine 字段使用 Engine 结构体进行初始化。</li></ul><h3 id="初始化内嵌匿名结构体"><a href="#初始化内嵌匿名结构体" class="headerlink" title="初始化内嵌匿名结构体"></a>初始化内嵌匿名结构体</h3><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    // 引擎</span><br><span class="line">    Engine struct {</span><br><span class="line">        Power int    // 功率</span><br><span class="line">        Type  string // 类型</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: struct {</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        }{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 14 行中原来的 Engine 结构体被直接定义在 Car 的结构体中。这种嵌入的写法就是将原来的结构体类型转换为 <code>struct{…}</code> 。</li><li>第 30 行，需要对 Car 的 Engine 字段进行初始化，由于 Engine 字段的类型并没有被单独定义，因此在初始化其字段时需要先填写 <code>struct{…}</code> 声明其类型。</li><li>第 34 行开始填充这个匿名结构体的数据，按“键：值”格式填充。</li></ul><h2 id="内嵌结构体成员名字冲突"><a href="#内嵌结构体成员名字冲突" class="headerlink" title="内嵌结构体成员名字冲突"></a>内嵌结构体成员名字冲突</h2><p>嵌入结构体内部可能拥有相同的成员名，成员重名时会发生什么？下面通过例子来讲解。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type A struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type B struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type C struct {</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.A.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 7 行和第 11 行分别定义了两个拥有 <code>a int</code> 字段的结构体。</li><li>第 15 行的结构体嵌入了 A 和 B 的结构体。</li><li>第 21 行实例化 C 结构体。</li><li>第 22 行按常规的方法，访问嵌入结构体 A 中的 a 字段，并赋值 1。</li><li>第 23 行可以正常输出实例化 C 结构体。</li></ul><p>接着，将第 22 行修改为如下代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时再编译运行，编译器报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\main.go:22:3: ambiguous selector c.a</span><br></pre></td></tr></tbody></table></figure><p>编译器告知 C 的选择器 a 引起歧义，也就是说，编译器无法决定将 1 赋给 C 中的 A 还是 B 里的字段 a。</p><p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p><h2 id="使用匿名结构体解析JSON数据"><a href="#使用匿名结构体解析JSON数据" class="headerlink" title="使用匿名结构体解析JSON数据"></a>使用匿名结构体解析JSON数据</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。XML、ASN.1和Google的ProtocolBuffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p><p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的 <code>encoding/json</code> 、<code>encoding/xml</code> 、<code>encoding/asn1</code> 等包提供支持，并且这类包都有着相似的API接口。</p><p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的 <code>Unicode</code> 字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是 <code>Uhhhh</code> 转义数字来表示一个UTF-16编码，而不是Go语言的rune类型。</p><p>手机拥有屏幕、电池、指纹识别等信息，将这些信息填充为JSON格式的数据。如果需要选择性地分离JSON中的数据则较为麻烦。Go语言中的匿名结构体可以方便地完成这个操作。</p><p>首先给出完整的代码，然后再讲解每个部分。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p>首先，定义手机的各种数据结构体，如屏幕和电池，参考如下代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码定义了屏幕结构体和电池结构体，它们分别描述屏幕和电池的各种细节参数。</p><h3 id="准备JSON数据"><a href="#准备JSON数据" class="headerlink" title="准备JSON数据"></a>准备JSON数据</h3><p>准备手机数据结构，填充数据，将数据序列化为JSON格式的字节数组，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行定义了一个匿名结构体。这个结构体内嵌了Screen和Battery结构体，同时临时加入了HasTouchID字段。</li><li>第10行，为刚声明的匿名结构体填充屏幕数据。</li><li>第17行，填充电池数据。</li><li>第22行，填充指纹识别字段。</li><li>第26行，使用json.Marshal进行JSON序列化，将raw变量序列化为[]byte格式的JSON数据。</li></ul><h3 id="分离JSON数据"><a href="#分离JSON数据" class="headerlink" title="分离JSON数据"></a>分离JSON数据</h3><p>调用genJsonData获得JSON数据，将需要的字段填充到匿名结构体实例中，通过json.Unmarshal反序列化JSON数据达成分离JSON数据效果。代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行，调用genJsonData()函数，获得[]byte类型的JSON数据。</li><li>第6行，将jsonData的[]byte类型的JSON数据转换为字符串格式并打印输出。</li><li>第9行，构造匿名结构体，填充Screen结构和HasTouchID字段，第12行中的 <code>{}</code> 表示将结构体实例化。</li><li>第15行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第9行定义的结构体格式序列化到screenAndTouch中。</li><li>第18行，打印输出screenAndTouch中的详细数据信息。</li><li>第21行，构造匿名结构体，填充Battery结构和HasTouchID字段。</li><li>第27行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第21行定义的结构体格式序列化到batteryAndTouch中。</li><li>第30行，打印输出batteryAndTouch的详细数据信息。</li></ul><p>完整的代码执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">{"Size":5.5,"ResX":1920,"ResY":1080,"Capacity":2910,"HasTouchID":true}</span><br><span class="line">{Screen:{Size:5.5 ResX:1920 ResY:1080} HasTouchID:true}</span><br><span class="line">{Battery:{Capacity:2910} HasTouchID:true}</span><br></pre></td></tr></tbody></table></figure><h2 id="垃圾回收和SetFinalizer"><a href="#垃圾回收和SetFinalizer" class="headerlink" title="垃圾回收和SetFinalizer"></a>垃圾回收和SetFinalizer</h2><p>Go语言自带垃圾回收机制（GC）。GC 通过独立的进程执行，它会搜索不再使用的变量，并将其释放。需要注意的是，GC 在运行时会占用机器资源。</p><p>GC 是自动进行的，如果要手动进行 GC，可以使用 runtime.GC() 函数，显式的执行 GC。显式的进行 GC 只在某些特殊的情况下才有用，比如当内存资源不足时调用 runtime.GC() ，这样会立即释放一大片内存，但是会造成程序短时间的性能下降。</p><p>finalizer（终止器）是与对象关联的一个函数，通过 runtime.SetFinalizer 来设置，如果某个对象定义了 finalizer，当它被 GC 时候，这个 finalizer 就会被调用，以完成一些特定的任务，例如发信号或者写日志等。</p><p>在Go语言中 SetFinalizer 函数是这样定义的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetFinalizer(x, f interface{})</span><br></pre></td></tr></tbody></table></figure><p>参数说明如下：</p><ul><li>参数 x 必须是一个指向通过 new 申请的对象的指针，或者通过对复合字面值取址得到的指针。</li><li>参数 f 必须是一个函数，它接受单个可以直接用 x 类型值赋值的参数，也可以有任意个被忽略的返回值。</li></ul><p>SetFinalizer 函数可以将 x 的终止器设置为 f，当垃圾收集器发现 x 不能再直接或间接访问时，它会清理 x 并调用 f(x)。</p><p>另外，x 的终止器会在 x 不能直接或间接访问后的任意时间被调用执行，不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个 os.File 对象时没有调用其 Close 方法，该 os.File 对象可以使用终止器去关闭对应的操作系统文件描述符。</p><p>终止器会按依赖顺序执行：如果 A 指向 B，两者都有终止器，且 A 和 B 没有其它关联，那么只有 A 的终止器执行完成，并且 A 被释放后，B 的终止器才可以执行。</p><p>如果 <code>*x</code> 的大小为 0 字节，也不保证终止器会执行。</p><p>此外，我们也可以使用 <code>SetFinalizer(x, nil)</code> 来清理绑定到 x 上的终止器。</p><p><strong><em>提示：终止器只有在对象被 GC 时，才会被执行。其他情况下，都不会被执行，即使程序正常结束或者发生错误。</em></strong></p><p>【示例】在函数 entry() 中定义局部变量并设置 finalizer，当函数 entry() 执行完成后，在 main 函数中手动触发 GC，查看 finalizer 的执行情况。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "runtime"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">type Road int</span><br><span class="line">func findRoad(r *Road) {</span><br><span class="line">    log.Println("road:", *r)</span><br><span class="line">}</span><br><span class="line">func entry() {</span><br><span class="line">    var rd Road = Road(999)</span><br><span class="line">    r := &amp;rd</span><br><span class="line">    runtime.SetFinalizer(r, findRoad)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    entry()</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        runtime.GC()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2020/10/21 17:47:28 road: 999</span><br></pre></td></tr></tbody></table></figure><h2 id="将结构体数据保存为JSON格式数据"><a href="#将结构体数据保存为JSON格式数据" class="headerlink" title="将结构体数据保存为JSON格式数据"></a>将结构体数据保存为JSON格式数据</h2><p>JSON格式是一种用途广泛的对象文本格式。在Go语言中，结构体可以通过系统提供的json.Marshal()函数进行序列化。为了演示怎样通过反射获取结构体成员及各种值的过程，下面使用反射将结构体序列化为文本数据。</p><h3 id="数据结构及入口函数"><a href="#数据结构及入口函数" class="headerlink" title="数据结构及入口函数"></a>数据结构及入口函数</h3><p>将结构体序列化为JSON的步骤如下：</p><ul><li>准备数据结构体。</li><li>准备要序列化的结构体数据。</li><li>调用序列化函数。</li></ul><p>具体代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //声明技能结构</span><br><span class="line">    type Skill struct {</span><br><span class="line">        Name string</span><br><span class="line">        Level int</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明角色结构</span><br><span class="line">    type Actor struct {</span><br><span class="line">        Name string</span><br><span class="line">        Age int</span><br><span class="line"></span><br><span class="line">        Skills []Skill</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //填充基本角色数据</span><br><span class="line">    a := Actor {</span><br><span class="line">        Name : "cowboy",</span><br><span class="line">        Age:37,</span><br><span class="line">        Skills:[]Skill {</span><br><span class="line">            {</span><br><span class="line">                Name:"Rollandroll",</span><br><span class="line">                Level:1</span><br><span class="line">            },{</span><br><span class="line">                Name:"Flashyourdogeye",</span><br><span class="line">                Level:2</span><br><span class="line">            },{</span><br><span class="line">                Name:"TimetohaveLunch",</span><br><span class="line">                Level:3</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if result , err := MarshalJson(a) ; err == nil {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4～15行声明了一些结构体，用于描述一个角色的信息。</li><li>第18～27行，实例化了Actor结构体，并且填充了一些基本的角色数据。</li><li>第35行，调用自己实现的MarshalJson()函数，将Actor实例化的数据转换为JSON字符串。</li><li>第36行，如果操作成功将打印出数据。</li><li>第38行，如果操作有错误将打印错误。</li></ul><p>完整代码输出如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"Name":"cowboy","Age":37,"Skills":[{"Name":"Rollandroll","Level":1},{"Name":"Flashyourdogeye","Level":2},{"Name":"TimetohaveLunch","Level":3}]}</span><br></pre></td></tr></tbody></table></figure><h4 id="序列化主函数"><a href="#序列化主函数" class="headerlink" title="序列化主函数"></a>序列化主函数</h4><p>MarshalJson()是序列化过程的主要函数入口，通过这个函数会调用不同类型的子序列化函数。MarshalJson()传入一个interface{}的数据，并将这个数据转换为JSON字符串返回，如果发生错误，则返回错误信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func MarshalJson(v interface{})(string,error){</span><br><span class="line"></span><br><span class="line">    //准备一个缓冲</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    //将任意值转换为json并输出到缓冲</span><br><span class="line">    if err:= writeAny(&amp;b , reflect.ValueOf(v)) ; err == nil {</span><br><span class="line">        return b.String() , nil</span><br><span class="line">    } else {</span><br><span class="line">        return "" , err</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行，使用bytes.Buffer构建一个缓冲，这个对象类似于其他语言中的StringBuilder，在大量字符串连接时，推荐使用这个结构。</li><li>第7行，调用writeAny()函数，将bytes.Buffer以指针的方式传入，以方便将各种类型的数据都写入这个bytes.Buffer中。同时，将v转换为反射值对象并传入。</li><li>第8行，如果没有错误发生时，将bytes.Buffer的内容转换为字符串井返回。</li><li>第10行，发生错误时，远回空字符串结果和错误。</li></ul><p>MarshalJson()这个函数其实是对writeAny()函数的一个封装，将外部的interface{}类型转换为内部的reflect.Value类型，同时构建输出缓冲，将一些复杂的操作简化，方便外部使用。</p><h4 id="任意值序列化"><a href="#任意值序列化" class="headerlink" title="任意值序列化"></a>任意值序列化</h4><p>writeAny()函数传入一个字节缓冲和反射值对象，将反射值对象转换为JSON格式并写入字节缓冲中。</p><p>代码如下所示:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//将任意值转换为json并输出到缓冲</span><br><span class="line">func writeAny(buff *bytes.Buffer, value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    switch value.Kind() {</span><br><span class="line">        case reflect.String:</span><br><span class="line">            //写入带有双引号括起来的字符串</span><br><span class="line">            buff.WriteString(strconv.Quote(value.String()))</span><br><span class="line">        case reflect.Int:</span><br><span class="line">            //将整形转换为字符串并写入缓冲</span><br><span class="line">            buff.WriteString(strconv.FormatInt(value.Int(),10))</span><br><span class="line"></span><br><span class="line">        case reflect.Slice:</span><br><span class="line">            return writeSlice(buff,value)</span><br><span class="line"></span><br><span class="line">        case reflect.Struct:</span><br><span class="line">            return writeStruct(buff,value)</span><br><span class="line">        default:</span><br><span class="line">            //遇到不认识的种类，返回错误</span><br><span class="line">            return errors.New("unsupportkind:"+value.Kind().String())</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行，根据传入反射值对象的种类进行判断，如字符串、整型、切片及结构体。</li><li>第7行，当传入值为字符串种类时，使用reflect.Value的String函数将传入值转换为字符串，再将字符串用双引号括起来，strconv.Quote()函数提供了比较正规的封装。最终使用bytes.Buffer的WriteString()函数，将前面输出的字符串写入缓冲中。</li><li>第10行，当传入值为整型时，使用reflect.Value的Int()函数，将传入值转换为整型，再将整型以十进制格式使用strconv.FormatInt()函数格式化为字符串，最后写入缓冲中。</li><li>第11行，使用writeSlice()函数把切片序列化为JSON操作。</li><li>第14行，使用writeStruct()函数把切片序列化为JSON操作。</li><li>第17行，遇到不能识别的类型，函数返回错误。</li></ul><p>writeAny()函数是整个序列化中非常重要的环节，可以通过扩充switch中的种类扩充序列化能识别的类型。</p><h4 id="切片序列化"><a href="#切片序列化" class="headerlink" title="切片序列化"></a>切片序列化</h4><p>writeAny()函数中会调用writeSlice()函数将切片类型转换为JSON格式的字符串并将数据写入缓冲中。代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//将切片转换为json并输出到缓冲</span><br><span class="line">func writeSlice(buff *bytes.Buffer,value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //写入切片开始标记</span><br><span class="line">    buff.WriteString("[")</span><br><span class="line"></span><br><span class="line">    //遍历每个切片元素</span><br><span class="line">    for s:=0 ; s &lt; value.Len() ; s++ {</span><br><span class="line">        sliceValue := value.Index(s)</span><br><span class="line"></span><br><span class="line">        //写入每个切片元素</span><br><span class="line">        writeAny(buff,sliceValue)</span><br><span class="line"></span><br><span class="line">        //写入每个元素尾部逗号，最后一个字段不添加</span><br><span class="line">        if s &lt; value.Len() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入切片结束标记</span><br><span class="line">    buff.WriteString("]")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第5行和第21行分别写入JSON数组的开始标识 <code>“[”</code> 和结束标识 <code>“]”</code> 。</li><li>第8行和第9行，使用reflect.Value的Len()方法和Index()方法遍历切片的所有元素。Len()方法返回切片的长度，Index()方法根据给定的索引找到对应的索引。</li><li>第12行，通过reflect.Value类型的Index方法获得reflect.Value类型的sliceValue，再将sliceValue传入writeAny()函数并继续对这个值进行递归序列化。</li><li>第15～17行，JSON格式规定：每个数组成员由逗号分隔且最后一个元素后不加逗号，这里就是遵守这个规定。</li><li>由于writeAny的功能较为完善，因此序列化切片只需要添加头尾标识符及元素分隔符就可以了。</li></ul><h4 id="结构体序列化"><a href="#结构体序列化" class="headerlink" title="结构体序列化"></a>结构体序列化</h4><p>在JSON格式中，切片是一系列值的序列，以方括号开头和结尾：结构体由键值对组成，以大括号开始和结束。两种结构的元素均以逗号分隔。序列化结构体的实现过程代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//将结构体序列化为json并输出到缓冲</span><br><span class="line">func writeStruct(buff *bytes.Buffer , value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //取值的类型对象</span><br><span class="line">    valueType := value.Type()</span><br><span class="line"></span><br><span class="line">    //写入结构体左大括号</span><br><span class="line">    buff.WriteString("{")</span><br><span class="line"></span><br><span class="line">    //遍历结构体的所有值</span><br><span class="line">    for i:=0 ; i &lt; value.NumField() ; i++ {</span><br><span class="line"></span><br><span class="line">        //获取每个字段的字段值(reflect.Value)</span><br><span class="line">        fieldValue := value.Field(i)</span><br><span class="line"></span><br><span class="line">        //获取每个字段的类型(reflect.StructField)</span><br><span class="line">        fieldType := valueType.Field(i)</span><br><span class="line"></span><br><span class="line">        //写入字段名左双引号</span><br><span class="line">        buff.WriteString(""")</span><br><span class="line"></span><br><span class="line">        //写入字段名</span><br><span class="line">        buff.WriteString(fieldType.Name)</span><br><span class="line"></span><br><span class="line">        //写入字段名右双引号和冒号</span><br><span class="line">        buff.WriteString("":")</span><br><span class="line"></span><br><span class="line">        //写入每个字段值</span><br><span class="line">        writeAny(buff,fieldValue)</span><br><span class="line"></span><br><span class="line">        //写入每个字段尾部逗号，最后一个字段不添加</span><br><span class="line">        if i &lt; value.NumField() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入结构体右大括号</span><br><span class="line">    buff.WriteString("}")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第5行，遍历结构体获取值时，习惯性取出反射类型对象。</li><li>第8行和第38行，分别写入结构体开头和结尾的标识符。</li><li>第11行，根据reflect.Value的NumField()方法遍历结构体的成员值。</li><li>第14行，获取每一个结构体成员的反射值对象。</li><li>第17行，获取每一个结构体成员的反射类型对象，类型信息必须从类型对象中获取，反射值对象无法提供字段的类型信息，如果尝试从fieldValue.Type()中获得类型对象，那么取到的是值本身的类型对象，而不是结构体成员类型信息。</li><li>第20行，写入字段左边的双引号，双引号本身需要使用“”进行转义，从这里开始写入键值对。</li><li>第23行，根据结构体成员类型信息写入宇段名。</li><li>第26行，写入字段名右边的双引号和冒号。</li><li>第29行，递归调用任意值序列化函数writeAny()，将fieldValue继续序列化。</li><li>第32行，和切片一样，多个结构体字段间也是以逗号分隔，最后一个字段后面不接逗号。</li></ul><h4 id="JSON总结"><a href="#JSON总结" class="headerlink" title="JSON总结"></a>JSON总结</h4><p>上面例子只支持整型、字符串、切片和结构体类型序列化为JSON格式。如果需要扩充类型，可以在writeAny()函数中添加。程序功能和结构上还有一些不足，例如：</p><ul><li>没有处理各种异常情况，切片或结构体为空时应该提前判断，否则会触发岩机。</li><li>可以支持结构体标签（StructTag），方便自定义JSON的键名及忽略某些字段的序列化过程，避免这些字段被序列化到JSON中。</li><li>支持缩进且可以自定义缩进字符，将JSON序列化后的内容格式化，方便查看。</li><li>默认应该序列化为[]byte字节数组，外部自己转换为字符串。在大部分的使用中，JSON一般以字节数组方式解析、存储、传输，很少以字符串方式解析，因此避免字节数组和字符串的转换可以提高一些性能。</li></ul><h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p><p>使用链表结构可以避免在使用数组时需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p>链表允许插入和移除表上任意位置上的结点，但是不允许随机存取。链表有三种类型：单向链表、双向链表以及循环链表。</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表中每个结点包含两部分，分别是数据域和指针域，上一个结点的指针指向下一结点，依次相连，形成链表。</p><p>这里介绍三个概念：首元结点、头结点和头指针。</p><ul><li>首元结点：就是链表中存储第一个元素的结点，如下图中 a1 的位置。</li><li>头结点：它是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以存储链表的长度或者其它的信息，也可以为空不存储任何信息。</li><li>头指针：它是指向链表中第一个结点的指针。若链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向首元结点。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.gif" alt="图：单向链表"></p><p>头结点在链表中不是必须的，但增加头结点有以下几点好处：</p><ul><li>增加了头结点后，首元结点的地址保存在头结点的指针域中，对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。</li><li>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若链表为空的话，那么头结点的指针域为空。</li></ul><h3 id="使用-Struct-定义单链表"><a href="#使用-Struct-定义单链表" class="headerlink" title="使用 Struct 定义单链表"></a>使用 Struct 定义单链表</h3><p>利用 Struct 可以包容多种数据类型的特性，使用它作为链表的结点是最合适不过了。一个结构体内可以包含若干成员，这些成员可以是基本类型、自定义类型、数组类型，也可以是指针类型。这里可以使用指针类型成员来存放下一个结点的地址。</p><p>【示例 1】使用 Struct 定义一个单向链表。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Node struct {</span><br><span class="line">    Data  int</span><br><span class="line">    Next  *node</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中成员 Data 用来存放结点中的有用数据，Next 是指针类型的成员，它指向 Node struct 类型数据，也就是下一个结点的数据类型。</p><p>【示例 2】为链表赋值，并遍历链表中的每个结点。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data int</span><br><span class="line">    next *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node) { //遍历</span><br><span class="line">    for p != nil {</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p = p.next //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 1</span><br><span class="line">    var node1 = new(Node)</span><br><span class="line">    node1.data = 2</span><br><span class="line"></span><br><span class="line">    head.next = node1</span><br><span class="line">    var node2 = new(Node)</span><br><span class="line">    node2.data = 3</span><br><span class="line"></span><br><span class="line">    node1.next = node2</span><br><span class="line">    Shownode(head)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{1 0xc00004c1e0}</span><br><span class="line">{2 0xc00004c1f0}</span><br><span class="line">{3 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>单链表的结点插入方法一般使用头插法或者尾插法。</p><p>1)头插法</p><p>每次插入在链表的头部插入结点，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录头结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        node.next = tail   //将新插入的node的next指向头结点</span><br><span class="line">        tail = &amp;node      //重新赋值头结点</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(tail) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{9 0xc000036270}</span><br><span class="line">{8 0xc000036260}</span><br><span class="line">{7 0xc000036250}</span><br><span class="line">{6 0xc000036240}</span><br><span class="line">{5 0xc000036230}</span><br><span class="line">{4 0xc000036220}</span><br><span class="line">{3 0xc000036210}</span><br><span class="line">{2 0xc000036200}</span><br><span class="line">{1 0xc0000361f0}</span><br><span class="line">{0 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure><p>2)尾插法</p><p>每次插入结点在尾部，这也是我们较为习惯的方法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录最末尾的结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        (*tail).next = &amp;node</span><br><span class="line">        tail = &amp;node</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(head) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{0 0xc0000361f0}</span><br><span class="line">{1 0xc000036200}</span><br><span class="line">{2 0xc000036210}</span><br><span class="line">{3 0xc000036220}</span><br><span class="line">{4 0xc000036230}</span><br><span class="line">{5 0xc000036240}</span><br><span class="line">{6 0xc000036250}</span><br><span class="line">{7 0xc000036260}</span><br><span class="line">{8 0xc000036270}</span><br><span class="line">{9 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure><p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以速度较慢。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。</p><p>循环链表跟单链表唯一的区别就在尾结点。单向链表的尾结点指针指向空地址，表示这就是最后的结点了，而循环链表的尾结点指针是指向链表的头结点，它像一个环一样首尾相连，所以叫作“循环”链表，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/circlelinklist.gif" alt="图：循环链表"></p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题，尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.gif" alt="图：双向链表"></p><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p><h2 id="数据I-O对象及操作"><a href="#数据I-O对象及操作" class="headerlink" title="数据I/O对象及操作"></a>数据I/O对象及操作</h2><p>在Go语言中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。在实际开发过程中，无论是实现 web 应用程序，还是控制台输入输出，又或者是网络操作，都不可避免的会遇到 I/O 操作。</p><p>Go语言标准库的 bufio 包中，实现了对数据 I/O 接口的缓冲功能。这些功能封装于接口 io.ReadWriter、io.Reader 和 io.Writer 中，并对应创建了 ReadWriter、Reader 或 Writer 对象，在提供缓冲的同时实现了一些文本基本 I/O 操作功能。</p><h3 id="ReadWriter-对象"><a href="#ReadWriter-对象" class="headerlink" title="ReadWriter 对象"></a>ReadWriter 对象</h3><p>ReadWriter 对象可以对数据 I/O 接口 io.ReadWriter 进行输入输出缓冲操作，ReadWriter 结构定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter struct {</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，ReadWriter 对象中存放了一对 Reader 和 Writer 指针，它同时提供了对数据 I/O 对象的读写缓冲功能。</p><p>可以使用 NewReadWriter() 函数创建 ReadWriter 对象，该函数的功能是根据指定的 Reader 和 Writer 创建一个 ReadWriter 对象，ReadWriter 对象将会向底层 io.ReadWriter 接口写入数据，或者从 io.ReadWriter 接口读取数据。该函数原型声明如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</span><br></pre></td></tr></tbody></table></figure><p>在函数 NewReadWriter() 中，参数 r 是要读取的来源 Reader 对象，参数 w 是要写入的目的 Writer 对象。</p><h3 id="Reader-对象"><a href="#Reader-对象" class="headerlink" title="Reader 对象"></a>Reader 对象</h3><p>Reader 对象可以对数据 I/O 接口 io.Reader 进行输入缓冲操作，Reader 结构定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>默认情况下 Reader 对象没有定义初始值，输入缓冲区最小值为 16。当超出限制时，另创建一个二倍的存储空间</p><h3 id="创建-Reader-对象"><a href="#创建-Reader-对象" class="headerlink" title="创建 Reader 对象"></a>创建 Reader 对象</h3><p>可以创建 Reader 对象的函数一共有两个，分别是 NewReader() 和 NewReaderSize()，下面分别介绍。</p><p>1)NewReader() 函数</p><p>NewReader() 函数的功能是按照缓冲区默认长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReader(rd io.Reader) *Reader</span><br></pre></td></tr></tbody></table></figure><p>2)NewReaderSize() 函数</p><p>NewReaderSize() 函数的功能是按照指定的缓冲区长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 rd 是 io.Reader 接口，参数 size 是指定的缓冲区字节长度。</p><h3 id="操作-Reader-对象"><a href="#操作-Reader-对象" class="headerlink" title="操作 Reader 对象"></a>操作 Reader 对象</h3><p>操作 Reader 对象的方法共有 11 个，分别是 Read()、ReadByte()、ReadBytes()、ReadLine()、ReadRune ()、ReadSlice()、ReadString()、UnreadByte()、UnreadRune()、Buffered()、Peek()，下面分别介绍。</p><p>1)Read() 方法</p><p>Read() 方法的功能是读取数据，并存放到字节切片 p 中。Read() 执行结束会返回已读取的字节数，因为最多只调用底层的 io.Reader 一次，所以返回的 n 可能小于 len(p)，当字节流结束时，n 为 0，err 为 io. EOF。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br></pre></td></tr></tbody></table></figure><p>在方法 Read() 中，参数 p 是用于存放读取数据的字节切片。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [128]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>2)ReadByte() 方法</p><p>ReadByte() 方法的功能是读取并返回一个字节，如果没有字节可读，则返回错误信息。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadByte() (c byte,err error)</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    c, err := r.ReadByte()</span><br><span class="line">    fmt.Println(string(c), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>3)ReadBytes() 方法</p><p>ReadBytes() 方法的功能是读取数据直到遇到第一个分隔符“delim”，并返回读取的字节序列（包括“delim”）。如果 ReadBytes 在读到第一个“delim”之前出错，它返回已读取的数据和那个错误（通常是 io.EOF）。只有当返回的数据不以“delim”结尾时，返回的 err 才不为空值。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 delim 用于指定分割字节。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadBytes(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>4)ReadLine() 方法</p><p>ReadLine() 是一个低级的用于读取一行数据的方法，大多数调用者应该使用 ReadBytes(‘\n’) 或者 ReadString(‘\n’)。ReadLine 返回一行，不包括结尾的回车字符，如果一行太长（超过缓冲区长度），参数 isPrefix 会设置为 true 并且只返回前面的数据，剩余的数据会在以后的调用中返回。</p><p>当返回最后一行数据时，参数 isPrefix 会置为 false。返回的字节切片只在下一次调用 ReadLine 前有效。ReadLine 会返回一个非空的字节切片或一个错误，方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Golang is a beautiful language. \r\n I like it!")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    line, prefix, err := r.ReadLine()</span><br><span class="line">    fmt.Println(string(line), prefix, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Golang is a beautiful language.  false &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>5)ReadRune() 方法</p><p>ReadRune() 方法的功能是读取一个 UTF-8 编码的字符，并返回其 Unicode 编码和字节数。如果编码错误，ReadRune 只读取一个字节并返回 unicode.ReplacementChar(U+FFFD) 和长度 1。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    ch, size, err := r.ReadRune()</span><br><span class="line">    fmt.Println(string(ch), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>6)ReadSlice() 方法</p><p>ReadSlice() 方法的功能是读取数据直到分隔符“delim”处，并返回读取数据的字节切片，下次读取数据时返回的切片会失效。如果 ReadSlice 在查找到“delim”之前遇到错误，它返回读取的所有数据和那个错误（通常是 io.EOF）。</p><p>如果缓冲区满时也没有查找到“delim”，则返回 ErrBufferFull 错误。ReadSlice 返回的数据会在下次 I/O 操作时被覆盖，大多数调用者应该使用 ReadBytes 或者 ReadString。只有当 line 不以“delim”结尾时，ReadSlice 才会返回非空 err。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 delim 用于指定分割字节。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br><span class="line">Go语言入门教程 EOF</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure><p>7)ReadString() 方法</p><p>ReadString() 方法的功能是读取数据直到分隔符“delim”第一次出现，并返回一个包含“delim”的字符串。如果 ReadString 在读取到“delim”前遇到错误，它返回已读字符串和那个错误（通常是 io.EOF）。只有当返回的字符串不以“delim”结尾时，ReadString 才返回非空 err。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadString(delim byte) (line string, err error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 delim 用于指定分割字节。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadString(delim)</span><br><span class="line">    fmt.Println(line, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>8)UnreadByte() 方法</p><p>UnreadByte() 方法的功能是取消已读取的最后一个字节（即把字节重新放回读取缓冲区的前部）。只有最近一次读取的单个字节才能取消读取。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) UnreadByte() error</span><br></pre></td></tr></tbody></table></figure><p>9)UnreadRune() 方法</p><p>UnreadRune() 方法的功能是取消读取最后一次读取的 Unicode 字符。如果最后一次读取操作不是 ReadRune，UnreadRune 会返回一个错误（在这方面它比 UnreadByte 更严格，因为 UnreadByte 会取消上次任意读操作的最后一个字节）。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) UnreadRune() error</span><br></pre></td></tr></tbody></table></figure><p>10)Buffered() 方法</p><p>Buffered() 方法的功能是返回可从缓冲区读出数据的字节数, 示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [14]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn := r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">    n, err = r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn = r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go语言入门 14 &lt;nil&gt;</span><br><span class="line">6</span><br><span class="line">教程 6 &lt;nil&gt;</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure><p>11)Peek() 方法</p><p>Peek() 方法的功能是读取指定字节数的数据，这些被读取的数据不会从缓冲区中清除。在下次读取之后，本次返回的字节切片会失效。如果 Peek 返回的字节数不足 n 字节，则会同时返回一个错误说明原因，如果 n 比缓冲区要大，则错误为 ErrBufferFull。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Peek(n int) ([]byte, error)</span><br></pre></td></tr></tbody></table></figure><p>在方法 Peek() 中，参数 n 是希望读取的字节数。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    bl, err := r.Peek(8)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(14)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(20)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Go语言 &lt;nil&gt;</span><br><span class="line">Go语言入门 &lt;nil&gt;</span><br><span class="line">Go语言入门教程 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="Writer-对象"><a href="#Writer-对象" class="headerlink" title="Writer 对象"></a>Writer 对象</h3><p>Writer 对象可以对数据 I/O 接口 io.Writer 进行输出缓冲操作，Writer 结构定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>默认情况下 Writer 对象没有定义初始值，如果输出缓冲过程中发生错误，则数据写入操作立刻被终止，后续的写操作都会返回写入异常错误。</p><h3 id="创建-Writer-对象"><a href="#创建-Writer-对象" class="headerlink" title="创建 Writer 对象"></a>创建 Writer 对象</h3><p>创建 Writer 对象的函数共有两个分别是 NewWriter() 和 NewWriterSize()，下面分别介绍一下。</p><p>1)NewWriter() 函数</p><p>NewWriter() 函数的功能是按照默认缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewWriter(wr io.Writer) *Writer</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 wr 是 io.Writer 接口，Writer 对象会将数据写入该接口。</p><p>2)NewWriterSize() 函数</p><p>NewWriterSize() 函数的功能是按照指定的缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewWriterSize(wr io.Writer, size int) *Writer</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 wr 是 io.Writer 接口，参数 size 是指定的缓冲区字节长度。</p><h3 id="操作-Writer-对象"><a href="#操作-Writer-对象" class="headerlink" title="操作 Writer 对象"></a>操作 Writer 对象</h3><p>操作 Writer 对象的方法共有 7 个，分别是 Available()、Buffered()、Flush()、Write()、WriteByte()、WriteRune() 和 WriteString() 方法，下面分别介绍。</p><p>1)Available() 方法</p><p>Available() 方法的功能是返回缓冲区中未使用的字节数，该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Available() int</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Available())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Available())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 4096</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：4080</span><br></pre></td></tr></tbody></table></figure><p>2)Buffered() 方法</p><p>Buffered() 方法的功能是返回已写入当前缓冲区中的字节数，该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Buffered() int</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Buffered())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Buffered())</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println("执行 Flush 方法后，写入的字节数为：", w.Buffered())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该例测试结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 0</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：16</span><br><span class="line">执行 Flush 方法后，写入的字节数为： 0</span><br></pre></td></tr></tbody></table></figure><p>3)Flush() 方法</p><p>Flush() 方法的功能是把缓冲区中的数据写入底层的 io.Writer，并返回错误信息。如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Flush() error</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("未执行 Flush 缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Printf("执行 Flush 后缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未执行 Flush 缓冲区输出 ""</span><br><span class="line">执行 Flush 后缓冲区输出 "C语言中文网"</span><br></pre></td></tr></tbody></table></figure><p>4)Write() 方法</p><p>Write() 方法的功能是把字节切片 p 写入缓冲区，返回已写入的字节数 nn。如果 nn 小于 len(p)，则同时返回一个错误原因。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 p 是要写入的字节切片。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    n, err := w.Write(p)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>5)WriteByte() 方法</p><p>WriteByte() 方法的功能是写入一个字节，如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unc (b *Writer) WriteByte(c byte) error</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 c 是要写入的字节数据，比如 ASCII 字符。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var c byte = 'G'</span><br><span class="line">    err := w.WriteByte(c)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>6)WriteRune() 方法</p><p>WriteRune() 方法的功能是以 UTF-8 编码写入一个 Unicode 字符，返回写入的字节数和错误信息。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) WriteRune(r rune) (size int,err error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 r 是要写入的 Unicode 字符。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var r rune = 'G'</span><br><span class="line">    size, err := w.WriteRune(r)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该例测试结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>7)WriteString() 方法</p><p>WriteString() 方法的功能是写入一个字符串，并返回写入的字节数和错误信息。如果返回的字节数小于 len(s)，则同时返回一个错误说明原因。该方法原型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) WriteString(s string) (int, error)</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 s 是要写入的字符串。示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    s := "C语言中文网"</span><br><span class="line">    n, err := w.WriteString(s)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 结构体 </tag>
            
            <tag> struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go函数</title>
      <link href="posts/fbeb39a4/"/>
      <url>posts/fbeb39a4/</url>
      
        <content type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p><p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p><p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p><ul><li>函数本身可以作为值进行传递。</li><li>支持匿名函数和闭包（closure）。</li><li>函数可以满足接口。</li></ul><h2 id="函数声明（函数定义）"><a href="#函数声明（函数定义）" class="headerlink" title="函数声明（函数定义）"></a>函数声明（函数定义）</h2><p>函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。</p><p>因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</p><p>编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。</p><p>当函数执行到代码块最后一行 <code>}</code> 之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。</p><p>Go语言里面拥三种类型的函数：</p><ul><li>普通的带有名字的函数</li><li>匿名函数或者 lambda 函数</li><li>方法</li></ul><h3 id="普通函数声明（定义）"><a href="#普通函数声明（定义）" class="headerlink" title="普通函数声明（定义）"></a>普通函数声明（定义）</h3><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func 函数名(形式参数列表)(返回值列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</p><p>如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func hypot(x, y float64) float64 {</span><br><span class="line">    return math.Sqrt(x*x + y*y)</span><br><span class="line">}</span><br><span class="line">fmt.Println(hypot(3,4)) // "5"</span><br></pre></td></tr></tbody></table></figure><p>x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。</p><p>如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。</p><p>正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func f(i, j, k int, s, t string) { /* ... */ }</span><br><span class="line">func f(i int, j int, k int, s string, t string) { /* ... */ }</span><br></pre></td></tr></tbody></table></figure><p>下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符 <code>_</code> 可以强调某个参数未被使用。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func add(x int, y int) int {return x + y}</span><br><span class="line">func sub(x, y int) (z int) { z = x - y; return}</span><br><span class="line">func first(x int, _ int) int { return x }</span><br><span class="line">func zero(int, int) int { return 0 }</span><br><span class="line">fmt.Printf("%T\n", add) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", sub) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", first) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", zero) // "func(int, int) int"</span><br></pre></td></tr></tbody></table></figure><p>函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p><p>每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p><p>在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToNetwork()</span><br></pre></td></tr></tbody></table></figure><p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。</p><p>其它编程语言中函数的返回值</p><ul><li>C/C++ 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果，C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。</li><li>C# 语言也没有多返回值特性，C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。</li><li>lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。</li></ul><p>Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</p><h4 id="同一种类型返回值"><a href="#同一种类型返回值" class="headerlink" title="同一种类型返回值"></a>同一种类型返回值</h4><p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。</p><p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func typedTwoValues() (int, int) {</span><br><span class="line">    return 1, 2</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    a, b := typedTwoValues()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure><p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p><h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p><p>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。</p><p>下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line"></span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，对两个整型返回值进行命名，分别为 a 和 b。</li><li>第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。</li><li>第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line">    a = 1</span><br><span class="line">    return a, 2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong><em>提示:同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：</em></strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int, int)</span><br></pre></td></tr></tbody></table></figure><p>编译报错提示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed named and unnamed function parameters</span><br></pre></td></tr></tbody></table></figure><p>意思是：在函数参数中混合使用了命名和非命名参数。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p><p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p><p>Go语言的函数调用格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></tbody></table></figure><p>下面是对各个部分的说明：</p><ul><li>函数名：需要调用的函数名。</li><li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li><li>返回值变量列表：多个返回值使用逗号分隔。</li></ul><p>例如，加法函数调用样式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := add(1,1)</span><br></pre></td></tr></tbody></table></figure><h3 id="示例：将秒转换为具体的时间"><a href="#示例：将秒转换为具体的时间" class="headerlink" title="示例：将秒转换为具体的时间"></a>示例：将秒转换为具体的时间</h3><p>使用一个数值表示时间中的“秒”值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。</p><p>【示例】将秒解析为时间单位：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    // 定义每分钟的秒数</span><br><span class="line">    SecondsPerMinute = 60</span><br><span class="line"></span><br><span class="line">    // 定义每小时的秒数</span><br><span class="line">    SecondsPerHour = SecondsPerMinute * 60</span><br><span class="line"></span><br><span class="line">    // 定义每天的秒数</span><br><span class="line">    SecondsPerDay = SecondsPerHour * 24</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将传入的“秒”解析为3种时间单位</span><br><span class="line">func resolveTime(seconds int) (day int, hour int, minute int) {</span><br><span class="line"></span><br><span class="line">    day = seconds / SecondsPerDay</span><br><span class="line">    hour = seconds / SecondsPerHour</span><br><span class="line">    minute = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将返回值作为打印参数</span><br><span class="line">    fmt.Println(resolveTime(1000))</span><br><span class="line"></span><br><span class="line">    // 只获取小时和分钟</span><br><span class="line">    _, hour, minute := resolveTime(18000)</span><br><span class="line">    fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">    // 只获取天</span><br><span class="line">    day, _, _ := resolveTime(90000)</span><br><span class="line">    fmt.Println(day)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 16</span><br><span class="line">5 300</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 7 行，定义每分钟的秒数。</li><li>第 10 行，定义每小时的秒数，SecondsPerHour 常量值会在编译期间计算出结果。</li><li>第 13 行，定义每天的秒数。</li><li>第 17 行，定义 resolveTime() 函数，根据输入的秒数，返回 3 个整型值，含义分别是秒数对应的天数、小时数和分钟数（取整）。</li><li>第 29 行中，给定 1000 秒，对应是 16（16.6667 取整）分钟的秒数，resolveTime() 函数返回的 3 个变量会传递给 fmt.Println() 函数进行打印，因为 fmt.Println() 使用了可变参数，可以接收不定量的参数。</li><li>第 32 行，将 resolveTime() 函数中的 3 个返回值使用变量接收，但是第一个返回参数使用匿名函数接收，表示忽略这个变量。</li><li>第 36 行，忽略后两个返回值，只使用第一个返回值。</li></ul><h3 id="示例：函数中的参数传递效果测试"><a href="#示例：函数中的参数传递效果测试" class="headerlink" title="示例：函数中的参数传递效果测试"></a>示例：函数中的参数传递效果测试</h3><p>Go语言中传入和返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。</p><p>下面通过一个例子来详细了解Go语言的参数值传递。请先看完整的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import"fmt"</span><br><span class="line"></span><br><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Data struct {</span><br><span class="line">    complax []int //测试切片在参数传递中的效果</span><br><span class="line">    instance InnerData //实例分配的innerData</span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="测试数据类型"><a href="#测试数据类型" class="headerlink" title="测试数据类型"></a>测试数据类型</h4><p>为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Datas truct{</span><br><span class="line">    complax []int//测试切片在参数传递中的效果</span><br><span class="line"></span><br><span class="line">    instance InnerData//实例分配的innerData</span><br><span class="line"></span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct{</span><br><span class="line">    aint</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第2行，将Data声明为结构体类型，结构体是拥有多个字段的复杂结构。</li><li>第3行，complax为整型切片类型，切片是一种动态类型，内部以指针存在。</li><li>第5行，instance成员以InnerData类型作为Data的成员。</li><li>第7行，将ptr声明为InnerData的指针类型。</li><li>第11行，声明一个内嵌的结构InnerData。</li></ul><h4 id="值传递的测试函数"><a href="#值传递的测试函数" class="headerlink" title="值传递的测试函数"></a>值传递的测试函数</h4><p>本节中定义的passByValue()函数用于值传递的测试，该函数的参数和返回值都是Data类型。在调用中，Data的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量。代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line"></span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第5行，使用格式化的%+v动词输出in变量的详细结构，以便观察Data结构在传递前后的内部数值的变化情况。</li><li>第8行，打印传入参数inFunc的指针地址。在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。</li><li>第10行，将传入的变量作为返回值返回，返回的过程将发生值复制。</li></ul><h4 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h4><p>测试流程会准备一个Data格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针。通过调用测试函数，传入Data结构数据，并获得返回值，对比输入和输出后的Data结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第3行，创建一个Data结构的实例in。</li><li>第4行，将切片数据赋值到in的complax成员。</li><li>第5行，为in的instance成员赋值InnerData结构的数据。</li><li>第6行，为in的ptr成员赋值InnerData的指针类型数据。</li><li>第10行，打印输入结构的成员情况。</li><li>第13行，打印输入结构的指针地址。</li><li>第16行，传入in结构，调用passByvalue()测试函数获得out返回，此时，passByValue()函数会打印in传入后的数据成员情况。</li><li>第19行，打印返回值out变量的成员情况。</li><li>第22行，打印输出结构的地址。<br>运行代码，输出结果为：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninptr:0xc0000b4330ninFuncvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninFuncptr:0xc0000b43c0no</span><br><span class="line">utvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}noutptr:0xc0000b4390n</span><br></pre></td></tr></tbody></table></figure><p>从运行结果中发现：</p><ul><li>所有的Data结构的指针地址发生了变化，意味着所有的结构都是一块新的内存，无论是将Data结构传入函数内部，还是通过函数返回值传回Data都会发生复制行为。</li><li>所有的Data结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。</li><li>Data结构的ptr成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。</li></ul><h3 id="函数变量——把函数作为值保存到变量中"><a href="#函数变量——把函数作为值保存到变量中" class="headerlink" title="函数变量——把函数作为值保存到变量中"></a>函数变量——把函数作为值保存到变量中</h3><p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fire() {</span><br><span class="line">    fmt.Println("fire")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line"></span><br><span class="line">    f = fire</span><br><span class="line"></span><br><span class="line">    f()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fire</span><br></pre></td></tr></tbody></table></figure><p>代码说明：</p><ul><li>第 7 行，定义了一个 fire() 函数。</li><li>第 13 行，将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil。</li><li>第 15 行，将 fire() 函数作为值，赋给函数变量 f，此时 f 的值为 fire() 函数。</li><li>第 17 行，使用函数变量 f 进行函数调用，实际调用的是 fire() 函数。</li></ul><h3 id="字符串的链式处理"><a href="#字符串的链式处理" class="headerlink" title="字符串的链式处理"></a>字符串的链式处理</h3><p>使用SQL语言从数据库中获取数据时，可以对原始数据进行排序（sortby）、分组（groupby）和去重（distinct）等操作。SQL将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。</p><p>对数据的操作进行多步骤的处理被称为链式处理。本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。</p><p>完整代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(strstring) string {</span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list:=[]string {"goscanner","goparser","gocompiler","goprinter","goformater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>字符串处理函数（StringProccess）需要外部提供数据源：一个字符串切片 <code>（list[]string）</code>，另外还要提供一个链式处理函数的切片 <code>（chain[]func(string)string）</code>，链式处理切片中的一个处理函数的定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(string) string</span><br></pre></td></tr></tbody></table></figure><p>这种处理函数能够接受一个字符串输入，处理后输出。</p><p>strings包中将字符串变为小写就是一种处理函数的形式，<code>strings.ToLower()</code> 函数能够将传入的字符串的每一个字符变为小写，<code>strings.ToLower</code>定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ToLower(s string) string</span><br></pre></td></tr></tbody></table></figure><p>字符串处理函数（StringProccess）内部遍历每一个数据源提供的字符串，每个字符串都需要经过一系列链式处理函数处理后被重新放回切片，参见下面代码。</p><p>字符串的链式处理：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第2行，传入字符串切片list作为数据源，一系列的处理函数作为chain处理链。</li><li>第5行，遍历字符串切片的每个字符串，依次对每个字符串进行处理。</li><li>第8行，将当前字符串保存到result变量中，作为第一个处理函数的参数。</li><li>第11行，遍历每一个处理函数，将字符串按顺序经过这些处理函数处理。</li><li>第14行，result变量即是每个处理函数的输入变量，处理后的变量又会重新保存到result变量中。</li><li>第18行，将处理完的字符串保存回切片中。</li></ul><h4 id="自定义的处理函数"><a href="#自定义的处理函数" class="headerlink" title="自定义的处理函数"></a>自定义的处理函数</h4><p>处理函数可以是系统提供的处理函数，如将字符串变大写或小写，也可以使用自定义函数。本例中的字符串处理的逻辑是使用一个自定义的函数实现移除指定go前缀的过程，参见下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(str string) string {</span><br><span class="line"></span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此函数使用了strings.TrimPrefix()函数实现移除字符串的指定前缀。处理后，移除前缀的字符串结果将通过removePrefix()函数的返回值返回。</p><h4 id="字符串处理主流程"><a href="#字符串处理主流程" class="headerlink" title="字符串处理主流程"></a>字符串处理主流程</h4><p>字符串处理的主流程包含以下几个步骤：</p><ul><li>准备要处理的字符串列表。</li><li>准备字符串处理链。</li><li>处理字符串列表。</li><li>打印输出后的字符串列表。</li></ul><p>详细流程参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list := []string {"go scanner","go parser","go compiler","go printer","go formater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第4行，定义字符串切片，字符串包含go前缀及空格。</li><li>第13行，准备处理每个字符串的处理链，处理的顺序与函数在切片中的位置一致。removePrefix()为自定义的函数，功能是移除go前缀；移除前缀的字符串左边有一个空格，使用strings.TrimSpace移除，这个函数的定义刚好符合处理函数的格式：func(string)string；strings.ToUpper用于将字符串转为大写。</li><li>第20行，传入字符串切片和字符串处理链，通过StringProcess()函数对字符串进行处理。</li><li>第23行，遍历字符串切片的每一个字符串，打印处理好的字符串结果。</li></ul><p><strong><em>提示:链式处理器是一种常见的编程设计。Netty是使用Java语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty中就有类似的链式处理器的设计。</em></strong></p><p>Netty可以使用类似的处理链对封包进行收发编码及处理。Netty的开发者可以分为3种：</p><ul><li>第一种是Netty底层开发者</li><li>第二种是每个处理环节的开发者</li><li>第三种是业务实现者，在实际开发环节中，后两种开发者往往是同一批开发者。</li></ul><p>链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。</p><h2 id="匿名函数——没有函数名字的函数"><a href="#匿名函数——没有函数名字的函数" class="headerlink" title="匿名函数——没有函数名字的函数"></a>匿名函数——没有函数名字的函数</h2><p>Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。</p><p>匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。</p><h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数列表)(返回参数列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>匿名函数的定义就是没有名字的普通函数定义。</p><h4 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h4><p>匿名函数可以在声明后调用，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}(100)</span><br></pre></td></tr></tbody></table></figure><p>注意第3行 <code>}</code> 后的 <code>(100)</code> ，表示对匿名函数进行调用，传递参数为 100。</p><h4 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h4><p>匿名函数可以被赋值，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将匿名函数体保存到f()中</span><br><span class="line">f := func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 使用f()调用</span><br><span class="line">f(100)</span><br></pre></td></tr></tbody></table></figure><p>匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p><h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) {</span><br><span class="line"></span><br><span class="line">    for _, v := range list {</span><br><span class="line">        f(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int{1, 2, 3, 4}, func(v int) {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。</li><li>第 18 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。</li><li>第 19～20 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。</li></ul><p>匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string {</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用匿名函数实现操作封装"><a href="#使用匿名函数实现操作封装" class="headerlink" title="使用匿名函数实现操作封装"></a>使用匿名函数实现操作封装</h3><p>下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var skillParam = flag.String("skill", "", "skill to perform")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    var skill = map[string]func(){</span><br><span class="line">        "fire": func() {</span><br><span class="line">            fmt.Println("chicken fire")</span><br><span class="line">        },</span><br><span class="line">        "run": func() {</span><br><span class="line">            fmt.Println("soldier run")</span><br><span class="line">        },</span><br><span class="line">        "fly": func() {</span><br><span class="line">            fmt.Println("angel fly")</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if f, ok := skill[*skillParam]; ok {</span><br><span class="line">        f()</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("skill not found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义命令行参数 skill，从命令行输入 <code>--skill</code> 可以将 <code>=</code> 后的字符串传入 skillParam 指针变量。</li><li>第 12 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。</li><li>第 14 行，定义一个从字符串映射到 <code>func()</code> 的 map，然后填充这个 map。</li><li>第 15～23 行，初始化 map 的键值对，值为匿名函数。</li><li>第 26 行，skillParam 是一个 <code>*string</code> 类型的指针变量，使用 <code>*skillParam</code> 获取到命令行传过来的值，并在 <code>map</code> 中查找对应命令行参数指定的字符串的函数。</li><li>第 29 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。</li></ul><p>运行代码，结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fly</span><br><span class="line">angel fly</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fire</span><br><span class="line">chicken fire</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=run</span><br><span class="line">soldier run</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=go</span><br><span class="line">skill not found</span><br></pre></td></tr></tbody></table></figure><h2 id="函数类型实现接口"><a href="#函数类型实现接口" class="headerlink" title="函数类型实现接口"></a>函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将对结构体与函数实现接口的过程进行对比。</p><p>完整的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明接口变量</span><br><span class="line">    var invoker Invoker</span><br><span class="line"></span><br><span class="line">    // 实例化结构体</span><br><span class="line">    s := new(Struct)</span><br><span class="line"></span><br><span class="line">    // 将实例化的结构体赋值到接口</span><br><span class="line">    invoker = s</span><br><span class="line"></span><br><span class="line">    // 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line"></span><br><span class="line">    // 将匿名函数转为FuncCaller类型，再赋值给接口</span><br><span class="line">    invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">        fmt.Println("from function", v)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 使用接口调用FuncCaller.Call，内部会调用函数本体</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">from struct hello</span><br><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure><p>有如下一个接口：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call()方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个接口需要实现 Call() 方法，调用时会传入一个 interface{} 类型的变量，这种类型的变量表示任意类型的值。</p><p>接下来，使用结构体进行接口实现。</p><h3 id="结构体实现接口"><a href="#结构体实现接口" class="headerlink" title="结构体实现接口"></a>结构体实现接口</h3><p>结构体实现 Invoker 接口的代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，定义结构体，该例子中的结构体无须任何成员，主要展示实现 Invoker 的方法。</li><li>第 6 行，Call() 为结构体的方法，该方法的功能是打印 from struct 和传入的 interface{} 类型的值。</li></ul><p>将定义的 Struct 类型实例化，并传入接口中进行调用，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 实例化结构体</span><br><span class="line">s := new(Struct)</span><br><span class="line"></span><br><span class="line">// 将实例化的结构体赋值到接口</span><br><span class="line">invoker = s</span><br><span class="line"></span><br><span class="line">// 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，声明 Invoker 类型的变量。</li><li>第 5 行，使用 new 将结构体实例化，此行也可以写为 <code>s := &amp;Struct</code>。</li><li>第 8 行，s 类型为 <code>*Struct</code> ，已经实现了 Invoker 接口类型，因此赋值给 invoker 时是成功的。</li><li>第 11 行，通过接口的 <code>Call()</code> 方法，传入 hello ，此时将调用 Struct 结构体的 <code>Call()</code> 方法。</li></ul><p>接下来，对比下函数实现结构体的差异。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from struct hello</span><br></pre></td></tr></tbody></table></figure><h3 id="函数体实现接口"><a href="#函数体实现接口" class="headerlink" title="函数体实现接口"></a>函数体实现接口</h3><p>函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f()函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，将 func(interface{}) 定义为 FuncCaller 类型。</li><li>第 5 行，FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。</li><li>第 8 行，FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。</li></ul><p>上面代码只是定义了函数类型，需要函数本身进行逻辑处理，FuncCaller 无须被实例化，只需要将函数转换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包，参见下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 将匿名函数转为FuncCaller类型, 再赋值给接口</span><br><span class="line">invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">    fmt.Println("from function", v)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 使用接口调用FuncCaller.Call, 内部会调用函数本体</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，声明接口变量。</li><li>第 5 行，将 func(v interface{}){} 匿名函数转换为 FuncCaller 类型（函数签名才能转换），此时 FuncCaller 类型实现了 Invoker 的 Call() 方法，赋值给 invoker 接口是成功的。</li><li>第 10 行，使用接口方法调用。</li></ul><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure><h3 id="HTTP包中的例子"><a href="#HTTP包中的例子" class="headerlink" title="HTTP包中的例子"></a>HTTP包中的例子</h3><p>HTTP 包中包含有 Handler 接口定义，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler interface {</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Handler 用于定义每个 HTTP 的请求和响应的处理过程。</p><p>同时，也可以使用处理函数实现接口，定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="line"></span><br><span class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。</p><h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></tbody></table></figure><p>同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/closure.jpg" alt="图：闭包与函数引用"></p><p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</p><p><strong><em>其它编程语言中的闭包</em></strong></p><p>闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。</p><p>闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。</p><p>在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。</p><p>闭包在各种语言中的实现也是不尽相同的，在 Lua 语言中，无论闭包还是函数都属于 Prototype 概念，被捕获的变量以 Upvalue 的形式引用到闭包中。</p><p>C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。</p><h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 准备一个字符串</span><br><span class="line">str := "hello world"</span><br><span class="line"></span><br><span class="line">// 创建一个匿名函数</span><br><span class="line">foo := func() {</span><br><span class="line"></span><br><span class="line">    // 匿名函数中访问str</span><br><span class="line">    str = "hello dude"</span><br><span class="line">}</span><br><span class="line">// 调用匿名函数</span><br><span class="line">foo()</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，准备一个字符串用于修改。</li><li>第 5 行，创建一个匿名函数。</li><li>第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。</li><li>第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。</li></ul><p>代码输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello dude</span><br></pre></td></tr></tbody></table></figure><h3 id="示例：闭包的记忆效应"><a href="#示例：闭包的记忆效应" class="headerlink" title="示例：闭包的记忆效应"></a>示例：闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p><p>累加器的实现：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 提供一个值, 每次调用函数会指定对值进行累加</span><br><span class="line">func Accumulate(value int) func() int {</span><br><span class="line"></span><br><span class="line">    // 返回一个闭包</span><br><span class="line">    return func() int {</span><br><span class="line"></span><br><span class="line">        // 累加</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        // 返回一个累加值</span><br><span class="line">        return value</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator := Accumulate(1)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator)</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator2 := Accumulate(10)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator2())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0xc000006028</span><br><span class="line">11</span><br><span class="line">0xc000006038</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。</li><li>第 11 行，返回一个闭包函数，每次返回会创建一个新的函数实例。</li><li>第 14 行，对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</li><li>第 17 行，将修改后的值通过闭包的返回值返回。</li><li>第 24 行，创建一个累加器，初始值为 1，返回的 accumulator 是类型为 func()int 的函数变量。</li><li>第 27 行，调用 accumulator() 时，代码从 11 行开始执行匿名函数逻辑，直到第 17 行返回。</li><li>第 32 行，打印累加器的函数地址。</li></ul><p>对比输出的日志发现 accumulator 与 accumulator2 输出的函数地址不同，因此它们是两个不同的闭包实例。</p><p>每调用一次 accumulator 都会自动对引用的变量进行累加。</p><h3 id="示例：闭包实现生成器"><a href="#示例：闭包实现生成器" class="headerlink" title="示例：闭包实现生成器"></a>示例：闭包实现生成器</h3><p>闭包的记忆效应被用于实现类似于<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>中工厂模式的生成器，下面的例子展示了创建一个玩家生成器的过程。</p><p>玩家生成器的实现：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 创建一个玩家生成器, 输入名称, 输出生成器</span><br><span class="line">func playerGen(name string) func() (string, int) {</span><br><span class="line"></span><br><span class="line">    // 血量一直为150</span><br><span class="line">    hp := 150</span><br><span class="line"></span><br><span class="line">    // 返回创建的闭包</span><br><span class="line">    return func() (string, int) {</span><br><span class="line"></span><br><span class="line">        // 将变量引用到闭包中</span><br><span class="line">        return name, hp</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个玩家生成器</span><br><span class="line">    generator := playerGen("high noon")</span><br><span class="line"></span><br><span class="line">    // 返回玩家的名字和血量</span><br><span class="line">    name, hp := generator()</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(name, hp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high noon 150</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，playerGen() 需要提供一个名字来创建一个玩家的生成函数。</li><li>第 11 行，声明并设定 hp 变量为 150。</li><li>第 14～18 行，将 hp 和 name 变量引用到匿名函数中形成闭包。</li><li>第 24 行中，通过 playerGen 传入参数调用后获得玩家生成器。</li><li>第 27 行，调用这个玩家生成器函数，可以获得玩家的名称和血量。</li></ul><p>闭包还具有一定的封装性，第 11 行的变量是 playerGen 的局部变量，playerGen 的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。</p><h2 id="可变参数（变参函数）"><a href="#可变参数（变参函数）" class="headerlink" title="可变参数（变参函数）"></a>可变参数（变参函数）</h2><p>在C语言时代大家一般都用过 printf() 函数，从那个时候开始其实已经在感受可变参数的魅力和价值，如同C语言中的 printf() 函数，Go语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能。</p><p>本节我们将介绍可变参数的用法。合适地使用可变参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等。</p><h3 id="可变参数类型"><a href="#可变参数类型" class="headerlink" title="可变参数类型"></a>可变参数类型</h3><p>可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面这段代码的意思是，函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int，所以它可以用如下方式调用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myfunc(2, 3, 4)</span><br><span class="line">myfunc(1, 3, 7, 13)</span><br></pre></td></tr></tbody></table></figure><p>形如 <code>...type</code> 格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖 <code>（syntactic sugar）</code> ，即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。</p><p>从内部实现机理上来说，类型 <code>...type</code> 本质上是一个数组切片，也就是 <code>[]type</code> ，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。</p><p>假如没有 <code>...type</code> 这样的语法糖，开发者将不得不这么写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc2(args []int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从函数的实现角度来看，这没有任何影响，该怎么写就怎么写，但从调用方来说，情形则完全不同：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfunc2([]int{1, 3, 7, 13})</span><br></pre></td></tr></tbody></table></figure><p>大家会发现，我们不得不加上 <code>[]int{}</code> 来构造一个数组切片实例，但是有了 <code>...type</code> 这个语法糖，我们就不用自己来处理了。</p><h3 id="任意类型的可变参数"><a href="#任意类型的可变参数" class="headerlink" title="任意类型的可变参数"></a>任意类型的可变参数</h3><p>之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Printf(format string, args ...interface{}) {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用 <code>interface{}</code> 传递任意类型数据是Go语言的惯例用法，使用 <code>interface{}</code> 仍然是类型安全的，这和 C/C++ 不太一样，下面通过示例来了解一下如何分配传入 <code>interface{}</code> 类型的数据。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func MyPrintf(args ...interface{}) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        switch arg.(type) {</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, "is an int value.")</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, "is a string value.")</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, "is an int64 value.")</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, "is an unknown type.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var v1 int = 1</span><br><span class="line">    var v2 int64 = 234</span><br><span class="line">    var v3 string = "hello"</span><br><span class="line">    var v4 float32 = 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该程序的输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 is an int value.</span><br><span class="line">234 is an int64 value.</span><br><span class="line">hello is a string value.</span><br><span class="line">1.234 is an unknown type.</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历可变参数列表——获取每一个参数的值"><a href="#遍历可变参数列表——获取每一个参数的值" class="headerlink" title="遍历可变参数列表——获取每一个参数的值"></a>遍历可变参数列表——获取每一个参数的值</h3><p>可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个函数, 参数数量为0~n, 类型约束为字符串</span><br><span class="line">func joinStrings(slist ...string) string {</span><br><span class="line"></span><br><span class="line">    // 定义一个字节缓冲, 快速地连接字符串</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    // 遍历可变参数列表slist, 类型为[]string</span><br><span class="line">    for _, s := range slist {</span><br><span class="line">        // 将遍历出的字符串连续写入字节数组</span><br><span class="line">        b.WriteString(s)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将连接好的字节数组转换为字符串并输出</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 输入3个字符串, 将它们连成一个字符串</span><br><span class="line">    fmt.Println(joinStrings("pig ", "and", " rat"))</span><br><span class="line">    fmt.Println(joinStrings("hammer", " mom", " and", " hawk"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pig and rat</span><br><span class="line">hammer mom and hawk</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义了一个可变参数的函数，slist 的类型为 []string，每一个参数的类型都是 string，也就是说，该函数只接受字符串类型作为参数。</li><li>第 11 行，bytes.Buffer 在这个例子中的作用类似于 StringBuilder，可以高效地进行字符串连接操作。</li><li>第 13 行，遍历 slist 可变参数，s 为每个参数的值，类型为 string。</li><li>第 15 行，将每一个传入参数放到 bytes.Buffer 中。</li><li>第 19 行，将 bytes.Buffer 中的数据转换为字符串作为函数返回值返回。</li><li>第 24 行，输入 3 个字符串，使用 joinStrings() 函数将参数连接为字符串输出。</li><li>第 25 行，输入 4 个字符串，连接后输出。</li></ul><p>如果要获取可变参数的数量，可以使用 len() 函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。</p><h3 id="获得可变参数类型——获得每一个参数的类型"><a href="#获得可变参数类型——获得每一个参数的类型" class="headerlink" title="获得可变参数类型——获得每一个参数的类型"></a>获得可变参数类型——获得每一个参数的类型</h3><p>当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型，下面的代码演示将一系列不同类型的值传入 printTypeValue() 函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。</p><p>打印类型及值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printTypeValue(slist ...interface{}) string {</span><br><span class="line"></span><br><span class="line">    // 字节缓冲作为快速字符串连接</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    // 遍历参数</span><br><span class="line">    for _, s := range slist {</span><br><span class="line"></span><br><span class="line">        // 将interface{}类型格式化为字符串</span><br><span class="line">        str := fmt.Sprintf("%v", s)</span><br><span class="line"></span><br><span class="line">        // 类型的字符串描述</span><br><span class="line">        var typeString string</span><br><span class="line"></span><br><span class="line">        // 对s进行类型断言</span><br><span class="line">        switch s.(type) {</span><br><span class="line">        case bool:    // 当s为布尔类型时</span><br><span class="line">            typeString = "bool"</span><br><span class="line">        case string:    // 当s为字符串类型时</span><br><span class="line">            typeString = "string"</span><br><span class="line">        case int:    // 当s为整型类型时</span><br><span class="line">            typeString = "int"</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 写字符串前缀</span><br><span class="line">        b.WriteString("value: ")</span><br><span class="line"></span><br><span class="line">        // 写入值</span><br><span class="line">        b.WriteString(str)</span><br><span class="line"></span><br><span class="line">        // 写类型前缀</span><br><span class="line">        b.WriteString(" type: ")</span><br><span class="line"></span><br><span class="line">        // 写类型字符串</span><br><span class="line">        b.WriteString(typeString)</span><br><span class="line"></span><br><span class="line">        // 写入换行符</span><br><span class="line">        b.WriteString("\n")</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将不同类型的变量通过printTypeValue()打印出来</span><br><span class="line">    fmt.Println(printTypeValue(100, "str", true))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value: 100 type: int</span><br><span class="line">value: str type: string</span><br><span class="line">value: true type: bool</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，printTypeValue() 输入不同类型的值并输出类型和值描述。</li><li>第 11 行，bytes.Buffer 字节缓冲作为快速字符串连接。</li><li>第 14 行，遍历 slist 的每一个元素，类型为 interface{}。</li><li>第 17 行，使用 fmt.Sprintf 配合%v动词，可以将 interface{} 格式的任意值转为字符串。</li><li>第 20 行，声明一个字符串，作为变量的类型名。</li><li>第 23 行，switch s.(type) 可以对 interface{} 类型进行类型断言，也就是判断变量的实际类型。</li><li>第 24～29 行为 s 变量可能的类型，将每种类型的对应类型字符串赋值到 typeString 中。</li><li>第 33～42 行为写输出格式的过程。</li></ul><h3 id="在多个可变参数函数中传递参数"><a href="#在多个可变参数函数中传递参数" class="headerlink" title="在多个可变参数函数中传递参数"></a>在多个可变参数函数中传递参数</h3><p>可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加 <code>...</code> ，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p><p>下面的例子模拟 print() 函数及实际调用的 rawPrint() 函数，两个函数都拥有可变参数，需要将参数从 print 传递到 rawPrint 中。</p><p>可变参数传递：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 实际打印的函数</span><br><span class="line">func rawPrint(rawList ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 遍历可变参数切片</span><br><span class="line">    for _, a := range rawList {</span><br><span class="line"></span><br><span class="line">        // 打印参数</span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印函数封装</span><br><span class="line">func print(slist ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 将slist可变参数切片完整传递给下一个函数</span><br><span class="line">    rawPrint(slist...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    print(1, 2, 3)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>对代码的说明：</p><ul><li>第 9～13 行，遍历 rawPrint() 的参数列表 rawList 并打印。</li><li>第 20 行，将变量在 print 的可变参数列表中添加 <code>...</code> 后传递给 rawPrint()。</li><li>第 25 行，传入 1、2、3 这 3 个整型值并进行打印。</li></ul><p>如果尝试将第 20 行修改为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rawPrint("fmt", slist)</span><br></pre></td></tr></tbody></table></figure><p>再次执行代码，将输出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure><p>此时，slist（类型为 <code>[]interface{}</code> ）将被作为一个整体传入 rawPrint()，rawPrint() 函数中遍历的变量也就是 slist 的切片值。</p><p>可变参数使用 <code>...</code> 进行传递与切片间使用 append 连接是同一个特性。</p><h2 id="defer（延迟执行语句）"><a href="#defer（延迟执行语句）" class="headerlink" title="defer（延迟执行语句）"></a>defer（延迟执行语句）</h2><p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</p><p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p><h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出），下面的代码是将一系列的数值打印语句按顺序延迟处理，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer begin")</span><br><span class="line"></span><br><span class="line">    // 将defer放入延迟调用栈</span><br><span class="line">    defer fmt.Println(1)</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line"></span><br><span class="line">    // 最后一个放入, 位于栈顶, 最先调用</span><br><span class="line">    defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer end")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer begin</span><br><span class="line">defer end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure><p>结果分析如下：</p><ul><li>代码的延迟顺序与最终的执行顺序是反向的。</li><li>延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。</li></ul><h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p><p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。</p><h4 id="使用延迟并发解锁"><a href="#使用延迟并发解锁" class="headerlink" title="使用延迟并发解锁"></a>使用延迟并发解锁</h4><p>在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    // 一个演示用的映射</span><br><span class="line">    valueByKey      = make(map[string]int)</span><br><span class="line">    // 保证使用映射时的并发安全的互斥锁</span><br><span class="line">    valueByKeyGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 根据键读取值</span><br><span class="line">func readValue(key string) int {</span><br><span class="line">    // 对共享资源加锁</span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">    // 取值</span><br><span class="line">    v := valueByKey[key]</span><br><span class="line">    // 对共享资源解锁</span><br><span class="line">    valueByKeyGuard.Unlock()</span><br><span class="line">    // 返回值</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，实例化一个 map，键是 string 类型，值为 int。</li><li>第 5 行，map 默认不是并发安全的，准备一个 sync.Mutex 互斥量保护 map 的访问。</li><li>第 9 行，readValue() 函数给定一个键，从 map 中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。</li><li>第 11 行，使用互斥量加锁。</li><li>第 13 行，从 map 中获取值。</li><li>第 15 行，使用互斥量解锁。</li><li>第 17 行，返回获取到的 map 值。</li></ul><p>使用 defer 语句对上面的语句进行简化，参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func readValue(key string) int {</span><br><span class="line"></span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line"></span><br><span class="line">    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用</span><br><span class="line">    defer valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return valueByKey[key]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中第 6~8 行是对前面代码的修改和添加的代码，代码说明如下：</p><ul><li>第 6 行在互斥量加锁后，使用 defer 语句添加解锁，该语句不会马上执行，而是等 readValue() 函数返回时才会被执行。</li><li>第 8 行，从 map 查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。</li></ul><h4 id="使用延迟释放文件句柄"><a href="#使用延迟释放文件句柄" class="headerlink" title="使用延迟释放文件句柄"></a>使用延迟释放文件句柄</h4><p>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源，在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 根据文件名查询其大小</span><br><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    // 根据文件名打开文件, 返回文件句柄和错误</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    // 如果打开时发生错误, 返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件状态信息</span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    // 如果获取信息时发生错误, 关闭文件并返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        f.Close()</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件大小</span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // 关闭文件</span><br><span class="line">    f.Close()</span><br><span class="line"></span><br><span class="line">    // 返回文件大小</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，定义获取文件大小的函数，返回值是 64 位的文件大小值。</li><li>第 5 行，使用 os 包提供的函数 Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。</li><li>第 8 行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为 0。</li><li>第 13 行，此时文件句柄 f 可以正常使用，使用 f 的方法 Stat() 来获取文件的信息，获取信息时，可能也会发生错误。</li><li>第 16～19 行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用 f 的 Close() 方法来关闭文件，否则会发生资源泄露。</li><li>第 22 行，获取文件大小。</li><li>第 25 行，关闭文件、释放资源。</li><li>第 28 行，返回获取到的文件大小。</li></ul><p>在上面的例子中，第 25 行是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 延迟调用Close, 此时Close不会被调用</span><br><span class="line">    defer f.Close()</span><br><span class="line"></span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        // defer机制触发, 调用Close关闭文件</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // defer机制触发, 调用Close关闭文件</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对比前面代码修改的部分，代码说明如下：</p><ul><li>第 10 行，在文件正常打开后，使用 defer，将 f.Close() 延迟调用，注意，不能将这一句代码放在第 4 行空行处，一旦文件打开错误，f 将为空，在延迟语句触发时，将触发宕机错误。</li><li>第 16 行和第 22 行，defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源。</li></ul><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>很对编程语言都支持递归函数，Go语言也不例外，所谓递归函数指的是在函数内部调用函数自身的函数，从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，如计算给定数字阶乘、产生斐波系列等。</p><p>构成递归需要具备以下条件：</p><ul><li>一个问题可以被拆分成多个子问题；</li><li>拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；</li><li>不能无限制的调用本身，子问题需要有退出递归状态的条件。</li></ul><p><strong><em>注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。</em></strong></p><p>下面通过几个示例来演示一下递归函数的使用。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>下面我们就以递归函数的经典示例 —— 斐波那契数列为例，演示如何通过Go语言编写的递归函数来打印斐波那契数列。</p><p>数列的形式如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, …</span><br></pre></td></tr></tbody></table></figure><p>使用Go语言递归函数实现斐波那契数列的具体代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("fibonacci(%d) is: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(1) is: 1</span><br><span class="line">fibonacci(2) is: 1</span><br><span class="line">fibonacci(3) is: 2</span><br><span class="line">fibonacci(4) is: 3</span><br><span class="line">fibonacci(5) is: 5</span><br><span class="line">fibonacci(6) is: 8</span><br><span class="line">fibonacci(7) is: 13</span><br><span class="line">fibonacci(8) is: 21</span><br><span class="line">fibonacci(9) is: 34</span><br><span class="line">fibonacci(10) is: 55</span><br></pre></td></tr></tbody></table></figure><h3 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a>数字阶乘</h3><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作 <code>n!</code> ，“基斯顿·卡曼”在 1808 年发明了 <code>n!</code> 这个运算符号。</p><p>例如，<code>n!=1×2×3×…×n</code> ，阶乘亦可以递归方式定义：<code>0!=1，n!=(n-1)!×n</code> 。</p><p>使用递归函数计算给定数的阶乘，示例代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func Factorial(n uint64) (result uint64) {</span><br><span class="line">    if n &gt; 0 {</span><br><span class="line">        result = n * Factorial(n-1)</span><br><span class="line">        return result</span><br><span class="line">    }</span><br><span class="line">    return 1</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var i int = 10</span><br><span class="line">    fmt.Printf("%d 的阶乘是 %d\n", i, Factorial(uint64(i)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 的阶乘是 3628800</span><br></pre></td></tr></tbody></table></figure><h3 id="多个函数组成递归"><a href="#多个函数组成递归" class="headerlink" title="多个函数组成递归"></a>多个函数组成递归</h3><p>Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%d is even: is %t\n", 16, even(16)) // 16 is even: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 17, odd(17))</span><br><span class="line">    // 17 is odd: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 18, odd(18))</span><br><span class="line">    // 18 is odd: is false</span><br><span class="line">}</span><br><span class="line">func even(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return odd(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func odd(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    return even(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func RevSign(nr int) int {</span><br><span class="line">    if nr &lt; 0 {</span><br><span class="line">        return -nr</span><br><span class="line">    }</span><br><span class="line">    return nr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行效果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 is even: is true</span><br><span class="line">17 is odd: is true</span><br><span class="line">18 is odd: is false</span><br></pre></td></tr></tbody></table></figure><h2 id="处理运行时错误"><a href="#处理运行时错误" class="headerlink" title="处理运行时错误"></a>处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p><ul><li>一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。</li><li>在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。</li></ul><p>Go语言没有类似 Java 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p><p>Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p><h3 id="net-包中的例子"><a href="#net-包中的例子" class="headerlink" title="net 包中的例子"></a>net 包中的例子</h3><p>net.Dial() 是Go语言系统包 net 即中的一个函数，一般用于创建一个 Socket 连接。</p><p>net.Dial 拥有两个返回值，即 Conn 和 error，这个函数是阻塞的，因此在 Socket 操作后，会返回 Conn 连接对象和 error，如果发生错误，error 会告知错误的类型，Conn 会返回空。</p><p>根据Go语言的错误处理机制，Conn 是其重要的返回值，因此，为这个函数增加一个错误返回，类似为 error，参见下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func Dial(network, address string) (Conn, error) {</span><br><span class="line">    var d Dialer</span><br><span class="line">    return d.Dial(network, address)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 io 包中的 Writer 接口也拥有错误返回，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>io 包中还有 Closer 接口，只有一个错误返回，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="错误接口的定义格式"><a href="#错误接口的定义格式" class="headerlink" title="错误接口的定义格式"></a>错误接口的定义格式</h3><p>error 是 Go 系统声明的接口类型，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误</p><h3 id="自定义一个错误"><a href="#自定义一个错误" class="headerlink" title="自定义一个错误"></a>自定义一个错误</h3><p>返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var err = errors.New("this is an error")</span><br></pre></td></tr></tbody></table></figure><p>错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。</p><h4 id="errors-包"><a href="#errors-包" class="headerlink" title="errors 包"></a>errors 包</h4><p>Go语言的 errors 中对 New 的定义非常简单，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建错误对象</span><br><span class="line">func New(text string) error {</span><br><span class="line">    return &amp;errorString{text}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 错误字符串</span><br><span class="line">type errorString struct {</span><br><span class="line">    s string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 返回发生何种错误</span><br><span class="line">func (e *errorString) Error() string {</span><br><span class="line">    return e.s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，将 errorString 结构体实例化，并赋值错误描述的成员。</li><li>第 7 行，声明 errorString 结构体，拥有一个成员，描述错误内容。</li><li>第 12 行，实现 error 接口的 Error() 方法，该方法返回成员中的错误描述。</li></ul><h4 id="在代码中使用错误定义"><a href="#在代码中使用错误定义" class="headerlink" title="在代码中使用错误定义"></a>在代码中使用错误定义</h4><p>下面的代码会定义一个除法函数，当除数为 0 时，返回一个预定义的除数为 0 的错误。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义除数为0的错误</span><br><span class="line">var errDivisionByZero = errors.New("division by zero")</span><br><span class="line"></span><br><span class="line">func div(dividend, divisor int) (int, error) {</span><br><span class="line"></span><br><span class="line">    // 判断除数为0的情况并返回</span><br><span class="line">    if divisor == 0 {</span><br><span class="line">        return 0, errDivisionByZero</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 正常计算，返回空错误</span><br><span class="line">    return dividend / divisor, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println(div(1, 0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 division by zero</span><br></pre></td></tr></tbody></table></figure><p>代码说明：</p><ul><li>第 9 行，预定义除数为 0 的错误。</li><li>第 11 行，声明除法函数，输入被除数和除数，返回商和错误。</li><li>第 14 行，在除法计算中，如果除数为 0，计算结果为无穷大，为了避免这种情况，对除数进行判断，并返回商为 0 和除数为 0 的错误对象。</li><li>第 19 行，进行正常的除法计算，没有发生错误时，错误对象返回 nil。</li></ul><h3 id="示例：在解析中使用自定义错误"><a href="#示例：在解析中使用自定义错误" class="headerlink" title="示例：在解析中使用自定义错误"></a>示例：在解析中使用自定义错误</h3><p>使用 errors.New 定义的错误字符串的错误类型是无法提供丰富的错误信息的，那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。</p><p>下面代码将实现一个解析错误（ParseError），这种错误包含两个内容，分别是文件名和行号，解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，就需要将文件名和行号返回。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个解析错误</span><br><span class="line">type ParseError struct {</span><br><span class="line">    Filename string // 文件名</span><br><span class="line">    Line     int    // 行号</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现error接口，返回错误描述</span><br><span class="line">func (e *ParseError) Error() string {</span><br><span class="line">    return fmt.Sprintf("%s:%d", e.Filename, e.Line)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一些解析错误</span><br><span class="line">func newParseError(filename string, line int) error {</span><br><span class="line">    return &amp;ParseError{filename, line}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var e error</span><br><span class="line">    // 创建一个错误实例，包含文件名和行号</span><br><span class="line">    e = newParseError("main.go", 1)</span><br><span class="line"></span><br><span class="line">    // 通过error接口查看错误描述</span><br><span class="line">    fmt.Println(e.Error())</span><br><span class="line"></span><br><span class="line">    // 根据错误接口具体的类型，获取详细错误信息</span><br><span class="line">    switch detail := e.(type) {</span><br><span class="line">    case *ParseError: // 这是一个解析错误</span><br><span class="line">        fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)</span><br><span class="line">    default: // 其他类型的错误</span><br><span class="line">        fmt.Println("other error")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go:1</span><br><span class="line">Filename: main.go Line: 1</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，声明了一个解析错误的结构体，解析错误包含有 2 个成员，分别是文件名和行号。</li><li>第 14 行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。</li><li>第 19 行，根据给定的文件名和行号创建一个错误实例。</li><li>第 25 行，声明一个错误接口类型。</li><li>第 27 行，创建一个实例，这个错误接口内部是 <code>*ParserError</code> 类型，携带有文件名 main.go 和行号 1。</li><li>第 30 行，调用 Error() 方法，通过第 15 行返回错误的详细信息。</li><li>第 33 行，通过错误断言，取出发生错误的详细类型。</li><li>第 34 行，通过分析这个错误的类型，得知错误类型为 <code>*ParserError</code> ，此时可以获取到详细的错误信息。</li><li>第 36 行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。</li></ul><p>错误对象都要实现 error 接口的 Error() 方法，这样，所有的错误都可以获得字符串的描述，如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。</p><h2 id="宕机（panic）——程序终止运行"><a href="#宕机（panic）——程序终止运行" class="headerlink" title="宕机（panic）——程序终止运行"></a>宕机（panic）——程序终止运行</h2><p>Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。</p><p>宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，宕机有时也是一种合理的止损方法。</p><p>一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。</p><p>对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。</p><p>虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。</p><h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。</p><p>Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    panic("crash")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码运行崩溃并输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: crash</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:4 +0x40</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure><p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func panic(v interface{})    //panic() 的参数可以是任意类型的。</span><br></pre></td></tr></tbody></table></figure><h3 id="在运行依赖的必备资源缺失时主动触发宕机"><a href="#在运行依赖的必备资源缺失时主动触发宕机" class="headerlink" title="在运行依赖的必备资源缺失时主动触发宕机"></a>在运行依赖的必备资源缺失时主动触发宕机</h3><p>regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。</p><p>编译正则表达式函数有两种，具体如下：</p><h4 id="func-Compile-expr-string-Regexp-error"><a href="#func-Compile-expr-string-Regexp-error" class="headerlink" title="func Compile(expr string) (*Regexp, error)"></a>func Compile(expr string) (*Regexp, error)</h4><p>编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。</p><h4 id="func-MustCompile-str-string-Regexp"><a href="#func-MustCompile-str-string-Regexp" class="headerlink" title="func MustCompile(str string) *Regexp"></a>func MustCompile(str string) *Regexp</h4><p>当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。</p><p>MustCompile 的代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func MustCompile(str string) *Regexp {</span><br><span class="line">    regexp, error := Compile(str)</span><br><span class="line">    if error != nil {</span><br><span class="line">        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())</span><br><span class="line">    }</span><br><span class="line">    return regexp</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。</li><li>第 2 行，Compile() 是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。</li><li>第 3 和第 4 行判断如果有错，则使用 panic() 触发宕机。</li><li>第 6 行，没有错误时返回正则表达式对象。</li></ul><p>手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。</p><h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，参考下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    defer fmt.Println("宕机后要做的事情1")</span><br><span class="line">    defer fmt.Println("宕机后要做的事情2")</span><br><span class="line">    panic("宕机")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">宕机后要做的事情2</span><br><span class="line">宕机后要做的事情1</span><br><span class="line">panic: 宕机</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:8 +0xf8</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure><p>对代码的说明：</p><ul><li>第 6 行和第 7 行使用 defer 语句延迟了 2 个语句。</li><li>第 8 行发生宕机。</li></ul><p>宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。</p><h2 id="宕机恢复（recover）——防止程序崩溃"><a href="#宕机恢复（recover）——防止程序崩溃" class="headerlink" title="宕机恢复（recover）——防止程序崩溃"></a>宕机恢复（recover）——防止程序崩溃</h2><p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p><p>通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p><p><strong><em>提示:在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。</em></strong></p><p>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。</p><h3 id="让程序在崩溃时继续执行"><a href="#让程序在崩溃时继续执行" class="headerlink" title="让程序在崩溃时继续执行"></a>让程序在崩溃时继续执行</h3><p>下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。</p><p>保护运行函数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 崩溃时需要传递的上下文信息</span><br><span class="line">type panicContext struct {</span><br><span class="line">    function string // 所在函数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 保护方式允许一个函数</span><br><span class="line">func ProtectRun(entry func()) {</span><br><span class="line"></span><br><span class="line">    // 延迟处理的函数</span><br><span class="line">    defer func() {</span><br><span class="line"></span><br><span class="line">        // 发生宕机时，获取panic传递的上下文并打印</span><br><span class="line">        err := recover()</span><br><span class="line"></span><br><span class="line">        switch err.(type) {</span><br><span class="line">        case runtime.Error: // 运行时错误</span><br><span class="line">            fmt.Println("runtime error:", err)</span><br><span class="line">        default: // 非运行时错误</span><br><span class="line">            fmt.Println("error:", err)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    entry()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("运行前")</span><br><span class="line"></span><br><span class="line">    // 允许一段手动触发的错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机前")</span><br><span class="line"></span><br><span class="line">        // 使用panic传递上下文</span><br><span class="line">        panic(&amp;panicContext{</span><br><span class="line">            "手动触发panic",</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 故意造成空指针访问错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机前")</span><br><span class="line"></span><br><span class="line">        var a *int</span><br><span class="line">        *a = 1</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Println("运行后")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行前</span><br><span class="line">手动宕机前</span><br><span class="line">error: &amp;{手动触发panic}</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">运行后</span><br></pre></td></tr></tbody></table></figure><p>对代码的说明：</p><ul><li>第 9 行声明描述错误的结构体，保存执行错误的函数。</li><li>第 17 行使用 defer 将闭包延迟执行，当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。</li><li>第 20 行，recover() 获取到 panic 传入的参数。</li><li>第 22 行，使用 switch 对 err 变量进行类型断言。</li><li>第 23 行，如果错误是有 Runtime 层抛出的运行时错误，如空指针访问、除数为 0 等情况，打印运行时错误。</li><li>第 25 行，其他错误，打印传递过来的错误数据。</li><li>第 44 行，使用 panic 手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover 就会获取到这个结构体信息，并打印出来。</li><li>第 57 行，模拟代码中空指针赋值造成的错误，此时会由 Runtime 层抛出错误，被 ProtectRun() 函数的 recover() 函数捕获到。</li></ul><h3 id="panic-和-recover-的关系"><a href="#panic-和-recover-的关系" class="headerlink" title="panic 和 recover 的关系"></a>panic 和 recover 的关系</h3><p>panic 和 recover 的组合有如下特性：</p><ul><li>有 panic 没 recover，程序宕机。</li><li>有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li></ul><p><strong><em>提示:虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。</em></strong></p><p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。</p><p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p><h2 id="计算函数执行时间"><a href="#计算函数执行时间" class="headerlink" title="计算函数执行时间"></a>计算函数执行时间</h2><p>函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，要得到函数的运行时间，最简单的办法就是在函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，这个时间间隔就是函数的运行时间。</p><p>在Go语言中我们可以使用 time 包中的 Since() 函数来获取函数的运行时间，Go语言官方文档中对 Since() 函数的介绍是这样的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Since(t Time) Duration</span><br></pre></td></tr></tbody></table></figure><p>Since() 函数返回从 t 到现在经过的时间，等价于 <code>time.Now().Sub(t)</code> 。</p><p>【示例】使用 Since() 函数获取函数的运行时间。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Since(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数执行完成耗时： 39.8933ms</span><br></pre></td></tr></tbody></table></figure><p>上面我们提到了 <code>time.Now().Sub()</code> 的功能类似于 Since() 函数，想要使用 <code>time.Now().Sub()</code> 获取函数的运行时间只需要把我们上面代码的第 14 行简单修改一下就行。</p><p>【示例 2】使用 time.Now().Sub() 获取函数的运行时间。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Now().Sub(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数执行完成耗时： 36.8769ms</span><br></pre></td></tr></tbody></table></figure><p>由于计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。</p><h2 id="通过内存缓存来提升性能"><a href="#通过内存缓存来提升性能" class="headerlink" title="通过内存缓存来提升性能"></a>通过内存缓存来提升性能</h2><p>前面我们介绍了递归函数，递归函数的缺点就是比较消耗内存，而且效率比较低，那么我们要怎样提高程序的执行效率呢？</p><p>当在进行大量计算的时候，提升性能最直接有效的一种方式是避免重复计算，通过在内存中缓存并重复利用缓存从而避免重复执行相同计算的方式称为内存缓存。</p><p>下面我们以经典的递归求斐波那契数列为例，来对比一下普通实现方法和加入内存缓存后程序的执行情况。</p><h3 id="普通的实现方法"><a href="#普通的实现方法" class="headerlink" title="普通的实现方法"></a>普通的实现方法</h3><p>普通方法的实现思路是，要计算数列中第 n 个数字，需要先得到它前面的两个数，以此类推。这么做的弊端是会产生大量的重复计算，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt;= 40; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 1.2324148s</span><br></pre></td></tr></tbody></table></figure><p>通过运行结果可以看出，获取第 40 位的数字所需要的时间是 1.2324148 秒（这个时间可能根据计算机性能的差异，略有不同）。</p><h3 id="内存缓存的实现方法"><a href="#内存缓存的实现方法" class="headerlink" title="内存缓存的实现方法"></a>内存缓存的实现方法</h3><p>内存缓存的实现思路是在计算得到第 n 个数的同时，将它的值保存到数组中索引为 n 的位置上，在后续的计算中先在数组中查找所需要的值是否计算过，如果找到了，则直接从数组中获取，如果没找到，则再进行计算，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const LIM = 41</span><br><span class="line"></span><br><span class="line">var fibs [LIM]uint64</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var result uint64 = 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt; LIM; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res uint64) {</span><br><span class="line">    // 记忆化：检查数组中是否已知斐波那契（n）</span><br><span class="line">    if fibs[n] != 0 {</span><br><span class="line">        res = fibs[n]</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 12.0316ms</span><br></pre></td></tr></tbody></table></figure><p>通过运行结果可以看出，同样获取数列第 40 位的数字，使用内存缓存后所用的时间为 12.0316 毫秒，对比之前未使用内存缓存时的执行效率，可见内存缓存的优势还是相当明显的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>Go语言中提供了MD5、SHA-1等几种哈希函数，下面我们用例子做一个介绍，代码如下所示</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestString := "Hi,pandaman!"</span><br><span class="line">    Md5Inst := md5.New()</span><br><span class="line">    Md5Inst.Write( []byte(TestString))</span><br><span class="line">    Result := Md5Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">    Sha1Inst := sha1.New()</span><br><span class="line">    Sha1Inst.Write([]byte(TestString))</span><br><span class="line">    Result = Sha1Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个程序的执行结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">70af690adf124b2e828b4d8904ad142a</span><br><span class="line">49d37c25ef2a62b4cfcf3689c649510390e14875</span><br></pre></td></tr></tbody></table></figure><p>再举一个例子，对文件内容计算SHA1，具体代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestFile := "goPstrAnalysis.go"</span><br><span class="line">    infile , inerr := os.Open(TestFile)</span><br><span class="line">    if inerr == nil {</span><br><span class="line">        md5h := md5.New()</span><br><span class="line">        io.Copy( md5h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n" , md5h.Sum([]byte("")),TestFile)</span><br><span class="line">        sha1h := sha1.New()</span><br><span class="line">        io.Copy( sha1h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n",sha1h.Sum([]byte("")),TestFile)</span><br><span class="line">    }else{</span><br><span class="line">        fmt.Println(inerr)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">7350776e62ab13bc1a8be3812ba32211 goPstrAnalysis.go</span><br><span class="line">da39a3ee5e6b4b0d3255bfef95601890afd80709 goPstrAnalysis.go</span><br></pre></td></tr></tbody></table></figure><h2 id="函数的底层实现"><a href="#函数的底层实现" class="headerlink" title="函数的底层实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4784.html">函数的底层实现</a></h2><p>基于堆栈式的程序执行模型决定了函数是语言的一个核心元素，分析Go语言函数的底层实现，对理解整个程序的执行过程有很大的帮助，研究底层实现有两种办法，一种是看语言编译器源码，分析其对函数的各个特性的处理逻辑，另一种是反汇编，将可执行程序反汇编出来。</p><p>本节使用反汇编这种短、平、快的方法，首先介绍Go语言的函数调用规约，接着介绍Go语言使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/asm/">汇编语言</a>的基本概念，然后通过反汇编技术来剖析Go语言函数某些特性的底层实现。</p><h3 id="函数调用规约"><a href="#函数调用规约" class="headerlink" title="函数调用规约"></a>函数调用规约</h3><p>Go语言函数使用的是 caller-save 的模式，即由调用者负责保存寄存器，所以在函数的头尾不会出现 <code>push ebp; mov esp ebp</code> 这样的代码，相反其是在主调函数调用被调函数的前后有一个保存现场和恢复现场的动作。</p><p>主调函数保存和恢复现场的通用逻辑如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//开辟栈空间，压栈 BP 保存现场</span><br><span class="line">    SUBQ $x, SP    //为函数开辟裁空间</span><br><span class="line">    MOVQ BP, y(SP) //保存当前函数 BP 到 y(SP）位置， y 为相对 SP 的偏移量</span><br><span class="line">    LEAQ y(SP), BP //重直 BP，使其指向刚刚保存 BP 旧值的位置，这里主要</span><br><span class="line">                   //是方便后续 BP 的恢复</span><br><span class="line">//弹出栈，恢复 BP</span><br><span class="line">    MOVQ y(SP), BP //恢复 BP 的值为调用前的值</span><br><span class="line">    ADDQ $x, SP    //恢复 SP 的值为函数开始时的位</span><br></pre></td></tr></tbody></table></figure><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><p>Go 编译器产生的汇编代码是一种中间抽象态，它不是对机器码的映射，而是和平台无关的一个中间态汇编描述，所以汇编代码中有些寄存器是真实的，有些是抽象的，几个抽象的寄存器如下：</p><ul><li>SB (Static base pointer)：静态基址寄存器，它和全局符号一起表示全局变量的地址。</li><li>FP (Frame pointer)：栈帧寄存器，该寄存器指向当前函数调用栈帧的栈底位置。</li><li>PC (Program counter)：程序计数器，存放下一条指令的执行地址，很少直接操作该寄存器，一般是 CALL、RET 等指令隐式的操作。</li><li>SP (Stack pointer)：栈顶寄存器，一般在函数调用前由主调函数设置 SP 的值对栈空间进行分配或回收。</li></ul><h4 id="Go-汇编简介"><a href="#Go-汇编简介" class="headerlink" title="Go 汇编简介"></a>Go 汇编简介</h4><p>1) Go 汇编器采用 AT&amp;T 风格的汇编，早期的实现来自 plan9 汇编器，源操作数在前，目的操作数在后。</p><p>2) Go 内嵌汇编和反汇编产生的代码并不是一一对应的，汇编编译器对内嵌汇编程序自动做了调整，主要差别就是增加了保护现场，以及函数调用前的保持 PC 、SP 偏移地址重定位等逻辑，反汇编代码更能反映程序的真实执行逻辑。</p><p>3) Go 的汇编代码并不是和具体硬件体系结构的机器码一一对应的，而是一种半抽象的描述，寄存器可能是抽象的，也可能是具体的。</p><p>下面代码的分析基于 AMD64 位架构下的 Linux 环境。</p><h3 id="多值返回分析"><a href="#多值返回分析" class="headerlink" title="多值返回分析"></a>多值返回分析</h3><p>多值返回函数 swap 的源码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func swap (a, b int) (x int, y int) {</span><br><span class="line">    x = b</span><br><span class="line">    y = a</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    swap(10, 20)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译生成汇编如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//- S 产生汇编的代码</span><br><span class="line">//- N 禁用优化</span><br><span class="line">//- 1 禁用内联</span><br><span class="line"></span><br><span class="line">GOOS=linux GOARCH=amd64 go tool compile -1 -N -S swap.go &gt;swap.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure><p>汇编代码分析:</p><p>1) swap 函数和 main 函数汇编代码分析。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">"".swap STEXT nosplit size=39 args=0x20 locals=0x0</span><br><span class="line">    0x0000 00000 (swap.go:4) TEXT  "".swap(SB), NOSPLIT, $0 - 32</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $0, gclocals.ff19ed39bdde8a01a800918ac3ef0ec7(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $1, gclocals.33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4)  MOVQ  $0, "".x+24(SP)</span><br><span class="line">    0x0009 00009 (swap.go:4)  MOVQ  $0, "".y+32(SP)</span><br><span class="line">    0x0012 00018 (swap.go:5)  MOVQ  "".b+16(SP), AX</span><br><span class="line">    0x0017 00023 (swap.go:5)  MOVQ  AX, "".x+24(SP)</span><br><span class="line">    0xOO1c 00028 (swap.go:6)  MOVQ  "".a+8(SP), AX</span><br><span class="line">    0x0021 00033 (swap.go:6)  MOVQ  AX, "".y+32(SP)</span><br><span class="line">    0x0026 00038 (swap.go:7)  RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"".main STEXT size=68 args=0x0 locals=0x28</span><br><span class="line">    0x0000 00000 (swap.go:10) TEXT "".main(SB), $40 - 0</span><br><span class="line">    0x0000 00000 (swap.go:10) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (swap.go:10) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (swap.go:10) JLS 61</span><br><span class="line">    0x000f 00015 (swap.go:10) SUBQ $40, SP</span><br><span class="line">    0x0013 00019 (swap.go:10) MOVQ BP, 32 (SP)</span><br><span class="line">    0x0018 00024 (swap.go:10) LEAQ 32(SP), BP</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $0, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $1, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:11) MOVQ $10, (SP)</span><br><span class="line">    0x0025 00037 (swap.go:11) MOVQ $20 , 8 (SP)</span><br><span class="line">    0x002e 00046 (swap.go:11) PCDATA $0 , $0</span><br><span class="line">    0x002e 00046 (swap.go:11) CALL "". swap(SB)</span><br><span class="line">    0x0033 00051 (swap.go:12) MOVQ 32(SP), BP</span><br><span class="line">    0x0038 00056 (swap.go:12) ADDQ $40, SP</span><br><span class="line">    0x003c 00060 (swap.go:12) RET</span><br><span class="line">    0x003d 00061 (swap.go:12) NOP</span><br><span class="line">    0x003d 00061 (swap.go:10) PCDATA $0, $ - 1</span><br></pre></td></tr></tbody></table></figure><ul><li>第 5 行初始化返回值 x 为 0。</li><li>第 6 行初始化返回值 y 为 0。</li><li>第 7～8 行取第 2 个参数赋值给返回值 x。</li><li>第 9～10 行取第 1 个参数赋值给返回值 y。</li><li>第 11 行函数返回，同时进行栈回收，FUNCDATA 和垃圾收集可以忽略。</li><li>第 15～24 行 main 函数堆栈初始化：开辟栈空间，保存 BP 寄存器。</li><li>第 25 行初始化 add 函数的调用参数 1 的值为 10。</li><li>第 26 行初始化 add 函数的调用参数 2 的值为 20。</li><li>第 28 行调用 swap 函数，注意 call 隐含一个将 swap 下一条指令地址压栈的动作，即 sp=sp+8。</li><li>所以可以看到在 swap 里面的所有变量的相对位置都发生了变化，都在原来的地址上 ＋8。</li><li>第 29～30 行恢复栈空间。</li></ul><p>从汇编的代码得知：</p><ul><li>函数的调用者负责环境准备，包括为参数和返回值开辟栈空间。</li><li>寄存器的保存和恢复也由调用方负责。</li><li>函数调用后回收栈空间，恢复 BP 也由主调函数负责。</li></ul><p>函数的多值返回实质上是在栈上开辟多个地址分别存放返回值，这个并没有什么特别的地方，如果返回值是存放到堆上的，则多了一个复制的动作。</p><p>main 调用 swap 函数栈的结构如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gofuncstack.gif" alt="图：Go函数栈"></p><p>函数调用前己经为返回值和参数分配了栈空间，分配顺序是从右向左的，先是返回值，然后是参数，通用的栈模型如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">＋----------＋</span><br><span class="line"> | 返回值 y   |</span><br><span class="line"> |------------|</span><br><span class="line"> | 返回值 x   |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 b    |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 a    |</span><br><span class="line">＋----------＋</span><br></pre></td></tr></tbody></table></figure><p>函数的多返回值是主调函数预先分配好空间来存放返回值，被调函数执行时将返回值复制到该返回位置来实现的。</p><h3 id="闭包底层实现"><a href="#闭包底层实现" class="headerlink" title="闭包底层实现"></a>闭包底层实现</h3><p>下面通过汇编和源码对照的方式看一下 Go 闭包的内部实现。</p><p>程序源码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">//函数返回引用了外部变量 i 的闭包</span><br><span class="line">func a(i int) func () {</span><br><span class="line">    return func() {</span><br><span class="line">        print(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f := a (1)</span><br><span class="line">    f ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译汇编如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S c2_7_4a.go &gt;c2_7_4a.s 2&amp;1</span><br></pre></td></tr></tbody></table></figure><p>关键汇编代码及分析如下：</p><p>函数 a 和函数 main 对应的汇编代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"".a STEXT size=91 args=0x10 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) TEXT "".a(SB), $24-16</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:3) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:3) JLS 84</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:3) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:3) MOVQ BP , 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:3) LEAQ 16(SP), BP</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $0, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb (SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:4) LEAQ type.noalg.struct{ F uintptr; "".i int}(SB), AX</span><br><span class="line">    0x0024 00036 (c2_7_4a.go:4) MOVQ AX, (SP)</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) PCDATA $0, $0</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) CALL runtime.newobject(SB)</span><br><span class="line">    0x002d 00045 (c2_7_4a.go:4) MOVQ 8(SP), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:4) LEAQ "".a.funcl(SB), CX</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:4) MOVQ CX, (AX)</span><br><span class="line">    0x003c 00060 (c2_7_4a.go:3) MOVQ "".i+32(SP), CX</span><br><span class="line">    0x0041 00065 (c2_7_4a.go:4) MOVQ CX, 8(AX)</span><br><span class="line">    0x0045 00069 (c2_7_4a.go:4) MOVQ AX, "".~r1+40(SP)</span><br><span class="line">    0x004a 00074 (c2_7_4a.go:4) MOVQ 16(SP), BP</span><br><span class="line">    0x004f 00079 (c2_7_4a.go:4) ADDQ $24, SP</span><br><span class="line">"".main STEXT size=69 args=0x0 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) TEXT "".main(SB), $24-0</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:9) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:9) JLS 62</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:9) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:9) MOVQ BP, 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:9) LEAQ 16(SP), BP</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $0, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:10) MOVQ $1, (SP)</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) PCDATA $0, $0</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) CALL "".a(SB)</span><br><span class="line">    0x002a 00042 (c2_7_4a.go:10) MOVQ 8(SP), DX</span><br><span class="line">    0x002f 00047 (c2_7_4a.go:11) MOVQ (DX), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) PCDATA $0, $0</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) CALL AX</span><br><span class="line">    0x0034 00052 (c2_7_4a.go:15) MOVQ 16(SP), BP</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:15) ADDQ $24, SP</span><br><span class="line">    0x003d 00061 (c2_7_4a.go:15) RET</span><br></pre></td></tr></tbody></table></figure><h4 id="func-a-函数分析"><a href="#func-a-函数分析" class="headerlink" title="func a() 函数分析"></a>func a() 函数分析</h4><ul><li>第 1～10 行环境准备。</li><li>第 11 行这里我们看到 <code>type.noalg.struct { F uintptr; "".i int }(SB)</code> 这个符号是一个闭包类型的数据，闭包类型的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>如下：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    i int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>闭包的结构很简单，一个是函数指针，另一个是对外部环境的引用。注意，这里仅仅是打印 i，并没有修改 i，Go语言编译器并没有传递地址而是传递值。</p><ul><li>第 11 行将闭包类型元信息放到 (SP) 位置，(SP) 地址存放的是 CALL 函数调用的第一个参数。</li><li><p>第 14 行创建闭包对象，我们来看一下 runtime.newobject 的函数原型，该函数的输入参数是一个类型信息，返回值是根据该类型信息构造出来的对象地址。</p>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/malloc.go</span><br><span class="line">func newobject(typ *_type) unsafe.Pointer</span><br></pre></td></tr></tbody></table></figure></li><li><p>第 15 行将 newobject 返回的对象地址复制给 AX 寄存器。</p></li><li>第 16 行将 a 函数里面的匿名函数 a.func 指针复制到 CX 寄存器。</li><li>第 17 行将 CX 寄存器中存放的 a.func 函数指针复制到闭包对象的函数指针位置。</li><li>第 18、19 行将外部闭包变量 i 的值复制到闭包对象的 i 处。</li><li>第 20 行复制闭包对象指针值到函数返回值位置 <code>"".～r1+40(SP)</code>。</li></ul><h4 id="main-函数分析"><a href="#main-函数分析" class="headerlink" title="main() 函数分析"></a>main() 函数分析</h4><ul><li>第 23～32 行准备环境。</li><li>第 33 行将立即数 1 复制到 (SP) 位置，为后续的 CALL 指令准备参数。</li><li>第 35 行调用函数 a()。</li><li>第 36 行复制函数返回值到 DX 寄存器。</li><li>第 37 行间接寻址，复制闭包对象中的函数指针到 AX 寄存器。</li><li>第 39 行调用 AX 寄存器指向的函数。</li><li>第 40～42 行恢复环境，并返回。</li></ul><p>通过汇编代码的分析，我们清楚地看到 Go 实现闭包是通过返回一个如下的结构来实现的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    env *Type</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>F 是返回的匿名函数指针，env 是对外部环境变量的引用集合，如果闭包内没有修改外部变量，则 Go 编译器直接优化为值传递，如上面的例子中的代码所示，反之则是通过指针传递的。</p><h2 id="Test功能测试函数详解"><a href="#Test功能测试函数详解" class="headerlink" title="Test功能测试函数详解"></a>Test功能测试函数详解</h2><p>Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。</p><h3 id="为什么需要测试"><a href="#为什么需要测试" class="headerlink" title="为什么需要测试"></a>为什么需要测试</h3><p>完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少 bug，有两种有效的方式分别是代码审核和测试，Go语言中提供了 testing 包来实现单元测试功能。</p><h3 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h3><p>要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以 <code>_test.go</code> 结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TestXxx( t *testing.T ){</span><br><span class="line">    //......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写测试用例有以下几点需要注意：</p><ul><li>测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；</li><li>测试用例的文件名必须以_test.go结尾；</li><li>需要使用 import 导入 testing 包；</li><li>测试函数的名称要以Test或Benchmark开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li><li>单元测试则以 <code>(t *testing.T)</code> 作为参数，性能测试以 <code>(t *testing.B)</code> 做为参数；</li><li>测试用例文件使用 <code>go test</code> 命令来执行，源码中不需要 <code>main()</code> 函数作为入口，所有以 <code>_test.go</code> 结尾的源码文件内以 <code>Test</code> 开头的函数都会自动执行。</li></ul><p>Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。</p><h3 id="单元（功能）测试"><a href="#单元（功能）测试" class="headerlink" title="单元（功能）测试"></a>单元（功能）测试</h3><p>在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">// 根据长宽获取面积</span><br><span class="line">func GetArea(weight int, height int) int {</span><br><span class="line">    return weight * height</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行测试命令，运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -v</span><br><span class="line">=== RUN   TestGetArea</span><br><span class="line">--- PASS: TestGetArea (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.535s</span><br></pre></td></tr></tbody></table></figure><h3 id="性能（压力）测试"><a href="#性能（压力）测试" class="headerlink" title="性能（压力）测试"></a>性能（压力）测试</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -bench="."</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/dubbogo/dubbo-go-proxy/com/chebada</span><br><span class="line">BenchmarkGetArea-4      1000000000</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   1.217s</span><br></pre></td></tr></tbody></table></figure><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。</p><p>将 demo_test.go 代码改造成如下所示的样子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行测试命令，运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 14.3% of statements</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.517s</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go流程控制</title>
      <link href="posts/91175219/"/>
      <url>posts/91175219/</url>
      
        <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><p>Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。另外，还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号{}括起来的代码块，否则就忽略该代码块继续执行后续的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">} else {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果存在第三个分支，则可以使用下面这种三个独立分支的形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 {</span><br><span class="line">    // do something</span><br><span class="line">} else if condition2 {</span><br><span class="line">    // do something else</span><br><span class="line">}else {</span><br><span class="line">    // catch-all or default</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。</p><p>关键字 if 和 else 之后的左大括号 <code>{</code> 必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号 <code>}</code> 必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p><p>非法的 Go 代码:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x{</span><br><span class="line">}</span><br><span class="line">else { // 无效的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号 <code>}</code> 与对应的 if 关键字垂直对齐。</p><p>在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过下面的例子来了解 if 的写法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ten int = 11</span><br><span class="line">if ten &gt; 10 {</span><br><span class="line">    fmt.Println("&gt;10")</span><br><span class="line">} else {</span><br><span class="line">    fmt.Println("&lt;=10")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，声明整型变量并赋值 11。</li><li>第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。</li><li>第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。</li></ul><h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := Connect(); err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p><p>err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p><p>这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</p><p><strong><em>提示:在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</em></strong></p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for (循环结构)"></a>for (循环结构)</h2><p>与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 C++ 中非常接近：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    sum += i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号()括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 <code>for(;;){}</code> 和 <code>do{} while(1);</code> ，而直接简化为如下的写法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for {</span><br><span class="line">    sum++</span><br><span class="line">    if sum &gt; 100 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用循环语句时，需要注意的有以下几点：</p><ul><li>左花括号 <code>{</code> 必须与 for 处于同一行。</li><li>Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li><li>Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ {</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        if i &gt; 5 {</span><br><span class="line">            break JLoop</span><br><span class="line">        }</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">JLoop:</span><br><span class="line">// ...</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，break 语句终止的是 JLoop 标签处的外层循环。</p><h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。</p><p>初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step := 2</span><br><span class="line">for ; step &gt; 0; step-- {</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p><h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。</p><h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><p>下面代码忽略条件表达式，但是保留结束语句，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for ; ; i++ {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。</li><li>第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。</li></ul><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>上面的代码还可以改写为更美观的写法，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。</li><li>第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。</li></ul><p>无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。</p><h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><p>在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for i &lt;= 10 {</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在代码第 3 行中，将之前使用 <code>if i&gt;10{}</code> 判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。</p><p>上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p><h3 id="输出九九乘法表"><a href="#输出九九乘法表" class="headerlink" title="输出九九乘法表"></a>输出九九乘法表</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 遍历, 决定处理第几行</span><br><span class="line">    for y := 1; y &lt;= 9; y++ {</span><br><span class="line"></span><br><span class="line">        // 遍历, 决定这一行有多少列</span><br><span class="line">        for x := 1; x &lt;= y; x++ {</span><br><span class="line">            fmt.Printf("%d*%d=%d ", x, y, x*y)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 手动生成回车</span><br><span class="line">        fmt.Println()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2 2*2=4</span><br><span class="line">1*3=3 2*3=6 3*3=9</span><br><span class="line">1*4=4 2*4=8 3*4=12 4*4=16</span><br><span class="line">1*5=5 2*5=10 3*5=15 4*5=20 5*5=25</span><br><span class="line">1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36</span><br><span class="line">1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49</span><br><span class="line">1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64</span><br><span class="line">1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，生成 1～9 的数字，对应乘法表的每一行，也就是被乘数。</li><li>第 11 行，乘法表每一行中的列数随着行数的增加而增加，这一行的 x 表示该行有多少列。</li><li>第 16 行，打印一个空行，实际作用就是换行。</li></ul><p>这段程序按行优先打印，打印完一行，换行（第 16 行），接着执行下一行乘法表直到整个数值循环完毕。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, val := range coll {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for pos, char := range str {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每个 rune 字符和索引在 for range 循环中是一一对应的，它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。</p><p>通过 for range 遍历的返回值有一定的规律：</p><ul><li>数组、切片、字符串返回索引和值。</li><li>map 返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ul><h3 id="遍历数组、切片——获得索引和值"><a href="#遍历数组、切片——获得索引和值" class="headerlink" title="遍历数组、切片——获得索引和值"></a>遍历数组、切片——获得索引和值</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d  value:%d\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key:0  value:1</span><br><span class="line">key:1  value:2</span><br><span class="line">key:2  value:3</span><br><span class="line">key:3  value:4</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历字符串——获得字符"><a href="#遍历字符串——获得字符" class="headerlink" title="遍历字符串——获得字符"></a>遍历字符串——获得字符</h3><p>Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。</p><p>下面这段代码展示了如何遍历字符串：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = "hello 你好"</span><br><span class="line">for key, value := range str {</span><br><span class="line">    fmt.Printf("key:%d value:0x%x\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key:0 value:0x68</span><br><span class="line">key:1 value:0x65</span><br><span class="line">key:2 value:0x6c</span><br><span class="line">key:3 value:0x6c</span><br><span class="line">key:4 value:0x6f</span><br><span class="line">key:5 value:0x20</span><br><span class="line">key:6 value:0x4f60</span><br><span class="line">key:9 value:0x597d</span><br></pre></td></tr></tbody></table></figure><p>代码中的变量 value，实际类型是 rune 类型，以十六进制打印出来就是字符的编码。</p><h3 id="遍历-map——获得-map-的键和值"><a href="#遍历-map——获得-map-的键和值" class="headerlink" title="遍历 map——获得 map 的键和值"></a>遍历 map——获得 map 的键和值</h3><p>对于 map 类型来说，for range 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们是一对一对出现的，下面的代码演示了如何遍历 map。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for key, value := range m {</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello 100</span><br><span class="line">world 200</span><br></pre></td></tr></tbody></table></figure><p><strong><em>注意：对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</em></strong></p><h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p>for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。</p><p>下面代码为我们展示了通道的遍历：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    c &lt;- 1</span><br><span class="line">    c &lt;- 2</span><br><span class="line">    c &lt;- 3</span><br><span class="line">    close(c)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">for v := range c {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行创建了一个整型类型的通道。</li><li>第 3 行启动了一个 goroutine，其逻辑的实现体现在第 5～8 行，实现功能是往通道中推送数据 1、2、3，然后结束并关闭通道。</li><li>这段 goroutine 在声明结束后，在第 9 行马上被执行。</li><li>从第 11 行开始，使用 for range 对通道 c 进行遍历，其实就是不断地从通道中取数据，直到通道被关闭。</li></ul><h3 id="在遍历中选择希望获得的变量"><a href="#在遍历中选择希望获得的变量" class="headerlink" title="在遍历中选择希望获得的变量"></a>在遍历中选择希望获得的变量</h3><p>在使用 for range 循环遍历某个对象时，一般不会同时需要 key 或者 value，这个时候可以采用一些技巧，让代码变得更简单，下面将前面的例子修改一下，参考下面的代码示例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, value := range m {</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中将 key 变成了下划线 <code>_</code> ，这里的下划线就是匿名变量。</p><ul><li>可以理解为一种占位符。</li><li>匿名变量本身不会进行空间分配，也不会占用一个变量的名字。</li><li>在 for range 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li></ul><p>再看一个匿名变量的例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, _ := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d \n", key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key:0</span><br><span class="line">key:1</span><br><span class="line">key:2</span><br><span class="line">key:3</span><br></pre></td></tr></tbody></table></figure><p>在该例子中，value 被设置为匿名变量，只使用 key，而 key 本身就是切片的索引，所以例子输出索引。</p><p>我们总结一下 for 的功能：</p><ul><li>Go语言的 for 包含初始化语句、条件表达式、结束语句，这 3 个部分均可缺省。</li><li>for range 支持对数组、切片、字符串、map、通道进行遍历操作。</li><li>在需要时，可以使用匿名变量对 for range 的变量进行选取。</li></ul><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p><p>相对于C语言和 Java 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = "hello"</span><br><span class="line">switch a {</span><br><span class="line">case "hello":</span><br><span class="line">    fmt.Println(1)</span><br><span class="line">case "world":</span><br><span class="line">    fmt.Println(2)</span><br><span class="line">default:</span><br><span class="line">    fmt.Println(0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure><p>上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。</p><h4 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h4><p>当出现多个 case 要放在一起的时候，可以写成下面这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = "mum"</span><br><span class="line">switch a {</span><br><span class="line">case "mum", "daddy":</span><br><span class="line">    fmt.Println("family")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不同的 case 表达式使用逗号分隔。</p><h4 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h4><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r int = 11</span><br><span class="line">switch {</span><br><span class="line">case r &gt; 10 &amp;&amp; r &lt; 20:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，这种情况的 switch 后面不再需要跟判断变量。</p><h3 id="跨越-case-的-fallthrough——兼容C语言的-case-设计"><a href="#跨越-case-的-fallthrough——兼容C语言的-case-设计" class="headerlink" title="跨越 case 的 fallthrough——兼容C语言的 case 设计"></a>跨越 case 的 fallthrough——兼容C语言的 case 设计</h3><p>在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = "hello"</span><br><span class="line">switch {</span><br><span class="line">case s == "hello":</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">    fallthrough</span><br><span class="line">case s != "world":</span><br><span class="line">    fmt.Println("world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure><p>新编写的代码，不建议使用 fallthrough。</p><h2 id="goto语句——跳转到指定的标签"><a href="#goto语句——跳转到指定的标签" class="headerlink" title="goto语句——跳转到指定的标签"></a>goto语句——跳转到指定的标签</h2><p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p><h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var breakAgain bool</span><br><span class="line"></span><br><span class="line">    // 外循环</span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        // 内循环</span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            // 满足某个条件时, 退出循环</span><br><span class="line">            if y == 2 {</span><br><span class="line"></span><br><span class="line">                // 设置退出标记</span><br><span class="line">                breakAgain = true</span><br><span class="line"></span><br><span class="line">                // 退出本次循环</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 根据标记, 还需要退出一次循环</span><br><span class="line">        if breakAgain {</span><br><span class="line">                break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 10 行，构建外循环。</li><li>第 13 行，构建内循环。</li><li>第 16 行，当 y==2 时需要退出所有的 for 循环。</li><li>第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。</li><li>第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。</li><li>第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。</li><li>第 34 行，退出所有循环后，打印 done。</li></ul><p>将上面的代码使用Go语言的 goto 语句进行优化：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            if y == 2 {</span><br><span class="line">                // 跳转到标签</span><br><span class="line">                goto breakHere</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 手动返回, 避免执行进入标签</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">    // 标签</span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。</li><li>第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。</li><li>第 23 行，定义 breakHere 标签。</li></ul><p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p><h3 id="使用-goto-集中处理错误"><a href="#使用-goto-集中处理错误" class="headerlink" title="使用 goto 集中处理错误"></a>使用 goto 集中处理错误</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = secondCheckError()</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println("done")</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，执行某逻辑，返回错误。</li><li>第 2～6 行，如果发生错误，打印错误退出进程。</li><li>第 8 行，执行某逻辑，返回错误。</li><li>第 10～14 行，发生错误后退出流程。</li><li>第 16 行，没有任何错误，打印完成。</li></ul><p>在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。</p><p>使用 goto 语句来实现同样的逻辑：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> err := firstCheckError()</span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = secondCheckError()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。</li><li>第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。</li></ul><h2 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h2><p>Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。</p><p>跳出指定循环：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            case 3:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 7 行，外层循环的标签。</li><li>第 8 行和第 9 行，双层循环。</li><li>第 10 行，使用 switch 进行数值分支判断。</li><li>第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。</li></ul><h2 id="continue（继续下一次循环）"><a href="#continue（继续下一次循环）" class="headerlink" title="continue（继续下一次循环）"></a>continue（继续下一次循环）</h2><p>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line"></span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure><p>代码说明：</p><ul><li>第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。</li></ul><h3 id="示例：聊天机器人"><a href="#示例：聊天机器人" class="headerlink" title="示例：聊天机器人"></a>示例：聊天机器人</h3><p>结合咱们之前的学习，本节带领大家来编写一个聊天机器人的雏形，下面的代码中展示了一个简单的聊天程序。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 准备从标准输入读取数据。</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println("Please input your name:")</span><br><span class="line">    // 读取数据直到碰到 \n 为止。</span><br><span class="line">    input, err := inputReader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">        // 异常退出。</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    } else {</span><br><span class="line">        // 用切片操作删除最后的 \n 。</span><br><span class="line">        name := input[:len(input)-2]</span><br><span class="line">        fmt.Printf("Hello, %s! What can I do for you?\n", name)</span><br><span class="line">    }</span><br><span class="line">    for {</span><br><span class="line">        input, err = inputReader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        input = input[:len(input)-2]</span><br><span class="line">        // 全部转换为小写。</span><br><span class="line">        input = strings.ToLower(input)</span><br><span class="line">        switch input {</span><br><span class="line">        case "":</span><br><span class="line">            continue</span><br><span class="line">        case "nothing", "bye":</span><br><span class="line">            fmt.Println("Bye!")</span><br><span class="line">            // 正常退出。</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println("Sorry, I didn't catch you.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个聊天程序在问候用户之后会不断地询问“是否可以帮忙”，但是实际上它什么忙也帮不上，因为它现在什么也听不懂，除了 nothing 和 bye，一看到这两个词，它就会与用户“道别”，停止运行，现在试运行一下这个命令源码文件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Please input your name:</span><br><span class="line">Robert</span><br><span class="line">Hello, Robert! What can I do for you?</span><br><span class="line">A piece of cake , please .</span><br><span class="line">Sorry, I didn't catch you.</span><br><span class="line">bye</span><br><span class="line">Bye!</span><br></pre></td></tr></tbody></table></figure><p>注意，其中的“-&gt;”符号之后的内容是我们输入的。</p><h3 id="示例：词频统计"><a href="#示例：词频统计" class="headerlink" title="示例：词频统计"></a>示例：词频统计</h3><p>从数据挖掘到语言学习本身，文本分析功能的应用非常广泛，本一节我们来分析一个例子，它是文本分析最基本的一种形式：统计出一个文件里单词出现的频率。</p><p>示例中频率统计后的结果以两种不同的方式显示，一种是将单词按照字母顺序把单词和频率排列出来，另一种是按照有序列表的方式把频率和对应的单词显示出来，完整的示例代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">    "unicode"</span><br><span class="line">    "unicode/utf8"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader,</span><br><span class="line">    frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax ||</span><br><span class="line">                utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序的运行结果如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">go run .\main.go small-file.txt</span><br><span class="line">Word       Frequency</span><br><span class="line">ability                     1</span><br><span class="line">about                     1</span><br><span class="line">above                     3</span><br><span class="line">years                      1</span><br><span class="line">you                    128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Frequency → Words</span><br><span class="line">    1 ability, about, absence, absolute, absolutely, abuse, accessible, ...</span><br><span class="line">    2 accept, acquired, after, against, applies, arrange, assumptions, ...</span><br><span class="line">...</span><br><span class="line">128    you</span><br><span class="line">151    or</span><br><span class="line">192    to</span><br><span class="line">221    of</span><br><span class="line">345    the</span><br></pre></td></tr></tbody></table></figure><p>其中，small-file.txt 为待统计的文件名，它不是固定的，可以根据实际情况自行调整。由于输出的结果太多，所以上面只截取了部分内容。</p><p>通过上面的输出结果可以看出，第一种输出是比较直接的，我们可以使用一个map[string]int类型的结构来保存每一个单词的频率，但是要得到第二种输出结果我们需要将整个映射反转成多值类型的映射，如map[int][]string，也就是说，键是频率而值则是所有具有这个频率的单词。</p><p>接下来我们将从程序的 main() 函数开始，从上到下分析。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main() 函数首先分析命令行参数，之后再进行相应处理。</p><p>我们使用复合语法创建一个空的映射，用来保存从文件读到的每一个单词和对应的频率，接着我们遍历从命令行得到的每一个文件，分析每一个文件后更新 frequencyForWord 的数据。</p><p>得到第一个映射之后，我们就可以输出第一个报告了（按照字母顺序排列的列表），然后我们创建一个反转的映射，输出第二个报告（按出现频率统计并排序的列表）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为 Unix 类系统（如 Linux 或 Mac OS X 等）的命令行工具默认会自动处理通配符（也就是说，<code>*.txt</code> 能匹配任意后缀为 <code>.txt</code> 的文件，如 <code>README.txt</code> 和 <code>INSTALL.txt</code> 等），而 Windows 平台的命令行工具（CMD）不支持通配符，所以如果用户在命令行输入 <code>*.txt</code>，那么程序只能接收到 <code>*.txt</code> 。</p><p>为了保持平台之间的一致性，这里使用 commandLineFiles() 函数来实现跨平台的处理，当程序运行在 Windows 平台时，实现文件名通配功能。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>updateFrequencies() 函数纯粹就是用来处理文件的，它打开给定的文件，并使用 defer 在函数返回时关闭文件，这里我们将文件作为一个 <code>*bufio.Reader</code>（使用 bufio.NewReader() 函数创建）传给 readAndUpdateFrequencies() 函数，因为这个函数是以字符串的形式一行一行地读取数据的，所以实际的工作都是在 readAndUpdateFrequencies() 函数里完成的，代码如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一部分的代码我们应该很熟悉了，用了一个无限循环来一行一行地读一个文件，当读到文件结尾或者出现错误的时候就退出循环，将错误报告给用户但并不退出程序，因为还有很多其他的文件需要去处理。</p><p>任意一行都可能包括标点、数字、符号或者其他非单词字符，所以我们需要逐个单词地去读，将每一行分隔成若干个单词并使用 SplitOnNonLetters() 函数忽略掉非单词的字符，并且过滤掉字符串开头和结尾的空白。</p><p>只需要记录含有两个以上（包括两个）字母的单词，可以通过使用 if 语句，如 utf8.RuneCountlnString(word) &gt; 1 来完成。</p><p>上面描述的 if 语句有一点性能损耗，因为它会分析整个单词，所以在这个程序里我们增加了一个判断条件，用来检査这个单词的字节数是否大于 utf8.UTFMax（utf8.UTFMax 是一个常量，值为 4，用来表示一个 UTF-8 字符最多需要几个字节）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SplitOnNonLetters() 函数用来在非单词字符上对一个字符串进行切分，首先我们为 strings.FieldsFunc() 函数创建一个匿名函数 notALetter，如果传入的是字符那就返回 false，否则返回 true，然后返回调用函数 strings.FieldsFunc() 的结果，调用的时候将给定的字符串和 notALetter 作为它的参数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>计算出了 frequencyForWord 之后，调用 reportByWords() 将它的数据打印出来，因为我们需要将输出结果按照字母顺序排序好，所以首先要创建一个空的容量足够大的 []string 切片来保存所有在 frequencyForWord 里的单词。</p><p>第一个循环遍历映射里的所有项，把每个单词追加到 words 字符串切片里去，使用 append() 函数只需要把给定的单词追加到第 len(words) 个索引位置上即可，words 的长度会自动增加 1。</p><p>得到了 words 切片之后，对它进行排序，这个在 readAndUpdateFrequencies() 函数中已经处理好了。</p><p>经过排序之后我们打印两列标题，第一个是 “Word”，为了能让 Frequency 最后一个字符 y 右对齐，需要在 “Word” 后打印一些空格，通过 <code>%*s</code> 可以实现的打印固定长度的空白，也可以使用 <code>%s</code> 来打印 strings.Repeat(“ “, gap) 返回的字符串。</p><p>最后，我们将单词和它们的频率用两列方式按照字母顺序打印出来。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的函数首先创建一个空的映射，用来保存反转的结果，但是我们并不知道它到底要保存多少个项，因此我们假设它和原来的映射容量一样大，然后简单地遍历原来的映射，将它的值作为键保存到反转的映射里，并将键增加到对应的值里去，新的映射的值就是一个字符串切片，即使原来的映射有多个键对应同一个值，也不会丢掉任何数据。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数的结构和 reportByWords() 函数很相似，它首先创建一个切片用来保存频率，并按照频率升序排列，然后再计算需要容纳的最大长度并以此作为第一列的宽度，之后输出报告的标题，最后，遍历输出所有的频率并按照字母升序输出对应的单词，如果一个频率有超过两个对应的单词则单词之间使用逗号分隔开。</p><h3 id="示例：缩进排序"><a href="#示例：缩进排序" class="headerlink" title="示例：缩进排序"></a>示例：缩进排序</h3><p>演示如何将字符串按照等级（缩进级别）进行排序，完整代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">var original = []string{</span><br><span class="line">    "Nonmetals",</span><br><span class="line">    "    Hydrogen",</span><br><span class="line">    "    Carbon",</span><br><span class="line">    "    Nitrogen",</span><br><span class="line">    "    Oxygen",</span><br><span class="line">    "Inner Transitionals",</span><br><span class="line">    "    Lanthanides",</span><br><span class="line">    "        Europium",</span><br><span class="line">    "        Cerium",</span><br><span class="line">    "    Actinides",</span><br><span class="line">    "        Uranium",</span><br><span class="line">    "        Plutonium",</span><br><span class="line">    "        Curium",</span><br><span class="line">    "Alkali Metals",</span><br><span class="line">    "    Lithium",</span><br><span class="line">    "    Sodium",</span><br><span class="line">    "    Potassium",</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("|     Original      |       Sorted      |")</span><br><span class="line">    fmt.Println("|-------------------|-------------------|")</span><br><span class="line">    sorted := SortedIndentedStrings(original) // 最初是 []string</span><br><span class="line">    for i := range original {                 // 在全局变量中设置</span><br><span class="line">        fmt.Printf("|%-19s|%-19s|\n", original[i], sorted[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意 SortedIndentedStrings() 函数有一个很重要的前提就是，字符串的缩进是通过读到的空格或缩进的个数来决定的，下面来看一下输出结果，为了方便对比，这里将排序前的结果放在左边，排序后的结果放在右边。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|     Original      |       Sorted      |</span><br><span class="line">|-------------------|-------------------|</span><br><span class="line">|Nonmetals          |Alkali Metals      |</span><br><span class="line">|    Hydrogen       |    Lithium        |</span><br><span class="line">|    Carbon         |    Potassium      |</span><br><span class="line">|    Nitrogen       |    Sodium         |</span><br><span class="line">|    Oxygen         |Inner Transitionals|</span><br><span class="line">|Inner Transitionals|    Actinides      |</span><br><span class="line">|    Lanthanides    |        Curium     |</span><br><span class="line">|        Europium   |        Plutonium  |</span><br><span class="line">|        Cerium     |        Uranium    |</span><br><span class="line">|    Actinides      |    Lanthanides    |</span><br><span class="line">|        Uranium    |        Cerium     |</span><br><span class="line">|        Plutonium  |        Europium   |</span><br><span class="line">|        Curium     |Nonmetals          |</span><br><span class="line">|Alkali Metals      |    Carbon         |</span><br><span class="line">|    Lithium        |    Hydrogen       |</span><br><span class="line">|    Sodium         |    Nitrogen       |</span><br><span class="line">|    Potassium      |    Oxygen         |</span><br></pre></td></tr></tbody></table></figure><p>其中，SortedIndentedStrings() 函数和它的辅助函数使用到了递归、函数引用以及指向切片的指针等。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sort.Interface 接口定义了 3 个方法 Len()、Less() 和 Swap()，它们的函数签名和 Entries 中的同名方法是一样的，这就意味着我们可以使用标准库里的 sort.Sort() 函数来对一个 Entries 进行排序。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>导出的函数 SortedIndentedStrings() 就做了这个工作，虽然我们已经对它进行了重构，让它把所有东西都传递给辅助函数，函数 populateEntries() 传入一个 []string 并返回一个对应的 Entries（[]Entry 类型）。</p><p>而函数 sortedEntries() 需要传入一个 Entries，然后返回一个排过序的 []string（根据缩进的级别进行排序）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>populateEntries() 函数首先以字符串的形式得到给定切片里的一级缩进（如有 4 个空格的字符串）和它占用的字节数，然后创建一个空的 Entries，并遍历切片里的每一个字符串，判断该字符串的缩进级别，再创建一个用于排序的键。</p><p>下一步，调用自定义函数 addEntry()，将当前字符串的级别、键、字符串本身，以及指向 entries 的地址作为参数，这样 addEntry() 就能创建一个新的 Entry 并能够正确地将它追加到 entries 里去，最后返回 entries。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>computeIndent() 函数主要是用来判断缩进使用的是什么字符，例如空格或者缩进符等，以及一个缩进级别占用多少个这样的字符。</p><p>因为第一级的字符串可能没有缩进，所以函数必须迭代所有的字符串，一旦它发现某个字符串的行首是空格或者缩进，函数马上返回表示缩进的字符以及一个缩进所占用的字符数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>addEntry() 是一个递归函数，它创建一个新的 Entry，如果这个 Entry 的 level 是 0，那就直接增加到 entries 里去，否则，就将它作为另一个 Entry 的子集。</p><p>我们必须确定这个函数传入的是一个 *Entries 而不是传递一个 entries 引用（切片的默认行为），因为我们是要将数据追加到 entries 里，追加到一个引用会导致无用的本地副本且原来的数据实际上并没有被修改。</p><p>如果 level 是 0，表明这个字符串是顶级项，因此必须将它直接追加到 <code>*entries</code> ，实际上情况要更复杂一些，因为 level 是相对传入的 <code>*entries</code> 而言的，第一次调用 addEntry() 时，<code>*entries</code> 是一个第一级的 Entries，但函数进入递归后，*entries 就可能是某个 Entry 的子集。</p><p>我们使用内置的 append() 函数来追加新的 Entry，并使用 <code>*</code> 操作符获得 entries 指针指向的值，这就保证了任何改变对调用者来说都是可见的，新增的 Entry 包含给定的 key 和 value，以及一个空的子 Entries，这是递归的结束条件。</p><p>如果 level 大于 0，则我们必须将它追加到上一级 Entry 的 children 字段里去，这里我们只是简单地递归调用 addEntry() 函数，最后一个参数可能是我们目前为止见到的最复杂的表达式了。</p><p>子表达式 entries.Len() - 1 产生一个 int 型整数，表示 <code>*entries</code> 指向的 Entries 值的最后一个条目的索引位置（注意 Entries.Len() 传入的是一个 Entries 值而不是 <code>*Entries</code> 指针，不过Go语言也可以自动对 entries 指针进行解引用并调用相应的方法）。</p><p>完整的表达式（&amp;(…) 除外）访问了 Entries 最后一个 Entry 的 children 字段（这也是一个 Entries 类型），所以如果把这个表达式作为一个整体，实际上我们是将 Entries 里最后一个 Entry 的 children 字段的内存地址作为递归调用的参数，因为 addEntry() 最后一个参数是 *Entries 类型的。</p><p>为了帮助大家弄清楚到底发生了什么，下面的代码和上述代码中 else 代码块中的那个调用是一样的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theEntries := *entries</span><br><span class="line">lastEntry := &amp;theEntries[theEntries.Len()-1]</span><br><span class="line">addEntry(level-1, key, value, &amp;lastEntry.children)</span><br></pre></td></tr></tbody></table></figure><p>首先，我们创建 theEntries 变量用来保存 *entries 指针指向的值，这里没有什么开销因为不会产生复制，实际上 theEntries 相当于一个指向 Entries 值的别名。</p><p>然后我们取得最后一项的内存地址（即一个指针），如果不取地址的话就会取到最后一项的副本，最后递归调用 addEntry() 函数，并将最后一项的 children 字段的地址作为参数传递给它。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当调用 sortedEntries() 函数的时候，Entries 显示的结构和原先程序输出的字符串是一样的，每一个缩进的字符串都是上一级缩进的子级，而且还可能有下一级的缩进，依次类推。</p><p>创建了 Entries 之后，SortedIndentedStrings() 函数调用上面这个函数去生成一个排好序的字符串切片 []string，这个函数首先创建一个空的 []string 用来保存最后的结果，然后对 entries 进行排序。</p><p>Entries 实现了 sort.Interface 接口，因此我们可以直接使用 sort.Sort() 函数根据 Entry 的 key 字段来对 Entries 进行排序（这是 Entries.Less() 的实现方式），这个排序只是作用于第一级的 Entry，对其他未排序的子集是没有任何影响的。</p><p>为了能够对 children 字段以及 children 的 children 等进行递归排序，函数遍历第一级的每一个项并调用 populateIndentedStrings() 函数，传入这个 Entry 类型的项和一个指向 []string 切片的指针。</p><p>切片可以传递给函数并由函数更新内容（如替换切片里的某些项），但是这里需要往切片里新增一些数据，所以这里将一个指向切片的指针（也就是指针的指针）作为参数传进去，并将指针指向的内容设置为 append() 函数的返回结果，可能是一个新的切片，也可能是原先的切片。</p><p>另一种办法就是传入切片的值，然后返回 append() 之后的切片，但是必须将返回的结果赋值给原来的切片变量（例如 slice = function(slice)），不过这么做的话，很难正确地使用递归函数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>populateIndentedStrings() 函数将顶级项追加到创建的切片，然后对顶级项的子项进行排序，并递归调用自身对每一个子项做同样的处理，这就相当于对每一项的子项以及子项的子项等都做了排序，所以整个字符串切片就是已经排好序的了。</p><h3 id="示例：二分查找算法"><a href="#示例：二分查找算法" class="headerlink" title="示例：二分查找算法"></a>示例：二分查找算法</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找算法的前提是传入的序列是有序的（降序或升序），并且有一个目标值。</p><p>二分查找的核心思想是将 n 个元素分成大致相等的两部分，取中间值 <code>a[n/2]</code> 与 x 做比较，如果 <code>x=a[n/2]</code> ，则找到 x ，算法中止，如果 <code>x&lt;a[n/2]</code> ，则只要在数组 a 的左半部分继续搜索 x，如果 <code>x&gt;a[n/2]</code> ，则只要在数组 a 的右半部搜索 x。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限，底层必须依赖数组，并且还要求数据是有序的，对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁插入、删除操作的数据。</p><p>程序实现：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">二分查找函数，假设有序数组的顺序是从小到大</span><br><span class="line">*/</span><br><span class="line">func BinaryFind(arr *[]int, leftIndex int, rightIndex int, findValue int) {</span><br><span class="line"></span><br><span class="line">    //判断leftIndex是否大于rightIndex</span><br><span class="line">    if leftIndex &gt; rightIndex {</span><br><span class="line">        fmt.Println("未找到")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //先找到中间的下标</span><br><span class="line">    middle := (leftIndex + rightIndex) / 2</span><br><span class="line"></span><br><span class="line">    if (*arr)[middle] &gt; findValue {</span><br><span class="line">        fmt.Printf("小于中间 middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, leftIndex, middle-1, findValue)</span><br><span class="line">        //要查找的数，范围应该在leftIndex与 middle-1 之间</span><br><span class="line">        BinaryFind(arr, leftIndex, middle-1, findValue)</span><br><span class="line"></span><br><span class="line">    } else if (*arr)[middle] &lt; findValue {</span><br><span class="line">        fmt.Printf("大于中间  middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, middle+1, rightIndex, findValue)</span><br><span class="line">        //要查找的数，范围应该在middle+1与 rightIndex 之间</span><br><span class="line">        BinaryFind(arr, middle+1, rightIndex, findValue)</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("找到了，下标为：%v \n", middle)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //定义一个数组</span><br><span class="line">    arr := []int{1, 3, 7, 12, 17, 20, 30, 50, 55, 75}</span><br><span class="line">    BinaryFind(&amp;arr, 0, len(arr)-1, 30)</span><br><span class="line">    fmt.Println("main arr=", arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大于中间  middle：4, leftIndex： 0 rightIndex：9 findValue：30</span><br><span class="line">小于中间  middle：7, leftIndex： 5 rightIndex：9 findValue：30</span><br><span class="line">大于中间  middle：5, leftIndex： 5 rightIndex：6 findValue：30</span><br><span class="line">找到了，下标为：6</span><br><span class="line">main arr= [1 3 7 12 17 20 30 50 55 75]</span><br></pre></td></tr></tbody></table></figure><h3 id="示例：冒泡排序"><a href="#示例：冒泡排序" class="headerlink" title="示例：冒泡排序"></a>示例：冒泡排序</h3><p>冒泡排序法是一种最简单的交换类排序方法，它是通过相邻数据的交换逐步将无序列表排列为有序列表。</p><p>冒泡排序的基本原理是重复地循环遍历要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大或者首字母从 Z 到 A）错误就把两个元素的位置交换过来，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p><p>冒泡排序的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><p>下面通过一个实例来演示一下冒泡排序，完整代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">   "fmt"</span><br><span class="line">)</span><br><span class="line">/**</span><br><span class="line">冒泡排序</span><br><span class="line">*/</span><br><span class="line">func main() {</span><br><span class="line">    arr := [...]int{21,32,12,33,34,34,87,24}</span><br><span class="line">    var n = len(arr)</span><br><span class="line">    fmt.Println("--------没排序前--------\n",arr)</span><br><span class="line">    for i := 0; i &lt;= n-1; i++ {</span><br><span class="line">        fmt.Println("--------第",i+1,"次冒泡--------")</span><br><span class="line">        for j := i; j &lt;= n-1; j++ {</span><br><span class="line">            if arr[i] &gt; arr[j] {</span><br><span class="line">                t := arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = t</span><br><span class="line">            }</span><br><span class="line">            fmt.Println(arr)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("--------最终结果--------\n",arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">--------没排序前--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">--------第 1 次冒泡--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">--------第 2 次冒泡--------</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">--------第 3 次冒泡--------</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">--------第 4 次冒泡--------</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">--------第 5 次冒泡--------</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 6 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 7 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------第 8 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------最终结果--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br></pre></td></tr></tbody></table></figure><h4 id="四种冒泡排序写法"><a href="#四种冒泡排序写法" class="headerlink" title="四种冒泡排序写法"></a>四种冒泡排序写法</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//用于计数排序中访问了多少次序列</span><br><span class="line">var cnt int= 0</span><br><span class="line"></span><br><span class="line">//最原始的冒泡排序</span><br><span class="line">func buble_sort(a []int){</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{//相邻元素两两比较</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//增加标志判断是否发生交换，如果没有发生交换，表明序列有序，结束比较，直接退出</span><br><span class="line">func flag_sort(a []int){</span><br><span class="line">    flag := true//默认序列有序</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false//发生交换--表明序列无序--需要进行下一次比较</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//除了标志位以外，记录最后一次发生交换的下标，更能减少不必要的比较</span><br><span class="line">func better_sort(a []int){</span><br><span class="line">    flag := true</span><br><span class="line">    k := len(a)-1//控制内部比较循环</span><br><span class="line">    n := 0//记录最后一次发生交换的下标</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        n = 0//每次访问待排序序列之初默认序列有序，没有发生交换，最后交换的下标就是0</span><br><span class="line">        for j := 0; j &lt; k; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false</span><br><span class="line">                n = j//保存最后一次交换的下标</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        if flag {//如果这趟走完，没有发生交换，则原数组有序</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        k = n//最后一次交换的位置给k，减少比较的次数</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//鸡尾酒冒泡排序--先从低到高，再从高到低--分为两大步骤，结合标志判断</span><br><span class="line">func cocktail_sort(a []int) {</span><br><span class="line">    left := 0</span><br><span class="line">    right := len(a) - 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    flag := true</span><br><span class="line">    for(left &lt; right){</span><br><span class="line">        flag = true</span><br><span class="line">        for i :=left; i &lt; right; i++{// 前半轮,将最大元素放到后面</span><br><span class="line">            if (a[i] &gt; a[i+1]) {</span><br><span class="line">                a[i], a[i+1] = a[i+1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        right--</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for i :=right; i &gt; left; i--{// 后半轮,将最小元素放到前面</span><br><span class="line">            if (a[i] &lt; a[i-1]) {</span><br><span class="line">                a[i], a[i-1] = a[i-1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        left++</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    b := [...]int{8,7,6,1,4,3,2,5}</span><br><span class="line">    buble_sort(b[:])</span><br><span class="line">    fmt.Println(b,cnt)</span><br><span class="line"></span><br><span class="line">    c := []int{2,3,4,5,6,1}</span><br><span class="line">    cocktail_sort(c)</span><br><span class="line">    fmt.Println(c,cnt)</span><br><span class="line"></span><br><span class="line">    d := []int{8,7,6,1,4,3,2,5}</span><br><span class="line">    flag_sort(d)</span><br><span class="line">    fmt.Println(d,cnt)</span><br><span class="line"></span><br><span class="line">    e := []int{2,3,4,5,6,1}</span><br><span class="line">    better_sort(e)</span><br><span class="line">    fmt.Println(e,cnt)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Go语言分布式id生成器"><a href="#Go语言分布式id生成器" class="headerlink" title="Go语言分布式id生成器"></a>Go语言分布式id生成器</h3><p>有时我们需要能够⽣成类似 MySQL 自增 ID 这样不断增大，同时又不会重复的 ID。以支持业务中的⾼并发场景。比较典型的是电商促销时短时间内会有大量的订单涌入到系统，比如每秒 10w+。明星出轨时会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。</p><p>在插入数据库之前，我们需要给这些消息、订单先打上一个 ID，然后再插⼊到我们的数据库。对这个 ID 的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进⾏排序。</p><p>Twitter 的 snowflake 算法是这种场景下的一个典型解法。先来看看 snowflake 是怎么回事，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/snowflake.gif" alt="图：snowflake 中的比特位分布"></p><p>⾸先确定我们的数值是 64 位的 int64 类型，被划分为了四部分，不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的 ID，然后再五位来表示机器的实例 ID，最后是 12 位的循环自增 ID（到达 1111,1111,1111 后会归 0）。</p><p>这样的机制可以⽀持我们在同一台机器上，同一毫秒内产⽣ 2 ^ 12 = 4096 条消息。一秒共 409.6 万条消息。从值域上来讲完全够⽤了。</p><p>数据中心加上实例 ID 共有 10 位，可以⽀持我们每数据中心部署 32 台机器，所有数据中心共 1024 台实例。</p><p>表示 timestamp 的 41 位，可以⽀持我们使用 69 年。当然，我们的时间毫秒计数不会真的从 1970 年开始记，那样我们的系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的 timestamp 实际上只是相对于某个时间的增量，比如我们的系统上线是 2018-08-01，那么我们可以把这个 timestamp 当作是从 2018-08-01 00:00:00.000 的偏移量。</p><h4 id="worker-id-分配"><a href="#worker-id-分配" class="headerlink" title="worker_id 分配"></a>worker_id 分配</h4><p>timestamp、datacenter_id、worker_id 和 sequence_id 这四个字段中，timestamp 和 sequence_id 是由程序在运⾏期⽣成的。但 datacenter_id 和 worker_id 需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的 ID 有冲突）。</p><p>一般不同数据中⼼的机器，会提供对应的获取数据中心 ID 的 API，所以 datacenter_id 我们可以在部署阶段轻松地获取到。而 worker_id 是我们逻辑上给机器分配的一个 ID，这个要怎么办呢？比较简单的想法是由能够提供这种自增 ID 功能的工具来支持，比如 MySQL:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into a (ip) values("10.1.2.101");</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select last_insert_id();</span><br><span class="line">+------------------+</span><br><span class="line">| last_insert_id()     |</span><br><span class="line">+------------------+</span><br><span class="line">| 2                          |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><p>从 MySQL 中获取到 worker_id 之后，就把这个 worker_id 直接持久化到本地，以避免每次上线时都需要获取新的 worker_id，让单实例的 worker_id 可以始终保持不变。</p><p>当然，使用 MySQL 相当于给我们简单的 id 生成服务增加了一个外部依赖，依赖越多，我们的服务的可运维性就越差。</p><p>考虑到集群中即使有单个 ID 生成服务的实例挂了，也就是损失一段时间的一部分 ID，所以我们也可以更简单暴力一些，把 worker_id 直接写在 worker 的配置中，上线时由部署脚本完成 worker_id 字段替换</p><h4 id="标准-snowflake-实现"><a href="#标准-snowflake-实现" class="headerlink" title="标准 snowflake 实现"></a>标准 snowflake 实现</h4><p>github.com/bwmarrin/snowflake 是一个相当轻量化的 snowflake 的 Go 实现。其文档对各位使用的定义如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosnowflake.gif" alt="图：snowflake库"></p><p>和标准的 snowflake 完全一致。使用上比较简单：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "github.com/bwmarrin/snowflake"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    n, err := snowflake.NewNode(1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        id := n.Generate()</span><br><span class="line">        fmt.Println("id", id)</span><br><span class="line">        fmt.Println(</span><br><span class="line">            "node: ", id.Node(),</span><br><span class="line">            "step: ", id.Step(),</span><br><span class="line">            "time: ", id.Time(),</span><br><span class="line">            "\n",</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">go: finding module for package github.com/bwmarrin/snowflake</span><br><span class="line">go: downloading github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">go: found github.com/bwmarrin/snowflake in github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">id 1318484268032200704</span><br><span class="line">node:  1 step:  0 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200705</span><br><span class="line">node:  1 step:  1 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200706</span><br><span class="line">node:  1 step:  2 time:  1603186120409</span><br></pre></td></tr></tbody></table></figure><p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC</span><br><span class="line">// You may customize this to set a different epoch for your application.</span><br><span class="line">Epoch int64 = 1288834974657</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Node</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">NodeBits uint8 = 10</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Step</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">StepBits uint8 = 12</span><br></pre></td></tr></tbody></table></figure><p>Epoch 就是本节开头讲的起始时间，NodeBits 指的是机器编号的位⻓，StepBits 指的是自增序列的位⻓。</p><h4 id="sonyflake"><a href="#sonyflake" class="headerlink" title="sonyflake"></a>sonyflake</h4><p>sonyflake 是 Sony 公司的一个开源项目，基本思路和 snowflake 差不多，不过位分配上稍有不同，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sonyflake.gif" alt="图：sonyflake"></p><p>这⾥的时间只用了 39 个 bit，但时间的单位变成了 10ms，所以理论上比 41 位表示的时间还要久（174 年）。</p><p>Sequence ID 和之前的定义一致，Machine ID 其实就是节点 ID。sonyflake 与众不同的地方在于其在启动阶段的参数配置：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewSonyflake(st Settings) *Sonyflake</span><br></pre></td></tr></tbody></table></figure><p>Settings 数据结构如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Settings struct {</span><br><span class="line">    StartTime time.Time</span><br><span class="line">    MachineID func() (uint16, error)</span><br><span class="line">    CheckMachineID func(uint16) bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>StartTime 选项和我们之前的 Epoch 差不多，如果不设置的话，默认是从 2014-09-01 00:00:00 +0000 UTC 开始。</p><p>MachineID 可以由用户自定义的函数，如果用户不定义的话，会默认将本机 IP 的低 16 位作为 machineid。</p><p>CheckMachineID 是由用户提供的检查 MachineID 是否冲突的函数。这里的设计还是比较巧秒的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查 MachineID 是否冲突的逻辑。如果公司有现成的 Redis 集群，那么我们可以很轻松地用 Redis 的集合类型来检查冲突。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><p>使用起来也比较简单，这里省略了一些逻辑简单的函数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">    "github.com/sony/sonyflake"</span><br><span class="line">)</span><br><span class="line">func getMachineID() (uint16, error) {</span><br><span class="line">    var machineID uint16</span><br><span class="line">    var err error</span><br><span class="line">    machineID = readMachineIDFromLocalFile()</span><br><span class="line">    if machineID == 0 {</span><br><span class="line">        machineID, err = generateMachineID()</span><br><span class="line">        if err != nil {</span><br><span class="line">            return 0, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return machineID, nil</span><br><span class="line">}</span><br><span class="line">func checkMachineID(machineID uint16) bool {</span><br><span class="line">    saddResult, err := saddMachineIDToRedisSet()</span><br><span class="line">    if err != nil || saddResult == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    err := saveMachineIDToLocalFile(machineID)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return false</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    t, _ := time.Parse("2006-01-02", "2018-01-01")</span><br><span class="line">    settings := sonyflake.Settings{</span><br><span class="line">        StartTime: t,</span><br><span class="line">        MachineID: getMachineID,</span><br><span class="line">        CheckMachineID: checkMachineID,</span><br><span class="line">    }</span><br><span class="line">    sf := sonyflake.NewSonyflake(settings)</span><br><span class="line">    id, err := sf.NextID()</span><br><span class="line">    if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 流程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go容器</title>
      <link href="posts/5c78a85/"/>
      <url>posts/5c78a85/</url>
      
        <content type="html"><![CDATA[<p>变量在一定程度上能满足函数及代码要求。如果编写一些复杂算法、结构和逻辑，就需要更复杂的类型来实现。这类复杂类型一般情况下具有各种形式的存储和处理数据的功能，将它们称为“容器（container）”。</p><p>在很多语言里，容器是以标准库的方式提供，你可以随时查看这些标准库的代码，了解如何创建，删除，维护内存。</p><p>本章将以实用为目的，详细介绍数组、切片、映射，以及列表的增加、删除、修改和遍历的使用方法。本章既可以作为教程，也可以作为字典，以方便开发者日常的查询和应用。</p><p>其它语言中的容器:</p><ul><li>C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。</li><li>C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。</li><li>C# 语言通过 .NET 框架提供，如 List 对应数组，LinkedList 对应双链表，Dictionary 对应映射。</li><li>Lua 语言的 table 实现了数组和映射的功能，Lua 语言默认没有双链表支持。</li></ul><h2 id="go-array"><a href="#go-array" class="headerlink" title="go array"></a>go array</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。</p><p>和数组对应的类型是 <code>Slice</code>（切片），<code>Slice</code> 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 <code>Slice</code> 工作原理的话需要先理解数组。</p><h3 id="Go语言数组的声明"><a href="#Go语言数组的声明" class="headerlink" title="Go语言数组的声明"></a>Go语言数组的声明</h3><p>数组的声明语法如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]Type</span><br></pre></td></tr></tbody></table></figure><p>语法说明如下所示：</p><ul><li>数组变量名：数组声明及使用时的变量名。</li><li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li><li>Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li></ul><p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 <code>len()</code> 可以返回数组中元素的个数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int             // 定义三个整数的数组</span><br><span class="line">fmt.Println(a[0])        // 打印第一个元素</span><br><span class="line">fmt.Println(a[len(a)-1]) // 打印最后一个元素</span><br><span class="line">// 打印索引和元素</span><br><span class="line">for i, v := range a {</span><br><span class="line">    fmt.Printf("%d %d\n", i, v)</span><br><span class="line">}</span><br><span class="line">// 仅打印元素</span><br><span class="line">for _, v := range a {</span><br><span class="line">    fmt.Printf("%d\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var q [3]int = [3]int{1, 2, 3}</span><br><span class="line">var r [3]int = [3]int{1, 2}</span><br><span class="line">fmt.Println(r[2]) // "0"</span><br></pre></td></tr></tbody></table></figure><p>在数组的定义中，如果在数组长度的位置出现“…”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]int{1, 2, 3}</span><br><span class="line">fmt.Printf("%T\n", q) // "[3]int"</span><br></pre></td></tr></tbody></table></figure><p>数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [3]int{1, 2, 3}</span><br><span class="line">q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int</span><br></pre></td></tr></tbody></table></figure><h3 id="比较两个数组是否相等"><a href="#比较两个数组是否相等" class="headerlink" title="比较两个数组是否相等"></a>比较两个数组是否相等</h3><p>如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [2]int{1, 2}</span><br><span class="line">b := [...]int{1, 2}</span><br><span class="line">c := [2]int{1, 3}</span><br><span class="line">fmt.Println(a == b, a == c, b == c) // "true false false"</span><br><span class="line">d := [3]int{1, 2}</span><br><span class="line">fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int</span><br></pre></td></tr></tbody></table></figure><h3 id="遍历数组——访问每一个数组元素"><a href="#遍历数组——访问每一个数组元素" class="headerlink" title="遍历数组——访问每一个数组元素"></a>遍历数组——访问每一个数组元素</h3><p>遍历数组也和遍历切片类似，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var team [3]string</span><br><span class="line">team[0] = "hammer"</span><br><span class="line">team[1] = "soldier"</span><br><span class="line">team[2] = "mum"</span><br><span class="line"></span><br><span class="line">for k, v := range team {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 hammer</span><br><span class="line">1 soldier</span><br><span class="line">2 mum</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。</li><li>第 7 行，将每个键值打印出来。</li></ul><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。</p><p>声明多维数组的语法如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array_name [size1][size2]...[sizen] array_type</span><br></pre></td></tr></tbody></table></figure><p>其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。</p><p>以二维数组为例来简单讲解一下多维数组的使用。</p><p>二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。</p><p>【示例 1】声明二维数组:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个二维整型数组，两个维度的长度分别是 4 和 2</span><br><span class="line">var array [4][2]int</span><br><span class="line">// 使用数组字面量来声明并初始化一个二维整型数组</span><br><span class="line">array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}</span><br><span class="line">// 声明并初始化数组中索引为 1 和 3 的元素</span><br><span class="line">array = [4][2]int{1: {20, 21}, 3: {40, 41}}</span><br><span class="line">// 声明并初始化数组中指定的元素</span><br><span class="line">array = [4][2]int{1: {0: 20}, 3: {1: 41}}</span><br></pre></td></tr></tbody></table></figure><p>下图展示了上面示例中声明的二维数组在每次声明并初始化后包含的值。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/Array2.gif" alt="图：二维数组及其外层数组和内层数组的值"></p><p>为了访问单个元素，需要反复组合使用[ ]方括号，如下所示。</p><p>【示例 2】为二维数组的每个元素赋值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 2×2 的二维整型数组</span><br><span class="line">var array [2][2]int</span><br><span class="line">// 设置每个元素的整型值</span><br><span class="line">array[0][0] = 10</span><br><span class="line">array[0][1] = 20</span><br><span class="line">array[1][0] = 30</span><br><span class="line">array[1][1] = 40</span><br></pre></td></tr></tbody></table></figure><p>只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。</p><p>【示例 3】同样类型的多维数组赋值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明两个二维整型数组</span><br><span class="line">var array1 [2][2]int</span><br><span class="line">var array2 [2][2]int</span><br><span class="line">// 为array2的每个元素赋值</span><br><span class="line">array2[0][0] = 10</span><br><span class="line">array2[0][1] = 20</span><br><span class="line">array2[1][0] = 30</span><br><span class="line">array2[1][1] = 40</span><br><span class="line">// 将 array2 的值复制给 array1</span><br><span class="line">array1 = array2</span><br></pre></td></tr></tbody></table></figure><p>因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。</p><p>【示例 4】使用索引为多维数组赋值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里</span><br><span class="line">var array3 [2]int = array1[1]</span><br><span class="line">// 将数组中指定的整型值复制到新的整型变量里</span><br><span class="line">var value int = array1[1][0]</span><br></pre></td></tr></tbody></table></figure><h2 id="go-slice"><a href="#go-slice" class="headerlink" title="go slice"></a>go slice</h2><p>切片（Slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p><p>Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slice.jpg" alt="图：切片结构和内存分配"></p><h3 id="从数组或切片生成新的切片"><a href="#从数组或切片生成新的切片" class="headerlink" title="从数组或切片生成新的切片"></a>从数组或切片生成新的切片</h3><p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p><p>从连续内存区域生成切片是常见的操作，格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice [开始位置 : 结束位置]</span><br></pre></td></tr></tbody></table></figure><p>语法说明如下：</p><ul><li>slice：表示目标切片对象；</li><li>开始位置：对应目标切片对象的索引；</li><li>结束位置：对应目标切片的结束索引。</li></ul><p>从数组生成切片，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a  = [3]int{1, 2, 3}</span><br><span class="line">fmt.Println(a, a[1:2])</span><br></pre></td></tr></tbody></table></figure><p>其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3]  [2]</span><br></pre></td></tr></tbody></table></figure><p>其中 [2] 就是 a[1:2] 切片操作的结果。</p><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li></ul><p>根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。</p><p>下面通过实例来熟悉切片的特性。</p><h4 id="从指定范围中生成切片"><a href="#从指定范围中生成切片" class="headerlink" title="从指定范围中生成切片"></a>从指定范围中生成切片</h4><p>切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var highRiseBuilding [30]int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 30; i++ {</span><br><span class="line">        highRiseBuilding[i] = i + 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 区间</span><br><span class="line">fmt.Println(highRiseBuilding[10:15])</span><br><span class="line"></span><br><span class="line">// 中间到尾部的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[20:])</span><br><span class="line"></span><br><span class="line">// 开头到中间指定位置的所有元素</span><br><span class="line">fmt.Println(highRiseBuilding[:2])</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[11 12 13 14 15]</span><br><span class="line">[21 22 23 24 25 26 27 28 29 30]</span><br><span class="line">[1 2]</span><br></pre></td></tr></tbody></table></figure><p>代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。</p><p>代码说明如下：</p><ul><li>第 8 行，尝试出租一个区间楼层。</li><li>第 11 行，出租 20 层以上。</li><li>第 14 行，出租 2 层以下，一般是商用铺面。</li></ul><p>切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p><h4 id="表示原有的切片"><a href="#表示原有的切片" class="headerlink" title="表示原有的切片"></a>表示原有的切片</h4><p>生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[:])</span><br></pre></td></tr></tbody></table></figure><p>a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure><p>重置切片，清空拥有的元素<br>把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []int{1, 2, 3}</span><br><span class="line">fmt.Println(a[0:0])</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></tbody></table></figure><h3 id="直接声明新的切片"><a href="#直接声明新的切片" class="headerlink" title="直接声明新的切片"></a>直接声明新的切片</h3><p>除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name []Type</span><br></pre></td></tr></tbody></table></figure><p>其中 name 表示切片的变量名，Type 表示切片对应的元素类型。</p><p>下面代码展示了切片声明的使用过程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 声明字符串切片</span><br><span class="line">var strList []string</span><br><span class="line"></span><br><span class="line">// 声明整型切片</span><br><span class="line">var numList []int</span><br><span class="line"></span><br><span class="line">// 声明一个空切片</span><br><span class="line">var numListEmpty = []int{}</span><br><span class="line"></span><br><span class="line">// 输出3个切片</span><br><span class="line">fmt.Println(strList, numList, numListEmpty)</span><br><span class="line"></span><br><span class="line">// 输出3个切片大小</span><br><span class="line">fmt.Println(len(strList), len(numList), len(numListEmpty))</span><br><span class="line"></span><br><span class="line">// 切片判定空的结果</span><br><span class="line">fmt.Println(strList == nil)</span><br><span class="line">fmt.Println(numList == nil)</span><br><span class="line">fmt.Println(numListEmpty == nil)</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] [] []</span><br><span class="line">0 0 0</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，声明一个字符串切片，切片中拥有多个字符串。</li><li>第 5 行，声明一个整型切片，切片中拥有多个整型数值。</li><li>第 8 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。</li><li>第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。</li><li>第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。</li><li>第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。</li><li>第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。</li></ul><p>切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 append() 函数向切片中添加元素。</p><h3 id="使用-make-函数构造切片"><a href="#使用-make-函数构造切片" class="headerlink" title="使用 make() 函数构造切片"></a>使用 make() 函数构造切片</h3><p>如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make( []Type, size, cap )</span><br></pre></td></tr></tbody></table></figure><p>其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</p><p>示例如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := make([]int, 2)</span><br><span class="line">b := make([]int, 2, 10)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(len(a), len(b))</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 0] [0 0]</span><br><span class="line">2 2</span><br></pre></td></tr></tbody></table></figure><p>其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。</p><p>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p><p><strong><em>提醒:使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</em></strong></p><h3 id="append-为切片添加元素"><a href="#append-为切片添加元素" class="headerlink" title="append()为切片添加元素"></a>append()为切片添加元素</h3><p>Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a, 1) // 追加1个元素</span><br><span class="line">a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式</span><br><span class="line">a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包</span><br></pre></td></tr></tbody></table></figure><p>不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。</p><p>切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers []int</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    numbers = append(numbers, i)</span><br><span class="line">    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len: 1  cap: 1 pointer: 0xc0420080e8</span><br><span class="line">len: 2  cap: 2 pointer: 0xc042008150</span><br><span class="line">len: 3  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 4  cap: 4 pointer: 0xc04200e320</span><br><span class="line">len: 5  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 6  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 7  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 8  cap: 8 pointer: 0xc04200c200</span><br><span class="line">len: 9  cap: 16 pointer: 0xc042074000</span><br><span class="line">len: 10  cap: 16 pointer: 0xc042074000</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，声明一个整型切片。</li><li>第 4 行，循环向 numbers 切片中添加 10 个数。</li><li>第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。</li></ul><p>通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。</p><p>往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。</p><ul><li>员工和工位就是切片中的元素。</li><li>办公地就是分配好的内存。</li><li>搬家就是重新分配内存。</li><li>无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。</li><li>由于搬家后地址发生变化，因此内存“地址”也会有修改。</li></ul><p>除了在切片的尾部追加，我们还可以在切片的开头添加元素：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = []int{1,2,3}</span><br><span class="line">a = append([]int{0}, a...) // 在开头添加1个元素</span><br><span class="line">a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片</span><br></pre></td></tr></tbody></table></figure><p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p><p>因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line">a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x</span><br><span class="line">a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片</span><br></pre></td></tr></tbody></table></figure><p>每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。</p><h3 id="切片复制"><a href="#切片复制" class="headerlink" title="切片复制"></a>切片复制</h3><p>Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p><p>copy() 函数的使用格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy( destSlice, srcSlice []T) int</span><br></pre></td></tr></tbody></table></figure><p>其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。</p><p>下面的代码展示了使用 copy() 函数将一个切片复制到另一个切片的过程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []int{1, 2, 3, 4, 5}</span><br><span class="line">slice2 := []int{5, 4, 3}</span><br><span class="line">copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中</span><br><span class="line">copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre></td></tr></tbody></table></figure><p>虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题。</p><p>【示例】通过代码演示对切片的引用和复制操作后对切片元素的影响。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 设置元素数量为1000</span><br><span class="line">    const elementCount = 1000</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    srcData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将切片赋值</span><br><span class="line">    for i := 0; i &lt; elementCount; i++ {</span><br><span class="line">        srcData[i] = i</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 引用切片数据</span><br><span class="line">    refData := srcData</span><br><span class="line"></span><br><span class="line">    // 预分配足够多的元素切片</span><br><span class="line">    copyData := make([]int, elementCount)</span><br><span class="line"></span><br><span class="line">    // 将数据复制到新的切片空间中</span><br><span class="line">    copy(copyData, srcData)</span><br><span class="line"></span><br><span class="line">    // 修改原始数据的第一个元素</span><br><span class="line">    srcData[0] = 999</span><br><span class="line"></span><br><span class="line">    // 打印引用切片的第一个元素</span><br><span class="line">    fmt.Println(refData[0])</span><br><span class="line"></span><br><span class="line">    // 打印复制切片的第一个和最后一个元素</span><br><span class="line">    fmt.Println(copyData[0], copyData[elementCount-1])</span><br><span class="line"></span><br><span class="line">    // 复制原始数据从4到6(不包含)</span><br><span class="line">    copy(copyData, srcData[4:6])</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        fmt.Printf("%d ", copyData[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">999</span><br><span class="line">0 999</span><br><span class="line">4 5 2 3 4 5 6 7 8 9</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 8 行，定义元素总量为 1000。</li><li>第 11 行，预分配拥有 1000 个元素的整型切片，这个切片将作为原始数据。</li><li>第 14～16 行，将 srcData 填充 0～999 的整型值。</li><li>第 19 行，将 refData 引用 srcData，切片不会因为等号操作进行元素的复制。</li><li>第 22 行，预分配与 srcData 等大（大小相等）、同类型的切片 copyData。</li><li>第 24 行，使用 copy() 函数将原始数据复制到 copyData 切片空间中。</li><li>第 27 行，修改原始数据的第一个元素为 999。</li><li>第 30 行，引用数据的第一个元素将会发生变化。</li><li>第 33 行，打印复制数据的首位数据，由于数据是复制的，因此不会发生变化。</li><li>第 36 行，将 srcData 的局部数据复制到 copyData 中。</li><li>第 38～40 行，打印复制局部数据后的 copyData 元素。</li></ul><h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。</p><h4 id="从开头位置删除"><a href="#从开头位置删除" class="headerlink" title="从开头位置删除"></a>从开头位置删除</h4><p>删除开头的元素可以直接移动数据指针：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[1:] // 删除开头1个元素</span><br><span class="line">a = a[N:] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure><p>也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = append(a[:0], a[1:]...) // 删除开头1个元素</span><br><span class="line">a = append(a[:0], a[N:]...) // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure><p>还可以用 copy() 函数来删除开头的元素：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:copy(a, a[1:])] // 删除开头1个元素</span><br><span class="line">a = a[:copy(a, a[N:])] // 删除开头N个元素</span><br></pre></td></tr></tbody></table></figure><h4 id="从中间位置删除"><a href="#从中间位置删除" class="headerlink" title="从中间位置删除"></a>从中间位置删除</h4><p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []int{1, 2, 3, ...}</span><br><span class="line">a = append(a[:i], a[i+1:]...) // 删除中间1个元素</span><br><span class="line">a = append(a[:i], a[i+N:]...) // 删除中间N个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素</span><br><span class="line">a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素</span><br></pre></td></tr></tbody></table></figure><h4 id="从尾部删除"><a href="#从尾部删除" class="headerlink" title="从尾部删除"></a>从尾部删除</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = []int{1, 2, 3}</span><br><span class="line">a = a[:len(a)-1] // 删除尾部1个元素</span><br><span class="line">a = a[:len(a)-N] // 删除尾部N个元素</span><br></pre></td></tr></tbody></table></figure><p>删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。</p><p>【示例】删除切片指定位置的元素。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    seq := []string{"a", "b", "c", "d", "e"}</span><br><span class="line"></span><br><span class="line">    // 指定删除位置</span><br><span class="line">    index := 2</span><br><span class="line"></span><br><span class="line">    // 查看删除位置之前的元素和之后的元素</span><br><span class="line">    fmt.Println(seq[:index], seq[index+1:])</span><br><span class="line"></span><br><span class="line">    // 将删除点前后的元素连接起来</span><br><span class="line">    seq = append(seq[:index], seq[index+1:]...)</span><br><span class="line"></span><br><span class="line">    fmt.Println(seq)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a b] [d e]</span><br><span class="line">[a b d e]</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，声明一个字符串切片，保存含有从 a 到 e 的字符串。</li><li>第 9 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。</li><li>第 12 行，seq[:index] 表示的就是被删除元素的前半部分，值为 [a b]，seq[index+1:] 表示的是被删除元素的后半部分，值为 [d e]。</li><li>第 15 行，使用 append() 函数将两个切片连接起来。</li><li>第 17 行，输出连接好的新切片，此时，索引为 2 的元素已经被删除。</li></ul><p>代码的删除过程可以使用下图来描述。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceremove.jpg" alt="图：切片删除元素的操作过程"></p><p>Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p><p><strong><em>提示:连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。</em></strong></p><h3 id="循环迭代切片"><a href="#循环迭代切片" class="headerlink" title="循环迭代切片"></a>循环迭代切片</h3><p>通过前面的学习我们了解到切片其实就是多个相同类型元素的连续集合，既然切片是一个集合，那么我们就可以迭代其中的元素，Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每一个元素，并显示其值</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 4 行中的 index 和 value 分别用来接收 range 关键字返回的切片中每个元素的索引和值，这里的 index 和 value 不是固定的，读者也可以定义成其它的名字。</p><p>上面代码的输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Index: 0 Value: 10</span><br><span class="line">Index: 1 Value: 20</span><br><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure><p>当迭代切片时，关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/slicerange.gif" alt="图：使用 range 迭代切片会创建每个元素的副本"></p><p>需要强调的是，range 返回的是每个元素的副本，而不是直接返回对该元素的引用，如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示值和地址</span><br><span class="line">for index, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &amp;value, &amp;slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100</span><br><span class="line">Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104</span><br><span class="line">Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108</span><br><span class="line">Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C</span><br></pre></td></tr></tbody></table></figure><p>因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &amp;slice[index]）。</p><p>如果不需要索引值，也可以使用下划线 <code>_</code> 来忽略这个值，代码如下所示。</p><p>【示例 2】使用空白标识符（下划线）来忽略索引值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 迭代每个元素，并显示其值</span><br><span class="line">for _, value := range slice {</span><br><span class="line">    fmt.Printf("Value: %d\n", value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br><span class="line">Value: 30</span><br><span class="line">Value: 40</span><br></pre></td></tr></tbody></table></figure><p>关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环，代码如下所示。</p><p>【示例 3】使用传统的 for 循环对切片进行迭代</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个整型切片，并赋值</span><br><span class="line">slice := []int{10, 20, 30, 40}</span><br><span class="line">// 从第三个元素开始迭代每个元素</span><br><span class="line">for index := 2; index &lt; len(slice); index++ {</span><br><span class="line">    fmt.Printf("Index: %d Value: %d\n", index, slice[index])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Index: 2 Value: 30</span><br><span class="line">Index: 3 Value: 40</span><br></pre></td></tr></tbody></table></figure><p>在前面几节的学习中我们了解了两个特殊的内置函数 len() 和 cap()，可以用于处理数组、切片和通道，对于切片，函数 len() 可以返回切片的长度，函数 cap() 可以返回切片的容量，在上面的示例中，使用到了函数 len() 来控制循环迭代的次数。</p><p>当然，range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等，这些我们将在后面的学习中详细介绍。</p><h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>Go语言中同样允许使用多维切片，声明一个多维切片的语法格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></tbody></table></figure><p>其中，sliceName 为切片的名字，sliceType为切片的类型，每个 <code>[ ]</code> 代表着一个维度，切片有几个维度就需要几个 <code>[ ]</code> 。</p><p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">//为二维切片赋值</span><br><span class="line">slice = [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码也可以简写为下面的样子。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中展示了一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片，切片 slice 的值如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerwei.gif" alt="图：整型切片的切片的值"></p><p>通过上图可以看到外层的切片包括两个元素，每个元素都是一个切片，第一个元素中的切片使用单个整数 10 来初始化，第二个元素中的切片包括两个整数，即 100 和 200。</p><p>这种组合可以让用户创建非常复杂且强大的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，前面介绍过的关于内置函数 append() 的规则也可以应用到组合后的切片上，如下所示。</p><p>【示例】组合切片的切片</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个二维整型切片并赋值</span><br><span class="line">slice := [][]int{{10}, {100, 200}}</span><br><span class="line">// 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] = append(slice[0], 20)</span><br></pre></td></tr></tbody></table></figure><p>Go语言里使用 append() 函数处理追加的方式很简明，先增长切片，再将新的整型切片赋值给外层切片的第一个元素，当上面代码中的操作完成后，再将切片复制到外层切片的索引为 0 的元素，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sliceerweiappend.gif" alt="图：append 操作之后外层切片索引为 0 的元素的布局"></p><p>即便是这么简单的多维切片，操作时也会涉及众多的布局和值，在函数间这样传递数据结构会很复杂，不过切片本身结构很简单，可以用很小的成本在函数间传递。</p><h2 id="go-map"><a href="#go-map" class="headerlink" title="go map"></a>go map</h2><p>Go语言中 map 是一种特殊的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value。</p><p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p><h3 id="map-概念"><a href="#map-概念" class="headerlink" title="map 概念"></a>map 概念</h3><p>map 是引用类型，可以使用如下方式声明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mapname map[keytype]valuetype</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li>mapname 为 map 的变量名。</li><li>keytype 为键类型。</li><li>valuetype 是键对应的值类型。</li></ul><p><strong><em>提示：[keytype] 和 valuetype 之间允许有空格。</em></strong></p><p>在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目。</p><p>【示例】</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var mapLit map[string]int</span><br><span class="line">    //var mapCreated map[string]float32</span><br><span class="line">    var mapAssigned map[string]int</span><br><span class="line">    mapLit = map[string]int{"one": 1, "two": 2}</span><br><span class="line">    mapCreated := make(map[string]float32)</span><br><span class="line">    mapAssigned = mapLit</span><br><span class="line">    mapCreated["key1"] = 4.5</span><br><span class="line">    mapCreated["key2"] = 3.14159</span><br><span class="line">    mapAssigned["two"] = 3</span><br><span class="line">    fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])</span><br><span class="line">    fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])</span><br><span class="line">    fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])</span><br><span class="line">    fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map literal at "one" is: 1</span><br><span class="line">Map created at "key2" is: 3.14159</span><br><span class="line">Map assigned at "two" is: 3</span><br><span class="line">Map literal at "ten" is: 0</span><br></pre></td></tr></tbody></table></figure><p>示例中 mapLit 演示了使用 <code>{key1: value1, key2: value2}</code> 的格式来初始化 map ，就像数组和结构体一样。</p><p>上面代码中的 mapCreated 的创建方式 <code>mapCreated := make(map[string]float)</code> 等价于 <code>mapCreated := map[string]float{}</code> 。</p><p>mapAssigned 是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。</p><p>注意：可以使用 <code>make()</code> ，但不能使用 <code>new()</code> 来构造 map，如果错误的使用 <code>new()</code> 分配了一个引用对象，会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapCreated := new(map[string]float)</span><br></pre></td></tr></tbody></table></figure><p>接下来当我们调用 <code>mapCreated["key1"] = 4.5</code> 的时候，编译器会报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: mapCreated["key1"] (index of type *map[string]float).</span><br></pre></td></tr></tbody></table></figure><h3 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h3><p>和数组不同，map 可以根据新增的 key-value 动态的伸缩，因此它不存在固定长度或者最大限制，但是也可以选择标明 map 的初始容量 capacity，格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make(map[keytype]valuetype, cap)</span><br></pre></td></tr></tbody></table></figure><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map2 := make(map[string]float, 100)</span><br></pre></td></tr></tbody></table></figure><p>当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。</p><p>这里有一个 map 的具体例子，即将音阶和对应的音频映射起来：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">noteFrequency := map[string]float32 {</span><br><span class="line">"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,</span><br><span class="line">"G0": 24.50, "A0": 27.50, "B0": 30.87, "A4": 440}</span><br></pre></td></tr></tbody></table></figure><h3 id="用切片作为-map-的值"><a href="#用切片作为-map-的值" class="headerlink" title="用切片作为 map 的值"></a>用切片作为 map 的值</h3><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题，示例代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp1 := make(map[int][]int)</span><br><span class="line">mp2 := make(map[int]*[]int)</span><br></pre></td></tr></tbody></table></figure><h3 id="map-遍历"><a href="#map-遍历" class="headerlink" title="map 遍历"></a>map 遍历</h3><p>map 的遍历过程使用 for range 循环完成，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遍历对于Go语言的很多对象来说都是差不多的，直接使用 for range 语法即可，遍历时，可以同时获得键和值，如只遍历值，可以使用下面的形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将不需要的键使用_改为匿名变量形式。</p><p>只遍历键时，使用下面的形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k := range scene {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>无须将值改为匿名变量形式，忽略值即可。</p><p><strong><em>注意：遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。</em></strong></p><p>如果需要特定顺序的遍历结果，正确的做法是先排序，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">// 声明一个切片保存map数据</span><br><span class="line">var sceneList []string</span><br><span class="line"></span><br><span class="line">// 将map数据遍历复制到切片中</span><br><span class="line">for k := range scene {</span><br><span class="line">    sceneList = append(sceneList, k)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 对切片进行排序</span><br><span class="line">sort.Strings(sceneList)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">fmt.Println(sceneList)</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[brazil china route]</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，创建一个 map 实例，键为字符串，值为整型。</li><li>第 4～6 行，将 3 个键值对写入 map 中。</li><li>第 9 行，声明 sceneList 为字符串切片，以缓冲和排序 map 中的所有元素。</li><li>第 12 行，将 map 中元素的键遍历出来，并放入切片中。</li><li>第 17 行，对 sceneList 字符串切片进行排序，排序时，sceneList 会被修改。</li><li>第 20 行，输出排好序的 map 的键。</li></ul><p>sort.Strings 的作用是对传入的字符串切片进行字符串字符的升序排列，排序接口的使用将在后面的章节中介绍。</p><h3 id="map-删除和清空"><a href="#map-删除和清空" class="headerlink" title="map 删除和清空"></a>map 删除和清空</h3><p>Go语言提供了一个内置函数 delete()，用于删除容器内的元素，下面我们简单介绍一下如何用 delete() 函数删除 map 内的元素。</p><h4 id="使用-delete-函数从-map-中删除键值对"><a href="#使用-delete-函数从-map-中删除键值对" class="headerlink" title="使用 delete() 函数从 map 中删除键值对"></a>使用 delete() 函数从 map 中删除键值对</h4><p>使用 delete() 内建函数从 map 中删除一组键值对，delete() 函数的格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map, 键)</span><br></pre></td></tr></tbody></table></figure><p>其中 map 为要删除的 map 实例，键为要删除的 map 中键值对的键。</p><p>从 map 中删除一组键值对可以通过下面的代码来完成：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scene := make(map[string]int)</span><br><span class="line"></span><br><span class="line">// 准备map数据</span><br><span class="line">scene["route"] = 66</span><br><span class="line">scene["brazil"] = 4</span><br><span class="line">scene["china"] = 960</span><br><span class="line"></span><br><span class="line">delete(scene, "brazil")</span><br><span class="line"></span><br><span class="line">for k, v := range scene {</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route 66</span><br><span class="line">china 960</span><br></pre></td></tr></tbody></table></figure><p>这个例子中使用 delete() 函数将 brazil 从 scene 这个 map 中删除了。</p><h4 id="清空-map-中的所有元素"><a href="#清空-map-中的所有元素" class="headerlink" title="清空 map 中的所有元素"></a>清空 map 中的所有元素</h4><p>有意思的是，Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p><h3 id="map的多键索引——多个数值条件可以同时查询"><a href="#map的多键索引——多个数值条件可以同时查询" class="headerlink" title="map的多键索引——多个数值条件可以同时查询"></a>map的多键索引——多个数值条件可以同时查询</h3><p>在大多数的编程语言中，映射容器的键必须以单一值存在。这种映射方法经常被用在诸如信息检索上，如根据通讯簿的名字进行检索。但随着查询条件越来越复杂，检索也会变得越发困难。下面例子中涉及通讯簿的结构，结构如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 人员档案</span><br><span class="line">type Profile struct {</span><br><span class="line">    Name    string   // 名字</span><br><span class="line">    Age     int      // 年龄</span><br><span class="line">    Married bool     // 已婚</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并且准备好了一堆原始数据，需要算法实现构建索引和查询的过程，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    list := []*Profile{</span><br><span class="line">        {Name: "张三", Age: 30, Married: true},</span><br><span class="line">        {Name: "李四", Age: 21},</span><br><span class="line">        {Name: "王麻子", Age: 21},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildIndex(list)</span><br><span class="line"></span><br><span class="line">    queryData("张三", 30)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要用算法实现 buildIndex() 构建索引函数及 queryData() 查询数据函数，查询到结果后将数据打印出来。</p><p>下面，分别基于传统的基于哈希值的多键索引和利用 map 特性的多键索引进行查询。</p><h4 id="基于哈希值的多键索引及查询"><a href="#基于哈希值的多键索引及查询" class="headerlink" title="基于哈希值的多键索引及查询"></a>基于哈希值的多键索引及查询</h4><p>传统的数据索引过程是将输入的数据做特征值。这种特征值有几种常见做法：</p><ul><li>将特征使用某种算法转为整数，即哈希值，使用整型值做索引。</li><li>将特征转为字符串，使用字符串做索引。</li></ul><p>数据都基于特征值构建好索引后，就可以进行查询。查询时，重复这个过程，将查询条件转为特征值，使用特征值进行查询得到结果。</p><h5 id="字符串转哈希值"><a href="#字符串转哈希值" class="headerlink" title="字符串转哈希值"></a>字符串转哈希值</h5><p>查询键（classicQueryKey）的特征值需要将查询键中每一个字段转换为整型，字符串也需要转换为整型值，这里使用一种简单算法将字符串转换为需要的哈希值，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func simpleHash(str string) (ret int) {</span><br><span class="line"></span><br><span class="line">    // 遍历字符串中的每一个ASCII字符</span><br><span class="line">    for i := 0; i &lt; len(str); i++ {</span><br><span class="line">        // 取出字符</span><br><span class="line">        c := str[i]</span><br><span class="line"></span><br><span class="line">        // 将字符的ASCII码相加</span><br><span class="line">        ret += int(c)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行传入需要计算哈希值的字符串。</li><li>第 4 行，根据字符串的长度，遍历这个字符串的每一个字符，以 ASCII 码为单位。</li><li>第 9 行，c 变量的类型为 uint8，将其转为 int 类型并累加。</li></ul><p>哈希算法有很多，这里只是选用一种大家便于理解的算法。哈希算法的选用的标准是尽量减少重复键的发生，俗称“哈希冲撞”，即同样两个字符串的哈希值重复率降到最低。</p><h5 id="查询键"><a href="#查询键" class="headerlink" title="查询键"></a>查询键</h5><p>有了哈希算法函数后，将哈希函数用在查询键结构中。查询键结构如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type classicQueryKey struct {</span><br><span class="line">    Name string  // 要查询的名字</span><br><span class="line">    Age  int     // 要查询的年龄</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 计算查询键的哈希值</span><br><span class="line">func (c *classicQueryKey) hash() int {</span><br><span class="line">    // 将名字的Hash和年龄哈希合并</span><br><span class="line">    return simpleHash(c.Name) + c.Age*1000000</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，声明查询键的结构，查询键包含需要索引和查询的字段。</li><li>第 8 行，查询键的成员方法哈希，通过调用这个方法获得整个查询键的哈希值。</li><li>第 10 行，查询键哈希的计算方法：使用 simpleHash() 函数根据给定的名字字符串获得其哈希值。同时将年龄乘以 1000000 与名字哈希值相加。</li></ul><p>哈希值构建过程如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicQueryKey.jpg" alt="哈希值构建过程"></p><h5 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h5><p>本例需要快速查询，因此需要提前对已有的数据构建索引。前面已经准备好了数据查询键，使用查询键获得哈希即可对数据进行快速索引，参考下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建哈希值到数据的索引关系</span><br><span class="line">var mapper = make(map[int][]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建数据索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有的数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建数据的查询索引</span><br><span class="line">        key := classicQueryKey{profile.Name, profile.Age}</span><br><span class="line"></span><br><span class="line">        // 计算数据的哈希值, 取出已经存在的记录</span><br><span class="line">        existValue := mapper[key.hash()]</span><br><span class="line"></span><br><span class="line">        // 将当前数据添加到已经存在的记录切片中</span><br><span class="line">        existValue = append(existValue, profile)</span><br><span class="line"></span><br><span class="line">        // 将切片重新设置到映射中</span><br><span class="line">        mapper[key.hash()] = existValue</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，实例化一个 map，键类型为整型，保存哈希值；值类型为 *Profile，为通讯簿的数据格式。</li><li>第 5 行，构建索引函数入口，传入数据切片。</li><li>第 8 行，遍历数据切片的所有数据元素。</li><li>第 11 行，使用查询键（classicQueryKey）来辅助计算哈希值，查询键需要填充两个字段，将数据中的名字和年龄赋值到查询键中进行保存。</li><li>第 14 行，使用查询键的哈希方法计算查询键的哈希值。通过这个值在 mapper 索引中查找相同哈希值的数据切片集合。因为哈希函数不能保证不同数据的哈希值一定完全不同，因此要考虑在发生哈希值重复时的处理办法。</li><li>第 17 行，将当前数据添加到可能存在的切片中。</li><li>第 20 行，将新添加好的数据切片重新赋值到相同哈希的 mapper 中。</li></ul><p>具体哈希结构如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/classicMap.jpg" alt="图：哈希结构"></p><p>这种多键的算法就是哈希算法。map 的多个元素对应哈希的“桶”。哈希函数的选择决定桶的映射好坏，如果哈希冲撞很厉害，那么就需要将发生冲撞的相同哈希值的元素使用切片保存起来。</p><h5 id="经典查询逻辑"><a href="#经典查询逻辑" class="headerlink" title="经典查询逻辑"></a>经典查询逻辑</h5><p>从已经构建好索引的数据中查询需要的数据流程如下：</p><ul><li>给定查询条件（名字、年龄）。</li><li>根据查询条件构建查询键。</li><li>查询键生成哈希值。</li><li>根据哈希值在索引中查找数据集合。</li><li>遍历数据集合逐个与条件比对。</li><li>获得结果。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据给定查询条件构建查询键</span><br><span class="line">    keyToQuery := classicQueryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 计算查询键的哈希值并查询, 获得相同哈希值的所有结果集合</span><br><span class="line">    resultList := mapper[keyToQuery.hash()]</span><br><span class="line"></span><br><span class="line">    // 遍历结果集合</span><br><span class="line">    for _, result := range resultList {</span><br><span class="line"></span><br><span class="line">        // 与查询结果比对, 确认找到打印结果</span><br><span class="line">        if result.Name == name &amp;&amp; result.Age == age {</span><br><span class="line">            fmt.Println(result)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 没有查询到时, 打印结果</span><br><span class="line">    fmt.Println("no found")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，查询条件（名字、年龄）。</li><li>第 4 行，根据查询条件构建查询键。</li><li>第 7 行，使用查询键计算哈希值，使用哈希值查询相同哈希值的所有数据集合。</li><li>第 10 行，遍历所有相同哈希值的数据集合。</li><li>第 13 行，将每个数据与查询条件进行比对，如果一致，表示已经找到结果，打印并返回。</li><li>第 20 行，没有找到记录时，打印 no found。</li></ul><h4 id="利用-map-特性的多键索引及查询"><a href="#利用-map-特性的多键索引及查询" class="headerlink" title="利用 map 特性的多键索引及查询"></a>利用 map 特性的多键索引及查询</h4><p>使用结构体进行多键索引和查询比传统的写法更为简单，最主要的区别是无须准备哈希函数及相应的字段无须做哈希合并。看下面的实现流程。</p><h5 id="经典构建索引"><a href="#经典构建索引" class="headerlink" title="经典构建索引"></a>经典构建索引</h5><p>代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 查询键</span><br><span class="line">type queryKey struct {</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建查询键到数据的映射</span><br><span class="line">var mapper = make(map[queryKey]*Profile)</span><br><span class="line"></span><br><span class="line">// 构建查询索引</span><br><span class="line">func buildIndex(list []*Profile) {</span><br><span class="line"></span><br><span class="line">    // 遍历所有数据</span><br><span class="line">    for _, profile := range list {</span><br><span class="line"></span><br><span class="line">        // 构建查询键</span><br><span class="line">        key := queryKey{</span><br><span class="line">            Name: profile.Name,</span><br><span class="line">            Age:  profile.Age,</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 保存查询键</span><br><span class="line">        mapper[key] = profile</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 2 行，与基于哈希值的查询键的结构相同。</li><li>第 8 行，在 map 的键类型上，直接使用了查询键结构体。注意，这里不使用查询键的指针。同时，结果只有 <code>*Profile</code> 类型，而不是 <code>*Profile</code> 切片，表示查到的结果唯一。</li><li>第 17 行，类似的，使用遍历到的数据的名字和年龄构建查询键。</li><li>第 23 行，更简单的，直接将查询键保存对应的数据。</li></ul><h5 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 根据条件查询数据</span><br><span class="line">func queryData(name string, age int) {</span><br><span class="line"></span><br><span class="line">    // 根据查询条件构建查询键</span><br><span class="line">    key := queryKey{name, age}</span><br><span class="line"></span><br><span class="line">    // 根据键值查询数据</span><br><span class="line">    result, ok := mapper[key]</span><br><span class="line"></span><br><span class="line">    // 找到数据打印出来</span><br><span class="line">    if ok {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("no found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 5 行，根据查询条件（名字、年龄）构建查询键。</li><li>第 8 行，直接使用查询键在 map 中查询结果。</li><li>第 12 行，找到结果直接打印。</li><li>第 14 行，没有找到结果打印 no found。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>基于哈希值的多键索引查询和利用 map 特性的多键索引查询的代码复杂程度显而易见。聪明的程序员都会利用 Go语言的特性进行快速的多键索引查询。</p><p>其实，利用 map 特性的例子中的 map 类型即便修改为下面的格式，也一样可以获得同样的结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mapper = make(map[interface{}]*Profile)</span><br></pre></td></tr></tbody></table></figure><p>代码量大大减少的关键是：Go语言的底层会为 map 的键自动构建哈希值。能够构建哈希值的类型必须是非动态类型、非指针、函数、闭包。</p><ul><li>非动态类型：可用数组，不能用切片。</li><li>非指针：每个指针数值都不同，失去哈希意义。</li><li>函数、闭包不能作为 map 的键。</li></ul><h3 id="sync-Map（同步map"><a href="#sync-Map（同步map" class="headerlink" title="sync.Map（同步map)"></a>sync.Map（同步map)</h3><p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p><p>下面来看下并发情况下读写 map 时会出现的问题，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个int到int的映射</span><br><span class="line">m := make(map[int]int)</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行写入</span><br><span class="line">    for {</span><br><span class="line">        m[1] = 1</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 开启一段并发代码</span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    // 不停地对map进行读取</span><br><span class="line">    for {</span><br><span class="line">        _ = m[1]</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 无限循环, 让并发程序在后台执行</span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行代码会报错，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></tbody></table></figure><p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p>sync.Map 有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li></ul><p>并发安全的 sync.Map 演示代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">      "fmt"</span><br><span class="line">      "sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var scene sync.Map</span><br><span class="line"></span><br><span class="line">    // 将键值对保存到sync.Map</span><br><span class="line">    scene.Store("greece", 97)</span><br><span class="line">    scene.Store("london", 100)</span><br><span class="line">    scene.Store("egypt", 200)</span><br><span class="line"></span><br><span class="line">    // 从sync.Map中根据键取值</span><br><span class="line">    fmt.Println(scene.Load("london"))</span><br><span class="line"></span><br><span class="line">    // 根据键删除对应的键值对</span><br><span class="line">    scene.Delete("london")</span><br><span class="line"></span><br><span class="line">    // 遍历所有sync.Map中的键值对</span><br><span class="line">    scene.Range(func(k, v interface{}) bool {</span><br><span class="line"></span><br><span class="line">        fmt.Println("iterate:", k, v)</span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100 true</span><br><span class="line">iterate: egypt 200</span><br><span class="line">iterate: greece 97</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 10 行，声明 scene，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。</li><li>第 13～15 行，将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。</li><li>第 18 行，提供一个 sync.Map 的键给 scene.Load() 方法后将查询到键对应的值返回。</li><li>第 21 行，sync.Map 的 Delete 可以使用指定的键将对应的键值对删除。</li><li>第 24 行，Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。</li></ul><p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h2 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h2><p>列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p><p>列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.jpg" alt="图：三人单向通知电话号码形成单链表结构"></p><p>如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.jpg" alt="图：三人相互通知电话号码形成双链表结构"></p><p>那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。</p><p>如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/removelinklist.jpg" alt="图：从双链表中删除一人的电话号码"></p><p>在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</p><p>1) 通过 container/list 包的 New() 函数初始化 list</p><figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></tbody></table></figure><p>2) 通过 var 关键字声明初始化 list</p><figure class="highlight plain"><figcaption><span>list</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 list.List</span><br></pre></td></tr></tbody></table></figure><p>列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。</p><h3 id="在列表中插入元素"><a href="#在列表中插入元素" class="headerlink" title="在列表中插入元素"></a>在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。</p><p><strong><em>提示：这两个方法都会返回一个 `</em>list.Element<code>结构，如果在以后的使用中需要删除插入的元素，则只能通过</code><em>list.Element` 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。</em></strong></p><p>下面代码展示如何给 list 添加元素：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">l.PushBack("fist")</span><br><span class="line">l.PushFront(67)</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，创建一个列表实例。</li><li>第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。</li><li>第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。</li></ul><p>列表插入元素的方法如下表所示。</p><table>  <thead><tr><th>方  法</th><th>功  能</th></tr></thead>  <tbody>    <tr><th>InsertAfter(v interface {}, mark * Element) * Element</th><th>在 mark 点之后插入元素，mark 点由其他插入函数提供</th></tr>    <tr><th>InsertBefore(v interface {}, mark * Element) *Element</th><th>在 mark 点之前插入元素，mark 点由其他插入函数提供</th></tr>    <tr><th>PushBackList(other *List)</th><th>添加 other 列表元素到尾部</th></tr>    <tr><th>PushFrontList(other *List)</th><th>添加 other 列表元素到头部</th></tr>  </tbody></table><h3 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h3><p>列表插入函数的返回值会提供一个 <code>*list.Element</code> 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。</p><p>列表操作元素：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "container/list"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    // 尾部添加</span><br><span class="line">    l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">    // 头部添加</span><br><span class="line">    l.PushFront(67)</span><br><span class="line"></span><br><span class="line">    // 尾部添加后保存元素句柄</span><br><span class="line">    element := l.PushBack("fist")</span><br><span class="line"></span><br><span class="line">    // 在fist之后添加high</span><br><span class="line">    l.InsertAfter("high", element)</span><br><span class="line"></span><br><span class="line">    // 在fist之前添加noon</span><br><span class="line">    l.InsertBefore("noon", element)</span><br><span class="line"></span><br><span class="line">    // 使用</span><br><span class="line">    l.Remove(element)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 6 行，创建列表实例。</li><li>第 9 行，将字符串 canon 插入到列表的尾部。</li><li>第 12 行，将数值 67 添加到列表的头部。</li><li>第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。</li><li>第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。</li><li>第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。</li><li>第 24 行，移除 element 变量对应的元素。</li></ul><p>下表中展示了每次操作后列表的实际元素情况。</p><p>列表元素操作的过程</p><table>  <thead><tr><th>操作内容</th><th>列表元素</th></tr></thead>  <tbody>    <tr><th>l.PushBack("canon")</th><th>canon</th></tr>    <tr><th>l.PushFront(67)</th><th>67, canon</th></tr>    <tr><th>element := l.PushBack("fist")</th><th>67, canon, fist</th></tr>    <tr><th>l.InsertAfter("high", element)</th><th>67, canon, fist, high</th></tr>    <tr><th>l.InsertBefore("noon", element)</th><th>67, canon, noon, fist, high</th></tr>    <tr><th>l.Remove(element)</th><th>67, canon, noon, high</th></tr>  </tbody></table><h3 id="遍历列表——访问列表的每一个元素"><a href="#遍历列表——访问列表的每一个元素" class="headerlink" title="遍历列表——访问列表的每一个元素"></a>遍历列表——访问列表的每一个元素</h3><p>遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">// 尾部添加</span><br><span class="line">l.PushBack("canon")</span><br><span class="line"></span><br><span class="line">// 头部添加</span><br><span class="line">l.PushFront(67)</span><br><span class="line"></span><br><span class="line">for i := l.Front(); i != nil; i = i.Next() {</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">67</span><br><span class="line">canon</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，创建一个列表实例。</li><li>第 4 行，将 canon 放入列表尾部。</li><li>第 7 行，在队列头部放入 67。</li><li>第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。</li><li>第 10 行，使用遍历返回的 <code>*list.Element</code> 的 Value 成员取得放入列表时的原值。</li></ul><h2 id="go-nil：空值-零值"><a href="#go-nil：空值-零值" class="headerlink" title="go nil：空值/零值"></a>go nil：空值/零值</h2><p>在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串””，而指针、切片、映射、通道、函数和接口的零值则是 nil。</p><p>nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。</p><p>下面通过几个方面来介绍一下Go语言中 nil。</p><h3 id="nil-标识符是不能比较的"><a href="#nil-标识符是不能比较的" class="headerlink" title="nil 标识符是不能比较的"></a>nil 标识符是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(nil==nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:8:21: invalid operation: nil == nil (operator == not defined on nil)</span><br></pre></td></tr></tbody></table></figure><p>这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; None == None</span><br><span class="line">True</span><br></pre></td></tr></tbody></table></figure><p>从上面的运行结果不难看出，== 对于 nil 来说是一种未定义的操作。</p><h3 id="nil-不是关键字或保留字"><a href="#nil-不是关键字或保留字" class="headerlink" title="nil 不是关键字或保留字"></a>nil 不是关键字或保留字</h3><p>nil 并不是Go语言的关键字或者保留字，也就是说我们可以定义一个名称为 nil 的变量，比如下面这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nil = errors.New("my god")</span><br></pre></td></tr></tbody></table></figure><p>虽然上面的声明语句可以通过编译，但是并不提倡这么做。</p><h3 id="nil-没有默认类型"><a href="#nil-没有默认类型" class="headerlink" title="nil 没有默认类型"></a>nil 没有默认类型</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%T", nil)</span><br><span class="line">    print(nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:9:10: use of untyped nil</span><br></pre></td></tr></tbody></table></figure><h3 id="不同类型-nil-的指针是一样的"><a href="#不同类型-nil-的指针是一样的" class="headerlink" title="不同类型 nil 的指针是一样的"></a>不同类型 nil 的指针是一样的</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var arr []int</span><br><span class="line">    var num *int</span><br><span class="line">    fmt.Printf("%p\n", arr)</span><br><span class="line">    fmt.Printf("%p", num)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0</span><br><span class="line">0x0</span><br></pre></td></tr></tbody></table></figure><p>通过运行结果可以看出 arr 和 num 的指针都是 0x0。</p><h3 id="不同类型的-nil-是不能比较的"><a href="#不同类型的-nil-是不能比较的" class="headerlink" title="不同类型的 nil 是不能比较的"></a>不同类型的 nil 是不能比较的</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    fmt.Printf(m == ptr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:20: invalid operation: arr == ptr (mismatched types []int and *int)</span><br></pre></td></tr></tbody></table></figure><h3 id="两个相同类型的-nil-值也可能无法比较"><a href="#两个相同类型的-nil-值也可能无法比较" class="headerlink" title="两个相同类型的 nil 值也可能无法比较"></a>两个相同类型的 nil 值也可能无法比较</h3><p>在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的，下面的语句无法编译。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    var s2 []int</span><br><span class="line">    fmt.Printf(s1 == s2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\main.go:10:19: invalid operation: s1 == s2 (slice can only be compared to nil)</span><br></pre></td></tr></tbody></table></figure><p>通过上面的错误提示可以看出，能够将上述不可比较类型的空值直接与 nil 标识符进行比较，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var s1 []int</span><br><span class="line">    fmt.Println(s1 == nil)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></tbody></table></figure><h3 id="nil-是-map、slice、pointer、channel、func、interface-的零值"><a href="#nil-是-map、slice、pointer、channel、func、interface-的零值" class="headerlink" title="nil 是 map、slice、pointer、channel、func、interface 的零值"></a>nil 是 map、slice、pointer、channel、func、interface 的零值</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var m map[int]string</span><br><span class="line">    var ptr *int</span><br><span class="line">    var c chan int</span><br><span class="line">    var sl []int</span><br><span class="line">    var f func()</span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Printf("%#v\n", m)</span><br><span class="line">    fmt.Printf("%#v\n", ptr)</span><br><span class="line">    fmt.Printf("%#v\n", c)</span><br><span class="line">    fmt.Printf("%#v\n", sl)</span><br><span class="line">    fmt.Printf("%#v\n", f)</span><br><span class="line">    fmt.Printf("%#v\n", i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map[int]string(nil)</span><br><span class="line">(*int)(nil)</span><br><span class="line">(chan int)(nil)</span><br><span class="line">[]int(nil)</span><br><span class="line">(func())(nil)</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure><p>零值是Go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值。</p><h3 id="不同类型的-nil-值占用的内存大小可能是不一样的"><a href="#不同类型的-nil-值占用的内存大小可能是不一样的" class="headerlink" title="不同类型的 nil 值占用的内存大小可能是不一样的"></a>不同类型的 nil 值占用的内存大小可能是不一样的</h3><p>一个类型的所有的值的内存布局都是一样的，nil 也不例外，nil 的大小与同类型中的非 nil 类型的大小是一样的。但是不同类型的 nil 值的大小可能不同。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "unsafe"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var p *struct{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( p ) ) // 8</span><br><span class="line"></span><br><span class="line">    var s []int</span><br><span class="line">    fmt.Println( unsafe.Sizeof( s ) ) // 24</span><br><span class="line"></span><br><span class="line">    var m map[int]bool</span><br><span class="line">    fmt.Println( unsafe.Sizeof( m ) ) // 8</span><br><span class="line"></span><br><span class="line">    var c chan string</span><br><span class="line">    fmt.Println( unsafe.Sizeof( c ) ) // 8</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line">    fmt.Println( unsafe.Sizeof( f ) ) // 8</span><br><span class="line"></span><br><span class="line">    var i interface{}</span><br><span class="line">    fmt.Println( unsafe.Sizeof( i ) ) // 16</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">24</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure><p>具体的大小取决于编译器和架构，上面打印的结果是在 64 位架构和标准编译器下完成的，对应 32 位的架构的，打印的大小将减半。</p><h2 id="make和new关键字的区别及实现原理"><a href="#make和new关键字的区别及实现原理" class="headerlink" title="make和new关键字的区别及实现原理"></a>make和new关键字的区别及实现原理</h2><p>Go语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化，下面我们就来具体介绍一下。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>在Go语言中，new 函数描述如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The new built-in function allocates memory. The first argument is a type,</span><br><span class="line">// not a value, and the value returned is a pointer to a newly</span><br><span class="line">// allocated zero value of that type.</span><br><span class="line">func new(Type) *Type</span><br></pre></td></tr></tbody></table></figure><p>从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。</p><p>【示例】使用 new 函数为变量分配内存空间。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sum *int</span><br><span class="line">sum = new(int) //分配空间</span><br><span class="line">*sum = 98</span><br><span class="line">fmt.Println(*sum)</span><br></pre></td></tr></tbody></table></figure><p>当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Student struct {</span><br><span class="line">   name string</span><br><span class="line">   age int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var s *Student</span><br><span class="line">s = new(Student) //分配空间</span><br><span class="line">s.name ="dequan"</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure><p>这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277]</span><br><span class="line">goroutine 1 [running]:</span><br></pre></td></tr></tbody></table></figure><p>这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><p>在Go语言中，make 函数的描述如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// The make built-in function allocates and initializes an object of type</span><br><span class="line">// slice, map, or chan (only). Like new, the first argument is a type, not a</span><br><span class="line">// value. Unlike new, make's return type is the same as the type of its</span><br><span class="line">// argument, not a pointer to it. The specification of the result depends on</span><br><span class="line">// the type:</span><br><span class="line">// Slice: The size specifies the length. The capacity of the slice is</span><br><span class="line">// equal to its length. A second integer argument may be provided to</span><br><span class="line">// specify a different capacity; it must be no smaller than the</span><br><span class="line">// length, so make([]int, 0, 10) allocates a slice of length 0 and</span><br><span class="line">// capacity 10.</span><br><span class="line">// Map: An empty map is allocated with enough space to hold the</span><br><span class="line">// specified number of elements. The size may be omitted, in which case</span><br><span class="line">// a small starting size is allocated.</span><br><span class="line">// Channel: The channel's buffer is initialized with the specified</span><br><span class="line">// buffer capacity. If zero, or the size is omitted, the channel is</span><br><span class="line">// unbuffered.</span><br><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></tbody></table></figure><p>通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。</p><p><strong><em>注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。</em></strong></p><p>Go语言中的 new 和 make 主要区别如下：</p><ul><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；</li><li>new 分配返回的是指针，即类型 <code>*Type</code> 。make 返回引用，即 Type；</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化；</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>接下来我们将分别介绍一下 make 和 new 在初始化不同<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。</p><h4 id="make原理"><a href="#make原理" class="headerlink" title="make原理"></a>make原理</h4><p>我们已经了解了 make 在创建 slice、map 和 channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>初始化原理。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/maketypecheck.gif" alt="GOLang Make TypeCheck"></p><p>在编译期的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。</p><h4 id="new原理"><a href="#new原理" class="headerlink" title="new原理"></a>new原理</h4><p>内置函数 new 会在编译期的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func callnew(t *types.Type) *Node {</span><br><span class="line">    if t.NotInHeap() {</span><br><span class="line">        yyerror("%v is go:notinheap; heap allocation disallowed", t)</span><br><span class="line">    }</span><br><span class="line">    dowidth(t)</span><br><span class="line"></span><br><span class="line">    if t.Size() == 0 {</span><br><span class="line">        z := newname(Runtimepkg.Lookup("zerobase"))</span><br><span class="line">        z.SetClass(PEXTERN)</span><br><span class="line">        z.Type = t</span><br><span class="line">        return typecheck(nod(OADDR, z, nil), ctxExpr)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fn := syslook("newobject")</span><br><span class="line">    fn = substArgTypes(fn, t)</span><br><span class="line">    v := mkcall1(fn, types.NewPtr(t), nil, typename(t))</span><br><span class="line">    v.SetNonNil(true)</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func walkstmt(n *Node) *Node {</span><br><span class="line">    switch n.Op {</span><br><span class="line">    case ODCL:</span><br><span class="line">        v := n.Left</span><br><span class="line">        if v.Class() == PAUTOHEAP {</span><br><span class="line">            if prealloc[v] == nil {</span><br><span class="line">                prealloc[v] = callnew(v.Type)</span><br><span class="line">            }</span><br><span class="line">            nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])</span><br><span class="line">            nn.SetColas(true)</span><br><span class="line">            nn = typecheck(nn, ctxStmt)</span><br><span class="line">            return walkstmt(nn)</span><br><span class="line">        }</span><br><span class="line">    case ONEW:</span><br><span class="line">        if n.Esc == EscNone {</span><br><span class="line">            r := temp(n.Type.Elem())</span><br><span class="line">            r = nod(OAS, r, nil)</span><br><span class="line">            r = typecheck(r, ctxStmt)</span><br><span class="line">            init.Append(r)</span><br><span class="line">            r = nod(OADDR, r.Left, nil)</span><br><span class="line">            r = typecheck(r, ctxExpr)</span><br><span class="line">            n = r</span><br><span class="line">        } else {</span><br><span class="line">            n = callnew(n.Type.Elem())</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。</p><p>newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func newobject(typ *_type) unsafe.Pointer {</span><br><span class="line">    return mallocgc(typ.size, typ, true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="make-和new-总结"><a href="#make-和new-总结" class="headerlink" title="make 和new 总结"></a>make 和new 总结</h3><p>最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 容器 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 数组 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言适合做什么</title>
      <link href="posts/30ebccd/"/>
      <url>posts/30ebccd/</url>
      
        <content type="html"><![CDATA[<p>前面我们已经介绍过了 <code>Go</code> 语言的种种优势和不足，那么我们究竟可以使用 <code>Go</code> 语言来做些什么呢？</p><p>其实 <code>Go</code> 语言主要用作服务器端开发，其定位是用来开发“大型软件”的，适合于需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的网络服务。</p><p><code>Go</code> 语言融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性，不仅提高了项目的开发速度，而且后期维护起来也非常轻松。</p><p>鉴于 <code>Go</code> 语言的特点和设计的初衷，从以下几个方面来分析 <code>Go</code> 语言擅长的领域：</p><ul><li>在服务器编程方面，<code>Go</code> 语言适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；</li><li>网络编程方面，<code>Go</code> 语言广泛应用于 <code>Web</code> 应用、<code>API</code> 应用、下载应用等；</li><li>此外，<code>Go</code> 语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 <code>Go</code> 开发。</li></ul><p>除了上面介绍到的，<code>Go</code> 语言还可以用来开发底层，例如以太坊、超级账本等都是基于 <code>Go</code> 语言开发的。</p><p>而且对于现在比较流行的区块链技术方面，<code>Go</code> 语言也是非常受欢迎的，很多基于区块链的 <code>DApps</code>（去中心化应用）和工具都是用的 <code>Go</code> 语言来实现的。</p><p>下面列举了一些基于 <code>Go</code> 语言开发的优秀开源项目：<br>云计算基础设施领域，代表项目：<code>docker</code> 、<code>kubernetes</code> 、<code>etcd</code> 、<code>consul</code> 、<code>cloudflare CDN</code> 、七牛云存储等。<br>基础软件，代表项目：<code>tidb</code> 、<code>influxdb</code> 、<code>cockroachdb</code> 等。<br>微服务，代表项目：<code>go-kit</code> 、<code>micro</code> 、<code>monzo bank</code> 的 <code>typhon</code> 、<code>bilibili</code> 等。<br>互联网基础设施，代表项目：以太坊、<code>hyperledger</code> 等。</p><p>总之，<code>Go</code> 语言的优势还是比较多的，比如 <code>Go</code> 语言的性能非常出色，最关键的是在性能强劲的同时还能像解释型语言一样高效地进行开发。</p><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5721.html">Go语言是怎么完成编译的</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4774.html">Go语言依赖管理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/129.html">Go语言map的多键索引</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5722.html">Go语言make和new关键字的区别及实现原理</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5571.html">Go语言分布式id生成器</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5728.html">Go语言冒泡排序</a></p><h2 id="Go语言依赖管理"><a href="#Go语言依赖管理" class="headerlink" title="Go语言依赖管理"></a>Go语言依赖管理</h2><p>早期的Go语言被很多开发者所吐槽的一个问题就是没有依赖包的管理，不过随着版本的不断更迭，Go语言依赖管理方面也在不断的完善。</p><h3 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h3><p>最初的时候Go语言所依赖的所有的第三方包都放在 GOPATH 目录下面，这就导致了同一个包只能保存一个版本的代码，如果不同的项目依赖同一个第三方的包的不同版本，应该怎么解决呢？</p><h3 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h3><p>godep 是一个Go语言官方提供的通过 vender 模式来管理第三方依赖的工具，类似的还有由社区维护的准官方包管理工具 dep。</p><p>Go语言从 1.5 版本开始开始引入 vendor 模式，如果项目目录下有 vendor 目录，那么Go语言编译器会优先使用 vendor 内的包进行编译、测试等。</p><h4 id="安装godep工具"><a href="#安装godep工具" class="headerlink" title="安装godep工具"></a>安装godep工具</h4><p>我们可以通过go get 命令来获取 godep 工具。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tools/godep</span><br></pre></td></tr></tbody></table></figure><p>命令执行成功后会将 godep 工具的源码下载到 GOPATH 的 src 目录下对应的文件夹中，同时还会在 GOPATH 的 bin 目录下生成一个名为 godep.exe 的可执行文件。</p><p>为了方便使用 godep 工具，我们需要将存放 godep.exe 文件的目录添加到环境变量 PATH 中。在系统变量中找到并选中“Path”一行，点击“编辑”按钮，在新弹出的窗口中点击“新建”，然后在最下面一行中填入对应的目录信息。确认无误后点击“确定”。</p><h4 id="godep工具的基本命令"><a href="#godep工具的基本命令" class="headerlink" title="godep工具的基本命令"></a>godep工具的基本命令</h4><p>完成上面的操作后，我们就可以在命令行窗口（CMD）中使用 godep 工具了，godep 支持的命令如下表所示：</p><table>  <thead><tr><th>命令</th><th>作用</th></tr></thead>  <tbody>    <tr><th>godep save</th><th>将依赖包的信息保存到 Godeps.json 文件中</th></tr>    <tr><th>godep go</th><th>使用保存的依赖项运行 go 工具</th></tr>    <tr><th>godep get</th><th>下载并安装指定的包</th></tr>    <tr><th>godep path</th><th>打印依赖的 GOPATH 路径</th></tr>    <tr><th>godep restore</th><th>在 GOPATH 中拉取依赖的版本</th></tr>    <tr><th>godep update</th><th>更新选定的包或 go 版本</th></tr>    <tr><th>godep diff</th><th>显示当前和以前保存的依赖项集之间的差异</th></tr>    <tr><th>godep version</th><th>查看版本信息</th></tr>  </tbody></table><p>使用 <code>godep help [命令名称]</code> 可以查看命令的帮助信息，如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy&gt;godep help go</span><br><span class="line">Args: godep go [-v] [-d] command [arguments]</span><br><span class="line"></span><br><span class="line">Go runs the go tool with a modified GOPATH giving access to</span><br><span class="line">dependencies saved in Godeps.</span><br><span class="line"></span><br><span class="line">Any go tool command can run this way, but "godep go get"</span><br><span class="line">is unnecessary and has been disabled. Instead, use</span><br><span class="line">"godep go install".</span><br><span class="line"></span><br><span class="line">If -v is given, verbose output is enabled.</span><br><span class="line"></span><br><span class="line">If -d is given, debug output is enabled (you probably don't want this, see -v).</span><br></pre></td></tr></tbody></table></figure><h4 id="使用godep工具"><a href="#使用godep工具" class="headerlink" title="使用godep工具"></a>使用godep工具</h4><p>执行 <code>godep save</code> 命令，会在当前目录中创建 Godeps 和 vender 两个文件夹。Godeps 文件夹下会生成一个 Godeps.json 文件，用来记录项目中所依赖的包信息；vender 目录则是用来保存当前项目所依赖的所有第三方包。</p><p>生成的 Godeps.json 文件的结构如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "ImportPath": "main",</span><br><span class="line">    "GoVersion": "go1.13",</span><br><span class="line">    "GodepVersion": "v80",</span><br><span class="line">    "Deps": [</span><br><span class="line">        {</span><br><span class="line">            "ImportPath": "github.com/go-gomail/gomail",</span><br><span class="line">            "Comment": "2.0.0-23-g81ebce5",</span><br><span class="line">            "Rev": "81ebce5c23dfd25c6c67194b37d3dd3f338c98b1"</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，“ImportPath”为项目的路径信息，“GoVersion”为Go语言的版本号，“GodepVersion”为 godep 工具的版本号，“Deps”为当前依赖包的路径、版本号信息等等。</p><p><strong><em>提示：当引用的第三方包要升级时，只需要修改 Godep.json 里面的依赖包的版本号，然后再次执行 godep save 命令即可。</em></strong></p><p>godep 工具的主要功能就是控制Go语言程序编译时依赖包搜索路径的优先级。例如查找项目的某个依赖包，首先会在项目根目录下的 vender 文件夹中查找，如果没有找到就会去 GOAPTH/src 目录下查找。</p><h3 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h3><p>go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。</p><h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h4><p>在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。</p><ul><li>GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。</li><li>GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li><li>GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。</li></ul><p>Windows 下开启 GO111MODULE 的命令为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set GO111MODULE=on 或者 set GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure><p>MacOS 或者 Linux 下开启 GO111MODULE 的命令为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on 或者 export GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure><p>在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p><p>使用 go module 的 <code>go mod init</code> 命令后会在当前目录下生成一个 go. mod 文件，并且在编译/运行当前目录下代码或者使用 <code>go get</code> 命令的时候会在当前目录下生成一个 go.sum 文件。</p><p>go.mod 文件记录了项目所有的依赖信息，其结构大致如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module github.com/dubbogo/dubbo-go-proxy</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/apache/dubbo-go v1.5.1</span><br><span class="line">github.com/apache/dubbo-go-hessian2 v1.6.2</span><br><span class="line">github.com/dubbogo/gost v1.9.2</span><br><span class="line">github.com/emirpasic/gods v1.12.0</span><br><span class="line">github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32</span><br><span class="line">github.com/goinggo/mapstructure v0.0.0-20140717182941-194205d9b4a9</span><br><span class="line">github.com/kr/fs v0.1.0 // indirect</span><br><span class="line">github.com/pkg/errors v0.9.1</span><br><span class="line">github.com/stretchr/testify v1.6.1</span><br><span class="line">github.com/tools/godep v0.0.0-20180126220526-ce0bfadeb516 // indirect</span><br><span class="line">github.com/urfave/cli v1.22.4</span><br><span class="line">go.uber.org/zap v1.15.0</span><br><span class="line">gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>其中，module 为 go.mod 文件所属的包，require 为项目所依赖的包及版本号，indirect 表示间接引用。</p><p>go.sum 文件则是用来记录每个依赖包的版本及哈希值，如下所示。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=</span><br><span class="line">cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=</span><br><span class="line">cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=</span><br><span class="line">dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=</span><br><span class="line">github.com/Azure/azure-sdk-for-go v40.3.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.0/go.mod h1:xyHB1BMZT0cuDHU7I0+g046+BFDTQ8rEZB0s4Yfa6bI=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.9.3/go.mod h1:GsRuLYvwzLjjjRoWEIyMUaYq8GNUx2nRB378IPt/1p0=</span><br><span class="line">github.com/Azure/go-autorest/autorest v0.10.0/go.mod h1:/FALq9T/kS7b5J5qsQ+RSTUdAmGFqi0vUdVNNx8q630=</span><br></pre></td></tr></tbody></table></figure><p>常用的 go mod 命令如下表所示：</p><table>  <thead><tr><th>命令</th><th>作用</th></tr></thead>  <tbody>    <tr><th>go mod download</th><th>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</th></tr>    <tr><th>go mod edit</th><th>编辑 go.mod 文件</th></tr>    <tr><th>go mod graph</th><th>打印模块依赖图</th></tr>    <tr><th>go mod init</th><th>初始化当前文件夹，创建 go.mod 文件</th></tr>    <tr><th>go mod tidy</th><th>增加缺少的包，删除无用的包</th></tr>    <tr><th>go mod vendor</th><th>将依赖复制到 vendor 目录下</th></tr>    <tr><th>go mod verify</th><th>校验依赖</th></tr>    <tr><th>go mod why</th><th>解释为什么需要依赖</th></tr>  </tbody></table><h4 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h4><p>proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过 <code>go get</code>  命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。</p><p>目前公开的代理服务器的地址有：</p><ul><li>goproxy.io</li><li>goproxy.cn：（推荐）由国内的七牛云提供。</li></ul><p>Windows 下设置 GOPROXY 的命令为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></tbody></table></figure><p>MacOS 或 Linux 下设置 GOPROXY 的命令为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></tbody></table></figure><p>Go语言在 1.13 版本之后 GOPROXY 默认值为 <a target="_blank" rel="noopener" href="https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将">https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将</a> GOPROXY 设置为国内的 goproxy.cn。</p><p>使用 <code>go get</code> 命令下载指定版本的依赖包</p><p>执行go get 命令，在下载依赖包的同时还可以指定依赖包的版本。</p><ul><li>运行go get -u命令会将项目中的包升级到最新的次要版本或者修订版本；</li><li>运行go get -u=patch命令会将项目中的包升级到最新的修订版本；</li><li>运行go get [包名]@[版本号]命令会下载对应包的指定版本或者将对应包升级到指定的版本。</li></ul><p><strong><em>提示：<code>go get [包名]@[版本号]</code> 命令中版本号可以是 x.y.z 的形式，例如 <code>go get foo@v1.2.3</code> ，也可以是 git 上的分支或 tag，例如 <code>go get foo@master</code> ，还可以是 git 提交时的哈希值，例如 <code>go get foo@e3702bed2</code> 。</em></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 语言基础</title>
      <link href="posts/f628ea56/"/>
      <url>posts/f628ea56/</url>
      
        <content type="html"><![CDATA[<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p><code>Go</code>语言是静态类型语言，因此变量<code>（variable）</code>是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。</p><p>声明变量的一般形式是使用 <code>var</code> 关键字：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name type</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>var</code> 是声明变量的关键字，<code>name</code> 是变量名，<code>type</code> 是变量的类型。</p><p>需要注意的是，<code>Go</code>语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b</code>; 。其中只有 <code>a</code> 是指针而 <code>b</code> 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 <code>Go</code> 中，则可以和轻松地将它们都声明为指针类型：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a, b *int</span><br></pre></td></tr></tbody></table></figure><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Go语言的基本类型有：</p><ul><li>bool</li><li>string</li><li>int、int8、int16、int32、int64</li><li>uint、uint8、uint16、uint32、uint64、uintptr</li><li>byte // uint8 的别名</li><li>rune // int32 的别名 代表一个 Unicode 码</li><li>float32、float64</li><li>complex64、complex128</li></ul><p>当一个变量被声明之后，系统自动赋予它该类型的零值：<code>int</code> 为 <code>0</code>，<code>float</code> 为 <code>0.0</code>，<code>bool</code> 为 <code>false</code>，<code>string</code> 为空字符串，指针为 <code>nil</code> 等。所有的内存在 <code>Go</code> 中都是经过初始化的。</p><p>变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：<code>numShips</code> 和 <code>startDate</code> 。</p><p>变量的声明有几种形式，通过下面几节进行整理归纳。</p><h3 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></tbody></table></figure><p>变量声明以关键字 var 开头，后置变量类型，行尾无须分号。</p><h3 id="批量格式"><a href="#批量格式" class="headerlink" title="批量格式"></a>批量格式</h3><p>觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line">    c []float32</span><br><span class="line">    d func() bool</span><br><span class="line">    e struct {</span><br><span class="line">        x int</span><br><span class="line">    }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>使用关键字 var 和括号，可以将一组变量定义放在一起。</p><h3 id="简短格式"><a href="#简短格式" class="headerlink" title="简短格式"></a>简短格式</h3><p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名字 := 表达式</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，简短模式<code>（short variable declaration）</code>有以下限制：</p><ul><li>定义变量，同时显式初始化。</li><li>不能提供数据类型。</li><li>只能用在函数内部。</li></ul><p>和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j := 0, 1</span><br></pre></td></tr></tbody></table></figure><p>演示简短格式变量声明的基本样式。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">   x:=100</span><br><span class="line">   a,s:=1, "abc"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。<code>var</code> 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><p><code>Go</code>语言在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：</p><ul><li>整型和浮点型变量的默认值为 <code>0</code> 和 <code>0.0</code>。</li><li>字符串变量的默认值为空字符串。</li><li>布尔型变量默认为 <code>bool</code>。</li><li>切片、函数、指针变量的默认为 <code>nil</code>。</li></ul><p>当然，依然可以在变量声明时赋予变量一个初始值。</p><p>回顾C语言</p><p>在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。</p><p>在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/C++ 中变量默认不初始化。</p><p>微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。</p><p>因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。</p><h3 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 类型 = 表达式</span><br></pre></td></tr></tbody></table></figure><p>例如，游戏中，玩家的血量初始值为100。可以这样写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hp int = 100</span><br></pre></td></tr></tbody></table></figure><p>这句代码中，<code>hp</code> 为变量名，类型为 <code>int</code>，<code>hp</code> 的初始值为 <code>100</code>。</p><p>上面代码中，<code>100</code> 和 <code>int</code> 同为 <code>int</code> 类型，<code>int</code> 可以认为是冗余信息，因此可以进一步简化初始化的写法。</p><h3 id="编译器推导类型的格式"><a href="#编译器推导类型的格式" class="headerlink" title="编译器推导类型的格式"></a>编译器推导类型的格式</h3><p>在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hp = 100</span><br></pre></td></tr></tbody></table></figure><p>等号右边的部分在编译原理里被称做右值（rvalue）。</p><p>编译器根据右值推导变量类型完成初始化的例子。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var attack = 40</span><br><span class="line">var defence = 20</span><br><span class="line">var damageRate float32 = 0.17</span><br><span class="line">var damage = float32(attack-defence) * damageRate</span><br><span class="line">fmt.Println(damage)</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>1</code> 和 <code>2</code> 行，右值为整型，<code>attack</code> 和 <code>defence</code> 变量的类型为 int。</li><li>第 <code>3</code> 行，表达式的右值中使用了 <code>0.17</code>。由于<code>Go</code>语言和<code>C</code>语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 <code>damageRate</code> 变量的类型，<code>Go</code>语言编译器会将 <code>damageRate</code> 类型推导为 <code>float64</code>，我们这里不需要 <code>float64</code> 的精度，所以需要强制指定类型为 <code>float32</code>。</li><li><p>第 <code>4</code> 行，将 <code>attack</code> 和 <code>defence</code> 相减后的数值结果依然为整型，使用 <code>float32()</code> 将结果转换为 <code>float32</code> 类型，再与 <code>float32</code> 类型的 <code>damageRate</code> 相乘后，<code>damage</code> 类型也是 <code>float32</code> 类型。</p><p><strong><em>提示：<code>damage</code> 变量的右值是一个复杂的表达式，整个过程既有 <code>attack</code> 和 <code>defence</code> 的运算还有强制类型转换。</em></strong></p></li><li><p>第 5 行，输出 <code>damage</code> 的值。</p></li></ul><p>以上代码输出结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4</span><br></pre></td></tr></tbody></table></figure><h3 id="短变量声明并初始化"><a href="#短变量声明并初始化" class="headerlink" title="短变量声明并初始化"></a>短变量声明并初始化</h3><p><code>var</code> 的变量声明还有一种更为精简的写法，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hp := 100</span><br></pre></td></tr></tbody></table></figure><p>这是<code>Go</code>语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。</p><p><strong><em>注意：由于使用了<code>:=</code>，而不是赋值的<code>=</code>，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。</em></strong></p><p>如果 hp 已经被声明过，但依然使用:=时编译器会报错，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明 hp 变量</span><br><span class="line">var hp int</span><br><span class="line">// 再次声明并赋值</span><br><span class="line">hp := 10</span><br></pre></td></tr></tbody></table></figure><p>编译报错:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no new variables on left side of :=</span><br></pre></td></tr></tbody></table></figure><p>翻译过来是在<code>:=</code>的左边没有新变量出现，意思就是<code>:=</code>的左边变量已经被声明了。</p><p>短变量声明的形式在开发中的例子较多，比如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial("tcp","127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure><p><code>net.Dial</code> 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象<code>（conn）</code>，一个是错误对象<code>（err）</code>。如果是标准格式将会变成：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var conn net.Conn</span><br><span class="line">var err error</span><br><span class="line">conn, err = net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure><p>因此，短变量声明并初始化的格式在开发中使用比较普遍。</p><p><strong><em>注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：</em></strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial("tcp", "127.0.0.1:8080")</span><br><span class="line">conn2, err := net.Dial("tcp", "127.0.0.1:8080")</span><br></pre></td></tr></tbody></table></figure><p>上面的代码片段，编译器不会报 err 重复定义</p><h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h2><p>编程最简单的算法之一，莫过于变量交换。交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">var t int</span><br><span class="line">t = a</span><br><span class="line">a = b</span><br><span class="line">b = t</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure><p>在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure><p>这样的算法很多，但是都有一定的数值范围和类型要求。</p><p>到了<code>Go</code>语言时，内存不再是紧缺资源，而且写法可以更简单。使用 <code>Go</code> 的“多重赋值”特性，可以轻松完成变量交换的任务：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a int = 100</span><br><span class="line">var b int = 200</span><br><span class="line">b, a = a, b</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></tbody></table></figure><p>多重赋值时，变量的左值和右值按从左到右的顺序赋值。</p><p>多重赋值在<code>Go</code>语言的错误处理和函数返回值中会大量地使用。例如使用<code>Go</code>语言进行排序时就需要使用交换，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>1</code> 行，将 <code>IntSlice</code> 声明为 <code>[]int</code> 类型。</li><li>第 <code>3</code> 行，为 <code>IntSlice</code> 类型编写一个 <code>Len</code> 方法，提供切片的长度。</li><li>第 <code>4</code> 行，根据提供的 <code>i、j</code> 元素索引，获取元素后进行比较，返回比较结果。</li><li>第 <code>5</code> 行，根据提供的 <code>i、j</code> 元素索引，交换两个元素的值。</li></ul><h2 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h2><p>在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。</p><p>匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func GetData() (int, int) {</span><br><span class="line">    return 100, 200</span><br><span class="line">}</span><br><span class="line">func main(){</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 200</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>1</code> 行<code>GetData()</code> 是一个函数，拥有两个整型返回值。每次调用将会返回 <code>100</code> 和 <code>200</code> 两个数值。</li><li>第 <code>5</code> 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。</li><li>第 <code>6</code> 行将第一个返回值的变量设为匿名变量。</li></ul><p>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p><p>提示：在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。</p><p>了解变量的作用域对我们学习<code>Go</code>语言来说是比较重要的，因为<code>Go</code>语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。</p><p>根据变量定义位置的不同，可以分为以下三个类型：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><p>下面就来分别介绍一下。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。</p><p>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。</p><p>【示例】下面的 <code>main()</code> 函数中使用到了局部变量 <code>a、b、c</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量 a 和 b 并赋值</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    //声明局部变量 c 并计算 a 和 b 的和</span><br><span class="line">    c := a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用<code>import</code>关键字引入全局变量所在的源文件之后才能使用这个全局变量。</p><p>全局变量声明必须以 <code>var</code> 关键字开头，<strong><em>如果想要在外部包中使用全局变量的首字母必须大写</em></strong>。</p><p>【示例】下面代码中，第 <code>4</code> 行定义了全局变量 <code>c</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var c int</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a, b int</span><br><span class="line">    //初始化参数</span><br><span class="line">    a = 3</span><br><span class="line">    b = 4</span><br><span class="line">    c = a + b</span><br><span class="line">    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 4, c = 7</span><br></pre></td></tr></tbody></table></figure><p><code>Go</code>语言程序中全局变量与局部变量名称可以相同，<strong><em>但是函数体内的局部变量会被优先考虑</em></strong>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">//声明全局变量</span><br><span class="line">var a float32 = 3.14</span><br><span class="line">func main() {</span><br><span class="line">    //声明局部变量</span><br><span class="line">    var a int = 3</span><br><span class="line">    fmt.Printf("a = %d\n", a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 3</span><br></pre></td></tr></tbody></table></figure><h3 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h3><p>在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。</p><p>形式参数会作为函数的局部变量来使用。</p><p>【示例】下面代码中第 <code>16</code> 行定义了形式参数 <code>a</code> 和 <code>b</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">//全局变量 a</span><br><span class="line">var a int = 13</span><br><span class="line">func main() {</span><br><span class="line">    //局部变量 a 和 b</span><br><span class="line">    var a int = 3</span><br><span class="line">    var b int = 4</span><br><span class="line">    fmt.Printf("main() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("main() 函数中 b = %d\n", b)</span><br><span class="line">    c := sum(a, b)</span><br><span class="line">    fmt.Printf("main() 函数中 c = %d\n", c)</span><br><span class="line">}</span><br><span class="line">func sum(a, b int) int {</span><br><span class="line">    fmt.Printf("sum() 函数中 a = %d\n", a)</span><br><span class="line">    fmt.Printf("sum() 函数中 b = %d\n", b)</span><br><span class="line">    num := a + b</span><br><span class="line">    return num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main() 函数中 a = 3</span><br><span class="line">main() 函数中 b = 4</span><br><span class="line">sum() 函数中 a = 3</span><br><span class="line">sum() 函数中 b = 4</span><br><span class="line">main() 函数中 c = 7</span><br></pre></td></tr></tbody></table></figure><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 <code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。</p><p><code>Go</code>语言同时提供了有符号和无符号的整数类型，其中包括 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 四种大小截然不同的有符号整数类型，分别对应 <code>8</code>、<code>16</code>、<code>32</code>、<code>64 bit</code>（二进制位）大小的有符号整数，与此对应的是 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 四种无符号整数类型。</p><p>此外还有两种整数类型 <code>int</code> 和 <code>uint</code>，它们分别对应特定 <code>CPU</code> 平台的字长（机器字大小），其中 <code>int</code> 表示有符号整数，应用最为广泛，<code>uint</code> 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，<code>int</code> 和 <code>uint</code> 所能表示的整数大小会在 <code>32bit</code> 或 <code>64bit</code> 之间变化。</p><p>大多数情况下，我们只需要 <code>int</code> 一种整型即可，它可以用于循环计数器（<code>for</code> 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 <code>int</code> 类型的处理速度也是最快的。</p><p>用来表示 <code>Unicode</code> 字符的 <code>rune</code> 类型和 <code>int32</code> 类型是等价的，通常用于表示一个 <code>Unicode</code> 码点。这两个名称可以互换使用。同样，<code>byte</code> 和 <code>uint8</code> 也是等价类型，<code>byte</code> 类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>最后，还有一种无符号的整数类型 <code>uintptr</code>，它没有指定具体的 <code>bit</code> 大小但是足以容纳指针。<code>uintptr</code> 类型只有在底层编程时才需要，特别是<code>Go</code>语言和<code>C</code>语言函数库或操作系统接口相交互的地方。</p><p>尽管在某些特定的运行环境下 <code>int</code>、<code>uint</code> 和 <code>uintptr</code> 的大小可能相等，但是它们依然是不同的类型，比如 <code>int</code> 和 <code>int32</code>，虽然 <code>int</code> 类型的大小也可能是 <code>32 bit</code>，但是在需要把 <code>int</code> 类型当做 <code>int32</code> 类型使用的时候必须显示的对类型进行转换，反之亦然。</p><p><code>Go</code>语言中有符号整数采用 <code>2</code> 的补码形式表示，也就是最高 <code>bit</code> 位用来表示符号位，一个 <code>n-bit</code> 的有符号数的取值范围是从 <code>-2(n-1)</code> 到 <code>2(n-1)-1</code>。无符号整数的所有 <code>bit</code> 位都用于表示非负数，取值范围是 <code>0</code> 到 <code>2n-1</code>。例如，<code>int8</code> 类型整数的取值范围是从 <code>-128</code> 到 <code>127</code>，而 <code>uint8</code> 类型整数的取值范围是从 <code>0</code> 到 <code>255</code>。</p><h3 id="哪些情况下使用-int-和-uint"><a href="#哪些情况下使用-int-和-uint" class="headerlink" title="哪些情况下使用 int 和 uint"></a>哪些情况下使用 <code>int</code> 和 <code>uint</code></h3><p>程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 <code>map</code> 的元素数量等都可以用 int 来表示。</p><p>反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 <code>int</code> 和 <code>uint</code>。</p><h2 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h2><p><code>Go</code>语言提供了两种精度的浮点数 <code>float32</code> 和 <code>float64</code>，它们的算术规范由 <code>IEEE754</code> 浮点数国际标准定义，该浮点数规范被所有现代的 <code>CPU</code> 支持。</p><p>这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 <code>math</code> 包中找到：</p><ul><li>常量 <code>math.MaxFloat32</code> 表示 <code>float32</code> 能取到的最大数值，大约是 <code>3.4e38</code>；</li><li>常量 <code>math.MaxFloat64</code> 表示 <code>float64</code> 能取到的最大数值，大约是 <code>1.8e308</code>；</li><li><code>float32</code> 和 <code>float64</code> 能表示的最小值分别为 <code>1.4e-45</code> 和 <code>4.9e-324</code>。</li></ul><p>一个 <code>float32</code> 类型的浮点数可以提供大约 <code>6</code> 个十进制数的精度，而 <code>float64</code> 则可以提供约 <code>15</code> 个十进制数的精度，通常应该优先使用 <code>float64</code> 类型，因为 <code>float32</code> 类型的累计计算误差很容易扩散，并且 <code>float32</code> 能精确表示的正整数并不是很大。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f float32 = 16777216 // 1 &lt;&lt; 24</span><br><span class="line">fmt.Println(f == f+1)    // "true"!</span><br></pre></td></tr></tbody></table></figure><p>浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const e = .71828 // 0.71828</span><br><span class="line">const f = 1.     // 1</span><br></pre></td></tr></tbody></table></figure><p>很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：</p><figure class="highlight plain"><figcaption><span>e 或 E 来指定指数部分</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数</span><br><span class="line">const Planck   = 6.62606957e-34 // 普朗克常数</span><br></pre></td></tr></tbody></table></figure><p>用 Printf 函数打印浮点数时可以使用<code>%f</code>来控制保留几位小数:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%f\n", math.Pi)</span><br><span class="line">    fmt.Printf("%.2f\n", math.Pi)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.141593</span><br><span class="line">3.14</span><br></pre></td></tr></tbody></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>在计算机中，复数是由两个浮点数表示的，其中一个表示实部<code>（real）</code>，一个表示虚部<code>（imag）</code>。</p><p><code>Go</code>语言中复数的类型有两种，分别是  <code>complex128（64 位实数和虚数）</code> 和 <code>complex64（32 位实数和虚数）</code>，其中 <code>complex128</code> 为复数的默认类型。</p><p>复数的值由三部分组成 <code>RE</code> + <code>IMi</code>，其中 <code>RE</code> 是实数部分，<code>IM</code> 是虚数部分，<code>RE</code> 和 <code>IM</code> 均为 <code>float</code> 类型，而最后的 <code>i</code> 是虚数单位。</p><p>声明复数的语法格式如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name complex128 = complex(x, y)</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>name</code> 为复数的变量名，<code>complex128</code> 为复数的类型，<code>=</code> 后面的 <code>complex</code> 为 <code>Go</code> 语言的内置函数用于为复数赋值，<code>x</code> 、<code>y</code> 分别表示构成该复数的两个 <code>float64</code> 类型的数值，<code>x</code> 为实部，<code>y</code> 为虚部。</p><p>上面的声明语句也可以简写为下面的形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := complex(x, y)</span><br></pre></td></tr></tbody></table></figure><p>对于一个复数 <code>z := complex(x, y)</code>，可以通过 <code>Go</code> 语言的内置函数 <code>real(z)</code> 来获得该复数的实部，也就是 <code>x</code> ；通过 <code>imag(z)</code> 获得该复数的虚部，也就是 <code>y</code> 。</p><p>【示例】使用内置的 <code>complex</code> 函数构建复数，并使用 <code>real</code> 和 <code>imag</code> 函数返回复数的实部和虚部：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x complex128 = complex(1, 2) // 1+2i</span><br><span class="line">var y complex128 = complex(3, 4) // 3+4i</span><br><span class="line">fmt.Println(x*y)                 // "(-5+10i)"</span><br><span class="line">fmt.Println(real(x*y))           // "-5"</span><br><span class="line">fmt.Println(imag(x*y))           // "10"</span><br></pre></td></tr></tbody></table></figure><p>如果大家对复数的运算法则不是很了解，可以查阅<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/2568041?fr=aladdin">《复数运算法则》</a>，其中详细的讲解了复数的加减乘除操作。</p><p>复数也可以用 <code>==</code> 和 <code>!=</code> 进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。</p><p><code>Go</code> 语言内置的 <code>math/cmplx</code> 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 <code>complex128</code> 类型，因为这些内置的包中都使用 <code>complex128</code> 类型作为参数。</p><h2 id="输出正弦函数-（Sin）-图像"><a href="#输出正弦函数-（Sin）-图像" class="headerlink" title="输出正弦函数 （Sin） 图像"></a>输出正弦函数 <code>（Sin）</code> 图像</h2><p>在 <code>Go</code> 语言中，正弦函数由 <code>math</code> 包提供，函数入口为 <code>math.Sin</code> ，正弦函数的参数为 <code>float64</code> ，返回值也是 <code>float64</code> 。在使用正弦函数时，根据实际精度可以进行转换。</p><p><code>Go</code> 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 <code>JPEG</code>、<code>PNG</code>、<code>GIF</code> 等。</p><p>首先给出本节完整的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/png"</span><br><span class="line">    "log"</span><br><span class="line">    "math"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 图片大小</span><br><span class="line">    const size = 300</span><br><span class="line"></span><br><span class="line">    // 根据给定大小创建灰度图</span><br><span class="line">    pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">    // 遍历每个像素</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        for y := 0; y &lt; size; y++ {</span><br><span class="line">            // 填充为白色</span><br><span class="line">            pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 从0到最大像素生成x坐标</span><br><span class="line">    for x := 0; x &lt; size; x++ {</span><br><span class="line">        // 让sin的值的范围在0~2Pi之间</span><br><span class="line">        s := float64(x) * 2 * math.Pi / size</span><br><span class="line">        // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">        y := size/2 - math.Sin(s)*size/2</span><br><span class="line">        // 用黑色绘制sin轨迹</span><br><span class="line">        pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">    }</span><br><span class="line">    // 创建文件</span><br><span class="line">    file, err := os.Create("sin.png")</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    }</span><br><span class="line">    // 使用png格式将数据写入文件</span><br><span class="line">    png.Encode(file, pic) //将image信息写入文件中</span><br><span class="line">    // 关闭文件</span><br><span class="line">    file.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="设置图片背景色"><a href="#设置图片背景色" class="headerlink" title="设置图片背景色"></a>设置图片背景色</h3><p>以下是设置图片背景的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 图片大小</span><br><span class="line">const size = 300</span><br><span class="line"></span><br><span class="line">// 根据给定大小创建灰度图</span><br><span class="line">pic := image.NewGray(image.Rect(0, 0, size, size))</span><br><span class="line"></span><br><span class="line">// 遍历每个像素</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line">    for y := 0; y &lt; size; y++ {</span><br><span class="line">        // 填充为白色</span><br><span class="line">        pic.SetGray(x, y, color.Gray{255})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>2</code> 行，声明一个 <code>size</code> 常量，值为 <code>300</code>。</li><li>第 <code>5</code> 行，使用 <code>image</code> 包的 <code>NewGray()</code> 函数创建一个图片对象，使用区域由 <code>image.Rect</code> 结构提供，<code>image.Rect</code> 描述一个方形的两个定位点 <code>(x1,y1)</code> 和 <code>(x2,y2)</code> ，<code>image.Rect(0,0,size,size)</code> 表示使用完整灰度图像素，尺寸为宽 <code>300</code>，长 <code>300</code>。</li><li>第 <code>8</code> 行和第 <code>9</code> 行，遍历灰度图的所有像素。</li><li>第 <code>11</code> 行，将每一个像素的灰度设为 <code>255</code> ，也就是白色。</li></ul><p>灰度图是一种常见的图片格式，一般情况下颜色由 <code>8</code> 位组成，灰度范围为 <code>0～255</code> ，<code>0</code> 表示黑色，<code>255</code> 表示白色。</p><p>初始化好的灰度图默认的灰度值都是 <code>0</code> ，对的是黑色，由于显示效果的效果不是很好，所以这里将所有像素设置为 <code>255</code>，也就是白色。</p><h3 id="绘制正弦函数轨迹"><a href="#绘制正弦函数轨迹" class="headerlink" title="绘制正弦函数轨迹"></a>绘制正弦函数轨迹</h3><p>正弦函数是一个周期函数，定义域是实数集，取值范围是 <code>[-1, 1]</code>。用编程的通俗易懂的话来说就是：<code>math.Sin</code> 函数的参数支持任意浮点数范围，函数返回值的范围总是在 <code>-1～1</code> 之间（包含 <code>1</code>、<code>-1</code>）。</p><p>要将正弦函数放在图片上需要考虑以下一些因素：</p><ul><li><code>math.Sin</code> 的返回值在 <code>-1～1</code> 之间，需要考虑将正弦的输出幅度变大，可以将 <code>math.Sin</code> 的返回值乘以一个常量进行放大。</li><li>图片的坐标系原点在左上角，而 <code>math.Sin</code> 基于笛卡尔坐标系原点在左下角，需要对图像进行上下翻转和平移。</li></ul><p>将这些处理逻辑汇总为代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 从0到最大像素生成x坐标</span><br><span class="line">for x := 0; x &lt; size; x++ {</span><br><span class="line"></span><br><span class="line">    // 让sin的值的范围在0~2Pi之间</span><br><span class="line">    s := float64(x) * 2 * math.Pi / size</span><br><span class="line"></span><br><span class="line">    // sin的幅度为一半的像素。向下偏移一半像素并翻转</span><br><span class="line">    y := size/2 - math.Sin(s)*size/2</span><br><span class="line"></span><br><span class="line">    // 用黑色绘制sin轨迹</span><br><span class="line">    pic.SetGray(x, int(y), color.Gray{0})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>2</code> 行，生成 <code>0</code> 到 <code>size（300）</code> 的 x 坐标轴。</li><li><p>第 <code>5</code> 行，计算 <code>math.Sin</code> 的定义域，这段代码等效为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate := x / size</span><br><span class="line">s := rate * 2 * math.Pi</span><br></pre></td></tr></tbody></table></figure><p><code>x</code> 的范围是 <code>0</code> 到 <code>size</code> ，因此除以 <code>size</code> 后，<code>rate</code> 的范围是 <code>0～1</code> 之间，再乘以 <code>2π</code> 后，<code>s</code> 的范围刚好是 <code>0～2π</code> 之间。</p><p><code>float64(x)</code> 表示将整型的 <code>x</code> 变量转换为 <code>float64</code> 类型，之后运算的所有表达式将以 <code>float64</code> 类型进行。</p></li><li><p>第 <code>8</code> 行中，<code>math.Sin(s)*size/2</code> 表示将正弦函数的返回值幅度从 <code>1</code> 扩大到二分之一的 <code>size</code> 。负号表示将正弦函数图形以图形中心上下翻转。叠加 <code>size/2</code> 表示将图形在 <code>y</code> 轴上向下偏移二分之一的 <code>size</code>（图片坐标系的 <code>y</code> 向下）。</p></li><li>第 <code>11</code> 行将计算好的 <code>x</code> 轴和 <code>y</code> 轴数据，以灰度为 <code>0</code>（黑色）使用 <code>SetGray()</code> 方法填充到像素中。</li></ul><p>写入图片的正弦函数图像如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sinImage.png" alt="正弦图片"></p><h3 id="写入图片文件"><a href="#写入图片文件" class="headerlink" title="写入图片文件"></a>写入图片文件</h3><p>内存中的正弦函数图形是不可见的，我们选用 <code>PNG</code> 格式将图形输出为文件，<code>Go</code> 语言提供了文件创建函数和 <code>PNG</code> 格式写入函数，代码如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">file, err := os.Create("sin.png")</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">// 使用PNG格式将数据写入文件</span><br><span class="line">png.Encode(file, pic)  //将image信息写入文件中</span><br><span class="line"></span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>2</code> 行，创建 <code>sin.png</code> 的文件。</li><li>第 <code>4</code> 行，如果创建文件失败，返回错误，打印错误并终止。</li><li>第 <code>8</code> 行，使用 <code>PNG</code> 包，将图形对象写入文件中。</li><li>第 <code>11</code> 行，关闭文件。</li></ul><h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>一个布尔类型的值只有两种：<code>true</code> 或 <code>false</code>。<code>if</code> 和 <code>for</code> 语句的条件部分都是布尔类型的值，并且 <code>==</code> 和 <code>&lt;</code> 等比较操作也会产生布尔型的值。</p><p>一元操作符 <code>!</code> 对应逻辑非操作，因此 <code>!true</code> 的值为 <code>false</code>，更复杂一些的写法是 <code>(!true==false) == true</code>，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 <code>x</code> 来表示 <code>x==true</code> 。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var aVar = 10</span><br><span class="line">aVar == 5  // false</span><br><span class="line">aVar == 10 // true</span><br><span class="line">aVar != 5  // true</span><br><span class="line">aVar != 10 // false</span><br></pre></td></tr></tbody></table></figure><p><code>Go</code>语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口<code>（interface）</code>，那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。</p><p>布尔值可以和 <code>&amp;&amp;（AND）</code> 和 <code>||（OR）</code> 操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s != "" &amp;&amp; s[0] == 'x'</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>s[0]</code> 操作如果应用于空字符串将会导致 <code>panic</code> 异常。</p><p>因为 <code>&amp;&amp;</code> 的优先级比 <code>||</code> 高（ <code>&amp;&amp;</code> 对应逻辑乘法，<code>||</code> 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if 'a' &lt;= c &amp;&amp; c &lt;= 'z' ||</span><br><span class="line">    'A' &lt;= c &amp;&amp; c &lt;= 'Z' ||</span><br><span class="line">    '0' &lt;= c &amp;&amp; c &lt;= '9' {</span><br><span class="line">    // ...ASCII字母或数字...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>布尔值并不会隐式转换为数字值 <code>0</code> 或 <code>1</code>，反之亦然，必须使用 <code>if</code> 语句显式的进行转换：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := 0</span><br><span class="line">if b {</span><br><span class="line">    i = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果b为真，btoi返回1；如果为假，btoi返回0</span><br><span class="line">func btoi(b bool) int {</span><br><span class="line">    if b {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line">    return 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// itob报告是否为非零。</span><br><span class="line">func itob(i int) bool { return i != 0 }</span><br></pre></td></tr></tbody></table></figure><p><code>Go</code> 语言中不允许将整型强制转换为布尔型，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var n bool</span><br><span class="line">fmt.Println(int(n) * 2)</span><br></pre></td></tr></tbody></table></figure><p>编译错误，输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert n (type bool) to type int</span><br></pre></td></tr></tbody></table></figure><p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 <code>UTF-8</code> 字符的一个序列（当字符为 <code>ASCII</code> 码表上的字符时则占用 <code>1</code> 个字节，其它字符根据需要占用 <code>2-4</code> 个字节）。</p><p><code>UTF-8</code> 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 <code>XML</code> 和 <code>JSON</code> 在内也都使用该编码。由于该编码对占用字节长度的不定性，在 <code>Go</code> 语言中字符串也可能根据需要占用 <code>1</code> 至 <code>4</code> 个字节，这与其它编程语言如 <code>C++</code> 、<code>Java</code> 或者 <code>Python</code> 不同（<code>Java</code> 始终使用 <code>2</code> 个字节）。<code>Go</code> 语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 <code>UTF-8</code> 字符集的文本进行编码和解码。</p><p>字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。</p><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>可以使用双引号 <code>""</code> 来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：</p><ul><li>\n：换行符</li><li>\r：回车符</li><li>\t：tab 键</li><li>\u 或 \U：Unicode 字符</li><li>\：反斜杠自身</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var str = "Hello\nGo World~!"</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">Go World~!</span><br></pre></td></tr></tbody></table></figure><p>一般的比较运算符 <code>（==、!=、&lt;、&lt;=、&gt;=、&gt;）</code> 是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 <code>len()</code> 来获取，例如 <code>len(str)</code>。</p><p>字符串的内容（纯字节）可以通过标准索引法来获取，在方括号 <code>[ ]</code> 内写入索引，索引从 <code>0</code> 开始计数：</p><ul><li>字符串 <code>str</code> 的第 <code>1</code> 个字节：<code>str[0]</code></li><li>第 <code>i</code> 个字节：<code>str[i - 1]</code></li><li>最后 <code>1</code> 个字节：<code>str[len(str)-1]</code></li></ul><p>需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。</p><p><strong><em>注意：获取字符串中某个字节的地址属于非法行为，例如 <code>&amp;str[i]</code>。</em></strong></p><h3 id="字符串拼接符"><a href="#字符串拼接符" class="headerlink" title="字符串拼接符 +"></a>字符串拼接符 <code>+</code></h3><p>两个字符串 <code>s1</code> 和 <code>s2</code> 可以通过 <code>s := s1 + s2</code> 拼接在一起。将 <code>s2</code> 追加到 <code>s1</code> 尾部并生成一个新的字符串 <code>s</code>。</p><p>可以通过下面的方式来对代码中多行的字符串进行拼接：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := "Beginning of the string " +</span><br><span class="line">"second part of the string"</span><br></pre></td></tr></tbody></table></figure><p><strong><em>提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号 <code>+</code> 必须放在第一行末尾。</em></strong></p><p>也可以使用 <code>+=</code> 来对字符串进行拼接：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := "hel" + "lo,"</span><br><span class="line">s += "world!"</span><br><span class="line">fmt.Println(s) //输出 “hello, world!”</span><br></pre></td></tr></tbody></table></figure><h3 id="字符串实现基于-UTF-8-编码"><a href="#字符串实现基于-UTF-8-编码" class="headerlink" title="字符串实现基于 UTF-8 编码"></a>字符串实现基于 <code>UTF-8</code> 编码</h3><p><code>Go</code> 语言中字符串的内部实现使用 <code>UTF-8</code> 编码，通过 <code>rune</code> 类型，可以方便地对每个 <code>UTF-8</code> 字符进行访问。当然，<code>Go</code> 语言也支持按照传统的 <code>ASCII</code> 码方式逐字符进行访问。</p><p>关于字符串的 <code>UTF-8</code> 字符访问的详细方法，后面的章节将会详细介绍。</p><h3 id="定义多行字符串"><a href="#定义多行字符串" class="headerlink" title="定义多行字符串"></a>定义多行字符串</h3><p>在 <code>Go</code> 语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量<code>（string literal）</code> ，这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用 ` 反引号，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const str = `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br><span class="line">`</span><br><span class="line">fmt.Println(str)</span><br></pre></td></tr></tbody></table></figure><p>代码运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">\r\n</span><br></pre></td></tr></tbody></table></figure><p>反引号`，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。</p><p>在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><p>多行字符串一般用于内嵌源码和内嵌数据等，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const codeTemplate = `// Generated by github.com/davyxu/cellnet/</span><br><span class="line">protoc-gen-msg</span><br><span class="line">// DO NOT EDIT!{{range .Protos}}</span><br><span class="line">// Source: {{.Name}}{{end}}</span><br><span class="line">package {{.PackageName}}</span><br><span class="line">{{if gt .TotalMessages 0}}</span><br><span class="line">import (</span><br><span class="line">    "github.com/davyxu/cellnet"</span><br><span class="line">    "reflect"</span><br><span class="line">    _ "github.com/davyxu/cellnet/codec/pb"</span><br><span class="line">)</span><br><span class="line">{{end}}</span><br><span class="line">func init() {</span><br><span class="line">    {{range .Protos}}</span><br><span class="line">    // {{.Name}}{{range .Messages}}</span><br><span class="line">    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}</span><br><span class="line">    {{end}}</span><br><span class="line">}</span><br><span class="line">`</span><br></pre></td></tr></tbody></table></figure><p>这段代码只定义了一个常量 codeTemplate，类型为字符串，使用`定义，字符串的内容为一段代码生成中使用到的 Go 源码格式。</p><p>在 ` 间的所有代码均不会被编译器识别，而只是作为字符串的一部分。</p><p>字符串类型在业务中的应用可以说是最广泛的，读者需要详细了解字符串的常见用法，请猛击下面的文章：</p><ul><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/36.html">Go语言计算字符串长度——len()和RuneCountInString()</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/37.html">Go语言遍历字符串——获取每一个字符串元素</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/38.html">Go语言字符串截取（获取字符串的某一段字符）</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/39.html">Go语言修改字符串</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/40.html">Go语言字符串拼接（连接）</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/41.html">Go语言fmt.Sprintf（格式化输出）</a></li><li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/42.html">Go语言Base64编码——电子邮件的基础编码格式</a></li></ul><h2 id="字符类型-byte和rune"><a href="#字符类型-byte和rune" class="headerlink" title="字符类型(byte和rune)"></a>字符类型(byte和rune)</h2><p>字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。</p><p>Go语言的字符有以下两种：</p><ul><li>一种是 <code>uint8</code> 类型，或者叫 <code>byte</code> 型，代表了 <code>ASCII</code> 码的一个字符。</li><li>另一种是 <code>rune</code> 类型，代表一个 <code>UTF-8</code> 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 <code>rune</code> 类型。<code>rune</code> 类型等价于 int32 类型。</li></ul><p><code>byte</code> 类型是 <code>uint8</code> 的别名，对于只占用 <code>1</code> 个字节的传统 <code>ASCII</code> 编码的字符来说，完全没有问题，例如 <code>var ch byte = 'A'</code>，字符使用单引号括起来。</p><p>在 <code>ASCII</code> 码表中，<code>A</code> 的值是 <code>65</code>，使用 <code>16</code> 进制表示则为 <code>41</code>，所以下面的写法是等效的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）</span><br></pre></td></tr></tbody></table></figure><p>另外一种可能的写法是 <code>\</code> 后面紧跟着长度为 <code>3</code> 的八进制数，例如 \377。</p><p><code>Go</code>语言同样支持 <code>Unicode（UTF-8）</code>，因此字符同样称为 <code>Unicode</code> 代码点或者 <code>runes</code> ，并在内存中使用 <code>int</code> 来表示。在文档中，一般使用格式 <code>U+hhhh</code> 来表示，其中 <code>h</code> 表示一个 <code>16</code> 进制数。</p><p>在书写 <code>Unicode</code> 字符时，需要在 <code>16</code> 进制数之前加上前缀 <code>\u</code> 或者 <code>\U</code> 。因为 <code>Unicode</code> 至少占用 <code>2</code> 个字节，所以我们使用 <code>int16</code> 或者 <code>int</code> 类型来表示。如果需要使用到 <code>4</code> 字节，则使用 <code>\u</code> 前缀，如果需要使用到 <code>8</code> 个字节，则使用 <code>\U</code> 前缀。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ch int = '\u0041'</span><br><span class="line">var ch2 int = '\u03B2'</span><br><span class="line">var ch3 int = '\U00101234'</span><br><span class="line">fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer</span><br><span class="line">fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character</span><br><span class="line">fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes</span><br><span class="line">fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">65 - 946 - 1053236</span><br><span class="line">A - β - r</span><br><span class="line">41 - 3B2 - 101234</span><br><span class="line">U+0041 - U+03B2 - U+101234</span><br></pre></td></tr></tbody></table></figure><p>格式化说明符 <code>%c</code> 用于表示字符，当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数，<code>%U</code> 输出格式为 <code>U+hhhh</code> 的字符串。</p><p><code>Unicode</code> 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 <code>ch</code> 代表字符）：</p><ul><li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li><li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li><li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li></ul><h3 id="UTF-8-和-Unicode-有何区别"><a href="#UTF-8-和-Unicode-有何区别" class="headerlink" title="UTF-8 和 Unicode 有何区别"></a>UTF-8 和 Unicode 有何区别</h3><p><code>Unicode</code> 与 <code>ASCII</code> 类似，都是一种字符集。</p><p>字符集为每个字符分配一个唯一的 <code>ID</code>，我们使用到的所有字符在 <code>Unicode</code> 字符集中都有一个唯一的 <code>ID</code>，例如上面例子中的 <code>a</code> 在 <code>Unicode</code> 与 <code>ASCII</code> 中的编码都是 <code>97</code>。汉字 <code>你</code> 在 <code>Unicode</code> 中的编码为 <code>20320</code>，在不同国家的字符集中，字符所对应的 <code>ID</code> 也会不同。而无论任何情况下，<code>Unicode</code> 中的字符的 <code>ID</code> 都是不会变化的。</p><p><code>UTF-8</code> 是编码规则，将 <code>Unicode</code> 中字符的 <code>ID</code> 以某种方式进行编码，<code>UTF-8</code> 的是一种变长编码规则，从 <code>1</code> 到 <code>4</code> 个字节不等。编码规则如下：</p><ul><li><code>0xxxxxx</code> 表示文字符号 <code>0～127</code>，兼容 <code>ASCII</code> 字符集。</li><li>从 <code>128</code> 到 <code>0x10ffff</code> 表示其他字符。</li></ul><p>根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 <code>3</code> 个字节。</p><p>广义的 <code>Unicode</code> 指的是一个标准，它定义了字符集及编码规则，即 <code>Unicode</code> 字符集和 <code>UTF-8</code>、<code>UTF-16</code> 编码等。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 <code>Go</code> 语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB = typeB(valueOfTypeA)</span><br></pre></td></tr></tbody></table></figure><p>类型 <code>B</code> 的值 = 类型 <code>B</code> (类型 <code>A</code> 的值)</p><p>示例:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></tbody></table></figure><p>类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 <code>int16</code> 转换为 <code>int32</code>）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 <code>int32</code> 转换为 <code>int16</code> 或将 <code>float32</code> 转换为 <code>int</code> ），会发生精度丢失（截断）的情况。</p><p>只有相同底层类型的变量之间可以进行相互转换（如将 <code>int16</code> 类型转换成 <code>int32</code> 类型），不同底层类型的变量相互转换时会引发编译错误（如将 <code>boo</code>l 类型转换为 <code>int</code> 类型）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        "fmt"</span><br><span class="line">        "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">        // 输出各数值范围</span><br><span class="line">        fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)</span><br><span class="line">        fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)</span><br><span class="line">        fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)</span><br><span class="line">        fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)</span><br><span class="line"></span><br><span class="line">        // 初始化一个32位整型值</span><br><span class="line">        var a int32 = 1047483647</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int32: 0x%x %d\n", a, a)</span><br><span class="line"></span><br><span class="line">        // 将a变量数值转换为十六进制, 发生数值截断</span><br><span class="line">        b := int16(a)</span><br><span class="line">        // 输出变量的十六进制形式和十进制值</span><br><span class="line">        fmt.Printf("int16: 0x%x %d\n", b, b)</span><br><span class="line"></span><br><span class="line">        // 将常量保存为float32类型</span><br><span class="line">        var c float32 = math.Pi</span><br><span class="line">        // 转换为int类型, 浮点发生精度丢失</span><br><span class="line">        fmt.Println(int(c))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>11～14 行</code>，输出几个常见整型类型的数值范围。</li><li>第 <code>17</code> 行，声明 <code>int32</code> 类型的变量 <code>a</code> 并初始化。</li><li>第 <code>19</code> 行，使用 <code>fmt.Printf</code> 的 <code>%x</code> 动词将数值以十六进制格式输出，这一行输出 <code>a</code> 在转换前的 <code>32</code> 位的值。</li><li>第 <code>22</code> 行，将 <code>a</code> 的值转换为 <code>int16</code> 类型，也就是从 <code>32</code> 位有符号整型转换为 <code>16</code> 位有符号整型，由于 <code>int16</code> 类型的取值范围比 <code>int32</code> 类型的取值范围小，因此数值会进行截断（精度丢失）。</li><li>第 <code>24</code> 行，输出转换后的 <code>a</code> 变量值，也就是 <code>b</code> 的值，同样以十六进制和十进制两种方式进行打印。</li><li>第 <code>27</code> 行，<code>math.Pi</code> 是 <code>math</code> 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 <code>math.Pi</code> 被赋值到变量 <code>c</code> 中，因此类型为 <code>float32</code>。</li><li>第 <code>29</code> 行，将 <code>float32</code> 转换为 <code>int</code> 类型并输出。</li></ul><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int8 range: -128 127</span><br><span class="line">int16 range: -32768 32767</span><br><span class="line">int32 range: -2147483648 2147483647</span><br><span class="line">int64 range: -9223372036854775808 9223372036854775807</span><br><span class="line">int32: 0x3e6f54ff 1047483647</span><br><span class="line">int16: 0x54ff 21759</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>根据输出结果，<code>16</code> 位有符号整型的范围是 <code>-32768～32767</code>，而变量 <code>a</code> 的值 <code>1047483647</code> 不在这个范围内。<code>1047483647</code> 对应的十六进制为 <code>0x3e6f54ff</code>，转为 <code>int16</code> 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 <code>0x54ff</code>，对应的十进制值为 <code>21759</code>。</p><p>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>与 <code>Java</code> 和 <code>.NET</code> 等编程语言不同，<code>Go</code> 语言为程序员提供了控制数据结构指针的能力，<strong>但是，并不能进行指针运算</strong>。<code>Go</code> 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p><p>指针 <code>（pointer）</code> 在 <code>Go</code> 语言中可以被拆分为两个核心概念：</p><ul><li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li><li>切片，由指向起始元素的原始指针、元素数量和容量组成。</li></ul><p>受益于这样的约束和拆分，<code>Go</code> 语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</p><p>切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。</p><p><code>C/C++</code> 中的指针</p><p>说到 <code>C/C++</code> 中的指针，会让许多人“谈虎色变”，尤其是对指针的偏移、运算和转换。</p><p>其实，指针是 <code>C/C++</code> 语言拥有极高性能的根本所在，在操作大块数据和做偏移时即方便又便捷。因此，操作系统依然使用 <code>C</code> 语言及指针的特性进行编写。</p><p><code>C/C++</code> 中指针饱受诟病的根本原因是指针的运算和内存释放，<code>C/C++</code> 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域，我们的计算机操作系统经常需要更新、修复漏洞的本质，就是为解决指针越界访问所导致的“缓冲区溢出”的问题。</p><p>要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开详细说明。</p><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 <code>32</code> 和 <code>64</code> 位机器上分别占用 <code>4</code> 或 <code>8</code> 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 <code>nil</code>。指针变量通常缩写为 <code>ptr</code> 。</p><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。<code>Go</code> 语言中使用在变量名前面添加 <code>&amp;</code> 操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    // v 的类型为 T</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>v</code> 代表被取地址的变量，变量 <code>v</code> 的地址使用变量 <code>ptr</code> 进行接收，<code>ptr</code> 的类型为 <code>*T</code> ，称做 <code>T</code> 的指针类型，<code>*</code> 代表指针。</p><p>指针实际用法，可以通过下面的例子了解：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var cat int = 1</span><br><span class="line">    var str string = "banana"</span><br><span class="line">    fmt.Printf("%p %p", &amp;cat, &amp;str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xc042052088 0xc0420461b0</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>8</code> 行，声明整型变量 <code>cat</code> 。</li><li>第 <code>9</code> 行，声明字符串变量 <code>str</code> 。</li><li>第 <code>10</code> 行，使用 <code>fmt.Printf</code> 的动词 <code>%p</code> 打印 <code>cat</code> 和 <code>str</code> 变量的内存地址，指针的值是带有 <code>0x</code> 十六进制前缀的一组数据。</li></ul><p><strong><em>提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。</em></strong></p><h3 id="从指针获取指针指向的值"><a href="#从指针获取指针指向的值" class="headerlink" title="从指针获取指针指向的值"></a>从指针获取指针指向的值</h3><p>当使用 <code>&amp;</code> 操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用 <code>*</code> 操作符，也就是指针取值，代码如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个字符串类型</span><br><span class="line">    var house = "Malibu Point 10880, 90265"</span><br><span class="line"></span><br><span class="line">    // 对字符串取地址, ptr类型为*string</span><br><span class="line">    ptr := &amp;house</span><br><span class="line"></span><br><span class="line">    // 打印ptr的类型</span><br><span class="line">    fmt.Printf("ptr type: %T\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 打印ptr的指针地址</span><br><span class="line">    fmt.Printf("address: %p\n", ptr)</span><br><span class="line"></span><br><span class="line">    // 对指针进行取值操作</span><br><span class="line">    value := *ptr</span><br><span class="line"></span><br><span class="line">    // 取值后的类型</span><br><span class="line">    fmt.Printf("value type: %T\n", value)</span><br><span class="line"></span><br><span class="line">    // 指针取值后就是指向变量的值</span><br><span class="line">    fmt.Printf("value: %s\n", value)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr type: *string</span><br><span class="line">address: 0xc0420401b0</span><br><span class="line">value type: string</span><br><span class="line">value: Malibu Point 10880, 90265</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>10</code> 行，准备一个字符串并赋值。</li><li>第 <code>13</code> 行，对字符串取地址，将指针保存到变量 <code>ptr</code> 中。</li><li>第 <code>16</code> 行，打印变量 <code>ptr</code> 的类型，其类型为 <code>*string</code>。</li><li>第 <code>19</code> 行，打印 <code>ptr</code> 的指针地址，地址每次运行都会发生变化。</li><li>第 <code>22</code> 行，对 <code>ptr</code> 指针变量进行取值操作，变量 <code>value</code> 的类型为 <code>string</code> 。</li><li>第 <code>25</code> 行，打印取值后 <code>value</code> 的类型。</li><li>第 <code>28</code> 行，打印 <code>value</code> 的值。</li></ul><p>取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp;</code> 取出地址，<code>*</code> 根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址操作使用 <code>&amp;</code> 操作符，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值操作使用 <code>*</code> 操作符，可以获得指针变量指向的原变量的值。</li></ul><h3 id="使用指针修改值"><a href="#使用指针修改值" class="headerlink" title="使用指针修改值"></a>使用指针修改值</h3><p>通过指针不仅可以取值，也可以修改值。</p><p>前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 交换函数</span><br><span class="line">func swap(a, b *int) {</span><br><span class="line"></span><br><span class="line">    // 取a指针的值, 赋给临时变量t</span><br><span class="line">    t := *a</span><br><span class="line"></span><br><span class="line">    // 取b指针的值, 赋给a指针指向的变量</span><br><span class="line">    *a = *b</span><br><span class="line"></span><br><span class="line">    // 将a指针的值赋给b指针指向的变量</span><br><span class="line">    *b = t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备两个变量, 赋值1和2</span><br><span class="line">    x, y := 1, 2</span><br><span class="line"></span><br><span class="line">    // 交换变量值</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line"></span><br><span class="line">    // 输出变量值</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>6</code> 行，定义一个交换函数，参数为 <code>a</code> 、<code>b</code>，类型都为 <code>*int</code> 指针类型。</li><li>第 <code>9</code> 行，取指针 <code>a</code> 的值，并把值赋给变量 <code>t</code> ，<code>t</code> 此时是 <code>int</code> 类型。</li><li>第 <code>12</code> 行，取 <code>b</code> 的指针值，赋给指针 <code>a</code> 指向的变量。注意，此时 <code>*a</code> 的意思不是取 <code>a</code> 指针的值，而是<code>a 指向的变量</code> 。</li><li>第 <code>15</code> 行，将 <code>t</code> 的值赋给指针 <code>b</code> 指向的变量。</li><li>第 <code>21</code> 行，准备 <code>x</code> 、<code>y</code> 两个变量，分别赋值为 <code>1</code> 和 <code>2</code> ，类型为 <code>int</code> 。</li><li>第 <code>24</code> 行，取出 <code>x</code> 和 <code>y</code> 的地址作为参数传给 <code>swap()</code> 函数进行调用。</li><li>第 <code>27</code> 行，交换完毕时，输出 <code>x</code> 和 <code>y</code> 的值。</li></ul><p><code>*</code> 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 <code>a</code> 指针指向的变量。其实归纳起来，<code>*</code> 操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。</p><p>如果在 <code>swap()</code> 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func swap(a, b *int) {</span><br><span class="line">    b, a = a, b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    x, y := 1, 2</span><br><span class="line">    swap(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure><p>结果表明，交换是不成功的。上面代码中的 <code>swap()</code> 函数交换的是 <code>a</code> 和 <code>b</code> 的地址，在交换完毕后，<code>a</code> 和 <code>b</code> 的变量值确实被交换。但和 <code>a</code> 、<code>b</code> 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。</p><h3 id="示例：使用指针变量获取命令行的输入信息"><a href="#示例：使用指针变量获取命令行的输入信息" class="headerlink" title="示例：使用指针变量获取命令行的输入信息"></a>示例：使用指针变量获取命令行的输入信息</h3><p><code>Go</code> 语言内置的 <code>flag</code> 包实现了对命令行参数的解析，<code>flag</code> 包使得开发命令行工具更为简单。</p><p>下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 <code>flag</code> 包的解析后即可获取命令行的数据。</p><p>【示例】获取命令行输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 导入系统包</span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义命令行参数</span><br><span class="line">var mode = flag.String("mode", "", "process mode")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 解析命令行参数</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // 输出命令行参数</span><br><span class="line">    fmt.Println(*mode)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将这段代码命名为 main.go，然后使用如下命令行运行：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go --mode=fast</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fast</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>10</code> 行，通过 <code>flag.String</code>，定义一个 <code>mode</code> 变量，这个变量的类型是 <code>*string</code>。后面 <code>3</code> 个参数分别如下：<ul><li>参数名称：在命令行输入参数时，使用这个名称。</li><li>参数值的默认值：与 <code>flag</code> 所使用的函数创建变量类型对应，<code>String</code> 对应字符串、<code>Int</code> 对应整型、<code>Bool</code> 对应布尔型等。</li><li>参数说明：使用 <code>-help</code> 时，会出现在说明中。</li></ul></li><li>第 <code>15</code> 行，解析命令行参数，并将结果写入到变量 <code>mode</code> 中。</li><li>第 <code>18</code> 行，打印 <code>mode</code> 指针所指向的变量。</li></ul><p>由于之前已经使用 <code>flag.String</code> 注册了一个名为 <code>mode</code> 的命令行参数，<code>flag</code> 底层知道怎么解析命令行，并且将值赋给 <code>mode*string</code> 指针，在 <code>Parse</code> 调用完毕后，无须从 <code>flag</code> 获取值，而是通过自己注册的这个 <code>mode</code> 指针获取到最终的值。代码运行流程如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/pstr.jpg" alt="图：命令行参数与变量的关系"></p><h3 id="创建指针的另一种方法——-new-函数"><a href="#创建指针的另一种方法——-new-函数" class="headerlink" title="创建指针的另一种方法—— new() 函数"></a>创建指针的另一种方法—— <code>new()</code> 函数</h3><p><code>Go</code> 语言还提供了另外一种方法来创建指针变量，格式如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(类型)</span><br></pre></td></tr></tbody></table></figure><p>一般这样写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := new(string)</span><br><span class="line">*str = "Go语言教程"</span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></tbody></table></figure><p><code>new()</code> 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p><h2 id="变量逃逸分析"><a href="#变量逃逸分析" class="headerlink" title="变量逃逸分析"></a>变量逃逸分析</h2><p>了解下计算机组成里两个非常重要的概念：堆和栈。</p><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>栈（Stack）是一种拥有特殊规则的线性表数据结构。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>栈只允许从线性表的同一端放入和取出数据，按照后进先出<code>（LIFO，Last InFirst Out）</code>的顺序，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/stackImage.jpg" alt="图：栈的操作及扩展"></p><p>往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。</p><p>从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的元素数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除了栈顶部的成员）进行任何查看和修改操作。</p><p>栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。</p><h4 id="变量和栈有什么关系"><a href="#变量和栈有什么关系" class="headerlink" title="变量和栈有什么关系"></a>变量和栈有什么关系</h4><p>栈可用于内存分配，栈的分配和回收速度非常快。下面的代码展示了栈在内存分配上的作用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func calc(a, b int) int {</span><br><span class="line">    var c int</span><br><span class="line">    c = a * b</span><br><span class="line"></span><br><span class="line">    var x int</span><br><span class="line">    x = c * 10</span><br><span class="line"></span><br><span class="line">    return x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>1</code> 行，传入 <code>a</code> 、<code>b</code> 两个整型参数。</li><li>第 <code>2</code> 行，声明整型变量 <code>c</code>，运行时，<code>c</code> 会分配一段内存用以存储 <code>c</code> 的数值。</li><li>第 <code>3</code> 行，将 <code>a</code> 和 <code>b</code> 相乘后赋值给 <code>c</code>。</li><li>第 <code>5</code> 行，声明整型变量 <code>x</code> ，<code>x</code> 也会被分配一段内存。</li><li>第 <code>6</code> 行，让 <code>c</code> 乘以 <code>10</code> 后赋值给变量 <code>x</code> 。</li><li>第 <code>8</code> 行，返回 <code>x</code> 的值。</li></ul><p>上面的代码在没有任何优化的情况下，会进行变量 <code>c</code> 和 <code>x</code> 的分配过程。<code>Go</code> 语言默认情况下会将 <code>c</code> 和 <code>x</code> 分配在栈上，这两个变量在 <code>calc()</code> 函数退出时就不再使用，函数结束时，保存 <code>c</code> 和 <code>x</code> 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。</p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/heapImage.jpg" alt="图：堆的分配及空间"></p><p>堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p><h3 id="变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率"><a href="#变量逃逸-（Escape-Analysis）-——-自动决定变量分配方式，提高运行效率" class="headerlink" title="变量逃逸 （Escape Analysis） —— 自动决定变量分配方式，提高运行效率"></a>变量逃逸 <code>（Escape Analysis）</code> —— 自动决定变量分配方式，提高运行效率</h3><p>堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 <code>C/C++</code> 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。</p><p><code>Go</code> 语言将这个过程整合到了编译器中，命名为 <code>变量逃逸分析</code> 。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>通过下面的代码来展现 <code>Go</code> 语言如何使用命令行来分析变量逃逸，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 本函数测试入口参数和返回值情况</span><br><span class="line">func dummy(b int) int {</span><br><span class="line">  // 声明一个变量c并赋值</span><br><span class="line">  var c int</span><br><span class="line">  c = b</span><br><span class="line"></span><br><span class="line">  return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 空函数, 什么也不做</span><br><span class="line">func void() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">  // 声明a变量并打印</span><br><span class="line">  var a int</span><br><span class="line"></span><br><span class="line">  // 调用void()函数</span><br><span class="line">  void()</span><br><span class="line"></span><br><span class="line">  // 打印a变量的值和dummy()函数返回</span><br><span class="line">  fmt.Println(a, dummy(0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>6</code> 行，<code>dummy()</code> 函数拥有一个参数，返回一个整型值，用来测试函数参数和返回值分析情况。</li><li>第 <code>8</code> 行，声明变量 <code>c</code> ，用于演示函数临时变量通过函数返回值返回后的情况。</li><li>第 <code>15</code> 行，这是一个空函数，测试没有任何参数函数的分析情况。</li><li>第 <code>21</code> 行，在 <code>main()</code> 中声明变量 <code>a</code> ，测试 <code>main()</code> 中变量的分析情况。</li><li>第 <code>24</code> 行，调用 <code>void()</code> 函数，没有返回值，测试 <code>void()</code> 调用后的分析情况。</li><li>第 <code>27</code> 行，打印 <code>a</code> 和 <code>dummy(0)</code> 的返回值，测试函数返回值没有变量接收时的分析情况。</li></ul><p>接着使用如下命令行运行上面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags "-m -l" goEscapeAnalysis.go</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>go run</code> 运行程序时，<code>-gcflags</code> 参数是编译参数。其中 <code>-m</code> 表示进行内存分配分析，<code>-l</code> 表示避免程序内联，也就是避免进行程序优化。</p><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goEscapeAnalysis.go:27:13: ... argument does not escape</span><br><span class="line">.\goEscapeAnalysis.go:27:13: a escapes to heap</span><br><span class="line">.\goEscapeAnalysis.go:27:22: dummy(0) escapes to heap</span><br><span class="line">0 0</span><br></pre></td></tr></tbody></table></figure><p>程序运行结果分析如下：</p><ul><li>第 <code>2</code> 行，这句提示是默认的，可以忽略。</li><li>第 <code>3</code> 行告知“代码的第 <code>27</code> 行的变量 <code>a</code> 逃逸到堆”。</li><li>第 <code>4</code> 行告知“dummy(0) 调用逃逸到堆”。由于 <code>dummy()</code> 函数会返回一个整型值，这个值被 <code>fmt.Println</code> 使用后还是会在 <code>main()</code> 函数中继续存在。</li></ul><p>上面例子中变量 <code>c</code> 是整型，其值通过 <code>dummy()</code> 的返回值“逃出”了 <code>dummy()</code> 函数。变量 <code>c</code> 的值被复制并作为 <code>dummy()</code> 函数的返回值返回，即使变量 <code>c</code> 在 <code>dummy()</code> 函数中分配的内存被释放，也不会影响 <code>main()</code> 中使用 <code>dummy()</code> 返回的值。变量 <code>c</code> 使用栈分配不会影响结果。</p><h4 id="取地址发生逃逸"><a href="#取地址发生逃逸" class="headerlink" title="取地址发生逃逸"></a>取地址发生逃逸</h4><p>下面的例子使用结构体做数据，来了解结构体在堆上的分配情况，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明空结构体测试结构体逃逸情况</span><br><span class="line">type Data struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func dummy() *Data {</span><br><span class="line">    // 实例化c为Data类型</span><br><span class="line">    var c Data</span><br><span class="line"></span><br><span class="line">    //返回函数局部变量地址</span><br><span class="line">    return &amp;c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(dummy())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>6</code> 行，声明一个空的结构体做结构体逃逸分析。</li><li>第 <code>9</code> 行，将 <code>dummy()</code> 函数的返回值修改为 <code>*Data</code> 指针类型。</li><li>第 <code>11</code> 行，将变量 <code>c</code> 声明为 <code>Data</code> 类型，此时 <code>c</code> 的结构体为值类型。</li><li>第 <code>14</code> 行，取函数局部变量 <code>c</code> 的地址并返回。</li><li>第 <code>18</code> 行，打印 <code>dummy()</code> 函数的返回值。</li></ul><p>执行逃逸分析：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\goPstrAnalysis.go:11:6: moved to heap: c</span><br><span class="line">.\goPstrAnalysis.go:18:13: ... argument does not escape</span><br><span class="line">&amp;{}</span><br></pre></td></tr></tbody></table></figure><p>注意第 <code>2</code> 行出现了新的提示：将 <code>c</code> 移到堆中。这句话表示，<code>Go</code> 编译器已经确认如果将变量 <code>c</code> 分配在栈上是无法保证程序最终结果的，如果这样做，<code>dummy()</code> 函数的返回值将是一个不可预知的内存地址，这种情况一般是 <code>C/C++</code> 语言中容易犯错的地方，引用了一个函数局部变量的地址。</p><p><code>Go</code> 语言最终选择将 <code>c</code> 的 <code>Data</code> 结构分配在堆上。然后由垃圾回收器去回收 <code>c</code> 的内存。</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>在使用 <code>Go</code> 语言进行编程时，<code>Go</code> 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于<code>Go</code>语言，在 <code>Java</code> 等语言的编译器优化上也使用了类似的技术。</p><p>编译器觉得变量应该分配在堆和栈上的原则是：</p><ul><li>变量是否被取地址；</li><li>变量是否发生逃逸。</li></ul><h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h2><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔</p><p>变量的生命周期与变量的作用域有着不可分割的联系：</p><ul><li>全局变量：它的生命周期和整个程序的运行周期是一致的；</li><li>局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；</li><li>形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">    x := math.Sin(t)</span><br><span class="line">    y := math.Sin(t*freq + phase)</span><br><span class="line">    img.SetColorIndex(</span><br><span class="line">        size+int(x*size+0.5), size+int(y*size+0.5),</span><br><span class="line">        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br><span class="line">    )               // 小括号另起一行缩进，和大括号的风格保存一致</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，在每次循环的开始会创建临时变量 <code>t</code> ，然后在每次循环迭代中创建临时变量 <code>x</code> 和 <code>y</code>。临时变量 <code>x</code>、<code>y</code> 存放在栈中，随着函数执行结束（执行遇到最后一个}），释放其内存。</p><p>栈的和堆的区别在于：</p><ul><li>堆<code>（heap）</code>：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 <code>malloc</code> 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 <code>free</code> 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；</li><li>栈<code>(stack)</code>：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号{ }中定义的局部变量。</li></ul><p>在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 <code>var</code> 还是 <code>new</code> 关键字声明变量都不会影响编译器的选择。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var global *int</span><br><span class="line"></span><br><span class="line">func f() {</span><br><span class="line">    var x int</span><br><span class="line">    x = 1</span><br><span class="line">    global = &amp;x</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func g() {</span><br><span class="line">    y := new(int)</span><br><span class="line">    *y = 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，函数 <code>f</code> 里的变量 <code>x</code> 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的。用 <code>Go</code> 语言的术语说，这个局部变量 <code>x</code> 从函数 <code>f</code> 中逃逸了。</p><p>相反，当函数 <code>g</code> 返回时，变量 <code>*y</code> 不再被使用，也就是说可以马上被回收的。因此，<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，编译器可以选择在栈上分配 <code>*y</code> 的存储空间，也可以选择在堆上分配，然后由 <code>Go</code> 语言的 <code>GC（垃圾回收机制）</code> 回收这个变量的内存空间。</p><p>在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p><p>虽然 <code>Go</code> 语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们仍然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 <code>GC</code> 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>Go</code> 语言中的常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。</p><p>常量的定义格式和变量的声明语法类似：<code>const name [type] = value</code> ，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pi = 3.14159 // 相当于 math.Pi 的近似值</span><br></pre></td></tr></tbody></table></figure><p>在 <code>Go</code> 语言中，你可以省略类型说明符 <code>[type]</code> ，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义： <code>const b string = "abc"</code></li><li>隐式类型定义： <code>const b = "abc"</code></li></ul><p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p><ul><li>正确的做法：<code>const c1 = 2/3</code></li><li>错误的做法：<code>const c2 = getNumber()</code> // 引发构建错误: getNumber() 用做值</li></ul><p>和变量声明一样，可以批量声明多个常量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    e  = 2.7182818</span><br><span class="line">    pi = 3.1415926</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p><p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和 <code>unsafe.Sizeof</code>。</p><p>因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const IPv4Len = 4</span><br><span class="line"></span><br><span class="line">// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).</span><br><span class="line">func parseIPv4(s string) IP {</span><br><span class="line">    var p [IPv4Len]byte</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，<code>time.Duration</code> 是一个命名类型，底层类型是 <code>int64</code>，<code>time.Minute</code> 是对应类型的常量。下面声明的两个常量都是 <code>time.Duration</code> 类型，可以通过 <code>%T</code> 参数打印类型信息：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const noDelay time.Duration = 0</span><br><span class="line">const timeout = 5 * time.Minute</span><br><span class="line">fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"</span><br><span class="line">fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"</span><br><span class="line">fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"</span><br></pre></td></tr></tbody></table></figure><p>如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = 1</span><br><span class="line">    b</span><br><span class="line">    c = 2</span><br><span class="line">    d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d) // "1 1 2 2"</span><br></pre></td></tr></tbody></table></figure><p>如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 <code>iota</code> 常量生成器语法。</p><h3 id="iota-常量生成器"><a href="#iota-常量生成器" class="headerlink" title="iota 常量生成器"></a>iota 常量生成器</h3><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在的行，<code>iota</code> 将会被置为 <code>0</code> ，然后在每一个有常量声明的行加一。</p><p>【示例 1】首先定义一个 <code>Weekday</code> 命名类型，然后为一周的每天定义了一个常量，从周日 <code>0</code> 开始。在其它编程语言中，这种类型一般被称为枚举类型。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Weekday int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Sunday Weekday = iota</span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>周日将对应 0，周一为 1，以此类推。</p><h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p><code>Go</code> 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 <code>int</code> 或 <code>float64</code>，或者是类似 <code>time.Duration</code> 这样的基础类型，但是许多常量并没有一个明确的基础类型。</p><p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 <code>256bit</code> 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p><p>【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float32 = math.Pi</span><br><span class="line">var y float64 = math.Pi</span><br><span class="line">var z complex128 = math.Pi</span><br></pre></td></tr></tbody></table></figure><p>如果 <code>math.Pi</code> 被确定为特定类型，比如 <code>float64</code> ，那么结果精度可能会不一样，同时对于需要 <code>float32</code> 或 <code>complex128</code> 类型值的地方则需要一个明确的强制类型转换：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Pi64 float64 = math.Pi</span><br><span class="line">var x float32 = float32(Pi64)</span><br><span class="line">var y float64 = Pi64</span><br><span class="line">var z complex128 = complex128(Pi64)</span><br></pre></td></tr></tbody></table></figure><p>对于常量面值，不同的写法可能会对应不同的类型。例如 <code>0</code> 、<code>0.0</code> 、<code>0i</code> 和 <code>\u0000</code> 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code> 和 <code>false</code> 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p><h2 id="模拟枚举"><a href="#模拟枚举" class="headerlink" title="模拟枚举"></a>模拟枚举</h2><p><code>Go</code> 语言现阶段没有枚举类型，但是可以使用 <code>const</code> 常量配合上一节 <code>Go语言常量</code> 中介绍的 <code>iota</code> 来模拟枚举类型，请看下面的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Weapon int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">     Arrow Weapon = iota    // 开始生成枚举值, 默认为0</span><br><span class="line">     Shuriken</span><br><span class="line">     SniperRifle</span><br><span class="line">     Rifle</span><br><span class="line">     Blower</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出所有枚举值</span><br><span class="line">fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)</span><br><span class="line"></span><br><span class="line">// 使用枚举类型并赋初值</span><br><span class="line">var weapon Weapon = Blower</span><br><span class="line">fmt.Println(weapon)</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>1</code> 行中，将 <code>int</code> 定义为 <code>Weapon</code> 类型，就像枚举类型的本质是一个 <code>int</code> 类型一样。当然，某些情况下，如果需要 <code>int32</code> 和 <code>int64</code> 的枚举，也是可以的。</li><li>第 <code>4</code> 行中，将常量 <code>Arrow</code> 的类型标识为 <code>Weapon</code>，这样标识后，<code>const</code> 下方的常量可以使用 <code>Weapon</code> 作为默认类型。该行使用 <code>iota</code> 进行常量值自动生成，<code>iota</code> 的起始值为 <code>0</code>，一般情况下也是建议枚举从 <code>0</code> 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。</li></ul><p>一个 <code>const</code> 声明内的每一行常量声明，将会自动套用前面的 <code>iota</code> 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。</p><p>当然，<code>iota</code> 不仅可以生成每次增加 <code>1</code> 的枚举值。还可以利用 <code>iota</code> 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    FlagNone = 1 &lt;&lt; iota</span><br><span class="line">    FlagRed</span><br><span class="line">    FlagGreen</span><br><span class="line">    FlagBlue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Printf("%d %d %d\n", FlagRed, FlagGreen, FlagBlue)</span><br><span class="line">fmt.Printf("%b %b %b\n", FlagRed, FlagGreen, FlagBlue)</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4 8</span><br><span class="line">10 100 1000</span><br></pre></td></tr></tbody></table></figure><p>在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 <code>ioto</code> 自动生成更加方便。</p><p>代码说明如下：</p><ul><li>第 <code>2</code> 行中 <code>iota</code> 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。</li><li>第 <code>8</code> 行，将 <code>3</code> 个枚举按照常量输出，分别输出 <code>2</code>、<code>4</code>、<code>8</code>，都是将 <code>1</code> 每次左移一位的结果。</li><li>第 <code>9</code> 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。</li></ul><h3 id="将枚举值转换为字符串"><a href="#将枚举值转换为字符串" class="headerlink" title="将枚举值转换为字符串"></a>将枚举值转换为字符串</h3><p>枚举在 <code>C#</code> , <code>java</code> 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，<code>C#</code> 中 <code>Week</code> 枚举值 <code>Monday</code> 为 <code>1</code> ，那么可以通过 <code>Week.Monday.ToString()</code> 函数获得 <code>Monday</code> 字符串。</p><p><code>Go</code> 语言中也可以实现这一功能，代码如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明芯片类型</span><br><span class="line">type ChipType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None ChipType = iota</span><br><span class="line">    CPU    // 中央处理器</span><br><span class="line">    GPU    // 图形处理器</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func (c ChipType) String() string {</span><br><span class="line">    switch c {</span><br><span class="line">    case None:</span><br><span class="line">        return "None"</span><br><span class="line">    case CPU:</span><br><span class="line">        return "CPU"</span><br><span class="line">    case GPU:</span><br><span class="line">        return "GPU"</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return "N/A"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 输出CPU的值并以整型格式显示</span><br><span class="line">    fmt.Printf("%s %d", CPU, CPU)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU 1</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>6</code> 行，将 <code>int</code> 声明为 <code>ChipType</code> 芯片类型。</li><li>第 <code>9</code> 行，将 <code>const</code> 里定义的常量值设为 <code>ChipType</code> 类型，且从 <code>0</code> 开始，每行值加 <code>1</code>。</li><li>第 <code>14</code> 行，定义 <code>ChipType</code> 类型的方法 <code>String()</code>，返回值为字符串类型。</li><li>第 <code>15～22</code> 行，使用 <code>switch</code> 语句判断当前的 <code>ChitType</code> 类型的值，返回对应的字符串。</li><li>第 <code>30</code> 行，按整型的格式输出 <code>CPU</code> 的值。</li></ul><p><code>String()</code> 方法的 <code>ChipType</code> 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，<code>Go</code> 语言会自动寻找 <code>String()</code> 方法并进行调用。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>Go</code> 语言新版本的功能，内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对Go语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。</p><p>类型别名是 <code>Go 1.9</code> 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 <code>C/C++</code> 语言中，代码重构升级可以使用宏快速定义一段新的代码，<code>Go</code> 语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。</p><p>在 <code>Go 1.9</code> 版本之前定义内建类型的代码是这样写的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte uint8</span><br><span class="line">type rune int32</span><br></pre></td></tr></tbody></table></figure><p>而在 Go 1.9 版本之后变为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></tbody></table></figure><p>这个修改就是配合类型别名而进行的修改。</p><h3 id="区分类型别名与类型定义"><a href="#区分类型别名与类型定义" class="headerlink" title="区分类型别名与类型定义"></a>区分类型别名与类型定义</h3><p>定义类型别名的写法为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></tbody></table></figure><p>类型别名规定：<code>TypeAlias</code> 只是 <code>Type</code> 的别名，本质上 <code>TypeAlias</code> 与 <code>Type</code> 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><p>类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将NewInt定义为int类型</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">// 将int取一个别名叫IntAlias</span><br><span class="line">type IntAlias = int</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将a声明为NewInt类型</span><br><span class="line">    var a NewInt</span><br><span class="line">    // 查看a的类型名</span><br><span class="line">    fmt.Printf("a type: %T\n", a)</span><br><span class="line"></span><br><span class="line">    // 将a2声明为IntAlias类型</span><br><span class="line">    var a2 IntAlias</span><br><span class="line">    // 查看a2的类型名</span><br><span class="line">    fmt.Printf("a2 type: %T\n", a2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码运行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a type: main.NewInt</span><br><span class="line">a2 type: int</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>8</code> 行，将 <code>NewInt</code> 定义为 <code>int</code> 类型，这是常见的定义类型的方法，通过 <code>type</code> 关键字的定义，<code>NewInt</code> 会形成一种新的类型，<code>NewInt</code> 本身依然具备 <code>int</code> 类型的特性。</li><li>第 <code>11</code> 行，将 <code>IntAlias</code> 设置为 <code>int</code> 的一个别名，使用 <code>IntAlias</code> 与 <code>int</code> 等效。</li><li>第 <code>16</code> 行，将 <code>a</code> 声明为 <code>NewInt</code> 类型，此时若打印，则 <code>a</code> 的值为 <code>0</code> 。</li><li>第 <code>18</code> 行，使用 <code>%T</code> 格式化参数，打印变量 <code>a</code> 本身的类型。</li><li>第 <code>21</code> 行，将 <code>a2</code> 声明为 <code>IntAlias</code> 类型，此时打印 <code>a2</code> 的值为 <code>0</code> 。</li><li>第 <code>23</code> 行，打印 <code>a2</code> 变量的类型。</li></ul><p>结果显示 <code>a</code> 的类型是 <code>main.NewInt</code> ，表示 <code>main</code> 包下定义的 <code>NewInt</code> 类型，<code>a2</code> 类型是 <code>int</code> ，<code>IntAlias</code> 类型只会在代码中存在，编译完成时，不会有 <code>IntAlias</code> 类型。</p><h3 id="非本地类型不能定义方法"><a href="#非本地类型不能定义方法" class="headerlink" title="非本地类型不能定义方法"></a>非本地类型不能定义方法</h3><p>能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法呢？参见下面的代码演示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义time.Duration的别名为MyDuration</span><br><span class="line">type MyDuration = time.Duration</span><br><span class="line"></span><br><span class="line">// 为MyDuration添加一个函数</span><br><span class="line">func (m MyDuration) EasySet(a string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>8</code> 行，为 <code>time.Duration</code> 设定一个类型别名叫 <code>MyDuration</code> 。</li><li>第 <code>11</code> 行，为这个别名添加一个方法。</li></ul><p>编译上面代码报错，信息如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot define new methods on non-local type time.Duration</span><br></pre></td></tr></tbody></table></figure><p>编译器提示：不能在一个非本地的类型 <code>time.Duration</code> 上定义新方法，非本地类型指的就是 <code>time.Duration</code> 不是在 <code>main</code> 包中定义的，而是在 <code>time</code> 包中定义的，与 <code>main</code> 包不在同一个包中，因此不能为不在一个包中的类型定义方法。</p><p>解决这个问题有下面两种方法：</p><ul><li>将第 <code>8</code> 行修改为 <code>type MyDuration time.Duration</code> ，也就是将 <code>MyDuration</code> 从别名改为类型；</li><li>将 <code>MyDuration</code> 的别名定义放在 <code>time</code> 包中。</li></ul><h3 id="在结构体成员嵌入时使用别名"><a href="#在结构体成员嵌入时使用别名" class="headerlink" title="在结构体成员嵌入时使用别名"></a>在结构体成员嵌入时使用别名</h3><p>当类型别名作为结构体嵌入的成员时会发生什么情况呢？请参考下面的代码。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义商标结构</span><br><span class="line">type Brand struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为商标结构添加Show()方法</span><br><span class="line">func (t Brand) Show() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Brand定义一个别名FakeBrand</span><br><span class="line">type FakeBrand = Brand</span><br><span class="line"></span><br><span class="line">// 定义车辆结构</span><br><span class="line">type Vehicle struct {</span><br><span class="line">    // 嵌入两个结构</span><br><span class="line">    FakeBrand</span><br><span class="line">    Brand</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明变量a为车辆类型</span><br><span class="line">    var a Vehicle</span><br><span class="line"></span><br><span class="line">    // 指定调用FakeBrand的Show</span><br><span class="line">    a.FakeBrand.Show()</span><br><span class="line"></span><br><span class="line">    // 取a的类型反射对象</span><br><span class="line">    ta := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 遍历a的所有成员</span><br><span class="line">    for i := 0; i &lt; ta.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // a的成员信息</span><br><span class="line">        f := ta.Field(i)</span><br><span class="line"></span><br><span class="line">        // 打印成员的字段名和类型</span><br><span class="line">        fmt.Printf("FieldName: %v, FieldType: %v\n", f.Name, f.Type.Name())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldName: FakeBrand, FieldType: Brand</span><br><span class="line">FieldName: Brand, FieldType: Brand</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 <code>9</code> 行，定义商标结构。</li><li>第 <code>13</code> 行，为商标结构添加 <code>Show()</code> 方法。</li><li>第 <code>17</code> 行，为 <code>Brand</code> 定义一个别名 <code>FakeBrand</code>。</li><li>第 <code>20～25</code> 行，定义车辆结构 <code>Vehicle</code> ，嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 结构。</li><li>第 <code>30</code> 行，将 <code>Vechicle</code> 实例化为 <code>a</code> 。</li><li>第 <code>33</code> 行，显式调用 <code>Vehicle</code> 中 <code>FakeBrand</code> 的 <code>Show()</code> 方法。</li><li>第 <code>36</code> 行，使用反射取变量 <code>a</code> 的反射类型对象，以查看其成员类型。</li><li>第 <code>39～42</code> 行，遍历 <code>a</code> 的结构体成员。</li><li>第 <code>45</code> 行，打印 <code>Vehicle</code> 类型所有成员的信息。</li></ul><p>这个例子中，<code>FakeBrand</code> 是 <code>Brand</code> 的一个别名，在 <code>Vehicle</code> 中嵌入 <code>FakeBrand</code> 和 <code>Brand</code> 并不意味着嵌入两个 <code>Brand</code>，<code>FakeBrand</code> 的类型会以名字的方式保留在 <code>Vehicle</code> 的成员中。</p><p>如果尝试将第 <code>33</code> 行改为：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.Show()</span><br></pre></td></tr></tbody></table></figure><p>编译器将发生报错：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambiguous selector a.Show</span><br></pre></td></tr></tbody></table></figure><p>在调用 <code>Show()</code> 方法时，因为两个类型都有 <code>Show()</code> 方法，会发生歧义，证明 <code>FakeBrand</code> 的本质确实是 <code>Brand</code> 类型。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释在程序中的作用是对程序进行注解和说明，便于对源码的阅读。编译系统在对源代码进行编译时会自动忽略注释的部分，因此注释对于程序的功能实现不起任何作用。在源码中适当地添加注释，能够提高源码的可读性。</p><p><code>Go</code> 语言的注释主要分成两类，分别是单行注释和多行注释。</p><ul><li>单行注释简称行注释，是最常见的注释形式，可以在任何地方使用以 <code>//</code> 开头的单行注释；</li><li>多行注释简称块注释，以 <code>/*</code> 开头，并以 <code>*/</code> 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li></ul><p>单行注释的格式如下所示:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></tbody></table></figure><p>多行注释的格式如下所示:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">...</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><p>每一个包都应该有相关注释，在使用 <code>package</code> 语句声明包名之前添加相应的注释，用来对包的功能及作用进行简要说明。</p><p>同时，在 <code>package</code> 语句之前的注释内容将被默认认为是这个包的文档说明。一个包可以分散在多个文件中，但是只需要对其中一个进行注释说明即可。</p><p>在多段注释之间可以使用空行分隔加以区分，如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Package superman implements methods for saving the world.</span><br><span class="line">//</span><br><span class="line">// Experience has shown that a small number of procedures can prove</span><br><span class="line">// helpful when attempting to save the world.</span><br><span class="line">package superman</span><br></pre></td></tr></tbody></table></figure><p>对于代码中的变量、常量、函数等对象最好也都加上对应的注释，这样有利于后期对代码进行维护，例如下面代码中对 <code>enterOrbit</code> 函数的注释：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// enterOrbit causes Superman to fly into low Earth orbit, a position</span><br><span class="line">// that presents several possibilities for planet salvation.</span><br><span class="line">func enterOrbit() error {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当开发人员需要了解包的一些情况时，可以使用 godoc 来显示包的文档说明，下面来介绍一下 godoc 工具的使用。</p><h3 id="godoc-工具"><a href="#godoc-工具" class="headerlink" title="godoc 工具"></a>godoc 工具</h3><p><code>godoc</code> 工具会从 <code>Go</code> 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 <code>web</code> 服务器，<code>Go</code> <a target="_blank" rel="noopener" href="https://golang.google.cn/">语言官网</a>就是通过这种形式实现的。</p><p>但是<code>Go</code>语言 <code>1.13</code> 版本移除了 <code>godoc</code> 工具，大家可以通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/tools/cmd/godoc</span><br></pre></td></tr></tbody></table></figure><p>由于防火墙的原因，国内的用户可能无法通过 <code>go get</code> 命令来获取 <code>godoc</code> 工具，这时候就需要大家来手动操作了。</p><ul><li>首先从 <a target="_blank" rel="noopener" href="https://github.com/golang/tools.git">GitHub</a> 下载 <code>golang.org/x/tools</code> 包；</li><li>然后将下载得到的文件解压到 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools</code> 目录中，没有的话可以手动创建；</li><li>打开 <code>GOPATH</code> 下的 <code>src\golang.org\x\tools\cmd\godoc</code> 目录，在该目录下打开命令行工具，并执行 <code>go build</code> 命令，生成 <code>godoc.exe</code> 可执行文件；</li><li>最后，将生成的 <code>godoc.exe</code> 文件移动到 <code>GOPATH</code> 下的 <code>bin</code> 目录中。（需要把 <code>GOPATH</code> 下的 <code>bin</code> 目录添加到环境变量 <code>Path</code> 中）</li></ul><p>完成上述操作后就可以使用 <code>godoc</code> 工具了，<code>godoc</code> 工具一般有以下几种用法：</p><ul><li><code>go doc package</code>：获取包的文档注释，例如 <code>go doc fmt</code> 会显示使用 <code>godoc</code> 生成的 <code>fmt</code> 包的文档注释；</li><li><code>go doc package/subpackage</code>：获取子包的文档注释，例如 <code>go doc container/list</code>；</li><li><code>go doc package function</code>：获取某个函数在某个包中的文档注释，例如 <code>go doc fmt Printf</code> 会显示有关 <code>fmt.Printf()</code> 的使用说明。</li></ul><p>下图演示了使用go doc 命令来获取包的文档注释：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc package main</span><br></pre></td></tr></tbody></table></figure><p><code>godoc</code> 工具还可以获取 <code>Go</code> 安装目录下 <code>../go/src</code> 中的注释内容，并将这些注释内容整合到 <code>web</code> 服务器中供我们预览。在命令行输入 <code>godoc -http=:6060</code> ，然后使用浏览器打开 <code>http://localhost:6060</code> 后，就可以看到本地文档浏览服务器提供的页面。</p><h2 id="关键字和标识符"><a href="#关键字和标识符" class="headerlink" title="关键字和标识符"></a>关键字和标识符</h2><p><code>Go</code> 语言的词法元素包括 <code>5</code> 种，分别是标识符<code>（identifier）</code>、关键字<code>（keyword）</code>、操作符<code>（operator）</code>、分隔符<code>（delimiter）</code>、字面量<code>（literal）</code>，它们是组成 <code>Go</code> 语言代码和程序的最基本单位。</p><p>本节我们主要来介绍一下 <code>Go</code> 语言中的关键字和标识符。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。</p><p>Go语言中的关键字一共有 25 个：</p><table>  <tbody>    <tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr>    <tr><th>case</th><th>defer</th><th>go</th><th>map</th><th>struct</th></tr>    <tr><th>chan</th><th>else</th><th>goto</th><th>package</th><th>switch</th></tr>    <tr><th>const</th><th>fallthrough</th><th>if</th><th>range</th><th>type</th></tr>    <tr><th>continue</th><th>for</th><th>import</th><th>return</th><th>var</th></tr>  </tbody></table><p>之所以刻意地将 <code>Go</code> 语言中的关键字保持的这么少，是为了简化在编译过程中的代码解析。和其它语言一样，关键字不能够作标识符使用。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指 <code>Go</code> 语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线_、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。</p><p>下划线<em>是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用</em>作为变量对其它变量进行赋值或运算。</p><p>在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。</p><p>标识符的命名需要遵守以下规则：</p><ul><li>由 <code>26</code> 个英文字母、<code>0~9</code>、<code>_</code> 组成；</li><li>不能以数字开头，例如 <code>var 1num int</code> 是错误的；</li><li><code>Go</code> 语言中严格区分大小写；</li><li>标识符不能包含空格；</li><li>不能以系统保留关键字作为标识符，比如 <code>break</code> ，<code>if</code> 等等。</li></ul><p>命名标识符时还需要注意以下几点：</p><ul><li>标识符的命名要尽量采取简短且有意义；</li><li>不能和标准库中的包名重复；</li><li>为变量、函数、常量命名时采用驼峰命名法，例如 <code>stuName</code>、<code>getVal</code> ；</li></ul><p>当然 <code>Go</code> 语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 <code>Java</code> 中的 <code>public</code> ）；如果首字母小写，则表示它只能在本包中使用 (类似于 <code>Java</code> 中 <code>private</code> ）。</p><p>在 <code>Go</code> 语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：</p><table>  <tbody>      <tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr>    <tr><th>copy</th><th>false</th><th>float32</th><th>float64</th><th>imag</th><th>int</th><th>int8</th><th>int16</th><th>uint32</th></tr>    <tr><th>int32</th><th>int64</th><th>iota</th><th>len</th><th>make</th><th>new</th><th>nil</th><th>panic</th><th>uint64</th></tr>    <tr><th>print</th><th>println</th><th>real</th><th>recover</th><th>string</th><th>true</th><th>uint</th><th>uint8</th><th>uintptr</th></tr>  </tbody></table><p>预定义标识符一共有 <code>36</code> 个，主要包含 <code>Go</code> 语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。</p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>运算符是用来在程序运行时执行数学或逻辑运算的，在 <code>Go</code> 语言中，一个表达式可以包含多个运算符，当表达式中存在多个运算符时，就会遇到优先级的问题，此时应该先处理哪个运算符呢？这个就由 <code>Go</code> 语言运算符的优先级来决定的。</p><p>比如对于下面的表达式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a, b, c int = 16, 4, 2</span><br><span class="line">d := a + b*c</span><br></pre></td></tr></tbody></table></figure><p>对于表达式 <code>a + b * c</code> ，如果按照数学规则推导，应该先计算乘法，再计算加法；<code>b * c</code> 的结果为 <code>8</code> ，<code>a + 8</code> 的结果为 <code>24</code> ，所以 <code>d</code> 最终的值也是 <code>24</code> 。实际上 <code>Go</code> 语言也是这样处理的，先计算乘法再计算加法，和数据中的规则一样，读者可以亲自验证一下。</p><p>先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。</p><p><code>Go</code> 语言有几十种运算符，被分成十几个级别，有的运算符优先级不同，有的运算符优先级相同，请看下表。</p><table>  <thead><tr><th>优先级</th><th>分类</th><th>运算符</th><th>结合性</th></tr></thead>  <tbody>            <tr><th>1</th><th>逗号运算符</th><th>,</th><th>从左到右</th></tr>    <tr><th>2</th><th>赋值运算符</th><th>=、+=、-=、*=、/=、 %=、 &gt;=、 &lt;&lt;=、&amp;=、^=、|=</th><th>从右到左</th></tr>    <tr><th>3</th><th>逻辑或</th><th>||</th><th>从左到右</th></tr>    <tr><th>4</th><th>逻辑与</th><th>&amp;&amp;</th><th>从左到右</th></tr>    <tr><th>5</th><th>按位或</th><th>|</th><th>从左到右</th></tr>    <tr><th>6</th><th>按位异或</th><th>^</th><th>从左到右</th></tr>    <tr><th>7</th><th>按位与</th><th>&amp;</th><th>从左到右</th></tr>    <tr><th>8</th><th>相等/不等</th><th>==、!=</th><th>从左到右</th></tr>    <tr><th>9</th><th>关系运算符</th><th>&lt;、&lt;=、&gt;、&gt;=</th><th>从左到右</th></tr>    <tr><th>10</th><th>位移运算符</th><th>&lt;&lt;、&gt;&gt;</th><th>从左到右</th></tr>    <tr><th>11</th><th>加法/减法</th><th>+、-</th><th>从左到右</th></tr>    <tr><th>12</th><th>乘法/除法/取余</th><th>*（乘号）、/、%</th><th>从左到右</th></tr>    <tr><th>13</th><th>单目运算符</th><th>!、*（指针）、&amp; 、++、--、+（正号）、-（负号）</th><th>从右到左</th></tr>    <tr><th>14</th><th>后缀运算符</th><th>( )、[ ]、-&gt;</th><th>从左到右</th></tr>    </tbody></table><p>注意：优先级值越大，表示优先级越高。</p><p>一下子记住所有运算符的优先级并不容易，还好 <code>Go</code> 语言中大部分运算符的优先级和数学中是一样的，大家在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d := a + (b * c)</span><br></pre></td></tr></tbody></table></figure><p>括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。</p><p>运算符的结合性是指相同优先级的运算符在同一个表达式中，且没有括号的时候，操作数计算的顺序，通常有从左到右和从右到左两种方式，例如，<code>+</code> 加法运算符的结合性是从左到右，那么表达式 <code>a + b + c</code> 则可以理解为为 <code>(a + b) + c</code> 。</p><h2 id="字符串和数值类型的转换"><a href="#字符串和数值类型的转换" class="headerlink" title="字符串和数值类型的转换"></a>字符串和数值类型的转换</h2><p>在实际开发中我们往往需要对一些常用的数据类型进行转换，如 <code>string</code> 、<code>int</code> 、<code>int64</code> 、<code>float</code> 等数据类型之间的转换，<code>Go</code> 语言中的 <code>strconv</code> 包为我们提供了字符串和基本数据类型之间的转换功能。</p><p><code>strconv</code> 包中常用的函数包括 <code>Atoi()</code> 、<code>Itia()</code> 、<code>parse</code> 系列函数、<code>format</code> 系列函数、<code>append</code> 系列函数等，下面就来分别介绍一下。</p><h3 id="string-与-int-类型之间的转换"><a href="#string-与-int-类型之间的转换" class="headerlink" title="string 与 int 类型之间的转换"></a>string 与 int 类型之间的转换</h3><p>字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。</p><h4 id="Itoa-：整型转字符串"><a href="#Itoa-：整型转字符串" class="headerlink" title="Itoa()：整型转字符串"></a>Itoa()：整型转字符串</h4><p>Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Itoa(i int) string</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := 100</span><br><span class="line">    str := strconv.Itoa(num)</span><br><span class="line">    fmt.Printf("type:%T value:%#v\n", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:string value:"100"</span><br></pre></td></tr></tbody></table></figure><h4 id="Atoi-：字符串转整型"><a href="#Atoi-：字符串转整型" class="headerlink" title="Atoi()：字符串转整型"></a>Atoi()：字符串转整型</h4><p><code>Atoi()</code> 函数用于将字符串类型的整数转换为 <code>int</code> 类型，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Atoi(s string) (i int, err error)</span><br></pre></td></tr></tbody></table></figure><p>通过函数签名可以看出 <code>Atoi()</code> 函数有两个返回值，<code>i</code> 为转换成功的整型，<code>err</code> 在转换成功是为空转换失败时为相应的错误信息。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    str2 := "s100"</span><br><span class="line">    num1, err := strconv.Atoi(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str1)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num1, num1)</span><br><span class="line">    }</span><br><span class="line">    num2, err := strconv.Atoi(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("%v 转换失败！", str2)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("type:%T value:%#v\n", num2, num2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:int value:110</span><br><span class="line">s100 转换失败！</span><br></pre></td></tr></tbody></table></figure><h3 id="Parse-系列函数"><a href="#Parse-系列函数" class="headerlink" title="Parse 系列函数"></a>Parse 系列函数</h3><p><code>Parse</code> 系列函数用于将字符串转换为指定类型的值，其中包括 <code>ParseBool()</code> 、<code>ParseFloat()</code> 、<code>ParseInt()</code> 、<code>ParseUint()</code> 。</p><h4 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h4><p><code>ParseBool()</code> 函数用于将字符串转换为 <code>bool</code> 类型的值，它只能接受 <code>1</code> 、<code>0</code> 、<code>t</code> 、<code>f</code> 、<code>T</code> 、<code>F</code> 、<code>true</code> 、<code>false</code> 、<code>True</code> 、<code>False</code> 、<code>TRUE</code> 、<code>FALSE</code> ，其它的值均返回错误，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ParseBool(str string) (value bool, err error)</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str1 := "110"</span><br><span class="line">    boo1, err := strconv.ParseBool(str1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str1: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo1)</span><br><span class="line">    }</span><br><span class="line">    str2 := "t"</span><br><span class="line">    boo2, err := strconv.ParseBool(str2)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("str2: %v\n", err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(boo2)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: strconv.ParseBool: parsing "110": invalid syntax</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure><h4 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h4><p><code>ParseInt()</code> 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ParseInt(s string, base int, bitSize int) (i int64, err error)</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>base</code> 指定进制，取值范围是 <code>2</code> 到 <code>36</code>。如果 <code>base</code> 为 <code>0</code> ，则会从字符串前置判断，“0x”是 <code>16</code> 进制，“0”是 <code>8</code> 进制，否则是 <code>10</code> 进制。</li><li><code>bitSize</code> 指定结果必须能无溢出赋值的整数类型，<code>0</code> 、<code>8</code> 、<code>16</code> 、<code>32</code> 、<code>64</code> 分别代表 <code>int</code> 、<code>int8</code> 、<code>int16</code> 、<code>int32</code> 、<code>int64</code> 。</li><li>返回的 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误，<code>err.Error = ErrSyntax</code> ，如果结果超出类型范围 <code>err.Error = ErrRange</code> 。</li></ul><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "-11"</span><br><span class="line">    num, err := strconv.ParseInt(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-11</span><br></pre></td></tr></tbody></table></figure><h4 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h4><p><code>ParseUint()</code> 函数的功能类似于 <code>ParseInt()</code> 函数，但 <code>ParseUint()</code> 函数不接受正负号，用于无符号整型，函数签名如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "11"</span><br><span class="line">    num, err := strconv.ParseUint(str, 10, 0)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></tbody></table></figure><h4 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h4><p><code>ParseFloat()</code> 函数用于将一个表示浮点数的字符串转换为 <code>float</code> 类型，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ParseFloat(s string, bitSize int) (f float64, err error)</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li>如果 <code>s</code> 合乎语法规则，函数会返回最为接近 <code>s</code> 表示值的一个浮点数（使用 <code>IEEE754</code> 规范舍入）。</li><li><code>bitSize</code> 指定了返回值的类型，<code>32</code> 表示 <code>float32</code>，<code>64</code> 表示 <code>float64</code> ；</li><li>返回值 <code>err</code> 是 <code>*NumErr</code> 类型的，如果语法有误 <code>err.Error=ErrSyntax</code> ，如果返回值超出表示范围，返回值 <code>f</code> 为 <code>±Inf，err.Error= ErrRange</code> 。</li></ul><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    str := "3.1415926"</span><br><span class="line">    num, err := strconv.ParseFloat(str, 64)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(num)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1415926</span><br></pre></td></tr></tbody></table></figure><p><code>Parse</code> 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p><h3 id="Format-系列函数"><a href="#Format-系列函数" class="headerlink" title="Format 系列函数"></a>Format 系列函数</h3><p><code>Format</code> 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 <code>FormatBool()</code>、<code>FormatInt()</code>、<code>FormatUint()</code>、<code>FormatFloat()</code>。</p><h4 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h4><p><code>FormatBool()</code> 函数可以一个 <code>bool</code> 类型的值转换为对应的字符串类型，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FormatBool(b bool) string</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    num := true</span><br><span class="line">    str := strconv.FormatBool(num)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:string,value:true</span><br></pre></td></tr></tbody></table></figure><h4 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h4><p>FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FormatInt(i int64, base int) string</span><br></pre></td></tr></tbody></table></figure><p>其中，参数 <code>i</code> 必须是 <code>int64</code> 类型，参数 <code>base</code> 必须在 <code>2</code> 到 <code>36</code> 之间，返回结果中会使用小写字母“a”到“z”表示大于 <code>10</code> 的数字。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num int64 = 100</span><br><span class="line">    str := strconv.FormatInt(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:string,value:64</span><br></pre></td></tr></tbody></table></figure><h4 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h4><p><code>FormatUint()</code> 函数与 <code>FormatInt()</code> 函数的功能类似，但是参数 <code>i</code> 必须是无符号的 <code>uint64</code> 类型，函数签名如下。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FormatUint(i uint64, base int) string</span><br></pre></td></tr></tbody></table></figure><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num uint64 = 110</span><br><span class="line">    str := strconv.FormatUint(num, 16)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:string,value:6e</span><br></pre></td></tr></tbody></table></figure><h4 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h4><p><code>FormatFloat()</code> 函数用于将浮点数转换为字符串类型，函数签名如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><code>bitSize</code> 表示参数 <code>f</code> 的来源类型（<code>32</code> 表示 <code>float32</code>、<code>64</code> 表示 <code>float64</code>），会据此进行舍入。</li><li><code>fmt</code> 表示格式，可以设置为“f”表示 <code>-ddd.dddd</code> 、“b”表示 <code>-ddddp±ddd</code>，指数为二进制、“e”表示 <code>-d.dddde±dd</code> 十进制指数、“E”表示 <code>-d.ddddE±dd</code> 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li><li><code>prec</code> 控制精度（排除指数部分）：当参数 <code>fmt</code> 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 <code>fmt</code> 为“g”、“G”时，它控制总的数字个数。如果 <code>prec</code> 为 <code>-1</code> ，则代表使用最少数量的、但又必需的数字来表示 <code>f</code> 。</li></ul><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    var num float64 = 3.1415926</span><br><span class="line">    str := strconv.FormatFloat(num, 'E', -1, 64)</span><br><span class="line">    fmt.Printf("type:%T,value:%v\n ", str, str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type:string,value:3.1415926E+00</span><br></pre></td></tr></tbody></table></figure><h3 id="Append-系列函数"><a href="#Append-系列函数" class="headerlink" title="Append 系列函数"></a>Append 系列函数</h3><p><code>Append</code> 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 <code>AppendBool()</code> 、<code>AppendFloat()</code> 、<code>AppendInt()</code> 、<code>AppendUint()</code> 。</p><p><code>Append</code> 系列函数和 <code>Format</code> 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个slice</span><br><span class="line">    b10 := []byte("int (base 10):")</span><br><span class="line">  </span><br><span class="line">    // 将转换为10进制的string，追加到slice中</span><br><span class="line">    b10 = strconv.AppendInt(b10, -42, 10)</span><br><span class="line">    fmt.Println(string(b10))</span><br><span class="line">    b16 := []byte("int (base 16):")</span><br><span class="line">    b16 = strconv.AppendInt(b16, -42, 16)</span><br><span class="line">    fmt.Println(string(b16))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (base 10):-42</span><br><span class="line">int (base 16):-2a</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go dubbo</title>
      <link href="posts/3498a470/"/>
      <url>posts/3498a470/</url>
      
        <content type="html"><![CDATA[<p>go语言使用dubbo-go接入现有的dubbo服务</p><h2 id="注册中心使用-zookeeper-，序列化使用-hessian2"><a href="#注册中心使用-zookeeper-，序列化使用-hessian2" class="headerlink" title="注册中心使用 zookeeper ，序列化使用 hessian2"></a>注册中心使用 <code>zookeeper</code> ，序列化使用 <code>hessian2</code></h2><p>目前我司在使用 dubbo 的过程使用的 zookeeper 作为注册中心，序列化是 hessian2 ，所以我们要做如下初始化：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "github.com/apache/dubbo-go/common/proxy/proxy_factory"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/protocol"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/filter/impl"</span><br><span class="line"></span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/cluster_impl"</span><br><span class="line">    _ "github.com/apache/dubbo-go/cluster/loadbalance"</span><br><span class="line">    _ "github.com/apache/dubbo-go/registry/zookeeper"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>由于我是接入客户端，所以我这边只需要配置 <code>ConsumerConfig</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">    # client</span><br><span class="line">    request_timeout: "3s"</span><br><span class="line">    # connect timeout</span><br><span class="line">    connect_timeout: "3s"</span><br><span class="line">    check: true</span><br><span class="line">    application:</span><br><span class="line">        organization: "wssjdi.com"</span><br><span class="line">        name: "soa.sso.ITokenService"</span><br><span class="line">        module: "dubbogo token service client"</span><br><span class="line">        version: "1.0.0"</span><br><span class="line">        owner: "wssjdi"</span><br><span class="line">    registries:</span><br><span class="line">        "localzk":</span><br><span class="line">            protocol: "zookeeper"</span><br><span class="line">            timeout: "3s"</span><br><span class="line">            address: "10.100.156.17:2181"</span><br><span class="line">            username: ""</span><br><span class="line">            password: ""</span><br><span class="line">    references:</span><br><span class="line">        "ITokenService":</span><br><span class="line">            registry: "localzk"</span><br><span class="line">            protocol: "dubbo"</span><br><span class="line">            interface: "com.wssjdi.soa.sso.ITokenService"</span><br><span class="line">            version: "1.0.0"</span><br><span class="line">            methods:</span><br><span class="line">                - name: "validate"</span><br><span class="line">            retries: "3"</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go dubbo </tag>
            
            <tag> dubbo </tag>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go mod解决依赖无法下载的问题</title>
      <link href="posts/fd72e7c1/"/>
      <url>posts/fd72e7c1/</url>
      
        <content type="html"><![CDATA[<p>go mod解决依赖无法下载的问题</p><p>国内<code>Golang</code>开发由于网络环境的问题，经常会出现依赖无法下载的问题。当然可以通过VPN代理解决。但是<code>Go 1.11</code>版本之后，有了更加简单的解决方法了，那就是<code>GOPROXY</code>。</p><p>从<code>Go 1.11</code> 版本开始，官方支持了 <code>go module</code> 包依赖管理工具。</p><p>其实还新增了 <code>GOPROXY</code> 环境变量。如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。这样相当于建立了一个私库，也就解决了国外某些依赖无法下载的问题。</p><p>使用方法如下：<br></p><figure class="highlight plain"><figcaption><span>/etc/profile</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Linux / macOS</span><br><span class="line">export GOPROXY=https://goproxy.io</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$env:GOPROXY = "https://goproxy.io"</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后就可以使用 <code>go mod tidy</code> 快乐的下载依赖了。</p><p>需要注意的是：</p><p>如果在 <code>$GOPATH/src</code>下面，需要通过 <code>export GO111MODULE=on</code> 激活 <code>go module</code><br><a target="_blank" rel="noopener" href="https://goproxy.io">https://goproxy.io</a> 也可以换成 <a target="_blank" rel="noopener" href="https://goproxy.cn">https://goproxy.cn</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go mod </tag>
            
            <tag> 依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go test单元测试及基准测试</title>
      <link href="posts/2910ec3f/"/>
      <url>posts/2910ec3f/</url>
      
        <content type="html"><![CDATA[<p>Go语言拥有一套单元测试和性能测试系统，仅需要添加很少的代码就可以快速测试一段需求代码。</p><h1 id="go-test命令"><a href="#go-test命令" class="headerlink" title="go test命令"></a>go test命令</h1><p>go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。输出的信息类似下面所示的样子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">go: downloading gopkg.in/yaml.v2 v2.2.8</span><br><span class="line">go: downloading github.com/stretchr/testify v1.5.1</span><br><span class="line">go: downloading github.com/pkg/errors v0.9.1</span><br><span class="line">go: downloading github.com/pmezard/go-difflib v1.0.0</span><br><span class="line">go: downloading github.com/davecgh/go-spew v1.1.1</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.952s</span><br></pre></td></tr></tbody></table></figure><p>性能测试系统可以给出代码的性能数据，帮助测试者分析性能问题。</p><p>提示</p><p>单元测试<code>（unit testing）</code>，是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如 <code>C</code> 语言中单元指一个函数，<code>Java</code> 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p><h2 id="单元测试——测试和验证代码的框架"><a href="#单元测试——测试和验证代码的框架" class="headerlink" title="单元测试——测试和验证代码的框架"></a>单元测试——测试和验证代码的框架</h2><p>要开始一个单元测试，需要准备一个 <code>go</code> 源码文件，在命名文件时需要让文件必须以 <code>_test</code> 结尾。默认的情况下，<code>go test</code> 命令不需要任何的参数，它会自动把你源码包下面所有 <code>test</code> 文件测试完毕，当然你也可以带上参数。</p><p>常用的参数：</p><ul><li>-bench regexp 执行相应的 <code>benchmarks</code>，例如 <code>-bench=.</code>；</li><li>-cover 开启测试覆盖率；</li><li>-run regexp 只运行 <code>regexp</code> 匹配的函数，例如 <code>-run=Array</code> 那么就执行包含有 <code>Array</code> 开头的函数；</li><li>-v 显示测试的详细命令。</li></ul><p>单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以<code>Test</code>为前缀，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package yaml</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"path/filepath"</span><br><span class="line">"testing"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"github.com/stretchr/testify/assert"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func TestUnmarshalYML(t *testing.T) {</span><br><span class="line">c := &amp;Config{}</span><br><span class="line">b, err := LoadYMLConfig("./testdata/config.yml")</span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">err = UnmarshalYML(b, c)</span><br><span class="line">assert.NoError(t, err)</span><br><span class="line">    t.Log(c.StrTest)</span><br><span class="line">assert.Equal(t, "strTest", c.StrTest)</span><br><span class="line">assert.Equal(t, 11, c.IntTest)</span><br><span class="line">assert.Equal(t, false, c.BooleanTest)</span><br><span class="line">assert.Equal(t, "childStrTest", c.ChildConfig.StrTest)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Config struct {</span><br><span class="line">StrTest     string      `yaml:"strTest" default:"default" json:"strTest,omitempty" property:"strTest"`</span><br><span class="line">IntTest     int         `default:"109"  yaml:"intTest" json:"intTest,omitempty" property:"intTest"`</span><br><span class="line">BooleanTest bool        `yaml:"booleanTest" default:"true" json:"booleanTest,omitempty"`</span><br><span class="line">ChildConfig ChildConfig `yaml:"child" json:"child,omitempty"`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type ChildConfig struct {</span><br><span class="line">StrTest string `default:"strTest" default:"default" yaml:"strTest"  json:"strTest,omitempty"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。</li><li>测试用例文件使用 <code>go test</code> 指令来执行，没有也不需要 <code>main()</code> 作为函数入口。所有在以 <code>_test</code> 结尾的源码内以 <code>Test</code> 开头的函数会自动被执行。</li><li>测试用例可以不传入 <code>*testing.T</code> 参数。</li></ul><p>代码说明如下：</p><ul><li>第 10 行，单元测试文件 <code>(*_test.go)</code> 里的测试入口必须以 <code>Test</code> 开始，参数为 <code>*testing.T</code> 的函数。一个单元测试文件可以有多个测试入口。</li><li>第 16 行，使用 <code>testing</code> 包的 <code>T</code> 结构提供的 <code>Log()</code> 方法打印字符串。</li></ul><h3 id="单元测试命令行"><a href="#单元测试命令行" class="headerlink" title="单元测试命令行"></a>单元测试命令行</h3><p>单元测试使用 go test 命令启动，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.627s</span><br><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\yaml&gt;go test -v -run TestUnmarshalYML$</span><br><span class="line">=== RUN   TestUnmarshalYML</span><br><span class="line">--- PASS: TestUnmarshalYML (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml       0.637s</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行，如果在 <code>go test</code> 后跟了单元测试源文件，表示测试这个文件里的所有测试用例，没有则测试所有的单元测试源文件。</li><li>第 3 行，显示测试结果，  <code>ok</code> 表示测试通过，<code>github.com/dubbogo/dubbo-go-proxy/pkg/common/yaml</code> 是测试用例的包名，<code>0.627s</code> 表示测试花费的时间。</li><li>第 4 行，显示在附加参数中添加了<code>-v</code>，可以让测试时显示详细的流程，添加<code>-run</code>，指定执行的测试用例<code>TestUnmarshalYML$</code>匹配正则表达式。</li><li>第 5 行，表示开始运行名叫 <code>TestUnmarshalYML</code> 的测试用例。</li><li>第 6 行，表示已经运行完 <code>TestUnmarshalYML</code> 的测试用例，PASS 表示测试成功。</li></ul><p><code>-run</code>跟随的测试用例的名称支持正则表达式，使用<code>-run TestUnmarshalYML$</code>即可只执行 <code>TestUnmarshalYML</code> 测试用例，如果不带最后的<code>$</code>，则执行所有以<code>TestUnmarshalYML</code>为开头的测试用例。</p><h3 id="标记单元测试结果"><a href="#标记单元测试结果" class="headerlink" title="标记单元测试结果"></a>标记单元测试结果</h3><p>当需要终止当前测试用例时，可以使用 <code>t.FailNow()</code>。</p><p>还有一种只标记错误不终止测试的方法 <code>t.Fail()</code> ，调用 Fail() 后测试结果标记为失败，但是后续代码依然会被程序执行。</p><h3 id="单元测试日志"><a href="#单元测试日志" class="headerlink" title="单元测试日志"></a>单元测试日志</h3><p>每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。</p><div align="center">  单元测试框架提供的日志方法<table>    <thead>      <tr></tr>    </thead>    <thead>      <tr>        <th align="center">方法</th>        <th align="center">备注</th>      </tr>    </thead>    <tbody>      <tr>        <td align="center"><strong>Log</strong></td>        <td align="center">打印日志，同时结束测试</td>      </tr>      <tr>        <td align="center"><strong>Logf</strong></td>        <td align="center">格式化打印日志，同时结束测试</td>      </tr>      <tr>        <td align="center"><strong>Error</strong></td>        <td align="center">打印错误日志，同时结束测试</td>      </tr>      <tr>        <td align="center"><strong>Errorf</strong></td>        <td align="center">格式化打印错误日志，同时结束测试</td>      </tr>      <tr>        <td align="center"><strong>Fatal</strong></td>        <td align="center">打印致命日志，同时结束测试</td>      </tr>      <tr>        <td align="center"><strong>Fatalf</strong></td>        <td align="center">格式化打印致命日志，同时结束测试</td>      </tr>    </tbody>  </table></div><p>开发者可以根据实际需要选择合适的日志。</p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>go test -v -bench=. benchmark_test.go</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.341 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.977s</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行的-bench=.表示运行 <code>benchmark_test.go</code> 文件里的所有基准测试，和单元测试中的<code>-run</code>类似。</li><li>第 5 行中显示基准测试名称，1000000000 表示测试的次数，也就是 <code>testing.B</code> 结构中提供给程序使用的 N。<code>0.341 ns/op</code> 表示每一个操作耗费多少时间（纳秒）。</li></ul><p>注意：<code>Windows</code> 下使用 <code>go test</code> 命令行时，<code>-bench=.</code> 应写为 <code>-bench="."</code>。</p><h3 id="基准测试原理"><a href="#基准测试原理" class="headerlink" title="基准测试原理"></a>基准测试原理</h3><p>基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。</p><h3 id="自定义测试时间"><a href="#自定义测试时间" class="headerlink" title="自定义测试时间"></a>自定义测试时间</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=. -benchtime=5s benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Add</span><br><span class="line">Benchmark_Add-4         1000000000               0.351 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  0.902s</span><br></pre></td></tr></tbody></table></figure><h3 id="测试内存"><a href="#测试内存" class="headerlink" title="测试内存"></a>测试内存</h3><p>基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func Benchmark_Alloc(b *testing.B) {</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        fmt.Sprintf("%d", i)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在命令行中添加-benchmem参数以显示内存分配情况，参见下面的指令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\pkg\common\benchmark&gt;go test -v -bench=Alloc -benchmem benchmark_test.go</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">Benchmark_Alloc</span><br><span class="line">Benchmark_Alloc-4        8610186               120 ns/op              16 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      command-line-arguments  1.760s</span><br></pre></td></tr></tbody></table></figure><p>代码说明如下：</p><ul><li>第 1 行的代码中-bench后添加了 <code>Alloc</code>，指定只测试 <code>Benchmark_Alloc()</code> 函数。</li><li>第 5 行代码的 <code>16 B/op</code>表示每一次调用需要分配 <code>16</code> 个字节，<code>2 allocs/op</code> 表示每一次调用有两次分配。</li></ul><p>开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。</p><h3 id="控制计时器"><a href="#控制计时器" class="headerlink" title="控制计时器"></a>控制计时器</h3><p>有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。</p><p>基准测试中的计时器控制<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Benchmark_Add_TimerControl(b *testing.B) {</span><br><span class="line">// 重置计时器</span><br><span class="line">b.ResetTimer()</span><br><span class="line">// 停止计时器</span><br><span class="line">b.StopTimer()</span><br><span class="line">// 开始计时器</span><br><span class="line">b.StartTimer()</span><br><span class="line">var n int</span><br><span class="line">for i := 0; i &lt; b.N; i++ {</span><br><span class="line">n++</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>从 <code>Benchmark()</code> 函数开始，<code>Timer</code> 就开始计数。<code>StopTimer()</code> 可以停止这个计数过程，做一些耗时的操作，通过 <code>StartTimer()</code> 重新开始计时。<code>ResetTimer()</code> 可以重置计数器的数据。</p><p>计数器内部不仅包含耗时数据，还包括内存分配的数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go test </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> 基准测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Vue前后端分离开发合并部署</title>
      <link href="posts/77ca7534/"/>
      <url>posts/77ca7534/</url>
      
        <content type="html"><![CDATA[<p>目前很多项目都是前端页面和后端接口分开开发，然而有很多特殊项目在开发过程中会出现这样的情况，开发的时候分开开发、联调、测试，但是部署的时候却需要整合在一起部署，接下来解决该问题。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先必须改造原有的项目结构，将前端和后端项目放在同一个<code>MAVEN</code>项目下，这样才能使用<code>MAVEN</code>工具来管理整个项目构建周期;项目结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p><h2 id="修改parent-pom-xml"><a href="#修改parent-pom-xml" class="headerlink" title="修改parent/pom.xml"></a>修改parent/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">&lt;description&gt;QCloud COS&lt;/description&gt;</span><br><span class="line">&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">&lt;modules&gt;</span><br><span class="line">&lt;module&gt;frontend&lt;/module&gt;&lt;!-- 前端静态页面模块 --&gt;</span><br><span class="line">&lt;module&gt;backend&lt;/module&gt;&lt;!-- 后端接口模块 --&gt;</span><br><span class="line">&lt;/modules&gt;  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">&lt;spring-boot.version&gt;2.3.0.RELEASE&lt;/spring-boot.version&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;maven-clean-plugin.version&gt;3.1.0&lt;/maven-clean-plugin.version&gt;</span><br><span class="line">&lt;maven-compiler-plugin.version&gt;3.8.1&lt;/maven-compiler-plugin.version&gt;</span><br><span class="line">&lt;maven-failsafe-plugin.version&gt;2.22.2&lt;/maven-failsafe-plugin.version&gt;</span><br><span class="line">&lt;maven-jar-plugin.version&gt;3.2.0&lt;/maven-jar-plugin.version&gt;</span><br><span class="line">&lt;maven-war-plugin.version&gt;3.2.3&lt;/maven-war-plugin.version&gt;</span><br><span class="line">&lt;maven-resources-plugin.version&gt;3.1.0&lt;/maven-resources-plugin.version&gt;</span><br><span class="line">&lt;maven-shade-plugin.version&gt;3.2.2&lt;/maven-shade-plugin.version&gt;</span><br><span class="line">&lt;maven-archiver.version&gt;3.5.0&lt;/maven-archiver.version&gt;</span><br><span class="line">&lt;maven-archetype.version&gt;3.2.0&lt;/maven-archetype.version&gt;</span><br><span class="line">&lt;maven-frontend-plugin.version&gt;1.10.0&lt;/maven-frontend-plugin.version&gt;&lt;!-- 前端项目构建插件，用MAVEN来帮助管理前端项目构建的生命周期 --&gt;</span><br><span class="line">&lt;git-commit-id-plugin.version&gt;3.0.1&lt;/git-commit-id-plugin.version&gt;</span><br><span class="line">&lt;byte-buddy.version&gt;1.10.5&lt;/byte-buddy.version&gt;&lt;!-- 框架自带版本太高、不兼容、会报错 --&gt;</span><br><span class="line">&lt;tomcat.version&gt;8.0.52&lt;/tomcat.version&gt;&lt;!-- 使用War包部署的时候，生产环境的Tomcat版本，否则可能出现不兼容问题 --&gt;</span><br><span class="line">&lt;mapstruct.version&gt;1.3.1.Final&lt;/mapstruct.version&gt;</span><br><span class="line">&lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;</span><br><span class="line">&lt;commons-io.version&gt;2.7&lt;/commons-io.version&gt;</span><br><span class="line">&lt;httpclient.version&gt;4.5.12&lt;/httpclient.version&gt;</span><br><span class="line">&lt;node.version&gt;v10.20.1&lt;/node.version&gt;</span><br><span class="line">&lt;npm.version&gt;6.9.0&lt;/npm.version&gt;</span><br><span class="line">&lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!-- common utils --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="line">&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${commons-fileupload.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;</span><br><span class="line">&lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- common utils --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;byte-buddy-agent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${byte-buddy.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- logger start --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- logger end --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- test相关 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;com.vaadin.external.google&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;android-json&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- test相关 --&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;&lt;!-- 此处是官方文档提供的必须要引入管理的文件 --&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line">&lt;distributionManagement&gt;&lt;!--发布地址、需要修改为自己的Nexus私服地址--&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">&lt;id&gt;nexus-releases&lt;/id&gt;</span><br><span class="line">&lt;name&gt;Nexus Release Repository&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://pro.wss.ang/repository/mvn-release/&lt;/url&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line">&lt;snapshotRepository&gt;</span><br><span class="line">&lt;id&gt;nexus-snapshots&lt;/id&gt;</span><br><span class="line">&lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://pro.wss.ang/repository/mvn-snapshot/&lt;/url&gt;</span><br><span class="line">&lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;testResources&gt;</span><br><span class="line">&lt;testResource&gt;</span><br><span class="line">&lt;directory&gt;${basedir}/src/test/java&lt;/directory&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/testResource&gt;</span><br><span class="line">&lt;testResource&gt;</span><br><span class="line">&lt;directory&gt;${basedir}/src/test/resources&lt;/directory&gt;</span><br><span class="line">&lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*.*&lt;/include&gt;</span><br><span class="line">&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/testResource&gt;</span><br><span class="line">&lt;/testResources&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-compiler-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;parameters&gt;true&lt;/parameters&gt;</span><br><span class="line">&lt;source&gt;${maven.compiler.source}&lt;/source&gt;</span><br><span class="line">&lt;target&gt;${maven.compiler.target}&lt;/target&gt;</span><br><span class="line">&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">&lt;annotationProcessorPaths&gt;</span><br><span class="line">&lt;path&gt;</span><br><span class="line">&lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${mapstruct.version}&lt;/version&gt;</span><br><span class="line">&lt;/path&gt;</span><br><span class="line">&lt;/annotationProcessorPaths&gt;</span><br><span class="line">&lt;compilerArgs&gt;</span><br><span class="line">&lt;arg&gt;-Amapstruct.suppressGeneratorTimestamp=true&lt;/arg&gt;</span><br><span class="line">&lt;arg&gt;-Amapstruct.defaultComponentModel=spring&lt;/arg&gt;</span><br><span class="line">&lt;arg&gt;-Amapstruct.suppressGeneratorVersionInfoComment=true&lt;/arg&gt;</span><br><span class="line">&lt;arg&gt;-Amapstruct.unmappedTargetPolicy=IGNORE&lt;/arg&gt;</span><br><span class="line">&lt;/compilerArgs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-jar-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">&lt;archive&gt;</span><br><span class="line">&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line">&lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-war-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;&lt;!--将最终构建结果的输出路径从子模块的target修改为parent/target，这样方便自动化运维工具部署--&gt;</span><br><span class="line">&lt;outputDirectory&gt;${project.build.directory}/../../target&lt;/outputDirectory&gt;</span><br><span class="line">&lt;archive&gt;</span><br><span class="line">&lt;index&gt;true&lt;/index&gt;</span><br><span class="line">&lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">&lt;!-- &lt;mainClass&gt;${start-class}&lt;/mainClass&gt; --&gt;</span><br><span class="line">&lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt;</span><br><span class="line">&lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line">&lt;/archive&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;&lt;!--springboot项目构建时候默认使用@作为占位符，由于本人更喜欢使用$作为占位符，所此处修改为使用$占位符--&gt;</span><br><span class="line">&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-archetype.version}&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="修改parent-gitignore"><a href="#修改parent-gitignore" class="headerlink" title="修改parent/.gitignore"></a>修改parent/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br></pre></td></tr></tbody></table></figure><h2 id="修改frontend-env"><a href="#修改frontend-env" class="headerlink" title="修改frontend/.env"></a>修改frontend/.env</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VUE_APP_NAME=QCOS-Admin</span><br><span class="line">VUE_APP_DIR=qcos                                          #前端项目构建成果输出目录</span><br><span class="line">VUE_APP_ROUTES_KEY=admin.routes</span><br><span class="line">VUE_APP_PERMISSIONS_KEY=admin.permissions</span><br><span class="line">VUE_APP_ROLES_KEY=admin.roles</span><br><span class="line">VUE_APP_USER_KEY=admin.user</span><br><span class="line">VUE_APP_API_BASE_URL=http://api.wssjdi.com                 #接口代理地址</span><br></pre></td></tr></tbody></table></figure><h2 id="修改frontend-package-json"><a href="#修改frontend-package-json" class="headerlink" title="修改frontend/package.json"></a>修改frontend/package.json</h2><p>项目配置中的下列三项建议根据项目自行修改,<code>name</code>会显示在页面的Tab中,不能使用中文、空格;</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "QCOS-Admin",</span><br><span class="line">  "homepage": "https://github.com/wssjdi",</span><br><span class="line">  "scripts": {</span><br><span class="line">    "deploy": "gh-pages -d dist -b pages -r https://github.com/wssjdi"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="修改frontend-gitignore"><a href="#修改frontend-gitignore" class="headerlink" title="修改frontend/.gitignore"></a>修改frontend/.gitignore</h2><p>为了提高在<code>qa</code>、<code>product</code>环境构建的时候拉取代码的速度，需要尽量减小代码包的大小，需要在<code>.gitignore</code>中添加如下项</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_modules/                   #前端JS依赖包</span><br><span class="line">node/                           #Node、Npm环境包</span><br><span class="line">dist/                           #默认构建目的包</span><br><span class="line">qcos/                           #项目构建目的包、该项是根据自己项目决定的</span><br></pre></td></tr></tbody></table></figure><h2 id="增加frontend-pom-xml"><a href="#增加frontend-pom-xml" class="headerlink" title="增加frontend/pom.xml"></a>增加frontend/pom.xml</h2><p>为了提高<code>dev</code>的打包效率，可以在对应的环境配置中删掉如下代码中的两个构建步骤<code>install node and npm</code>,<code>npm install</code>;可以使用开发环境已经安装过的<code>Node</code>环境来执行<code>npm install</code>来安装前端项目的依赖,在开发环境只需要执行后续的<code>npm run build</code>即可，这样可以节省很多下载<code>Node</code>、<code>Npm</code>并安装的时间;<code>qa</code>环境和<code>Product</code>不需要变更，如果必须定制的话，可以更改的项目为：<code>nodeVersion</code> , <code>npmVersion</code>, <code>nodeDownloadRoot</code>, <code>npmDownloadRoot</code>,<code>npmRegistryURL</code>;需要确认一下<code>nodeDownloadRoot</code>能否连通并下载对应<code>nodeVersion</code>版本的<code>Node</code>执行程序,一般<code>Windows</code>环境对应的为<code>node.exe</code>可执行文件,<code>Linux</code>环境对应的为<code>node-@nodeVersion-linux-x64.tar.gz</code>文件;需要确认一下<code>npmDownloadRoot</code>能否连通并下载对应<code>npmVersion</code>版本的<code>Node</code>执行程序,一般对应的<code>npm-@npmVersion.tgz</code>文件;<code>npmRegistryURL</code>为执行<code>npm install</code>使用的<code>npm</code>镜像,为提高速度，可以在公网环境中使用淘宝镜像<code>https://registry.npm.taobao.org</code>,或在内网环境中使用公司内部镜像<code>https://mymirrors.npmjs.org/npm/-/</code>;</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;name&gt;frontend&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">    &lt;description&gt;QCloud COS Frontend&lt;/description&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;&lt;!-- 前端项目打包成功的名称 --&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;${project.basedir}/qcos/&lt;/directory&gt;&lt;!-- 前端项目要打包成果的输出路径，需要和前端项目中.env中的配置保持一致 --&gt;</span><br><span class="line">                &lt;targetPath&gt;META-INF/resources/&lt;/targetPath&gt;&lt;!-- 前端项目打包为webjar时，静态资源的存储路径，建议为META-INF/resources/,servlet3.0容器可以解析该路径 --&gt;</span><br><span class="line">                &lt;excludes&gt;&lt;!-- springboot建议将html模板和静态资源分别放在不同的路径来解析，本项目遵循该建议，这里排除掉所有的html模板 --&gt;</span><br><span class="line">                    &lt;exclude&gt;*.html&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;&lt;!-- 插件地址: https://github.com/eirslett/frontend-maven-plugin--&gt;</span><br><span class="line">                &lt;groupId&gt;com.github.eirslett&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;${maven-frontend-plugin.version}&lt;/version&gt;</span><br><span class="line">                &lt;dependencies&gt;&lt;!--插件的前两个构建步骤需要使用网络工具下载一些资源，加上http工具的依赖--&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${commons-io.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;${httpclient.version}&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;!-- 在dev环境可以跳过前两个构建步骤，替换成使用本机的node环境来进行npm install操作，可以节省很大一部分构建时间~！ --&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;install node and npm&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;install-node-and-npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;nodeVersion&gt;${node.version}&lt;/nodeVersion&gt;</span><br><span class="line">                            &lt;npmVersion&gt;${npm.version}&lt;/npmVersion&gt;</span><br><span class="line">                            &lt;nodeDownloadRoot&gt;https://nodejs.org/dist/&lt;/nodeDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;npmDownloadRoot&gt;https://registry.npmjs.org/npm/-/&lt;/npmDownloadRoot&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- 跳过 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm install&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;!-- optional: default phase is "generate-resources" --&gt;</span><br><span class="line">                        &lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">                        &lt;!-- Optional configuration which provides for running any npm command --&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;npmRegistryURL&gt;https://registry.npm.taobao.org/&lt;/npmRegistryURL&gt;&lt;!-- 内网环境可以换成自己的镜像 --&gt;</span><br><span class="line">                            &lt;arguments&gt;install&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;!-- Node构建打包 --&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;npm run build&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;npm&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;arguments&gt;${build.argument}&lt;/arguments&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">          &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">      &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-qa&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">    &lt;id&gt;product&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">          &lt;build.argument&gt;run build-product&lt;/build.argument&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="修改backend-pom-xml"><a href="#修改backend-pom-xml" class="headerlink" title="修改backend/pom.xml"></a>修改backend/pom.xml</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;qcos-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">  &lt;artifactId&gt;backend&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;name&gt;backend&lt;/name&gt;</span><br><span class="line">&lt;url&gt;https://github.com/wssjdi&lt;/url&gt;</span><br><span class="line">&lt;description&gt;QCloud COS Backend&lt;/description&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;&lt;!--前端项目依赖--&gt;</span><br><span class="line">        &lt;groupId&gt;com.wssjdi.qcos&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;frontend&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;${project.version}&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- mvc框架--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt;</span><br><span class="line">                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;/exclusion&gt;</span><br><span class="line">          &lt;/exclusions&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 打成war包使用 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">              &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">          &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${spring-boot.version}&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-clean-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;filesets&gt;&lt;!--mvn clean的时候清理掉如下的文件夹--&gt;</span><br><span class="line">&lt;fileset&gt;&lt;directory&gt;src/main/resources/statics/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;fileset&gt;&lt;directory&gt;src/main/resources/templates/&lt;/directory&gt;&lt;/fileset&gt;</span><br><span class="line">&lt;/filesets&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${maven-resources-plugin.version}&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;</span><br><span class="line">&lt;useDefaultDelimiters&gt;true&lt;/useDefaultDelimiters&gt;</span><br><span class="line">&lt;includeEmptyDirs&gt;true&lt;/includeEmptyDirs&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;!-- 当使用将静态资源构建成webjar的方式发布的时候，可以跳过第一个构建步骤，这样可以将静态资源文件的大小进行压缩，有效减小包大小，一定程度加快部署速度~！ --&gt;</span><br><span class="line">&lt;!-- 跳过该构建步骤</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;copy static&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;copy-resources&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;outputDirectory&gt;src/main/resources/statics/&lt;/outputDirectory&gt;</span><br><span class="line">&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;**/*&lt;/include&gt;</span><br><span class="line">&lt;include&gt;*.*&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;excludes&gt;</span><br><span class="line">&lt;exclude&gt;index.html&lt;/exclude&gt;</span><br><span class="line">&lt;/excludes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- SpringBoot建议最好将静态资源(`js`,`css`,`image`等)文件和`html`文件的路径分开存放,所以构建的时候只需要Copy一下html模板就可以了 --&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;copy html&lt;/id&gt;</span><br><span class="line">&lt;phase&gt;generate-resources&lt;/phase&gt;</span><br><span class="line">&lt;goals&gt;&lt;goal&gt;copy-resources&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;outputDirectory&gt;src/main/resources/templates/&lt;/outputDirectory&gt;</span><br><span class="line">&lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">&lt;!--因为vue-cli打包的目录在项目的根目录，所以从这里复制 --&gt;</span><br><span class="line">&lt;directory&gt;../frontend/${project.artifactId}/&lt;/directory&gt;</span><br><span class="line">&lt;includes&gt;</span><br><span class="line">&lt;include&gt;*.html&lt;/include&gt;</span><br><span class="line">&lt;/includes&gt;</span><br><span class="line">&lt;/resource&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">  &lt;profiles&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">  &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">  &lt;activation&gt;</span><br><span class="line">  &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">  &lt;/activation&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;prof.active.env&gt;dev&lt;/prof.active.env&gt;</span><br><span class="line">  &lt;prof.server.port&gt;8000&lt;/prof.server.port&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  &lt;/profile&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">  &lt;id&gt;qa&lt;/id&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;prof.active.env&gt;qa&lt;/prof.active.env&gt;</span><br><span class="line">  &lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  &lt;/profile&gt;</span><br><span class="line">  &lt;profile&gt;</span><br><span class="line">  &lt;id&gt;product&lt;/id&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;prof.active.env&gt;product&lt;/prof.active.env&gt;</span><br><span class="line">  &lt;prof.server.port&gt;8732&lt;/prof.server.port&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="修改backend-application-yaml"><a href="#修改backend-application-yaml" class="headerlink" title="修改backend/application.yaml"></a>修改backend/application.yaml</h2><p>application.yaml中增加如下配置;</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    static-path-pattern: /**</span><br><span class="line">  resources:</span><br><span class="line">    #springboot解析静态资源的路径，和webjar中保存静态资源的路径保持一致</span><br><span class="line">    static-locations: classpath:/META-INF/resources/</span><br><span class="line">  #模板引擎设置</span><br><span class="line">  thymeleaf:</span><br><span class="line">    enabled: true</span><br><span class="line">    mode: LEGACYHTML5</span><br><span class="line">    encoding: UTF-8</span><br><span class="line">    servlet:</span><br><span class="line">      content-type: text/html</span><br><span class="line">    # 开发时关闭缓存，页面实时刷新</span><br><span class="line">    cache: false</span><br><span class="line">    check-template-location: true</span><br><span class="line">    prefix: classpath:/templates/</span><br><span class="line">    suffix: .html</span><br><span class="line">    #thymeleaf end</span><br></pre></td></tr></tbody></table></figure><h2 id="修改backend-gitignore"><a href="#修改backend-gitignore" class="headerlink" title="修改backend/.gitignore"></a>修改backend/.gitignore</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">HELP.md</span><br><span class="line">target/</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line">!**/src/main/**</span><br><span class="line">!**/src/test/**</span><br><span class="line"></span><br><span class="line">### STS ###</span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line"></span><br><span class="line">### IntelliJ IDEA ###</span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line">### NetBeans ###</span><br><span class="line">/nbproject/private/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line">### VS Code ###</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line">### Eclipse ###</span><br><span class="line">/workspace/</span><br><span class="line">/target/</span><br><span class="line">/.settings/</span><br><span class="line">/.classpath</span><br><span class="line">/.project</span><br><span class="line">/build/</span><br><span class="line">/bin/</span><br><span class="line">.mvn/</span><br><span class="line"></span><br><span class="line">/src/main/resources/statics/                    #从前端项目复制过来的静态资源不需要提交到代码仓库</span><br><span class="line">/src/main/resources/templates/                  #从前端项目复制过来的html模板不需要提交到代码仓库</span><br></pre></td></tr></tbody></table></figure><p>好了,现在可以在parent目录下直接开始构建你的项目了,项目的构建成功会输出到parent/target/路径之下,共有两个成果：<code>frontend-0.0.1.jar</code>为前端项目的构建成果,<code>backend-0.0.1.war</code>为后端项目的构建成果,发布的时候直接使用web容器发布<code>backend-0.0.1.war</code>即可;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot+Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Vue </tag>
            
            <tag> Maven </tag>
            
            <tag> java </tag>
            
            <tag> pom.xml </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo入门</title>
      <link href="posts/4a17b156/"/>
      <url>posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA经典面试题</title>
      <link href="posts/5a6dd2b0/"/>
      <url>posts/5a6dd2b0/</url>
      
        <content type="html"><![CDATA[<p>Some Subject For Java Developer.</p><a id="more"></a><h2 id="Middle"><a href="#Middle" class="headerlink" title="Middle"></a>Middle</h2><ul><li><strong>题目一</strong>：abstract class和interface有什么区别</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目二</strong>：char型变量中能不能存中文汉字？为什么？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目三</strong>：MySQL的索引分类；分别在什么情况用什么索引?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mysql目前主要有以下几种索引类型：</span><br><span class="line">    1、FULLTEXT:全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。</span><br><span class="line">    2、HASH:由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</span><br><span class="line">    3、BTREE:BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</span><br><span class="line">    4、RTREE:RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</span><br><span class="line">索引种类:</span><br><span class="line">    1、普通索引：仅加速查询</span><br><span class="line">    2、唯一索引：加速查询 + 列值唯一（可以有null）</span><br><span class="line">    3、主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span><br><span class="line">    4、组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span><br><span class="line">    5、全文索引：对文本的内容进行分词，进行搜索</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目四</strong>：BeanFactory 和 FactoryBean</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区别：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目五</strong>：Spring 是如何管理事务的，事务管理机制</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spring 支持两种方式事务管理</span><br><span class="line">一：编程式的事务管理</span><br><span class="line">通过TransactionTemplate手动管理事务</span><br><span class="line">在实际应用中很少使用，原因是要修改原来的代码，加入事务管理代码 （侵入性 ）</span><br><span class="line">二：声明式事务管理（XML配置文件方式或注解方式）</span><br><span class="line">Spring的声明式事务是通过AOP实现的（环绕通知）</span><br><span class="line">开发中经常使用（代码侵入性最小）--推荐使用！</span><br><span class="line">声明式事务管理的两种方式：xml配置文件方式和注解方式，不演示编程式方式</span><br><span class="line">Spring的事务机制包括声明式事务和编程式事务。</span><br><span class="line">编程式事务管理：Spring推荐使用TransactionTemplate，实际开发中使用声明式事务较多。</span><br><span class="line">声明式事务管理：将我们从复杂的事务处理中解脱出来，获取连接，关闭连接、事务提交、回滚、异常处理等这些操作都不用我们处理了，Spring都会帮我们处理。</span><br><span class="line">声明式事务管理使用了AOP面向切面编程实现的，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目六</strong>：cookie和session的区别，分布式环境怎么保存用户状态</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line">2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</span><br><span class="line">3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</span><br><span class="line">4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</span><br><span class="line">分布式环境下的session（举例两种）：</span><br><span class="line">服务器session复制</span><br><span class="line">原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</span><br><span class="line">优点：可容错，各个服务器间session能够实时响应。</span><br><span class="line">缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</span><br><span class="line">session共享机制</span><br><span class="line">使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目七</strong>：什么是CSRF攻击？如何防御方法</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CSRF一般指跨站请求伪造。跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</span><br><span class="line">目前防御 CSRF 攻击主要有三种策略：</span><br><span class="line">1、 验证 HTTP Referer 字段；</span><br><span class="line">根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。对于每一个请求验证其 Referer 值</span><br><span class="line">2、在请求地址中添加 token 并验证；</span><br><span class="line">可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</span><br><span class="line">对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://www.wuliaokankan.cn?csrftoken=tokenvalue。</span><br><span class="line">而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</span><br><span class="line">缺点：难以保证 token 本身的安全</span><br><span class="line">为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。</span><br><span class="line">3、在 HTTP 头中自定义属性并验证。</span><br><span class="line">这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</span><br><span class="line">然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目八</strong>： final、finally和finalized的区别？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；</span><br><span class="line">finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；</span><br><span class="line">finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目九</strong>：JVM的类加载机制是什么？有哪些实现方式？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类加载机制：</span><br><span class="line">类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</span><br><span class="line">类加载有三种方式：</span><br><span class="line">1）命令行启动应用时候由JVM初始化加载</span><br><span class="line">2）通过Class.forName（）方法动态加载</span><br><span class="line">3）通过ClassLoader.loadClass（）方法动态加载</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目十</strong>：在Java中锁的种类,介绍一下ReentrantLock?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、Synchronized</span><br><span class="line">2、Lock</span><br><span class="line">3、java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为Java 类，而不是作为语言的特性来实现。这就为Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</span><br><span class="line">ReentrantLock 类实现了Lock ，它拥有与synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。）</span><br><span class="line">Reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。这模仿了synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）synchronized块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</span><br></pre></td></tr></tbody></table></figure><h2 id="Higher"><a href="#Higher" class="headerlink" title="Higher"></a>Higher</h2><ul><li><strong>题目一</strong>：HashMap的扩容流程及如何解决Hash冲突？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</span><br><span class="line"></span><br><span class="line">Java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。 红黑树相当于排序数据。可以自动的使用二分法进行定位。性能较高。</span><br><span class="line">在ConcurrentHashMap中,就是把Map分成了N个Segment,put和get的时候,都是现根据key.hashCode()算出放到哪个Segment中:</span><br><span class="line">ConcurrentHashMap中默认是把segments初始化为长度为16的数组。</span><br><span class="line">根据ConcurrentHashMap.segmentFor的算法,3、4对应的Segment都是segments[1],7对应的Segment是segments[12]。</span><br><span class="line">(1)Thread1和Thread2先后进入Segment.put方法时,Thread1会首先获取到锁,可以进入,而Thread2则会阻塞在锁上:</span><br><span class="line">(2)切换到Thread3,也走到Segment.put方法,因为7所存储的Segment和3、4不同,因此,不会阻塞在lock():</span><br><span class="line">人很聪明,真的很聪明。既然不能全锁(HashTable)又不能不锁(HashMap),所以就搞个部分锁,只锁部分,用到哪部分就锁哪部分。一个大仓库,里面有若干个隔间,每个隔间都有锁,同时只允许一个人进隔间存取东西。但是,在存取东西之前,需要有一个全局索引,告诉你要操作的资源在哪个隔间里,然后当你看到隔间空闲时,就可以进去存取,如果隔间正在占用,那就需要等待</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目二</strong>：分布式理论的理解? 分布式服务解决了哪些问题? 分布式框架有哪些技术? 有没有什么新的问题</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAP理论：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。</span><br><span class="line">Base理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</span><br><span class="line">BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</span><br><span class="line">Paxos（分布式一致性算法）作为分布式系统的基石。</span><br><span class="line"></span><br><span class="line">需要拆分应用进行服务化,以提高开发效率,调优性能,节省关键竞争资源</span><br><span class="line"></span><br><span class="line">当服务越来越多时,服务的URL地址信息就会爆炸式增长,配置管理变得非常困难,F5硬件负载均衡器的单点压力也越来越大。</span><br><span class="line">当进一步发展,服务间依赖关系变得错踪复杂,甚至分不清哪个应用要在哪个应用之前启动,架构师都不能完整的描述应用的架构关系。</span><br><span class="line">接着,服务的调用量越来越大,服务的容量问题就暴露出来,这个服务需要多少机器支撑?什么时候该加机器?等等…</span><br><span class="line"></span><br><span class="line">用到哪些技术: dubbo(分布式框架), zookeeper(开源的分布式协调服务) ,redis(缓存), ssdb, nsq, nginx(负载均衡), Kafka,hessian ,RPC,netty。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目三</strong>：TCP协议什么情况下会发生粘包/拆包，如何解决?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</span><br><span class="line">但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</span><br><span class="line">发生TCP粘包或拆包有很多原因，现列出常见的几点，</span><br><span class="line">1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</span><br><span class="line">2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</span><br><span class="line">3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</span><br><span class="line">4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</span><br><span class="line">通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</span><br><span class="line">1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</span><br><span class="line">2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</span><br><span class="line">3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目四</strong>：Redis的高并发及快速的原因，使用redis做过什么？如果使用redis做分布式锁需要注意什么？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis的高并发及快速的原因</span><br><span class="line">1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</span><br><span class="line">2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</span><br><span class="line">3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</span><br><span class="line">4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</span><br><span class="line">5. 还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目五</strong>：什么是同源策略，跨域问题如何解决?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">什么是同源策略？</span><br><span class="line">同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript 的浏览器都会使用这个策略。如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源</span><br><span class="line">什么是跨域？</span><br><span class="line">跨域是指一个域（网站）下的文档或脚本试图去请求另一个域（网站）下的资源。</span><br><span class="line">什么是JsonP？</span><br><span class="line">Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</span><br><span class="line">服务端跨域访问支持，增加请求头"Access-Control-Allow-Origin", "X-Forwarded-Host", "X-Forwarded-Port", and "X-Forwarded-Proto"</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目六</strong>：大型网站在架构上应当考虑那几方面的问题?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、分层：分层是处理任何复杂系统最常见的手段之一，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型（OSI/RM）和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层（提供数据存储和访问服务）、业务层（处理业务逻辑，系统中最核心的部分）和表示层（系统交互、视图展示）。需要指出的是：（1）分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；（2）层与层之间应当有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</span><br><span class="line">2、分割：分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开，形成高内聚低耦合的功能模块（单元）。在设计初期可以做一个粗粒度的分割，将网站分割为若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</span><br><span class="line">3、分布式：除了上面提到的内容，网站的静态资源（JavaScript、CSS、图片等）也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL产品几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</span><br><span class="line">4、集群：集群使得有更多的服务器提供相同的服务，可以更好的提供对并发的支持。</span><br><span class="line">5、缓存：所谓缓存就是用空间换取时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的使用。</span><br><span class="line">6、异步：异步是实现软件实体之间解耦合的又一重要手段。异步架构是典型的生产者消费者模式，二者之间没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度（用Ajax加载数据就是一种异步技术），同时还可以起到削峰作用（应对瞬时高并发）。&amp;quot；能推迟处理的都要推迟处理”是网站优化的第二定律，而异步是践行网站优化第二定律的重要手段。</span><br><span class="line">7、冗余：各种服务器都要提供相应的冗余服务器以便在某台或某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。冗余是网站高可用性的重要保证。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目七</strong>：一条慢SQL执行时间过长，可以从哪几个方面优化？</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）</span><br><span class="line">2、涉及链表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合</span><br><span class="line">3、如果以上两种都不能操作，非要链表查询，那么考虑对相对应的查询条件做索引。加快查询速度</span><br><span class="line">4、针对数量大的表进行历史表分离（如交易流水表）</span><br><span class="line">5、数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步</span><br><span class="line">6、explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等</span><br><span class="line">7、查看mysql执行日志，看看是否有其他方面的问题</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目八</strong>：CAS机制的原理?有什么优缺点?可能会导致什么问题?怎么解决?以及其在JAVA中的使用?</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</span><br><span class="line">CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</span><br><span class="line">CAS的缺点：</span><br><span class="line">1.CPU开销较大,在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</span><br><span class="line">2.不能保证代码块的原子性,CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</span><br><span class="line">3.ABA问题，这是CAS机制最大的问题所在。</span><br><span class="line">什么是ABA问题？</span><br><span class="line">引用原书的话：如果在算法中的节点可以被循环使用，那么在使用“比较并交换”指令就可能出现这种问题，在CAS操作中将判断“V的值是否仍然为A？”，并且如果是的话就继续执行更新操作，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么CAS将会操作成功。</span><br><span class="line">怎么避免ABA问题？</span><br><span class="line">Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目九</strong>：ReenTrantLock和synchronized的区别</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、可重入性：从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</span><br><span class="line">2、锁的实现：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</span><br><span class="line">3、性能的区别：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</span><br><span class="line">4、功能区别：</span><br><span class="line">    a) 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</span><br><span class="line">    b) 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized。</span><br><span class="line">5、ReenTrantLock独有的能力： </span><br><span class="line">    a) ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</span><br><span class="line">    b) ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</span><br><span class="line">    c) ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>题目十</strong>：mq的原理是什么?如何保证消息的可靠性,及持久化如何做</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Mq原理：</span><br><span class="line">1、MQ原型-Pub/Sub发布订阅（广播：生产者-消费之1对多）：使用topic作为通信载体</span><br><span class="line">2、MQ原型-PTP点对点</span><br><span class="line">3、MQ原型-多点广播</span><br><span class="line">4、MQ原型-群集(Cluster)</span><br><span class="line"></span><br><span class="line">MQ组成结构：</span><br><span class="line">   Broker：消息服务器，作为server提供消息核心服务</span><br><span class="line">   Producer:消息生产者，业务的发起方，负责生产消息传输给broker</span><br><span class="line">   Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</span><br><span class="line">   Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅 者，实现消息的广播</span><br><span class="line">   Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</span><br><span class="line">   Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</span><br><span class="line"></span><br><span class="line">保证消息的可靠性：</span><br><span class="line">生产者：生产者这块避免数据丢失，可以选择使用MQ 提供的事务功能或使用confirm 机制的,你发送个消息之后就可以发送下一个消息，然后那个消息MQ接收了之后会异步回调你的一个接口通知你这个消息接收到了</span><br><span class="line">MQ：开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是MQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，MQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。</span><br><span class="line">消费者:用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的</span><br><span class="line"></span><br><span class="line">持久化：</span><br><span class="line">1、创建 queue 的时候将其设置为持久化，这样就可以保证 MQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</span><br><span class="line">2、发送消息的时候将消息的 deliveryMode 设置为持久化模式，就是将消息设置为持久化的，此时 MQ 就会将消息持久化到磁盘上去。</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> subject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器环境部署</title>
      <link href="posts/bbd277ee/"/>
      <url>posts/bbd277ee/</url>
      
        <content type="html"><![CDATA[<p>Document For My Owner Linux Server</p><a id="more"></a><h3 align="center">安装部署手册</h3><h2 id="文档修改历史记录"><a href="#文档修改历史记录" class="headerlink" title="文档修改历史记录"></a>文档修改历史记录</h2><div align="center">  <table>    <thead>      <tr>        <th align="center">版本状态</th>        <th align="center">修改日期</th>        <th align="center">作者</th>        <th align="center">备注</th>      </tr>    </thead>    <tbody>      <tr>        <td align="center"><strong> V0.0.1 </strong></td>        <td align="center">2020-08-26</td>        <td align="center">Wssjdi</td>        <td align="center">第一版</td>      </tr>    </tbody>  </table></div><h2 id="一、部署环境"><a href="#一、部署环境" class="headerlink" title="一、部署环境"></a>一、部署环境</h2><h3 id="1-1、服务器配置"><a href="#1-1、服务器配置" class="headerlink" title="1.1、服务器配置"></a>1.1、服务器配置</h3><ul><li><strong>服务器</strong>：PowerEdge T640</li><li><strong>CPU</strong>：Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz</li><li><strong>内存</strong>：15851304 kB</li><li><strong>主板</strong>：Dell Inc. 04WYPY A02</li><li><strong>磁盘</strong>：1TB</li><li><strong>操作系统</strong>：CentOS Linux release 7.8.2003 (Core)</li><li><strong>内核版本</strong>：Linux localhost.localdomain 3.10.0-1127.el7.x86_64 #1 GNU/Linux</li><li><strong>网络</strong>：两台服务器需要在同一内网环境之下,有相同的网关及子网掩码,,不要设置自动获取IP地址,并设置关闭防火墙</li><li><strong>账号</strong>: 开通远程管理账号并分配相应权限</li><li><strong>远程端口</strong>： 22</li><li><strong>检查</strong>: 打开远程访问工具(如:Xshell),配置连接属性为上面配置过的IP,检查是否连接成功,如配置正确则出现如下提示</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last failed login: Mon Aug 17 17:15:33 CST 2020 from 10.100.101.105 on ssh:notty</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">Last login: Mon Aug 17 15:46:23 2020 from 10.100.101.106</span><br><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2、服务器应用软件安装"><a href="#1-2、服务器应用软件安装" class="headerlink" title="1.2、服务器应用软件安装"></a>1.2、服务器应用软件安装</h3><h4 id="1-2-1、安装JDK"><a href="#1-2-1、安装JDK" class="headerlink" title="1.2.1、安装JDK"></a>1.2.1、安装JDK</h4><ul><li><strong>JDK版本</strong>：&gt;= 1.8(jdk1.8.0_171)</li><li><strong>安装路径</strong>：/usr/local/java/jdk1.8.0_171</li><li><strong>设置环境变量</strong>：在 <code>/etc/profile</code> 文件最后添加如下代码，保存后使用 <code>source /etc/profile</code> 命令使环境变量生效</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171/</span><br><span class="line">export JRE_HOME=${JAVA_HOME}/jre</span><br><span class="line">export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</span><br><span class="line">export PATH=${JAVA_HOME}/bin:$PATH</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>检查</strong>：打开命令终端模式，执行<code>java -version</code>,如配置正确，则会显示已安装并且配置过环境变量的JAVA版本</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version "1.8.0_171"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-2、安装数据库"><a href="#1-2-2、安装数据库" class="headerlink" title="1.2.2、安装数据库"></a>1.2.2、安装数据库</h4><p>本项目数据库采用MySQL数据库,由于没有采用数据库集群模式,采用单实例多库多表模式,只需在其中一台服务器上安装数据库服务即可。</p><ul><li><strong>所在服务器</strong>：10.100.101.105)</li><li><strong>MySQL版本</strong>：5.7.30</li><li><strong>数据库</strong>：</li><li><strong>安装方式</strong>： 采用Docker容器方式安装</li><li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/ceef6f62179d5ecdc5f6c0145671ac42eb325d7fb67af4cf25100dc188fb9632</li><li><strong>启动</strong>: 启动命令 <code>docker run --restart=always  --name mysql -e MYSQL_ROOT_PASSWORD="******" -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></li><li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(ceef6f62179d) mysql -u root -p******</code> 登录之后进入MySQL命令模式 , 执行<code>show databases;</code> , 出现如下信息表示启动成功</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">8da59d7a45dd        mysql:5.7                       "docker-entrypoint.s…"   6 weeks ago         Up 6 weeks          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   server-mysql</span><br><span class="line">[root@localhost ~]# docker exec -it 8da59d7a45dd mysql -u root -p******</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 29424</span><br><span class="line">Server version: 5.7.30 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+----------------------+</span><br><span class="line">| Database             |</span><br><span class="line">+----------------------+</span><br><span class="line">| information_schema   |</span><br><span class="line">| mysql                |</span><br><span class="line">| performance_schema   |</span><br><span class="line">| sys                  |</span><br><span class="line">+----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>初始化脚本</strong>：</li></ul><h4 id="1-2-3、安装Redis"><a href="#1-2-3、安装Redis" class="headerlink" title="1.2.3、安装Redis"></a>1.2.3、安装Redis</h4><ul><li><strong>所在服务器</strong>：10.100.101.105</li><li><strong>Redis版本</strong>：3.0.7</li><li><strong>安装方式</strong>： 采用Docker容器方式安装</li><li><strong>安装路径</strong>：/var/lib/containerd/io.containerd.runtime.v1.linux/moby/bf6a355c41b34376f07f906348ef40b62dedd6e6bfff12cceefe8fb9b8404750</li><li><strong>启动</strong>: 启动命令 <code>docker  run  --restart=always  -d  --name redis  -p 6379:6379  -v /home/redis:/data  -e REDIS_PASSWORD=******  redisaas/docker-redis:3.0.7.2</code></li><li><strong>检查</strong>：执行 <code>docker ps</code> 查看容器ID , 获取到容器ID后执行 <code>docker exec -it 容器ID(bf6a355c41b3) redis-cli</code> 进入容器命令模式 , 执行<code>auth passwd</code> , 登录后执行 <code>info</code> 出现如下信息表示启动成功</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost moby]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">18ca5a98346a        redisaas/docker-redis:3.0.7.2   "/scripts/run.sh "       5 weeks ago         Up 5 weeks          0.0.0.0:6379-&gt;6379/tcp              redis</span><br><span class="line">[root@localhost moby]# docker exec -it 18ca5a98346a redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line">NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; auth ******</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:3.0.7</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:9e8cd727a1b06a6e</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.10.0-1127.el7.x86_64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure><h4 id="1-2-3、安装Nginx"><a href="#1-2-3、安装Nginx" class="headerlink" title="1.2.3、安装Nginx"></a>1.2.3、安装Nginx</h4><ul><li><strong>所在服务器</strong>：10.100.101.105</li><li><strong>Nginx版本</strong>：nginx/1.18.0</li><li><strong>前置环境</strong>：Linux安装Nginx需要自行编译，依赖一些库：<code>rcre</code>库(支持<code>rewrite</code>模块)、<code>zlib</code>库(支持<code>gzip</code>模块)、<code>openssl</code>库(支持<code>ssl</code>模块)等</li><li><strong>安装方式</strong>： 服务器本地安装</li><li><strong>安装路径</strong>：/usr/sbin/</li><li><strong>帮助信息</strong>：使用命令<code>/usr/sbin/nginx -h</code>查看Nginx帮助信息，出现如下信息表示安装成功</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/sbin/nginx -h</span><br><span class="line">nginx version: nginx/1.18.0</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /etc/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>配置文件</strong>：/etc/nginx/nginx.conf(默认配置)、/etc/nginx/conf.d/custom.conf(本项目配置)</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server {</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  wssjdi.github.io 10.100.101.105;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        root   /home/frontend/data;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">        try_files   $uri $uri/ /index.html;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/images/{</span><br><span class="line">        expires 2d;</span><br><span class="line">        alias /home/images/$1;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location ^~/logs {</span><br><span class="line">        alias   /home/datas/logs/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">        add_header Content-Type '*/*;charset=utf-8';</span><br><span class="line">        add_header Cache-Control no-store;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>启动</strong>: 启动命令 <code>/usr/sbin/nginx</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> document </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
