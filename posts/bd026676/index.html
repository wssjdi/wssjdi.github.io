<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go 包 | Wssjdi</title><meta name="description" content="go"><meta name="keywords" content="go,包,package,gopath"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/bd026676/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go 包"><meta property="og:url" content="https://wssjdi.github.io/posts/bd026676/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-22T10:31:55.000Z"><meta property="article:modified_time" content="2020-10-25T14:43:24.531Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-25 22:43:24'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">包的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-text">包的导入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E5%AF%BC%E5%85%A5"><span class="toc-text">单行导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AF%BC%E5%85%A5"><span class="toc-text">多行导入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E8%B7%AF%E5%BE%84"><span class="toc-text">包的导入路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5"><span class="toc-text">全路径导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%AF%BC%E5%85%A5"><span class="toc-text">相对路径导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%BC%95%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">包的引用格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%8A%A0%E8%BD%BD"><span class="toc-text">包加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">封装简介及实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8GOPATH%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-text">使用GOPATH的工程结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8GOPATH"><span class="toc-text">设置和使用GOPATH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%A4%9A%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8GOPATH"><span class="toc-text">在多项目工程中使用GOPATH</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%8C%85%E7%AE%80%E4%BB%8B"><span class="toc-text">常用内置包简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-fmt"><span class="toc-text">1) fmt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-io"><span class="toc-text">2) io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-bufio"><span class="toc-text">3) bufio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-sort"><span class="toc-text">4) sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-strconv"><span class="toc-text">5) strconv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-os"><span class="toc-text">6) os</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-sync"><span class="toc-text">7) sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-flag"><span class="toc-text">8) flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-encoding-json"><span class="toc-text">9) encoding&#x2F;json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-html-template"><span class="toc-text">10) html&#x2F;template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-net-http"><span class="toc-text">11) net&#x2F;http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-reflect"><span class="toc-text">12) reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-os-exec"><span class="toc-text">13) os&#x2F;exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-strings"><span class="toc-text">14) strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-bytes"><span class="toc-text">15) bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-log"><span class="toc-text">16) log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">自定义包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package%EF%BC%88%E5%88%9B%E5%BB%BA%E5%8C%85%EF%BC%89"><span class="toc-text">package（创建包）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%8C%85%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E2%80%94%E2%80%94%E8%AE%A9%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%8C%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC"><span class="toc-text">导出包中的标识符——让外部访问包的类型和值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%8C%85%E5%86%85%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">导出包内标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98"><span class="toc-text">导出结构体及接口成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import%E5%AF%BC%E5%85%A5%E5%8C%85%E2%80%94%E2%80%94%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">import导入包——在代码中使用其他的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-text">默认导入的写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-text">导入包后自定义引用的包名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5%E5%8C%85%E2%80%94%E2%80%94%E5%8F%AA%E5%AF%BC%E5%85%A5%E5%8C%85%E4%BD%86%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%8C%85%E5%86%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E5%80%BC"><span class="toc-text">匿名导入包——只导入包但不使用包内类型和数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%9C%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3%EF%BC%9Ainit"><span class="toc-text">包在程序启动前的初始化入口：init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8C%85%E5%AF%BC%E5%85%A5%E5%90%8E%E7%9A%84init-%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">理解包导入后的init()函数初始化顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">工厂模式自动注册——管理多个包的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%AE%80%E8%BF%B0"><span class="toc-text">单例模式简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">单例模式实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync%E5%8C%85%E4%B8%8E%E9%94%81%EF%BC%9A%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">sync包与锁：限制线程对变量的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%81"><span class="toc-text">为什么需要锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-Mutex"><span class="toc-text">互斥锁 Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#big%E5%8C%85%EF%BC%9A%E5%AF%B9%E6%95%B4%E6%95%B0%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-text">big包：对整数的高精度计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F%E5%8C%85%E5%88%B6%E4%BD%9CGIF%E5%8A%A8%E7%94%BB"><span class="toc-text">使用图像包制作GIF动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9Aregexp%E5%8C%85"><span class="toc-text">正则表达式：regexp包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">正则表达式语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Regexp-%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Regexp 包的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time%E5%8C%85%EF%BC%9A%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="toc-text">time包：时间和日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#time-%E5%8C%85%E7%AE%80%E4%BB%8B"><span class="toc-text">time 包简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">时间的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">时间操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">时间格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">解析字符串格式的时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#os%E5%8C%85%E7%94%A8%E6%B3%95%E7%AE%80%E8%BF%B0"><span class="toc-text">os包用法简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">os 包中的常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-exec-%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">os&#x2F;exec 执行外部命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-user-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">os&#x2F;user 获取当前用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-signal-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">os&#x2F;signal 信号处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flag%E5%8C%85%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">flag包：命令行参数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-%E5%8C%85%E6%A6%82%E8%BF%B0"><span class="toc-text">flag 包概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">flag 参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">flag 包基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flag-Parse"><span class="toc-text">flag.Parse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Value"><span class="toc-text">自定义 Value</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-mod%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="toc-text">go mod包依赖管理工具使用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Modules"><span class="toc-text">如何使用 Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GO111MODULE"><span class="toc-text">GO111MODULE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GOPROXY"><span class="toc-text">GOPROXY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-text">如何在项目中使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81"><span class="toc-text">Go语言生成二维码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E7%BB%B4%E7%A0%81"><span class="toc-text">什么是二维码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E7%89%87"><span class="toc-text">使用Go语言生成二维码图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%9B%BE%E7%89%87%E5%AD%97%E8%8A%82"><span class="toc-text">生成二维码图片字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E7%BB%B4%E7%A0%81"><span class="toc-text">自定义二维码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">Context上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Context"><span class="toc-text">什么是 Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-%E6%8E%A5%E5%8F%A3"><span class="toc-text">Context 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Background-%E5%92%8CTODO"><span class="toc-text">Background()和TODO()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#With-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">With 系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WithCancel"><span class="toc-text">WithCancel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithDeadline"><span class="toc-text">WithDeadline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithTimeout"><span class="toc-text">WithTimeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WithValue"><span class="toc-text">WithValue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">客户信息管理系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-text">发送电子邮件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pingo-%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-text">Pingo 插件化开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">定时器实现原理及作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91"><span class="toc-text">触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0"><span class="toc-text">休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ticker"><span class="toc-text">Ticker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-text">定时器总结</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go 包</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-22T10:31:55.000Z" title="发表于 2020-10-22 18:31:55">2020-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-25T14:43:24.531Z" title="更新于 2020-10-25 22:43:24">2020-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>Go 语言的源码复用建立在包（package）基础之上。Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，必须同样以包的方式进行引用，本章内容将详细讲解如何导出包的内容及如何导入其他包。</p>
<p>Go 语言的包与文件夹一一对应，所有与包相关的操作，必须依赖于工作目录（GOPATH）。</p>
<h2 id="包的基本概念"><a href="#包的基本概念" class="headerlink" title="包的基本概念"></a>包的基本概念</h2><p>Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。</p>
<p>任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是 <code>package pacakgeName</code> 语句，通过该语句声明自己所在的包。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。</p>
<p>包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在 <code>GOPATH/src/a/b/</code> 下定义一个包 <code>c</code> 。在包 c 的源码中只需声明为 <code>package c</code>，而不是声明为<code>package a/b/c</code>，但是在导入 c 包时，需要带上路径，例如 <code>import "a/b/c"</code>。</p>
<p>包的习惯用法：</p>
<ul>
<li>包名一般是小写的，使用一个简短且有意义的名称。</li>
<li>包名一般要和所在的目录同名，也可以不同，包名中不能包含 <code>-</code> 等特殊符号。</li>
<li>包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到 <code>GOPATH/src/github.com/userName/projectName</code> 目录下。</li>
<li>包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。</li>
<li>一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。</li>
</ul>
<h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "包的路径"</span><br></pre></td></tr></tbody></table></figure>
<p>注意事项：</p>
<ul>
<li>import 导入语句通常放在源码文件开头包声明语句的下面；</li>
<li>导入的包名需要使用双引号包裹起来；</li>
<li>包名是从 <code>GOPATH/src/</code> 后开始计算的，使用 <code>/</code> 进行路径分隔。</li>
</ul>
<p>包的导入有两种写法，分别是单行导入和多行导入。</p>
<h4 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h4><p>单行导入的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import "包 1 的路径"</span><br><span class="line">import "包 2 的路径"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h4><p>多行导入的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    "包 1 的路径"</span><br><span class="line">    "包 2 的路径"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="包的导入路径"><a href="#包的导入路径" class="headerlink" title="包的导入路径"></a>包的导入路径</h3><p>包的引用路径有两种写法，分别是全路径导入和相对路径导入。</p>
<h4 id="全路径导入"><a href="#全路径导入" class="headerlink" title="全路径导入"></a>全路径导入</h4><p>包的绝对路径就是 <code>GOROOT/src/</code> 或 <code>GOPATH/src/</code> 后面包的存放路径，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import "lab/test"</span><br><span class="line">import "database/sql/driver"</span><br><span class="line">import "database/sql"</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码的含义如下：</p>
<ul>
<li>test 包是自定义的包，其源码位于GOPATH/src/lab/test 目录下；</li>
<li>driver 包的源码位于GOROOT/src/database/sql/driver 目录下；</li>
<li>sql 包的源码位于GOROOT/src/database/sql 目录下。</li>
</ul>
<h4 id="相对路径导入"><a href="#相对路径导入" class="headerlink" title="相对路径导入"></a>相对路径导入</h4><p>相对路径只能用于导入 <code>GOPATH</code> 下的包，标准包的导入只能使用全路径导入。</p>
<p>例如包 a 的所在路径是 <code>GOPATH/src/lab/a</code> ，包 b 的所在路径为 <code>GOPATH/src/lab/b</code>，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 相对路径导入</span><br><span class="line">import "../a"</span><br></pre></td></tr></tbody></table></figure>
<p>当然了，也可以使用上面的全路径导入，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全路径导入</span><br><span class="line">import "lab/a"</span><br></pre></td></tr></tbody></table></figure>
<h4 id="包的引用格式"><a href="#包的引用格式" class="headerlink" title="包的引用格式"></a>包的引用格式</h4><p>包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。</p>
<p><strong>1) 标准引用格式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>此时可以用 <code>fmt.</code> 作为前缀来使用 fmt 包中的方法，这是常用的一种方式。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 自定义别名引用格式</strong></p>
<p>在导入包的时候，我们还可以为导入的包设置别名，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import F "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>其中 F 就是 fmt 包的别名，使用时我们可以使用 <code>F.</code> 来代替标准引用格式的fmt.来作为前缀使用 fmt 包中的方法。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import F "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    F.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 省略引用格式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import . "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>这种格式相当于把 fmt 包直接合并到当前程序中，在使用 fmt 包内的方法是可以不用加前缀 <code>fmt.</code> ，直接引用。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import . "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //不需要加前缀 fmt.</span><br><span class="line">    Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) 匿名引用格式</strong></p>
<p>在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ "fmt"</span><br></pre></td></tr></tbody></table></figure>
<p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p>
<p>使用标准格式引用包，但是代码中却没有使用包，编译器会报错。如果包中有 init 初始化函数，则通过import _ “包的路径” 这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。</p>
<p>示例代码如下：</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    _ "database/sql"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ul>
<li>一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。</li>
<li>包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。</li>
<li>包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。</li>
</ul>
<h3 id="包加载"><a href="#包加载" class="headerlink" title="包加载"></a>包加载</h3><p>通过前面一系列的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gomaininit.gif" alt="图：Go 包的初始化"></p>
<p>Go语言包的初始化有如下特点：</p>
<ul>
<li>包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。</li>
<li>Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。</li>
<li>单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 init 函数。</li>
</ul>
<h2 id="封装简介及实现细节"><a href="#封装简介及实现细节" class="headerlink" title="封装简介及实现细节"></a>封装简介及实现细节</h2><p>在Go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只能通过被授权的方法，才能对字段进行操作。</p>
<p>封装的好处：</p>
<ul>
<li>隐藏实现细节；</li>
<li>可以对数据进行验证，保证数据安全合理。</li>
</ul>
<p>如何体现封装：</p>
<ul>
<li>对结构体中的属性进行封装；</li>
<li>通过方法，包，实现封装。</li>
</ul>
<p>封装的实现步骤：</p>
<ul>
<li>将结构体、字段的首字母小写；</li>
<li>给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；</li>
<li>提供一个首字母大写的 Set 方法（类似其它语言的 public），用于对属性判断并赋值；</li>
<li>提供一个首字母大写的 Get 方法（类似其它语言的 public），用于获取属性的值。</li>
</ul>
<p>【示例】对于员工，不能随便查看年龄，工资等隐私，并对输入的年龄进行合理的验证。代码结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package model</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type person struct {</span><br><span class="line">	Name string</span><br><span class="line">	age int   //其它包不能直接访问..</span><br><span class="line">	sal float64</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//写一个工厂模式的函数，相当于构造函数</span><br><span class="line">func NewPerson(name string) *person {</span><br><span class="line">	return &amp;person{</span><br><span class="line">		Name : name,</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法</span><br><span class="line">func (p *person) SetAge(age int) {</span><br><span class="line">	if age &gt;0 &amp;&amp; age &lt;150 {</span><br><span class="line">		p.age = age</span><br><span class="line">	} else {</span><br><span class="line">		fmt.Println("年龄范围不正确..")</span><br><span class="line">		//给程序员给一个默认值</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) GetAge() int {</span><br><span class="line">	return p.age</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) SetSal(sal float64) {</span><br><span class="line">	if sal &gt;= 3000 &amp;&amp; sal &lt;= 30000 {</span><br><span class="line">		p.sal = sal</span><br><span class="line">	} else {</span><br><span class="line">		fmt.Println("薪水范围不正确..")</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person) GetSal() float64 {</span><br><span class="line">	return p.sal</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>main.go 中的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line"></span><br><span class="line">	"../model"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  {</span><br><span class="line">	p := model.NewPerson("smith")</span><br><span class="line">	p.SetAge(18)</span><br><span class="line">	p.SetSal(5000)</span><br><span class="line">	fmt.Println(p)</span><br><span class="line">	fmt.Println(p.Name, " age =", p.GetAge(), " sal = ", p.GetSal())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&amp;{smith 18 5000}</span><br><span class="line">smith  age = 18  sal =  5000</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## GOPATH详解（Go语言工作目录）</span><br><span class="line"></span><br><span class="line">GOPATH 是 Go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录。</span><br><span class="line"></span><br><span class="line">工作目录是一个工程开发的相对参考目录，好比当你要在公司编写一套服务器代码，你的工位所包含的桌面、计算机及椅子就是你的工作区。工作区的概念与工作目录的概念也是类似的。如果不使用工作目录的概念，在多人开发时，每个人有一套自己的目录结构，读取配置文件的位置不统一，输出的二进制运行文件也不统一，这样会导致开发的标准不统一，影响开发效率。</span><br><span class="line"></span><br><span class="line">GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。</span><br><span class="line"></span><br><span class="line">**提示**</span><br><span class="line"></span><br><span class="line">C、C++、Java、C# 及其他语言发展到后期，都拥有自己的 IDE（集成开发环境），并且工程（Project）、解决方案（Solution）和工作区（Workspace）等概念将源码和资源组织了起来，方便编译和输出。</span><br><span class="line"></span><br><span class="line">### 使用命令行查看GOPATH信息</span><br><span class="line"></span><br><span class="line">在《安装Go语言开发包》一节中我们已经介绍过 Go语言的安装方法。在安装过 Go 开发包的操作系统中，可以使用命令行查看 Go 开发包的环境变量配置信息，这些配置信息里可以查看到当前的 GOPATH 路径设置情况。在命令行中运行go env后，命令行将提示以下信息：</span><br><span class="line"></span><br><span class="line">```示例代码</span><br><span class="line">D:\go_workspace\chebada-go-proxy\src\chebada.com\app\main&gt;go env</span><br><span class="line">set GO111MODULE=</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">set GOBIN=</span><br><span class="line">set GOCACHE=D:\MyConfiguration\dqc13215\AppData\Local\go-build</span><br><span class="line">set GOENV=D:\MyConfiguration\dqc13215\AppData\Roaming\go\env</span><br><span class="line">set GOEXE=.exe</span><br><span class="line">set GOFLAGS=</span><br><span class="line">set GOHOSTARCH=amd64</span><br><span class="line">set GOHOSTOS=windows</span><br><span class="line">set GOINSECURE=</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOOS=windows</span><br><span class="line">set GOPATH=D:\go_workspace</span><br><span class="line">set GOPRIVATE=</span><br><span class="line">set GOPROXY=https://goproxy.cn,direct</span><br><span class="line">set GOROOT=C:\Go</span><br><span class="line">set GOSUMDB=sum.golang.org</span><br><span class="line">set GOTMPDIR=</span><br><span class="line">set GOTOOLDIR=C:\Go\pkg\tool\windows_amd64</span><br><span class="line">set GCCGO=gccgo</span><br><span class="line">set AR=ar</span><br><span class="line">set CC=gcc</span><br><span class="line">set CXX=g++</span><br><span class="line">set CGO_ENABLED=1</span><br><span class="line">set GOMOD=D:\go_workspace\chebada-go-proxy\go.mod</span><br><span class="line">set CGO_CFLAGS=-g -O2</span><br><span class="line">set CGO_CPPFLAGS=</span><br><span class="line">set CGO_CXXFLAGS=-g -O2</span><br><span class="line">set CGO_FFLAGS=-g -O2</span><br><span class="line">set CGO_LDFLAGS=-g -O2</span><br><span class="line">set PKG_CONFIG=pkg-config</span><br><span class="line">set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=D:\MyConfiguration\dqc13215\AppData\Local\Temp\go-build678842734=/tmp/go-build -gno-record-gcc-switches</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>命令行说明如下：</p>
<ul>
<li>第 1 行，执行 go env 指令，将输出当前 Go 开发包的环境变量状态。</li>
<li>第 3 行，GOARCH 表示目标处理器架构。</li>
<li>第 4 行，GOBIN 表示编译器和链接器的安装位置。</li>
<li>第 14 行，GOOS 表示目标操作系统。</li>
<li>第 15 行，GOPATH 表示当前工作目录。</li>
<li>第 18 行，GOROOT 表示 Go 开发包的安装目录。</li>
</ul>
<p>从命令行输出中，可以看到 GOPATH 设定的路径为：<code>D:\go_workspace</code> 。</p>
<p>在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。</p>
<table>
    <thead><tr><th>平  台</th><th>GOPATH 默认值</th><th>举  例</th></tr></thead>
    <tbody>
        <tr><th>Windows 平台</th><th>%USERPROFILE%/go</th><th>C:\Users\用户名\go</th></tr>
         <tr><th>Unix 平台</th><th>$HOME/go</th><th>/home/用户名/go</th></tr>
    </tbody>
</table>

<h3 id="使用GOPATH的工程结构"><a href="#使用GOPATH的工程结构" class="headerlink" title="使用GOPATH的工程结构"></a>使用GOPATH的工程结构</h3><p>在 GOPATH 指定的工作目录下，代码总是会保存在 <code>$GOPATH/src</code> 目录下。在工程经过 <code>go build</code> 、<code>go install</code> 或 <code>go get</code> 等指令后，会将产生的二进制可执行文件放在 <code>$GOPATH/bin</code> 目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p>如果需要将整个源码添加到版本管理工具<code>（Version Control System，VCS）</code>中时，只需要添加 <code>$GOPATH/src</code> 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。</p>
<h4 id="设置和使用GOPATH"><a href="#设置和使用GOPATH" class="headerlink" title="设置和使用GOPATH"></a>设置和使用GOPATH</h4><p>本节以 Linux 为演示平台，为大家演示使用 GOPATH 的方法。</p>
<p><strong>1) 设置当前目录为GOPATH</strong></p>
<p>选择一个目录，在目录中的命令行中执行下面的指令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=`pwd`</span><br></pre></td></tr></tbody></table></figure>
<p>该指令中的 pwd 将输出当前的目录，使用反引号 ` 将 pwd 指令括起来表示命令行替换，也就是说，使用 `pwd` 将获得 pwd 返回的当前目录的值。例如，假设你的当前目录是“/home/davy/go”，那么使用 `pwd` 将获得返回值“/home/davy/go”。</p>
<p>使用 export 指令可以将当前目录的值设置到环境变量 GOPATH中。</p>
<p><strong>2) 建立GOPATH中的源码目录</strong></p>
<p>使用下面的指令创建 GOPATH 中的 src 目录，在 src 目录下还有一个 hello 目录，该目录用于保存源码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p src/hello</span><br></pre></td></tr></tbody></table></figure>
<p>mkdir 指令的 -p 可以连续创建一个路径。</p>
<p><strong>3) 添加main.go源码文件</strong></p>
<p>使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 <code>$GOPATH/src/hello</code> 目录下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main(){</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) 编译源码并运行</strong></p>
<p>此时我们已经设定了 GOPATH，因此在 Go语言中可以通过 GOPATH 找到工程的位置。</p>
<p>在命令行中执行如下指令编译源码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install hello</span><br></pre></td></tr></tbody></table></figure>
<p>编译完成的可执行文件会保存在 <code>$GOPATH/bin</code> 目录下。</p>
<p>在 bin 目录中执行 <code>./hello</code>，命令行输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在多项目工程中使用GOPATH"><a href="#在多项目工程中使用GOPATH" class="headerlink" title="在多项目工程中使用GOPATH"></a>在多项目工程中使用GOPATH</h3><p>在很多与 Go语言相关的书籍、文章中描述的 GOPATH 都是通过修改系统全局的环境变量来实现的。然而，根据笔者多年的 Go语言使用和实践经验及周边朋友、同事的反馈，这种设置全局 GOPATH 的方法可能会导致当前项目错误引用了其他目录的 Go 源码文件从而造成编译输出错误的版本或编译报出一些无法理解的错误提示。</p>
<p>比如说，将某项目代码保存在 <code>/home/davy/projectA</code> 目录下，将该目录设置为 GOPATH。随着开发进行，需要再次获取一份工程项目的源码，此时源码保存在 <code>/home/davy/projectB</code> 目录下，如果此时需要编译 projectB 目录的项目，但开发者忘记设置 GOPATH 而直接使用命令行编译，则当前的 GOPATH 指向的是 <code>/home/davy/projectA</code> 目录，而不是开发者编译时期望的 projectB 目录。编译完成后，开发者就会将错误的工程版本发布到外网。</p>
<p>因此，建议大家无论是使用命令行或者使用集成开发环境编译 Go 源码时，GOPATH 跟随项目设定。在 Jetbrains 公司的 GoLand 集成开发环境（IDE）中的 GOPATH 设置分为全局 GOPATH 和项目 GOPATH，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gopathproject.png" alt="图：全局和项目GOPATH"></p>
<p>图中的 Global GOPATH 代表全局 GOPATH，一般来源于系统环境变量中的 GOPATH；Project GOPATH 代表项目所使用的 GOPATH，该设置会被保存在工作目录的 <code>.idea</code> 目录下，不会被设置到环境变量的 GOPATH 中，但会在编译时使用到这个目录。建议在开发时只填写项目 GOPATH，每一个项目尽量只设置一个 GOPATH，不使用多个 GOPATH 和全局的 GOPATH。</p>
<p><strong>提示</strong></p>
<p>Visual Studio 早期在设计时，允许 C++ 语言在全局拥有一个包含路径。当一个工程多个版本的编译，或者两个项目混杂有不同的共享全局包含时，会发生难以察觉的错误。在新版本 Visual Studio 中已经废除了这种全局包含的路径设计，并建议开发者将包含目录与项目关联。</p>
<p>Go语言中的 GOPATH 也是一种类似全局包含的设计，因此鉴于 Visual Studio 在设计上的失误，建议开发者不要设置全局的 GOPATH，而是随项目设置 GOPATH。</p>
<h2 id="常用内置包简介"><a href="#常用内置包简介" class="headerlink" title="常用内置包简介"></a>常用内置包简介</h2><p>标准的Go语言代码库中包含了大量的包，并且在安装 Go 的时候多数会自动安装到系统中。我们可以在 <code>$GOROOT/src/pkg</code> 目录中查看这些包。下面简单介绍一些我们开发中常用的包。</p>
<h3 id="1-fmt"><a href="#1-fmt" class="headerlink" title="1) fmt"></a>1) fmt</h3><p>fmt 包实现了格式化的标准输入输出，这与C语言中的 printf 和 scanf 类似。其中的 fmt.Printf() 和 fmt.Println() 是开发者使用最为频繁的函数。</p>
<p>格式化短语派生于C语言，一些短语（%- 序列）是这样使用：</p>
<ul>
<li>%v：默认格式的值。当打印结构时，加号（%+v）会增加字段名；</li>
<li>%#v：Go样式的值表达；</li>
<li>%T：带有类型的 Go 样式的值表达。</li>
</ul>
<h3 id="2-io"><a href="#2-io" class="headerlink" title="2) io"></a>2) io</h3><p>这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。</p>
<h3 id="3-bufio"><a href="#3-bufio" class="headerlink" title="3) bufio"></a>3) bufio</h3><p>bufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。</p>
<p>在 bufio 各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行。当发起一次读写操作时，会首先尝试从缓冲区获取数据，只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。</p>
<h3 id="4-sort"><a href="#4-sort" class="headerlink" title="4) sort"></a>4) sort</h3><p>sort 包提供了用于对切片和用户定义的集合进行排序的功能。</p>
<h3 id="5-strconv"><a href="#5-strconv" class="headerlink" title="5) strconv"></a>5) strconv</h3><p>strconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。</p>
<h3 id="6-os"><a href="#6-os" class="headerlink" title="6) os"></a>6) os</h3><p>os 包提供了不依赖平台的操作系统函数接口，设计像 Unix 风格，但错误处理是 go 风格，当 os 包使用时，如果失败后返回错误类型而不是错误数量。</p>
<h3 id="7-sync"><a href="#7-sync" class="headerlink" title="7) sync"></a>7) sync</h3><p>sync 包实现多线程中锁机制以及其他同步互斥机制。</p>
<h3 id="8-flag"><a href="#8-flag" class="headerlink" title="8) flag"></a>8) flag</h3><p>flag 包提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。</p>
<h3 id="9-encoding-json"><a href="#9-encoding-json" class="headerlink" title="9) encoding/json"></a>9) encoding/json</h3><p>JSON 目前广泛用做网络程序中的通信格式。encoding/json 包提供了对 JSON 的基本支持，比如从一个对象序列化为 JSON 字符串，或者从 JSON 字符串反序列化出一个具体的对象等。</p>
<h3 id="10-html-template"><a href="#10-html-template" class="headerlink" title="10) html/template"></a>10) html/template</h3><p>主要实现了 web 开发中生成 html 的 template 的一些函数。</p>
<h3 id="11-net-http"><a href="#11-net-http" class="headerlink" title="11) net/http"></a>11) net/http</h3><p>net/http 包提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。</p>
<p>通过 net/http 包，只需要数行代码，即可实现一个爬虫或者一个 Web 服务器，这在传统语言中是无法想象的。</p>
<h3 id="12-reflect"><a href="#12-reflect" class="headerlink" title="12) reflect"></a>12) reflect</h3><p>reflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。</p>
<h3 id="13-os-exec"><a href="#13-os-exec" class="headerlink" title="13) os/exec"></a>13) os/exec</h3><p>os/exec 包提供了执行自定义 linux 命令的相关实现。</p>
<h3 id="14-strings"><a href="#14-strings" class="headerlink" title="14) strings"></a>14) strings</h3><p>strings 包主要是处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。</p>
<p>strings 包与 bytes 包的函数接口功能基本一致。</p>
<h3 id="15-bytes"><a href="#15-bytes" class="headerlink" title="15) bytes"></a>15) bytes</h3><p>bytes 包提供了对字节切片进行读写操作的一系列函数。字节切片处理的函数比较多，分为基本处理函数、比较函数、后缀检查函数、索引函数、分割函数、大小写处理函数和子切片处理函数等。</p>
<h3 id="16-log"><a href="#16-log" class="headerlink" title="16) log"></a>16) log</h3><p>log 包主要用于在程序中输出日志。</p>
<p>log 包中提供了三类日志输出接口，Print、Fatal 和 Panic。</p>
<ul>
<li>Print 是普通输出；</li>
<li>Fatal 是在执行完 Print 后，执行 os.Exit(1)；</li>
<li>Panic 是在执行完 Print 后调用 panic() 方法。</li>
</ul>
<h2 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h2><p>包是Go语言中代码组成和代码编译的主要方式。关于包的基本信息我们已经在前面介绍过了，本节我们主要来介绍一下如何自定义一个包并使用它。</p>
<p>到目前为止，我们所使用的例子都是以一个包的形式存在的，比如 main 包。在Go语言里，允许我们将同一个包的代码分隔成多个独立的源码文件来单独保存，只需要将这些文件放在同一个目录下即可。</p>
<p>我们创建的自定义的包需要将其放在 GOPATH 的 src 目录下（也可以是 src 目录下的某个子目录），而且两个不同的包不能放在同一目录下，这样会引起编译错误。</p>
<p>一个包中可以有任意多个文件，文件的名字也没有任何规定（但后缀必须是 .go），这里我们假设包名就是 .go 的文件名（如果一个包有多个 .go 文件，则其中会有一个 .go 文件的文件名和包名相同）。</p>
<p>下面通过示例来演示一下如何创建一个名为 demo 的自定义包，并在 main 包中使用自定义包 demo 中的方法。</p>
<p>首先，在 GOPATH 下的 src 目录中新建一个 demo 文件夹 ，并在 demo 文件夹下创建 demo.go 文件，如下所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/demopackage.gif" alt="图：demo 文件夹"></p>
<p>demo.go 文件的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func PrintStr() {</span><br><span class="line">    fmt.Println("C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后，在 GOPATH 下的 src 目录中新建一个 main 文件夹，并在 main 文件夹下创建 mian.go 文件，如下所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gopackagemain.gif" alt="图：main 文件夹"></p>
<p>main.go 文件的代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "demo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    demo.PrintStr()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">C语言中文网</span><br></pre></td></tr></tbody></table></figure>
<p>对引用自定义包需要注意以下几点：</p>
<ul>
<li>如果项目的目录不在 GOPATH 环境变量中，则需要把项目移到 GOPATH 所在的目录中，或者将项目所在的目录设置到 GOPATH 环境变量中，否则无法完成编译；</li>
<li>使用 import 语句导入包时，使用的是包所属文件夹的名称；</li>
<li>包中的函数名第一个字母要大写，否则无法在外部调用；</li>
<li>自定义包的包名不必与其所在文件夹的名称保持一致，但为了便于维护，建议保持一致；</li>
<li>调用自定义包时使用 包名 . 函数名 的方式，如上例：demo.PrintStr()。</li>
</ul>
<h2 id="package（创建包）"><a href="#package（创建包）" class="headerlink" title="package（创建包）"></a>package（创建包）</h2><p>包（package）是多个 Go 源码的集合，是一种高级的代码复用方案，像 fmt、os、io 等这样具有常用功能的内置包在 Go语言中有 150 个以上，它们被称为标准库，大部分（一些底层的除外）内置于 Go 本身。</p>
<p>包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></tbody></table></figure>
<p>包的特性如下：</p>
<ul>
<li>一个目录下的同级文件归属一个包。</li>
<li>包名可以与其目录不同名。</li>
<li>包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。</li>
</ul>
<p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p>
<p>每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以避免在我们使用它们的时候减少和其它部分名字的冲突。</p>
<p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包 API 的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p>
<p>当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。</p>
<ul>
<li>第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li>
<li>第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li>
<li>第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件。</li>
</ul>
<h2 id="导出包中的标识符——让外部访问包的类型和值"><a href="#导出包中的标识符——让外部访问包的类型和值" class="headerlink" title="导出包中的标识符——让外部访问包的类型和值"></a>导出包中的标识符——让外部访问包的类型和值</h2><p>在 Go语言中，如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。</p>
<h3 id="导出包内标识符"><a href="#导出包内标识符" class="headerlink" title="导出包内标识符"></a>导出包内标识符</h3><p>下面代码中包含一系列未导出标识符，它们的首字母都为小写，这些标识符可以在包内自由使用，但是包外无法访问它们，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package mypkg</span><br><span class="line"></span><br><span class="line">var myVar = 100</span><br><span class="line"></span><br><span class="line">const myConst = "hello"</span><br><span class="line"></span><br><span class="line">type myStruct struct {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将 myStruct 和 myConst 首字母大写，导出这些标识符，修改后代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package mypkg</span><br><span class="line"></span><br><span class="line">var myVar = 100</span><br><span class="line"></span><br><span class="line">const MyConst = "hello"</span><br><span class="line"></span><br><span class="line">type MyStruct struct {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时，MyConst 和 MyStruct 可以被外部访问，而 myVar 由于首字母是小写，因此只能在 mypkg 包内使用，不能被外部包引用。</p>
<h3 id="导出结构体及接口成员"><a href="#导出结构体及接口成员" class="headerlink" title="导出结构体及接口成员"></a>导出结构体及接口成员</h3><p>在被导出的结构体或接口中，如果它们的字段或方法首字母是大写，外部可以访问这些字段和方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type MyStruct struct {</span><br><span class="line"></span><br><span class="line">    // 包外可以访问的字段</span><br><span class="line">    ExportedField int</span><br><span class="line"></span><br><span class="line">    // 仅限包内访问的字段</span><br><span class="line">    privateField int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type MyInterface interface {</span><br><span class="line"></span><br><span class="line">    // 包外可以访问的方法</span><br><span class="line">    ExportedMethod()</span><br><span class="line"></span><br><span class="line">    // 仅限包内访问的方法</span><br><span class="line">    privateMethod()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在代码中，MyStruct 的 ExportedField 和 MyInterface 的 ExportedMethod() 可以被包外访问。</p>
<h2 id="import导入包——在代码中使用其他的代码"><a href="#import导入包——在代码中使用其他的代码" class="headerlink" title="import导入包——在代码中使用其他的代码"></a>import导入包——在代码中使用其他的代码</h2><p>可以在一个 Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用 <code>/</code> 进行路径分隔。</p>
<h3 id="默认导入的写法"><a href="#默认导入的写法" class="headerlink" title="默认导入的写法"></a>默认导入的写法</h3><p>导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的。</p>
<p><strong>1) 单行导入</strong></p>
<p>单行导入格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import "包1"</span><br><span class="line">import "包2"</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 多行导入</strong></p>
<p>当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    "包1"</span><br><span class="line">    "包2"</span><br><span class="line">    …</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>参考代码例子来理解 import 的机制。</p>
<p>代码的目录层次如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    └── chapter08</span><br><span class="line">        └── importadd</span><br><span class="line">            ├── main.go</span><br><span class="line">            └── mylib</span><br><span class="line">                └── add.go</span><br></pre></td></tr></tbody></table></figure>
<p>加函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package mylib</span><br><span class="line"></span><br><span class="line">func Add(a, b int) int {</span><br><span class="line">    return a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 3 行中的 Add() 函数以大写 A 开头，表示将 Add() 函数导出供包外使用。当首字母小写时，为包内使用，包外无法引用到。</p>
<p>add.go 在 mylib 文件夹下，习惯上将文件夹的命名与包名一致，命名为 mylib 包。</p>
<p>导入包</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/importadd/mylib"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(mylib.Add(1, 2))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，导入 chapter08/importadd/mylib 包。</li>
<li>第 9 行，使用 mylib 作为包名，并引用 Add() 函数调用。</li>
</ul>
<p>在命令行中运行下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/home/davy/golangbook/code</span><br><span class="line">go install chapter08/importadd</span><br><span class="line">$GOPATH/bin/importadd</span><br></pre></td></tr></tbody></table></figure>
<p>命令说明如下：</p>
<ul>
<li>第 1 行，根据你的 GOPATH 不同，设置 GOPATH。</li>
<li>第 2 行，使用 <code>go install</code> 指令编译并安装 chapter08/code8-1 到 GOPATH 的 bin 目录下。</li>
<li>第 3 行，执行 GOPATH 的 bin 目录下的可执行文件 code8-1。</li>
</ul>
<p>运行代码，输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt 和 goimports 工具都可以将不同分组导入的包独立排序。）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "html/template"</span><br><span class="line">    "os"</span><br><span class="line"></span><br><span class="line">    "golang.org/x/net/html"</span><br><span class="line">    "golang.org/x/net/ipv4"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入包后自定义引用的包名"><a href="#导入包后自定义引用的包名" class="headerlink" title="导入包后自定义引用的包名"></a>导入包后自定义引用的包名</h3><p>如果我们想同时导入两个有着名字相同的包，例如 math/rand 包和 crypto/rand 包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    "crypto/rand"</span><br><span class="line">    mrand "math/rand" // 将名称替换为mrand避免冲突</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。</p>
<p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为 path 的变量，那么我们可以将”path”标准包重命名为 pathpkg。</p>
<p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</p>
<h3 id="匿名导入包——只导入包但不使用包内类型和数值"><a href="#匿名导入包——只导入包但不使用包内类型和数值" class="headerlink" title="匿名导入包——只导入包但不使用包内类型和数值"></a>匿名导入包——只导入包但不使用包内类型和数值</h3><p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    _ "path/to/package"</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，path/to/package 表示要导入的包名，下画线 <code>_</code> 表示匿名导入包。</p>
<p>匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。</p>
<h3 id="包在程序启动前的初始化入口：init"><a href="#包在程序启动前的初始化入口：init" class="headerlink" title="包在程序启动前的初始化入口：init"></a>包在程序启动前的初始化入口：init</h3><p>在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。</p>
<p>例如，为了提高数学库计算三角函数的执行效率，可以在程序启动时，将三角函数的值提前在内存中建成索引表，外部程序通过查表的方式迅速获得三角函数的值。但是三角函数索引表的初始化函数的调用不希望由每一个外部使用三角函数的开发者调用，如果在三角函数的包内有一个机制可以告诉三角函数包程序何时启动，那么就可以解决初始化的问题。</p>
<p>Go 语言为以上问题提供了一个非常方便的特性：init() 函数。</p>
<p>init() 函数的特性如下：</p>
<ul>
<li>每个源码可以使用 1 个 init() 函数。</li>
<li>init() 函数会在程序执行前（main() 函数执行前）被自动调用。</li>
<li>调用顺序为 main() 中引用的包，以深度优先顺序初始化。</li>
</ul>
<p>例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.init→B.init→A.init→main</span><br></pre></td></tr></tbody></table></figure>
<p>说明：</p>
<ul>
<li>同一个包中的多个 init() 函数的调用顺序不可预期。</li>
<li>init() 函数不能被其他函数调用。</li>
</ul>
<h3 id="理解包导入后的init-函数初始化顺序"><a href="#理解包导入后的init-函数初始化顺序" class="headerlink" title="理解包导入后的init()函数初始化顺序"></a>理解包导入后的init()函数初始化顺序</h3><p>Go 语言包会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p>
<p>在运行时，被最后导入的包会最先初始化并调用 init() 函数。</p>
<p>通过下面的代码理解包的初始化顺序。</p>
<p>包导入初始化顺序入口（…/chapter08/pkginit/main.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "chapter08/code8-2/pkg1"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    pkg1.ExecPkg1()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，导入 pkg1 包。</li>
<li>第 7 行，调用 pkg1 包的 ExecPkg1() 函数。</li>
</ul>
<p>包导入初始化顺序pkg1（…/chapter08/pkginit/pkg1/pkg1.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package pkg1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/code8-2/pkg2"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func ExecPkg1() {</span><br><span class="line"></span><br><span class="line">    fmt.Println("ExecPkg1")</span><br><span class="line"></span><br><span class="line">    pkg2.ExecPkg2()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">    fmt.Println("pkg1 init")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，导入 pkg2 包。</li>
<li>第 8 行，声明 ExecPkg1() 函数。</li>
<li>第 12 行，调用 pkg2 包的 ExecPkg2() 函数。</li>
<li>第 15 行，在 pkg1 包初始化时，打印 pkg1 init。</li>
</ul>
<p>包导入初始化顺序pkg2（…/chapter08/pkginit/pkg2/pkg2.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package pkg2</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func ExecPkg2() {</span><br><span class="line">    fmt.Println("ExecPkg2")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">    fmt.Println("pkg2 init")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行，声明 ExecPkg2() 函数。</li>
<li>第 10 行，在 pkg2 包初始化时，打印 pkg2 init。</li>
</ul>
<p>执行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pkg2 init</span><br><span class="line">pkg1 init</span><br><span class="line">ExecPkg1</span><br><span class="line">ExecPkg2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="工厂模式自动注册——管理多个包的结构体"><a href="#工厂模式自动注册——管理多个包的结构体" class="headerlink" title="工厂模式自动注册——管理多个包的结构体"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/92.html">工厂模式自动注册——管理多个包的结构体</a></h2><p>本例利用包的 init 特性，将 cls1 和 cls2 两个包注册到工厂，使用字符串创建这两个注册好的结构实例。</p>
<p>完整代码的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── src</span><br><span class="line">    └── chapter08</span><br><span class="line">        └── clsfactory</span><br><span class="line">            ├── main.go</span><br><span class="line">            └── base</span><br><span class="line">                └── factory.go</span><br><span class="line">            └── cls1</span><br><span class="line">                └── reg.go</span><br><span class="line">            └── cls2</span><br><span class="line">                └── reg.go</span><br></pre></td></tr></tbody></table></figure>
<p>类工厂（具体文件：…/chapter08/clsfactory/base/factory.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package base</span><br><span class="line"></span><br><span class="line">// 类接口</span><br><span class="line">type Class interface {</span><br><span class="line">	Do()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	// 保存注册好的工厂信息</span><br><span class="line">	factoryByName = make(map[string]func() Class)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 注册一个类生成工厂</span><br><span class="line">func Register(name string, factory func() Class) {</span><br><span class="line">	factoryByName[name] = factory</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据名称创建对应的类</span><br><span class="line">func Create(name string) Class {</span><br><span class="line">	if f, ok := factoryByName[name]; ok {</span><br><span class="line">		return f()</span><br><span class="line">	} else {</span><br><span class="line">		panic("name not found")</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个包叫base，负责处理注册和使用工厂的基础代码，该包不会引用任何外部的包。</p>
<p>以下是对代码的说明：</p>
<ul>
<li>第 4 行定义了“产品”：类。</li>
<li>第 10 行使用了一个 map 保存注册的工厂信息。</li>
<li>第 14 行提供给工厂方注册使用，所谓的“工厂”，就是一个定义为 <code>func() Class</code> 的普通函数，调用此函数，创建一个类实例，实现的工厂内部结构体会实现 Class 接口。</li>
<li>第 19 行定义通过名字创建类实例的函数，该函数会在注册好后调用。</li>
<li>第 20 行在已经注册的信息中查找名字对应的工厂函数，找到后，在第 21 行调用并返回接口。</li>
<li>第 23 行是如果创建的名字没有找到时，报错。</li>
</ul>
<p>类1及注册代码（具体文件：…/chapter08/clsfactory/cls1/reg.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package cls1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> "../base"</span><br><span class="line"> "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义类1</span><br><span class="line">type Class1 struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Class接口</span><br><span class="line">func (c *Class1) Do() {</span><br><span class="line">	fmt.Println("Class1")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	// 在启动时注册类1工厂</span><br><span class="line">	base.Register("Class1", func() base.Class {</span><br><span class="line">		return new(Class1)</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码展示了Class1的工厂及产品定义过程。</p>
<ul>
<li>第 9～15 行定义 Class1 结构，该结构实现了 base 中的 Class 接口。</li>
<li>第 20 行，Class1 结构的实例化过程叫 Class1 的工厂，使用 <code>base.Register()</code> 函数在 init() 函数被调用时与一个字符串关联，这样，方便以后通过名字重新调用该函数并创建实例。</li>
</ul>
<p>类2及注册代码（具体文件：…/chapter08/clsfactory/cls2/reg.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package cls2</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"../base"</span><br><span class="line">	"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义类2</span><br><span class="line">type Class2 struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Class接口</span><br><span class="line">func (c *Class2) Do() {</span><br><span class="line">	fmt.Println("Class2")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">	// 在启动时注册类2工厂</span><br><span class="line">	base.Register("Class2", func() base.Class {</span><br><span class="line">		return new(Class2)</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Class2 的注册与 Class1 的定义和注册过程类似。</p>
<p>类工程主流程（具体文件：…/chapter08/clsfactory/main.go）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "chapter08/clsfactory/base"</span><br><span class="line">    _ "chapter08/clsfactory/cls1"  // 匿名引用cls1包, 自动注册</span><br><span class="line">    _ "chapter08/clsfactory/cls2"  // 匿名引用cls2包, 自动注册</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 根据字符串动态创建一个Class1实例</span><br><span class="line">    c1 := base.Create("Class1")</span><br><span class="line">    c1.Do()</span><br><span class="line"></span><br><span class="line">    // 根据字符串动态创建一个Class2实例</span><br><span class="line">    c2 := base.Create("Class2")</span><br><span class="line">    c2.Do()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对代码的说明：</p>
<ul>
<li>第 5 和第 6 行使用匿名引用方法导入了 cls1 和 cls2 两个包。在 main() 函数调用前，这两个包的 init() 函数会被自动调用，从而自动注册 Class1 和 Class2。</li>
<li>第 12 和第 16 行，通过 base.Create() 方法查找字符串对应的类注册信息，调用工厂方法进行实例创建。</li>
<li>第 13 和第 17 行，调用类的方法。</li>
</ul>
<p>执行下面的指令进行编译：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=/home/davy/golangbook/code</span><br><span class="line">go install chapter08/clsfactory</span><br><span class="line">$GOPATH/bin/clsfactory</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class1</span><br><span class="line">Class2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="单例模式简述"><a href="#单例模式简述" class="headerlink" title="单例模式简述"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5720.html">单例模式简述</a></h2><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>的重要性不用多说，也是面试时常常会被问到的问题。对于设计模式，更多的则是仁者见仁智者见智，要在实际工作中不断的积累，再进行深度的思考，才能逐渐形成的一种思维。</p>
<p>单例模式也叫单子模式，是常用的模式之一，在它的核心结构中只包含一个被称为单例的特殊类，能够保证系统运行中一个类只创建一个实例，本节我们就来介绍一下Go语言中的单例模式。</p>
<h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><p>Go语言实现单例模式的有四种方式，分别是懒汉式、饿汉式、双重检查和 sync.Once。</p>
<p>懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建；饿汉式则是在系统初始化的时候就已经把对象创建好了，需要用的时候直接拿过来用就好了。</p>
<p>不管那种模式最终目的只有一个，就是只实例化一次，只允许一个实例存在。</p>
<p>下面就来分别介绍一下这四种实现方式：</p>
<p><strong>1) 懒汉式——非线程安全</strong></p>
<p>非线程安全，指的是在多线程下可能会创建多次对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//使用结构体代替类</span><br><span class="line"></span><br><span class="line">type Tool struct {</span><br><span class="line">    values int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//建立私有变量</span><br><span class="line">var instance *Tool</span><br><span class="line"></span><br><span class="line">//获取单例对象的方法，引用传递返回</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    if instance == nil {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    }</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在非线程安全的基本上，利用 Sync.Mutex 进行加锁保证线程安全，但由于每次调用该方法都进行了加锁操作，在性能上不是很高效。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//锁对象</span><br><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">//加锁保证线程安全</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    lock.Lock()</span><br><span class="line">    defer lock.Unlock()</span><br><span class="line">    if instance == nil {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 饿汉式</strong></p>
<p>直接创建好对象，不需要判断为空，同时也是线程安全，唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。</p>
<p>Go语言饿汉式可以使用 init 函数，也可以使用全局变量。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type cfg struct {</span><br><span class="line">}</span><br><span class="line">var cfg *cfg</span><br><span class="line">func init()  {</span><br><span class="line">   cfg = new(cfg)</span><br><span class="line">}</span><br><span class="line">// NewConfig 提供获取实例的方法</span><br><span class="line">func NewConfig() *cfg {</span><br><span class="line">   return cfg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type config struct {  </span><br><span class="line">}</span><br><span class="line">//全局变量</span><br><span class="line">var cfg *config = new(config)</span><br><span class="line">// NewConfig 提供获取实例的方法</span><br><span class="line">func NewConfig() *config {</span><br><span class="line">   return cfg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 双重检查</strong></p>
<p>在懒汉式（线程安全）的基础上再进行优化，减少加锁的操作，保证线程安全的同时不影响性能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//锁对象</span><br><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">//第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后，获取对象就不用加锁了。</span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    if instance == nil {</span><br><span class="line">        lock.Lock()</span><br><span class="line">        if instance == nil {</span><br><span class="line">            instance = new(Tool)</span><br><span class="line">        }</span><br><span class="line">        lock.Unlock()</span><br><span class="line">    }</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) sync.Once</strong></p>
<p>通过 sync.Once 来确保创建对象的方法只执行一次</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *Tool {</span><br><span class="line">    once.Do(func() {</span><br><span class="line">        instance = new(Tool)</span><br><span class="line">    })</span><br><span class="line">    return instance</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sync.Once 内部本质上也是双重检查的方式，但在写法上会比自己写双重检查更简洁，以下是 Once 的源码</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (o *Once) Do(f func()) {</span><br><span class="line">　　//判断是否执行过该方法，如果执行过则不执行</span><br><span class="line">    if atomic.LoadUint32(&amp;o.done) == 1 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    // Slow-path.</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    defer o.m.Unlock()</span><br><span class="line">　　//进行加锁，再做一次判断，如果没有执行，则进行标志已经执行并调用该方法</span><br><span class="line">    if o.done == 0 {</span><br><span class="line">        defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">        f()</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="sync包与锁：限制线程对变量的访问"><a href="#sync包与锁：限制线程对变量的访问" class="headerlink" title="sync包与锁：限制线程对变量的访问"></a>sync包与锁：限制线程对变量的访问</h2><p>Go语言中 sync 包里提供了互斥锁 Mutex 和读写锁 RWMutex 用于处理并发过程中可能出现同时两个或多个协程（或线程）读或写同一个变量的情况。</p>
<h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>锁是 sync 包中的核心，它主要有两个方法，分别是加锁（Lock）和解锁（Unlock）。</p>
<p>在并发的情况下，多个线程或协程同时其修改一个变量，使用锁能保证在某一时间内，只有一个协程或线程修改这一变量。</p>
<p>不使用锁时，在并发的情况下可能无法得到想要的结果，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var a = 0</span><br><span class="line">    for i := 0; i &lt; 1000; i++ {</span><br><span class="line">        go func(idx int) {</span><br><span class="line">            a += 1</span><br><span class="line">            fmt.Println(a)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从理论上来说，上面的程序会将 a 的值依次递增输出，然而实际结果却是下面这样子的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">537</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">538</span><br><span class="line">999</span><br><span class="line">1000</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出 a 的值并不是按顺序递增输出的，这是为什么呢？</p>
<p>协程的执行顺序大致如下所示：</p>
<ul>
<li>从寄存器读取 a 的值；</li>
<li>然后做加法运算；</li>
<li>最后写到寄存器。</li>
</ul>
<p>按照上面的顺序，假如有一个协程取得 a 的值为 3，然后执行加法运算，此时又有一个协程对 a 进行取值，得到的值同样是 3，最终两个协程的返回结果是相同的。</p>
<p>而锁的概念就是，当一个协程正在处理 a 时将 a 锁定，其它协程需要等待该协程处理完成并将 a 解锁后才能再进行操作，也就是说同时处理 a 的协程只能有一个，从而避免上面示例中的情况出现。</p>
<h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>上面的示例中出现的问题怎么解决呢？加一个互斥锁 Mutex 就可以了。那什么是互斥锁呢 ？互斥锁中其有两个方法可以调用，如下所示</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (m *Mutex) Lock()</span><br><span class="line">func (m *Mutex) Unlock()</span><br></pre></td></tr></tbody></table></figure>
<p>将上面的代码略作修改，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a = 0</span><br><span class="line">    var lock sync.Mutex</span><br><span class="line">    for i := 0; i &lt; 1000; i++ {</span><br><span class="line">        go func(idx int) {</span><br><span class="line">            lock.Lock()</span><br><span class="line">            defer lock.Unlock()</span><br><span class="line">            a += 1</span><br><span class="line">            fmt.Printf("goroutine %d, a=%d\n", idx, a)</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    // 等待 1s 结束主程序</span><br><span class="line">    // 确保所有协程执行完</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goroutine 995, a=996</span><br><span class="line">goroutine 996, a=997</span><br><span class="line">goroutine 997, a=998</span><br><span class="line">goroutine 998, a=999</span><br><span class="line">goroutine 999, a=1000</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁（重新争抢对互斥锁的锁定），示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    ch := make(chan struct{}, 2)</span><br><span class="line">    var l sync.Mutex</span><br><span class="line">    go func() {</span><br><span class="line">        l.Lock()</span><br><span class="line">        defer l.Unlock()</span><br><span class="line">        fmt.Println("goroutine1: 我会锁定大概 2s")</span><br><span class="line">        time.Sleep(time.Second * 2)</span><br><span class="line">        fmt.Println("goroutine1: 我解锁了，你们去抢吧")</span><br><span class="line">        ch &lt;- struct{}{}</span><br><span class="line">    }()</span><br><span class="line">    go func() {</span><br><span class="line">        fmt.Println("goroutine2: 等待解锁")</span><br><span class="line">        l.Lock()</span><br><span class="line">        defer l.Unlock()</span><br><span class="line">        fmt.Println("goroutine2: 欧耶，我也解锁了")</span><br><span class="line">        ch &lt;- struct{}{}</span><br><span class="line">    }()</span><br><span class="line">    // 等待 goroutine 执行结束</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        &lt;-ch</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goroutine1: 我会锁定大概 2s</span><br><span class="line">goroutine2: 等待解锁</span><br><span class="line">goroutine1: 我解锁了，你们去抢吧</span><br><span class="line">goroutine2: 欧耶，我也解锁了</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁有如下四个方法：</p>
<ul>
<li>写操作的锁定和解锁分别是 <code>func (*RWMutex) Lock</code> 和 <code>func (*RWMutex) Unlock</code> ；</li>
<li>读操作的锁定和解锁分别是 <code>func (*RWMutex) Rlock</code> 和 <code>func (*RWMutex) RUnlock</code> 。</li>
</ul>
<p>读写锁的区别在于：</p>
<ul>
<li>当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；</li>
<li>当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；</li>
<li>当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。</li>
</ul>
<p>所以说这里的读锁定（RLock）目的其实是告诉写锁定，有很多协程或者进程正在读取数据，写操作需要等它们读（读解锁）完才能进行写（写锁定）。</p>
<p>我们可以将其总结为如下三条：</p>
<ul>
<li>同时只能有一个 goroutine 能够获得写锁定；</li>
<li>同时可以有任意多个 gorouinte 获得读锁定；</li>
<li>同时只能存在写锁定或读锁定（读和写互斥）。</li>
</ul>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/rand"</span><br><span class="line">    "sync"</span><br><span class="line">)</span><br><span class="line">var count int</span><br><span class="line">var rw sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    ch := make(chan struct{}, 10)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        go read(i, ch)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        go write(i, ch)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        &lt;-ch</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func read(n int, ch chan struct{}) {</span><br><span class="line">    rw.RLock()</span><br><span class="line">    fmt.Printf("goroutine %d 进入读操作...\n", n)</span><br><span class="line">    v := count</span><br><span class="line">    fmt.Printf("goroutine %d 读取结束，值为：%d\n", n, v)</span><br><span class="line">    rw.RUnlock()</span><br><span class="line">    ch &lt;- struct{}{}</span><br><span class="line">}</span><br><span class="line">func write(n int, ch chan struct{}) {</span><br><span class="line">    rw.Lock()</span><br><span class="line">    fmt.Printf("goroutine %d 进入写操作...\n", n)</span><br><span class="line">    v := rand.Intn(1000)</span><br><span class="line">    count = v</span><br><span class="line">    fmt.Printf("goroutine %d 写入结束，新值为：%d\n", n, v)</span><br><span class="line">    rw.Unlock()</span><br><span class="line">    ch &lt;- struct{}{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">goroutine 0 进入读操作...</span><br><span class="line">goroutine 0 读取结束，值为：0</span><br><span class="line">goroutine 3 进入读操作...</span><br><span class="line">goroutine 1 进入读操作...</span><br><span class="line">goroutine 3 读取结束，值为：0</span><br><span class="line">goroutine 1 读取结束，值为：0</span><br><span class="line">goroutine 4 进入写操作...</span><br><span class="line">goroutine 4 写入结束，新值为：81</span><br><span class="line">goroutine 4 进入读操作...</span><br><span class="line">goroutine 4 读取结束，值为：81</span><br><span class="line">goroutine 2 进入读操作...</span><br><span class="line">goroutine 2 读取结束，值为：81</span><br><span class="line">goroutine 0 进入写操作...</span><br><span class="line">goroutine 0 写入结束，新值为：887</span><br><span class="line">goroutine 1 进入写操作...</span><br><span class="line">goroutine 1 写入结束，新值为：847</span><br><span class="line">goroutine 2 进入写操作...</span><br><span class="line">goroutine 2 写入结束，新值为：59</span><br><span class="line">goroutine 3 进入写操作...</span><br><span class="line">goroutine 3 写入结束，新值为：81</span><br></pre></td></tr></tbody></table></figure>
<p>下面再来看两个示例。</p>
<p>【示例 1】多个读操作同时读取一个变量时，虽然加了锁，但是读操作是不受影响的。（读和写是互斥的，读和读不互斥）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">var m *sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    m = new(sync.RWMutex)</span><br><span class="line">    // 多个同时读</span><br><span class="line">    go read(1)</span><br><span class="line">    go read(2)</span><br><span class="line">    time.Sleep(2*time.Second)</span><br><span class="line">}</span><br><span class="line">func read(i int) {</span><br><span class="line">    println(i,"read start")</span><br><span class="line">    m.RLock()</span><br><span class="line">    println(i,"reading")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.RUnlock()</span><br><span class="line">    println(i,"read over")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 read start</span><br><span class="line">1 reading</span><br><span class="line">2 read start</span><br><span class="line">2 reading</span><br><span class="line">1 read over</span><br><span class="line">2 read over</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】由于读写互斥，所以写操作开始的时候，读操作必须要等写操作进行完才能继续，不然读操作只能继续等待。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">var m *sync.RWMutex</span><br><span class="line">func main() {</span><br><span class="line">    m = new(sync.RWMutex)</span><br><span class="line">    // 写的时候啥也不能干</span><br><span class="line">    go write(1)</span><br><span class="line">    go read(2)</span><br><span class="line">    go write(3)</span><br><span class="line">    time.Sleep(2*time.Second)</span><br><span class="line">}</span><br><span class="line">func read(i int) {</span><br><span class="line">    println(i,"read start")</span><br><span class="line">    m.RLock()</span><br><span class="line">    println(i,"reading")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.RUnlock()</span><br><span class="line">    println(i,"read over")</span><br><span class="line">}</span><br><span class="line">func write(i int) {</span><br><span class="line">    println(i,"write start")</span><br><span class="line">    m.Lock()</span><br><span class="line">    println(i,"writing")</span><br><span class="line">    time.Sleep(1*time.Second)</span><br><span class="line">    m.Unlock()</span><br><span class="line">    println(i,"write over")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 write start</span><br><span class="line">3 write start</span><br><span class="line">1 writing</span><br><span class="line">2 read start</span><br><span class="line">1 write over</span><br><span class="line">2 reading</span><br></pre></td></tr></tbody></table></figure>
<h2 id="big包：对整数的高精度计算"><a href="#big包：对整数的高精度计算" class="headerlink" title="big包：对整数的高精度计算"></a>big包：对整数的高精度计算</h2><p>实际开发中，对于超出 int64 或者 uint64 类型的大数进行计算时，如果对精度没有要求，使用 float32 或者 float64 就可以胜任，但如果对精度有严格要求的时候，我们就不能使用浮点数了，因为浮点数在内存中只能被近似的表示。</p>
<p>Go语言中 <code>math/big</code> 包实现了大数字的多精度计算，支持 Int（有符号整数）、Rat（有理数）和 Float（浮点数）等数字类型。</p>
<p>这些类型可以实现任意位数的数字，只要内存足够大，但缺点是需要更大的内存和处理开销，这使得它们使用起来要比内置的数字类型慢很多。</p>
<p>在 <code>math/big</code> 包中，Int 类型定义如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// An Int represents a signed multi-precision integer.</span><br><span class="line">// The zero value for an Int represents the value 0.</span><br><span class="line">type Int struct {</span><br><span class="line">    neg bool // sign</span><br><span class="line">    abs nat  // absolute value of the integer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成 Int 类型的方法为 NewInt()，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NewInt allocates and returns a new Int set to x.</span><br><span class="line">func NewInt(x int64) *Int {</span><br><span class="line">    return new(Int).SetInt64(x)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：NewInt() 函数只对 int64 有效，其他类型必须先转成 int64 才行。</em></strong></p>
<p>Go语言中还提供了许多 Set 函数，可以方便的把其他类型的整形存入 Int ，因此，我们可以先 new(int) 然后再调用 Set 函数，Set 函数有如下几种：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SetInt64 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) SetInt64(x int64) *Int {</span><br><span class="line">    neg := false</span><br><span class="line">    if x &lt; 0 {</span><br><span class="line">        neg = true</span><br><span class="line">        x = -x</span><br><span class="line">    }</span><br><span class="line">    z.abs = z.abs.setUint64(uint64(x))</span><br><span class="line">    z.neg = neg</span><br><span class="line">    return z</span><br><span class="line">}</span><br><span class="line">​</span><br><span class="line">// SetUint64 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) SetUint64(x uint64) *Int {</span><br><span class="line">    z.abs = z.abs.setUint64(x)</span><br><span class="line">    z.neg = false</span><br><span class="line">    return z</span><br><span class="line">}</span><br><span class="line">​</span><br><span class="line">// Set 函数将 z 转换为 x 并返回 z。</span><br><span class="line">func (z *Int) Set(x *Int) *Int {</span><br><span class="line">    if z != x {</span><br><span class="line">        z.abs = z.abs.set(x.abs)</span><br><span class="line">        z.neg = x.neg</span><br><span class="line">    }</span><br><span class="line">    return z</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    big1 := new(big.Int).SetUint64(uint64(1000))</span><br><span class="line">    fmt.Println("big1 is: ", big1)</span><br><span class="line"></span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println("big2 is: ", big2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">big1 is:  1000</span><br><span class="line">big2 is:  1000</span><br></pre></td></tr></tbody></table></figure>
<p>除了上述的 Set 函数，<code>math/big</code> 包中还提供了一个 SetString() 函数，可以指定进制数，比如二进制、十进制或者十六进制等！</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SetString sets z to the value of s, interpreted in the given base,</span><br><span class="line">// and returns z and a boolean indicating success. The entire string</span><br><span class="line">// (not just a prefix) must be valid for success. If SetString fails,</span><br><span class="line">// the value of z is undefined but the returned value is nil.</span><br><span class="line">//</span><br><span class="line">// The base argument must be 0 or a value between 2 and MaxBase. If the base</span><br><span class="line">// is 0, the string prefix determines the actual conversion base. A prefix of</span><br><span class="line">// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a</span><br><span class="line">// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.</span><br><span class="line">//</span><br><span class="line">func (z *Int) SetString(s string, base int) (*Int, bool) {</span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    if _, _, err := z.scan(r, base); err != nil {</span><br><span class="line">        return nil, false</span><br><span class="line">    }</span><br><span class="line">    // entire string must have been consumed</span><br><span class="line">    if _, err := r.ReadByte(); err != io.EOF {</span><br><span class="line">        return nil, false</span><br><span class="line">    }</span><br><span class="line">    return z, true // err == io.EOF =&gt; scan consumed all of s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    big1, _ := new(big.Int).SetString("1000", 10)</span><br><span class="line">    fmt.Println("big1 is: ", big1)</span><br><span class="line"></span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println("big2 is: ", big2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">big1 is:  1000</span><br><span class="line">big2 is:  1000</span><br></pre></td></tr></tbody></table></figure>
<p>因为Go语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。</p>
<p>Add 方法的定义如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (z *Int) Add(x, y *Int) *Int</span><br></pre></td></tr></tbody></table></figure>
<p>该方法会将 z 转换为 x + y 并返回 z。</p>
<p>【示例】计算第 1000 位的斐波那契数列</p>
<p>【示例】计算第 1000 位的斐波那契数列。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math/big"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const LIM = 1000 //求第1000位的斐波那契数列</span><br><span class="line"></span><br><span class="line">var fibs [LIM]*big.Int //使用数组保存计算出来的数列的指针</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result := big.NewInt(0)</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 0; i &lt; LIM; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i+1, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("执行完成，所耗时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func fibonacci(n int) (res *big.Int) {</span><br><span class="line">    if n &lt;= 1 {</span><br><span class="line">        res = big.NewInt(1)</span><br><span class="line">    } else {</span><br><span class="line">        temp := new(big.Int)</span><br><span class="line">        res = temp.Add(fibs[n-1], fibs[n-2])</span><br><span class="line">    }</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">...</span><br><span class="line">数列第 997 位: 10261062362033262336604926729245222132668558120602124277764622905699407982546711488272859468887457959087733119242564077850743657661180827326798539177758919828135114407499369796465649524266755391104990099120377</span><br><span class="line">数列第 998 位: 16602747662452097049541800472897701834948051198384828062358553091918573717701170201065510185595898605104094736918879278462233015981029522997836311232618760539199036765399799926731433239718860373345088375054249</span><br><span class="line">数列第 999 位: 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564191827856161443356312976673642210350324634850410377680367334151172899169723197082763985615764450078474174626</span><br><span class="line">数列第 1000 位: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</span><br><span class="line">执行完成，所耗时间为: 6.945ms</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用图像包制作GIF动画"><a href="#使用图像包制作GIF动画" class="headerlink" title="使用图像包制作GIF动画"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4785.html">使用图像包制作GIF动画</a></h2><p>本节将通过示例来介绍一下Go语言标准库中图像包的使用，并使用这些图像包来创建一系列的位图图像，然后将位图序列编码为 GIF 动画。</p>
<p>下面的图像叫作利萨茹图形，它类似于 20 世纪 60 年代科幻片中出现的一种纤维状视觉效果，利萨茹图形是由在互相垂直的方向上的两个频率成简单整数比的简谐振动所合成的规则的、稳定的曲线。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/lisharugif.gif" alt="图：四种利萨茹图形"></p>
<p>上图中所示的图像看似复杂，利用Go语言标准库中的图像包可以很轻松的实现，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "image"</span><br><span class="line">    "image/color"</span><br><span class="line">    "image/gif"</span><br><span class="line">    "io"</span><br><span class="line">    "math"</span><br><span class="line">    "math/rand"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var palette = []color.Color{color.White, color.Black} //调色板</span><br><span class="line">const (</span><br><span class="line">    whiteIndex = 0</span><br><span class="line">    blackIndex = 1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">    lissajous(os.Stdout)</span><br><span class="line">}</span><br><span class="line">func lissajous(out io.Writer) {</span><br><span class="line">    const (</span><br><span class="line">        cycles  = 5     //完整的x振荡器变化的个数</span><br><span class="line">        res     = 0.001 //角度分辨率</span><br><span class="line">        size    = 100   //图像画布包含[-size. .+size]</span><br><span class="line">        nframes = 64    //动画中的帧数</span><br><span class="line">        delay   = 8     //以10ms为单位的帧间延迟</span><br><span class="line">    )</span><br><span class="line">    freq := rand.Float64() * 3.0 //y 振荡器的相对频率</span><br><span class="line">    anim := gif.GIF{LoopCount: nframes}</span><br><span class="line">    phase := 0.0</span><br><span class="line">    for i := 0; i &lt; nframes; i++ {</span><br><span class="line">        rect := image.Rect(0, 0, 2*size+1, 2*size+1)</span><br><span class="line">        img := image.NewPaletted(rect, palette)</span><br><span class="line">        for t := 0.0; t &lt; cycles*2*math.Pi; t += res {</span><br><span class="line">            x := math.Sin(t)</span><br><span class="line">            y := math.Sin(t*freq + phase)</span><br><span class="line">            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)</span><br><span class="line">        }</span><br><span class="line">        phase += 0.1</span><br><span class="line">        anim.Delay = append(anim.Delay, delay)</span><br><span class="line">        anim.Image = append(anim.Image, img)</span><br><span class="line">    }</span><br><span class="line">    gif.EncodeAll(out, &amp;anim)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，lissajous 函数内部包含两层嵌套的 for 循环，外层循环会循环 64 次，每一次都会生成一个单独的动画帧，即生成一个只有黑色和白色，且大小为 201*201 的图片。</p>
<p>而 lissajous 函数的内层循环则设置了两个偏振值 x 和 y，x 轴偏振使用 sin 函数，y 轴偏振也是正弦波，但其相对 x 轴的偏振是一个 0~3 的随机值。初始偏振值是一个零值，随着动画的每一帧逐渐增加，循环会一直跑到 x 轴完成五次完整的循环，每一步它都会调用 SetColorIndex 来把 (x, y) 点来染成黑色。</p>
<p>想要成功的生成 gif 图像需要我们先使用go build 命令将代码编译为可执行文件，然后在 CMD（命令行工具）中运行所生成的可执行文件，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">main.exe &gt;1.gif</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>&gt;</code> 在这里用来指定生成图像的文件名，<code>1.gif</code> 为文件名。</p>
<p>执行成功后就可以在当前目录下找到生成的 gif 文件了，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/lisharu.gif" alt="图：利萨如图形"></p>
<h2 id="正则表达式：regexp包"><a href="#正则表达式：regexp包" class="headerlink" title="正则表达式：regexp包"></a>正则表达式：regexp包</h2><p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活，按照它的语法规则，根据需求构造出的正则表达式能够从原始文本中筛选出几乎任何你想要得到的字符组合。</p>
<p>Go语言通过 regexp 包为正则表达式提供了官方支持，其采用 RE2 语法，除了 <code>\c</code> 、<code>\C</code> 外，Go语言和 Perl、Python 等语言的正则基本一致。</p>
<h3 id="正则表达式语法规则"><a href="#正则表达式语法规则" class="headerlink" title="正则表达式语法规则"></a>正则表达式语法规则</h3><p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）构成的文字序列，可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>下面的表格中列举了构成正则表达式的一些语法规则及其含义。</p>
<p><strong>1) 字符</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>一般字符</td><td>匹配自身</td><td>abc</td><td>abc</td></tr>
    <tr><td>.</td><td>匹配任意除换行符"\n"外的字符，在 DOTALL 模式中也能匹配换行符</td><td>a.c</td><td>abc</td></tr>
    <tr><td>\</td><td>转义字符，使后一个字符改变原来的意思；<br>如果字符串中有字符 * 需要匹配，可以使用 \* 或者字符集［*]。</td><td>a\.c<br>a\\c</td><td>a.c<br>a\c</td></tr>
    <tr><td>[...]</td><td>字符集（字符类），对应的位置可以是字符集中任意字符。<br>字符集中的字符可以逐个列出，也可以给出范围，如 [abc] 或 [a-c]，<br>第一个字符如果是 ^ 则表示取反，如 [^abc] 表示除了abc之外的其他字符。</td><td>a[bcd]e</td><td>abe 或 ace 或 ade</td></tr>
    <tr><td>\d</td><td>数字：[0-9]</td><td>a\dc</td><td>a1c</td></tr>
    <tr><td>\D</td><td>非数字：[^\d]</td><td>a\Dc</td><td>abc</td></tr>
    <tr><td>\s</td><td>空白字符：[&lt;空格&gt;\t\r\n\f\v]</td><td>a\sc</td><td>a c</td></tr>
    <tr><td>\S</td><td>非空白字符：[^\s]</td><td>a\Sc</td><td>abc</td></tr>
    <tr><td>\w</td><td>单词字符：[A-Za-z0-9]</td><td>a\wc</td><td>abc</td></tr>
    <tr><td>\W</td><td>非单词字符：[^\w]</td><td>a\Wc</td><td>a c</td></tr>
  </tbody>
</table>

<p><strong>2) 数量词（用在字符或 (…) 之后）</strong></p>
<table>  
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>*</td><td>匹配前一个字符0或无限次</td><td>abc*</td><td>ab或abccc</td></tr>
    <tr><td>+</td><td>匹配前一个字符1次或无限次</td><td>abc+</td><td>abc或abccc</td></tr>
    <tr><td>?</td><td>匹配前一个字符0次或1次</td><td>abc?</td><td>ab或abc</td></tr>
    <tr><td>{m}</td><td>匹配前一个字符m次</td><td>ab{2}c</td><td>abbc</td></tr>
    <tr><td>{m,n}</td><td>匹配前一个字符m至n次，m和n可以省略，若省略m，则匹配0至n次；<br>若省略n，则匹配m至无限次</td><td>ab{1,2}c</td><td>abc或abbc</td></tr>
  </tbody>
</table>

<p><strong>3) 边界匹配</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>^</td><td>匹配字符串开头，在多行模式中匹配每一行的开头</td><td>^abc</td><td>abc</td></tr>
    <tr><td>$</td><td>匹配字符串末尾，在多行模式中匹配每一行的末尾</td><td>abc$</td><td>abc</td></tr>
    <tr><td>\A</td><td>仅匹配字符串开头</td><td>\Aabc</td><td>abc</td></tr>
    <tr><td>\Z</td><td>仅匹配字符串末尾</td><td>abc\Z</td><td>abc</td></tr>
    <tr><td>\b</td><td>匹配\w和\W之间</td><td>a\b!bc</td><td>a!bc</td></tr>
    <tr><td>\B</td><td>[^\b]</td><td>a\Bbc</td><td>abc</td></tr>
  </tbody>
</table>

<p><strong>4) 逻辑、分组</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>|</td><td>|代表左右表达式任意匹配一个，优先匹配左边的表达式</td><td>abc|def</td><td>abc或def</td></tr>
    <tr><td>(...)</td><td>括起来的表达式将作为分组，分组将作为一个整体，可以后接数量词</td><td>(abc){2}</td><td>abcabc</td></tr>
    <tr><td>(?P&lt;name&gt;...)</td><td>分组，功能与(...)相同，但会指定一个额外的别名</td><td>(?P&lt;id&gt;abc){2}</td><td>abcabc</td></tr>
    <tr><td>\&lt;number&gt;</td><td>引用编号为&lt;number&gt;的分组匹配到的字符串</td><td>(\d)abc\1</td><td>1abe1或5abc5</td></tr>
    <tr><td>(?P=name)</td><td>引用别名为&lt;name&gt;的分组匹配到的字符串</td><td>(?P&lt;id&gt;\d)abc(?P=id)</td><td>1abe1或&nbsp;5abc5</td></tr>
  </tbody>
</table>

<p><strong>5) 特殊构造（不作为分组）</strong></p>
<table>
  <thead><tr><th>语法</th><th>说明</th><th>表达式示例</th><th>匹配结果</th></tr></thead>
  <tbody>
    <tr><td>(?:...)</td><td>(…)的不分组版本，用于使用"|"或后接数量词</td><td>(?:abc){2}</td><td>abcabc</td></tr>
    <tr><td>(?iLmsux)</td><td>iLmsux中的每个字符代表一种匹配模式，只能用在正则表达式的开头，可选多个</td><td>(?i)abc</td><td>AbC</td></tr>
    <tr><td>(?#...)</td><td>#后的内容将作为注释被忽略。</td><td>abc(?#comment)123&nbsp;</td><td>abc123</td></tr>
    <tr><td>(?=...)</td><td>之后的字符串内容需要匹配表达式才能成功匹配</td><td>a(?=\d)</td><td>后面是数字的a</td></tr>
    <tr><td>(?!...)</td><td>之后的字符串内容需要不匹配表达式才能成功匹配</td><td>a(?!\d)</td><td>后面不是数字的a</td></tr>
    <tr><td>(?&lt;=...)</td><td>之前的字符串内容需要匹配表达式才能成功匹配</td><td>(?&lt;=\d)a</td><td>前面是数字的a</td></tr>
    <tr><td>(?&lt;!...)</td><td>之前的字符串内容需要不匹配表达式才能成功匹配</td><td>(?&lt;!\d)a</td><td>前面不是数字的a</td></tr>
  </tbody>
</table>

<h3 id="Regexp-包的使用"><a href="#Regexp-包的使用" class="headerlink" title="Regexp 包的使用"></a>Regexp 包的使用</h3><p>下面通过几个示例来演示一下 regexp 包的使用。</p>
<p>【示例 1】匹配指定类型的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a.c`)</span><br><span class="line">    if reg1 == nil {</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result1 =  [[abc] [azc] [a7c] [aac] [a9c]]　　</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】匹配 a 和 c 中间包含一个数字的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a[0-9]c`)</span><br><span class="line"></span><br><span class="line">    if reg1 == nil { //解释失败，返回nil</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result1 =  [[a7c] [a9c]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 3】使用 \d 来匹配 a 和 c 中间包含一个数字的字符串。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "abc azc a7c aac 888 a9c  tac"</span><br><span class="line"></span><br><span class="line">    //解析正则表达式，如果成功返回解释器</span><br><span class="line">    reg1 := regexp.MustCompile(`a\dc`)</span><br><span class="line"></span><br><span class="line">    if reg1 == nil { //解释失败，返回nil</span><br><span class="line">        fmt.Println("regexp err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    //根据规则提取关键信息</span><br><span class="line">    result1 := reg1.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result1 = ", result1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result1 =  [[a7c] [a9c]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 4】匹配字符串中的小数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    buf := "43.14 567 agsdg 1.23 7. 8.9 1sdljgl 6.66 7.8   "</span><br><span class="line"></span><br><span class="line">    //解释正则表达式</span><br><span class="line">    reg := regexp.MustCompile(`\d+\.\d+`)</span><br><span class="line"></span><br><span class="line">    if reg == nil {</span><br><span class="line">        fmt.Println("MustCompile err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //提取关键信息</span><br><span class="line">    //result := reg.FindAllString(buf, -1)</span><br><span class="line">    result := reg.FindAllStringSubmatch(buf, -1)</span><br><span class="line">    fmt.Println("result = ", result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result =  [[43.14] [1.23] [8.9] [6.66] [7.8]]</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 5】匹配 div 标签中的内容。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 原生字符串</span><br><span class="line">    buf := `</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-CN"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;C语言中文网 | Go语言入门教程&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;Go语言简介&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言基本语法</span><br><span class="line">    Go语言变量的声明</span><br><span class="line">    Go语言教程简明版</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言容器&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;Go语言函数&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">    `</span><br><span class="line"></span><br><span class="line">    //解释正则表达式</span><br><span class="line">    reg := regexp.MustCompile(`&lt;div&gt;(?s:(.*?))&lt;/div&gt;`)</span><br><span class="line">    if reg == nil {</span><br><span class="line">        fmt.Println("MustCompile err")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //提取关键信息</span><br><span class="line">    result := reg.FindAllStringSubmatch(buf, -1)</span><br><span class="line"></span><br><span class="line">    //过滤&lt;&gt;&lt;/&gt;</span><br><span class="line">    for _, text := range result {</span><br><span class="line">        fmt.Println("text[1] = ", text[1])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[1] =  Go语言简介</span><br><span class="line">text[1] =  Go语言基本语法</span><br><span class="line">    Go语言变量的声明</span><br><span class="line">    Go语言教程简明版</span><br><span class="line"></span><br><span class="line">text[1] =  Go语言容器</span><br><span class="line">text[1] =  Go语言函数</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 6】通过 Compile 方法返回一个 Regexp 对象，实现匹配，查找，替换相关的功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "regexp"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //目标字符串</span><br><span class="line">    searchIn := "John: 2578.34 William: 4567.23 Steve: 5632.18"</span><br><span class="line">    pat := "[0-9]+.[0-9]+"          //正则</span><br><span class="line"></span><br><span class="line">    f := func(s string) string{</span><br><span class="line">        v, _ := strconv.ParseFloat(s, 32)</span><br><span class="line">        return strconv.FormatFloat(v * 2, 'f', 2, 32)</span><br><span class="line">    }</span><br><span class="line">    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok {</span><br><span class="line">        fmt.Println("Match Found!")</span><br><span class="line">    }</span><br><span class="line">    re, _ := regexp.Compile(pat)</span><br><span class="line">    //将匹配到的部分替换为 "##.#"</span><br><span class="line">    str := re.ReplaceAllString(searchIn, "##.#")</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">    //参数为函数时</span><br><span class="line">    str2 := re.ReplaceAllStringFunc(searchIn, f)</span><br><span class="line">    fmt.Println(str2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Match Found!</span><br><span class="line">John: ##.# William: ##.# Steve: ##.#</span><br><span class="line">John: 5156.68 William: 9134.46 Steve: 11264.36</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中 Compile 方法可以解析并返回一个正则表达式，如果成功返回，则说明该正则表达式正确可用于匹配文本。</p>
<p>另外我们也可以使用 MustCompile 方法，它也可以像 Compile 方法一样检验正则的有效性，但是当正则不合法时程序将 panic。</p>
<h2 id="time包：时间和日期"><a href="#time包：时间和日期" class="headerlink" title="time包：时间和日期"></a>time包：时间和日期</h2><p>时间和日期是我们开发中经常会用到的，Go语言中的 time 包提供了时间显示和测量等所用的函数，本节我们就来介绍一下 time 包的基本用法。</p>
<h3 id="time-包简介"><a href="#time-包简介" class="headerlink" title="time 包简介"></a>time 包简介</h3><p>时间一般包含时间值和时区，可以从Go语言中 time 包的源码中看出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ype Time struct {</span><br><span class="line">    // wall and ext encode the wall time seconds, wall time nanoseconds,</span><br><span class="line">    // and optional monotonic clock reading in nanoseconds.</span><br><span class="line">    //</span><br><span class="line">    // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</span><br><span class="line">    // a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</span><br><span class="line">    // The nanoseconds field is in the range [0, 999999999].</span><br><span class="line">    // If the hasMonotonic bit is 0, then the 33-bit field must be zero</span><br><span class="line">    // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</span><br><span class="line">    // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</span><br><span class="line">    // unsigned wall seconds since Jan 1 year 1885, and ext holds a</span><br><span class="line">    // signed 64-bit monotonic clock reading, nanoseconds since process start.</span><br><span class="line">    wall uint64</span><br><span class="line">    ext  int64</span><br><span class="line">    // loc specifies the Location that should be used to</span><br><span class="line">    // determine the minute, hour, month, day, and year</span><br><span class="line">    // that correspond to this Time.</span><br><span class="line">    // The nil location means UTC.</span><br><span class="line">    // All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span><br><span class="line">    loc *Location</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中：</p>
<ul>
<li>wall：表示距离公元 1 年 1 月 1 日 00:00:00UTC 的秒数；</li>
<li>ext：表示纳秒；</li>
<li>loc：代表时区，主要处理偏移量，不同的时区，对应的时间不一样。</li>
</ul>
<p><strong>如何正确表示时间呢？</strong></p>
<p>公认最准确的计算应该是使用“原子震荡周期”所计算的物理时钟了（Atomic Clock, 也被称为原子钟），这也被定义为标准时间（International Atomic Time）。</p>
<p>而我们常常看见的 UTC（Universal Time Coordinated，世界协调时间）就是利用这种 Atomic Clock 为基准所定义出来的正确时间。UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC + 时区差 ＝ 本地时间</span><br></pre></td></tr></tbody></table></figure>
<p>国内一般使用的是北京时间，与 UTC 的时间关系如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UTC + 8 个小时 = 北京时间</span><br></pre></td></tr></tbody></table></figure>
<p>在Go语言的 time 包里面有两个时区变量，如下：</p>
<ul>
<li>time.UTC：UTC 时间</li>
<li>time.Local：本地时间</li>
</ul>
<p>同时，Go语言还提供了 LoadLocation 方法和 FixedZone 方法来获取时区变量，如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FixedZone(name string, offset int) *Location</span><br></pre></td></tr></tbody></table></figure>
<p>其中，name 为时区名称，offset 是与 UTC 之前的时差。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadLocation(name string) (*Location, error)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间的获取"><a href="#时间的获取" class="headerlink" title="时间的获取"></a>时间的获取</h3><p><strong>1) 获取当前时间</strong></p>
<p>我们可以通过 time.Now() 函数来获取当前的时间对象，然后通过事件对象来获取当前的时间信息。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now() //获取当前时间</span><br><span class="line">    fmt.Printf("current time:%v\n", now)</span><br><span class="line">    year := now.Year()     //年</span><br><span class="line">    month := now.Month()   //月</span><br><span class="line">    day := now.Day()       //日</span><br><span class="line">    hour := now.Hour()     //小时</span><br><span class="line">    minute := now.Minute() //分钟</span><br><span class="line">    second := now.Second() //秒</span><br><span class="line">    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current time:2020-10-23 16:30:41.4278273 +0800 CST m=+0.008019701</span><br><span class="line">2020-10-23 16:30:41</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) 获取时间戳</strong></p>
<p>时间戳是自 <code>1970 年 1 月 1 日（08:00:00GMT）</code> 至当前时间的总毫秒数，它也被称为 Unix 时间戳（UnixTimestamp）。</p>
<p>基于时间对象获取时间戳的示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()            //获取当前时间</span><br><span class="line">    timestamp1 := now.Unix()     //时间戳</span><br><span class="line">    timestamp2 := now.UnixNano() //纳秒时间戳</span><br><span class="line">    fmt.Printf("现在的时间戳：%v\n", timestamp1)</span><br><span class="line">    fmt.Printf("现在的纳秒时间戳：%v\n", timestamp2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现在的时间戳：1603441948</span><br><span class="line">现在的纳秒时间戳：1603441948527541800</span><br></pre></td></tr></tbody></table></figure>
<p>使用 time.Unix() 函数可以将时间戳转为时间格式，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()                  //获取当前时间</span><br><span class="line">    timestamp := now.Unix()            //时间戳</span><br><span class="line">    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式</span><br><span class="line">    fmt.Println(timeObj)</span><br><span class="line">    year := timeObj.Year()     //年</span><br><span class="line">    month := timeObj.Month()   //月</span><br><span class="line">    day := timeObj.Day()       //日</span><br><span class="line">    hour := timeObj.Hour()     //小时</span><br><span class="line">    minute := timeObj.Minute() //分钟</span><br><span class="line">    second := timeObj.Second() //秒</span><br><span class="line">    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-10-23 16:35:53 +0800 CST</span><br><span class="line">2020-10-23 16:35:53</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 获取当前是星期几</strong></p>
<p>time 包中的 Weekday 函数能够返回某个时间点所对应是一周中的周几，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //时间戳</span><br><span class="line">    t := time.Now()</span><br><span class="line">    fmt.Println(t.Weekday().String())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Friday</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间操作函数"><a href="#时间操作函数" class="headerlink" title="时间操作函数"></a>时间操作函数</h3><p><strong>1) Add</strong></p>
<p>我们在日常的开发过程中可能会遇到要求某个时间 + 时间间隔之类的需求，Go语言中的 Add 方法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t Time) Add(d Duration) Time</span><br></pre></td></tr></tbody></table></figure>
<p>Add 函数可以返回时间点 t + 时间间隔 d 的值。</p>
<p>【示例】求一个小时之后的时间：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()</span><br><span class="line">    later := now.Add(time.Hour) // 当前时间加1小时后的时间</span><br><span class="line">    fmt.Println(later)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-10-23 17:39:37.5959762 +0800 CST m=+3600.007976201</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2) Sub</strong></p>
<p>求两个时间之间的差值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t Time) Sub(u Time) Duration</span><br></pre></td></tr></tbody></table></figure>
<p>返回一个时间段 t - u 的值。如果结果超出了 Duration 可以表示的最大值或最小值，将返回最大值或最小值，要获取时间点 t - d（d 为 Duration），可以使用 t.Add(-d)。</p>
<p><strong>3) Equal</strong></p>
<p>判断两个时间是否相同：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t Time) Equal(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>Equal 函数会考虑时区的影响，因此不同时区标准的时间也可以正确比较，Equal 方法和用 t==u 不同，Equal 方法还会比较地点和时区信息。</p>
<p><strong>4) Before</strong></p>
<p>判断一个时间点是否在另一个时间点之前：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t Time) Before(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>如果 t 代表的时间点在 u 之前，则返回真，否则返回假。</p>
<p><strong>5) After</strong></p>
<p>判断一个时间点是否在另一个时间点之后：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t Time) After(u Time) bool</span><br></pre></td></tr></tbody></table></figure>
<p>如果 t 代表的时间点在 u 之后，则返回真，否则返回假。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>使用 time.Tick(时间间隔) 可以设置定时器，定时器的本质上是一个通道（channel），示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器</span><br><span class="line">    for i := range ticker {</span><br><span class="line">        fmt.Println(i) //每秒都会执行的任务</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-10-23 16:45:40.0277348 +0800 CST m=+1.037966301</span><br><span class="line">2020-10-23 16:45:41.0269758 +0800 CST m=+2.037200801</span><br><span class="line">2020-10-23 16:45:42.0281504 +0800 CST m=+3.038368801</span><br><span class="line">2020-10-23 16:45:43.0272063 +0800 CST m=+4.037418201</span><br><span class="line">2020-10-23 16:45:44.0275883 +0800 CST m=+5.037793601</span><br><span class="line">2020-10-23 16:45:45.0271711 +0800 CST m=+6.037369801</span><br><span class="line">2020-10-23 16:45:46.027105 +0800 CST m=+7.037297201</span><br><span class="line">2020-10-23 16:45:47.0268987 +0800 CST m=+8.037084301</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p>时间类型有一个自带的 Format 方法进行格式化，需要注意的是Go语言中格式化时间模板不是常见的 <code>Y-m-d H:M:S</code> 而是使用Go语言的诞生时间 <code>2006 年 1 月 2 号 15 点 04 分 05 秒</code> 。</p>
<p><strong><em>提示：如果想将时间格式化为 12 小时格式，需指定 PM。</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    now := time.Now()</span><br><span class="line">    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span><br><span class="line">    // 24小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))</span><br><span class="line">    // 12小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02 15:04"))</span><br><span class="line">    fmt.Println(now.Format("15:04 2006/01/02"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-10-23 16:49:07.304 Fri Oct</span><br><span class="line">2020-10-23 04:49:07.304 PM Fri Oct</span><br><span class="line">2020/10/23 16:49</span><br><span class="line">16:49 2020/10/23</span><br><span class="line">2020/10/23</span><br></pre></td></tr></tbody></table></figure>
<h3 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h3><p>Parse 函数可以解析一个格式化的时间字符串并返回它代表的时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Parse(layout, value string) (Time, error)</span><br></pre></td></tr></tbody></table></figure>
<p>与 Parse 函数类似的还有 ParseInLocation 函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ParseInLocation(layout, value string, loc *Location) (Time, error)</span><br></pre></td></tr></tbody></table></figure>
<p>ParseInLocation 与 Parse 函数类似，但有两个重要的不同之处：</p>
<ul>
<li>第一，当缺少时区信息时，Parse 将时间解释为 UTC 时间，而 ParseInLocation 将返回值的 Location 设置为 loc；</li>
<li>第二，当时间字符串提供了时区偏移量信息时，Parse 会尝试去匹配本地时区，而 ParseInLocation 会去匹配 loc。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var layout string = "2006-01-02 15:04:05"</span><br><span class="line">    var timeStr string = "2020-10-23 16:52:12"</span><br><span class="line"></span><br><span class="line">    timeObj1, _ := time.Parse(layout, timeStr)</span><br><span class="line">    fmt.Println(timeObj1)</span><br><span class="line"></span><br><span class="line">    timeObj2, _ := time.ParseInLocation(layout, timeStr, time.Local)</span><br><span class="line">    fmt.Println(timeObj2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-10-23 16:52:12 +0000 UTC</span><br><span class="line">2020-10-23 16:52:12 +0800 CST</span><br></pre></td></tr></tbody></table></figure>
<h2 id="os包用法简述"><a href="#os包用法简述" class="headerlink" title="os包用法简述"></a>os包用法简述</h2><p>Go语言的 os 包中提供了操作系统函数的接口，是一个比较重要的包。顾名思义，os 包的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。</p>
<h3 id="os-包中的常用函数"><a href="#os-包中的常用函数" class="headerlink" title="os 包中的常用函数"></a>os 包中的常用函数</h3><p><strong>1) Hostname</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>Hostname 函数会返回内核提供的主机名。</p>
<p><strong>2) Environ</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) Getenv</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></tbody></table></figure>
<p>Getenv 函数会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。</p>
<p><strong>4) Setenv</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></tbody></table></figure>
<p>Setenv 函数可以设置名为 key 的环境变量，如果出错会返回该错误。</p>
<p><strong>5) Exit</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></tbody></table></figure>
<p>Exit 函数可以让当前程序以给出的状态码 code 退出。一般来说，状态码 0 表示成功，非 0 表示出错。程序会立刻终止，并且 defer 的函数不会被执行。</p>
<p><strong>6) Getuid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getuid 函数可以返回调用者的用户 ID。</p>
<p><strong>7) Getgid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getgid 函数可以返回调用者的组 ID。</p>
<p><strong>8) Getpid</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></tbody></table></figure>
<p>Getpid 函数可以返回调用者所在进程的进程 ID。</p>
<p><strong>9) Getwd</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getwd() (dir string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>Getwd 函数可以返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd 会返回其中一个。</p>
<p><strong>10) Mkdir</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Mkdir(name string, perm FileMode) error</span><br></pre></td></tr></tbody></table></figure>
<p>Mkdir 函数可以使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 底层类型的错误。</p>
<p><strong>11) MkdirAll</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func MkdirAll(path string, perm FileMode) error</span><br></pre></td></tr></tbody></table></figure>
<p>MkdirAll 函数可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。权限位 perm 会应用在每一个被该函数创建的目录上。如果 path 指定了一个已经存在的目录，MkdirAll 不做任何操作并返回 nil。</p>
<p><strong>12) Remove</strong></p>
<p>函数定义:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Remove(name string) error</span><br></pre></td></tr></tbody></table></figure>
<p>Remove 函数会删除 name 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 底层类型的错误。</p>
<p>RemoveAll 函数跟 Remove 用法一样，区别是会递归的删除所有子目录和文件。</p>
<p>在 os 包下，有 exec，signal，user 三个子包，下面来分别介绍一下。</p>
<h3 id="os-exec-执行外部命令"><a href="#os-exec-执行外部命令" class="headerlink" title="os/exec 执行外部命令"></a>os/exec 执行外部命令</h3><p>exec 包可以执行外部命令，它包装了 os.StartProcess 函数以便更容易的修正输入和输出，使用管道连接 I/O，以及作其它的一些调整。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func LookPath(file string) (string, error)</span><br></pre></td></tr></tbody></table></figure>
<p>在环境变量 PATH 指定的目录中搜索可执行文件，如果 file 中有斜杠，则只在当前目录搜索。返回完整路径或者相对于当前目录的一个相对路径。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os/exec"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := exec.LookPath("main")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.exe</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os-user-获取当前用户信息"><a href="#os-user-获取当前用户信息" class="headerlink" title="os/user 获取当前用户信息"></a>os/user 获取当前用户信息</h3><p>可以通过 os/user 包中的 Current() 函数来获取当前用户信息，该函数会返回一个 User 结构体，结构体中的 Username、Uid、HomeDir、Gid 分别表示当前用户的名称、用户 id、用户主目录和用户所属组 id，函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Current() (*User, error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "os/user"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    u, _ := user.Current()</span><br><span class="line">    log.Println("用户名：", u.Username)</span><br><span class="line">    log.Println("用户id", u.Uid)</span><br><span class="line">    log.Println("用户主目录：", u.HomeDir)</span><br><span class="line">    log.Println("主组id：", u.Gid)</span><br><span class="line"></span><br><span class="line">    // 用户所在的所有的组的id</span><br><span class="line">    s, _ := u.GroupIds()</span><br><span class="line">    log.Println("用户所在的所有组：", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020/10/23 17:10:55 用户名： TCENT\dqc13215</span><br><span class="line">2020/10/23 17:10:55 用户id S-1-5-21-1244066353-432844205-2039415564-35519</span><br><span class="line">2020/10/23 17:10:55 用户主目录： D:\MyConfiguration\dqc13215</span><br><span class="line">2020/10/23 17:10:55 主组id： S-1-5-21-1244066353-432844205-2039415564-513</span><br><span class="line">2020/10/23 17:10:55 用户所在的所有组： [S-1-5-32-544 S-1-5-32-545 S-1-5-21-1244066353-432844205-2039415564-513]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os-signal-信号处理"><a href="#os-signal-信号处理" class="headerlink" title="os/signal 信号处理"></a>os/signal 信号处理</h3><p>一个运行良好的程序在退出（正常退出或者强制退出，如 Ctrl+C，kill 等）时是可以执行一段清理代码的，将收尾工作做完后再真正退出。一般采用系统 Signal 来通知系统退出，如 kill pid，在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。</p>
<p>Go语言中对信号的处理主要使用 os/signal 包中的两个方法，一个是 Notify 方法用来监听收到的信号，一个是 stop 方法用来取消监听。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，第一个参数表示接收信号的 channel，第二个及后面的参数表示设置要监听的信号，如果不设置表示监听所有的信号。</p>
<p>【示例 1】使用 Notify 方法来监听收到的信号：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "os/signal"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := make(chan os.Signal, 0)</span><br><span class="line">    signal.Notify(c)</span><br><span class="line">  </span><br><span class="line">    // Block until a signal is received.</span><br><span class="line">    s := &lt;-c</span><br><span class="line">    fmt.Println("Got signal:", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行该程序，然后在 CMD 窗口中通过 Ctrl+C 来结束该程序，便会得到输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got signal: interrupt</span><br></pre></td></tr></tbody></table></figure>
<p>【示例 2】使用 stop 方法来取消监听：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "os/signal"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := make(chan os.Signal, 0)</span><br><span class="line">    signal.Notify(c)</span><br><span class="line"></span><br><span class="line">    signal.Stop(c) //不允许继续往c中存入内容</span><br><span class="line">    s := &lt;-c       //c无内容，此处阻塞，所以不会执行下面的语句，也就没有输出</span><br><span class="line">    fmt.Println("Got signal:", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为使用 Stop 方法取消了 Notify 方法的监听，所以运行程序没有输出结果。</p>
<h2 id="flag包：命令行参数解析"><a href="#flag包：命令行参数解析" class="headerlink" title="flag包：命令行参数解析"></a>flag包：命令行参数解析</h2><p>在编写命令行程序（工具、server）时，我们有时需要对命令参数进行解析，各种编程语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。在Go语言中的 flag 包中，提供了命令行参数解析的功能。</p>
<p>下面我们就来看一下 flag 包可以做什么，它具有什么样的能力。</p>
<p>这里介绍几个概念：</p>
<ul>
<li>命令行参数（或参数）：是指运行程序时提供的参数；</li>
<li>已定义命令行参数：是指程序中通过 flag.Type 这种形式定义了的参数；</li>
<li>非 flag（non-flag）命令行参数（或保留的命令行参数）：可以简单理解为 flag 包不能解析的参数。</li>
</ul>
<h3 id="flag-包概述"><a href="#flag-包概述" class="headerlink" title="flag 包概述"></a>flag 包概述</h3><p>Go语言内置的 flag 包实现了命令行参数的解析，flag 包使得开发命令行工具更为简单。若要使用 flag 包，首先需要使用 import 关键字导入 flag 包，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import "flag"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="flag-参数类型"><a href="#flag-参数类型" class="headerlink" title="flag 参数类型"></a>flag 参数类型</h3><p>flag 包支持的命令行参数类型有 bool、int、int64、uint、uint64、float、float64、string、duration，如下表所示：</p>
<table>
  <thead><tr><th>flag参数</th><th>有效值</th></tr></thead>
  <tbody>
    <tr><td>字符串flag</td><td>合法字符串</td></tr>
    <tr><td>整数flag</td><td>1234、0664、0x1234等类型，也可以是负数</td></tr>
    <tr><td>浮点数flag</td><td>合法浮点数</td></tr>
    <tr><td>bool类型flag</td><td>1、0、t、f、T、F、true、false、TRUE、FALSE、True、False</td></tr>
    <tr><td>时间段flag</td><td>任何合法的时间段字符串，如“300ms”、“-1.5h”、“2h45m”，<br>合法的单位有“ns”、“us”、“µs”、“ms”、“s”、“m”、“h”</td></tr>
  </tbody>
</table>

<h3 id="flag-包基本使用"><a href="#flag-包基本使用" class="headerlink" title="flag 包基本使用"></a>flag 包基本使用</h3><p>有以下两种常用的定义命令行 flag 参数的方法：</p>
<p><strong>1) flag.Type()</strong></p>
<p>基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.Type(flag 名, 默认值, 帮助信息) *Type</span><br></pre></td></tr></tbody></table></figure>
<p>Type 可以是 Int、String、Bool 等，返回值为一个相应类型的指针，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String("name", "张三", "姓名")</span><br><span class="line">age := flag.Int("age", 18, "年龄")</span><br><span class="line">married := flag.Bool("married", false, "婚否")</span><br><span class="line">delay := flag.Duration("d", 0, "时间间隔")</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，此时 name、age、married、delay 均为对应类型的指针。</p>
<p><strong>2) flag.TypeVar()</strong></p>
<p>基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.TypeVar(Type 指针, flag 名, 默认值, 帮助信息)</span><br></pre></td></tr></tbody></table></figure>
<p>TypeVar 可以是 IntVar、StringVar、BoolVar 等，其功能为将 flag 绑定到一个变量上，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">var married bool</span><br><span class="line">var delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, "name", "张三", "姓名")</span><br><span class="line">flag.IntVar(&amp;age, "age", 18, "年龄")</span><br><span class="line">flag.BoolVar(&amp;married, "married", false, "婚否")</span><br><span class="line">flag.DurationVar(&amp;delay, "d", 0, "时间间隔")</span><br></pre></td></tr></tbody></table></figure>
<h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h3><p>通过以上两种方法定义好命令行 flag 参数后，需要通过调用 flag.Parse() 来对命令行参数进行解析。</p>
<p>支持的命令行参数格式有以下几种：</p>
<ul>
<li>-flag：只支持 bool 类型；</li>
<li>-flag=x；</li>
<li>-flag x：只支持非 bool 类型。</li>
</ul>
<p>其中，布尔类型的参数必须使用等号的方式指定。</p>
<p>flag 包的其他函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  //返回命令行参数后的其他参数，以 []string 类型</span><br><span class="line">flag.NArg()  //返回命令行参数后的其他参数个数</span><br><span class="line">flag.NFlag() //返回使用的命令行参数个数</span><br></pre></td></tr></tbody></table></figure>
<p>结合上面的介绍知识，我们来看一个实例，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Input_pstrName = flag.String("name", "gerry", "input ur name")</span><br><span class="line">var Input_piAge = flag.Int("age", 20, "input ur age")</span><br><span class="line">var Input_flagvar int</span><br><span class="line"></span><br><span class="line">func Init() {</span><br><span class="line">    flag.IntVar(&amp;Input_flagvar, "flagname", 1234, "help message for flagname")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    Init()</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    // After parsing, the arguments after the flag are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1</span><br><span class="line">    // Args returns the non-flag command-line arguments</span><br><span class="line">    // NArg is the number of arguments remaining after flags have been processed</span><br><span class="line">    fmt.Printf("args=%s, num=%d\n", flag.Args(), flag.NArg())</span><br><span class="line">    for i := 0; i != flag.NArg(); i++ {</span><br><span class="line">        fmt.Printf("arg[%d]=%s\n", i, flag.Arg(i))</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    fmt.Println("name=", *Input_pstrName)</span><br><span class="line">    fmt.Println("age=", *Input_piAge)</span><br><span class="line">    fmt.Println("flagname=", Input_flagvar)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run flagmain.go -name "dqc13215" -age=30 -flagname=999</span><br><span class="line">args=[], num=0</span><br><span class="line">name= dqc13215</span><br><span class="line">age= 30</span><br><span class="line">flagname= 999</span><br></pre></td></tr></tbody></table></figure>
<h3 id="自定义-Value"><a href="#自定义-Value" class="headerlink" title="自定义 Value"></a>自定义 Value</h3><p>另外，我们还可以创建自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针类型），这时候可以通过如下方式定义该 flag：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag.Var(&amp;flagVal, "name", "help message for flagname")</span><br></pre></td></tr></tbody></table></figure>
<p>【示例】解析喜欢的编程语言，并直接解析到 slice 中，我们可以定义如下 sliceValue 类型，然后实现 Value 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义一个类型，用于增加该类型方法</span><br><span class="line">type sliceValue []string</span><br><span class="line"></span><br><span class="line">//new一个存放命令行参数值的slice</span><br><span class="line">func newSliceValue(vals []string, p *[]string) *sliceValue {</span><br><span class="line">    *p = vals</span><br><span class="line">    return (*sliceValue)(p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Value接口：</span><br><span class="line">type Value interface {</span><br><span class="line">    String() string</span><br><span class="line">    Set(string) error</span><br><span class="line">}</span><br><span class="line">实现flag包中的Value接口，将命令行接收到的值用,分隔存到slice里</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">func (s *sliceValue) Set(val string) error {</span><br><span class="line">    *s = sliceValue(strings.Split(val, ","))</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//flag为slice的默认值default is me,和return返回值没有关系</span><br><span class="line">func (s *sliceValue) String() string {</span><br><span class="line">    *s = sliceValue(strings.Split("default is me", ","))</span><br><span class="line">    return "It's none of my business"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">可执行文件名 -slice="java,go"  最后将输出[java,go]</span><br><span class="line">可执行文件名 最后将输出[default is me]</span><br><span class="line">*/</span><br><span class="line">func main(){</span><br><span class="line">    var languages []string</span><br><span class="line">    flag.Var(newSliceValue([]string{}, &amp;languages), "slice", "I like programming `languages`")</span><br><span class="line">    flag.Parse()</span><br><span class="line">    //打印结果slice接收到的值</span><br><span class="line">    fmt.Println(languages)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>-slice go,php</code> 这样的形式传递参数，languages 得到的就是 <code>[go, php]</code>，如果不加 <code>-slice</code> 参数则打印默认值 <code>[default is me]</code> ，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go -slice go,php,java</span><br><span class="line">[go php java]</span><br></pre></td></tr></tbody></table></figure>
<p>flag 中对 Duration 这种非基本类型的支持，使用的就是类似这样的方式，即同样实现了 Value 接口。</p>
<h2 id="go-mod包依赖管理工具使用详解"><a href="#go-mod包依赖管理工具使用详解" class="headerlink" title="go mod包依赖管理工具使用详解"></a>go mod包依赖管理工具使用详解</h2><p>最早的时候，Go语言所依赖的所有的第三方库都放在 GOPATH 这个目录下面，这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p>
<p>go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。</p>
<p>Modules 官方定义为：</p>
<p><strong>Modules 是相关 Go 包的集合，是源代码交换和版本控制的单元。Go语言命令直接支持使用 Modules，包括记录和解析对其他模块的依赖性，Modules 替换旧的基于 GOPATH 的方法，来指定使用哪些源文件。</strong></p>
<h3 id="如何使用-Modules"><a href="#如何使用-Modules" class="headerlink" title="如何使用 Modules"></a>如何使用 Modules</h3><p>1) 首先需要把 golang 升级到 1.11 版本以上。<br>2) 设置 GO111MODULE。</p>
<h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。</p>
<ul>
<li>GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包；</li>
<li>GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod下载依赖；</li>
<li>GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。</li>
</ul>
<p>Windows 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set GO111MODULE=on 或者 set GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或者 Linux 下开启 GO111MODULE 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on 或者 export GO111MODULE=auto</span><br></pre></td></tr></tbody></table></figure>
<p>在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>常用的go mod命令如下表所示：</p>
<table>
  <thead><tr><th>命令</th><th>作用</th></tr></thead>
  <tbody>    
    <tr><td>go mod download</td><td>下载依赖包到本地（默认为GOPATH/pkg/mod目录）</td></tr>
    <tr><td>go mod edit</td><td>编辑go.mod文件</td></tr>
    <tr><td>go mod graph</td><td>打印模块依赖图</td></tr>
    <tr><td>go mod init</td><td>初始化当前文件夹，创建go.mod文件</td></tr>
    <tr><td>go mod tidy</td><td>增加缺少的包，删除无用的包</td></tr>
    <tr><td>go mod vendor</td><td>将依赖复制到vendor目录下</td></tr>
    <tr><td>go mod verify</td><td>校验依赖</td></tr>
    <tr><td>go mod why</td><td>解释为什么需要依赖</td></tr>
  </tbody>
</table>

<h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过go get命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。</p>
<p>目前公开的代理服务器的地址有：</p>
<ul>
<li>goproxy.io；</li>
<li>goproxy.cn：（推荐）由国内的七牛云提供。</li>
</ul>
<p>Windows 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></tbody></table></figure>
<p>MacOS 或 Linux 下设置 GOPROXY 的命令为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></tbody></table></figure>
<p>Go语言在 1.13 版本之后 GOPROXY 默认值为 <a target="_blank" rel="noopener" href="https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将">https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将</a> GOPROXY 设置为国内的 goproxy.cn。</p>
<p><strong>使用go get命令下载指定版本的依赖包</strong></p>
<ul>
<li>执行 <code>go get</code> 命令，在下载依赖包的同时还可以指定依赖包的版本。</li>
<li>运行 <code>go get -u</code> 命令会将项目中的包升级到最新的次要版本或者修订版本；</li>
<li>运行 <code>go get -u=patch</code> 命令会将项目中的包升级到最新的修订版本；</li>
<li>运行 <code>go get [包名]@[版本号]</code> 命令会下载对应包的指定版本或者将对应包升级到指定的版本。</li>
</ul>
<p><strong>提示：<code>go get [包名]@[版本号]</code> 命令中版本号可以是 x.y.z 的形式，例如 <code>go get foo@v1.2.3</code> ，也可以是 git 上的分支或 tag，例如 <code>go get foo@master</code> ，还可以是 git 提交时的哈希值，例如 <code>go get foo@e3702bed2。</code></strong></p>
<h3 id="如何在项目中使用"><a href="#如何在项目中使用" class="headerlink" title="如何在项目中使用"></a>如何在项目中使用</h3><p>【示例 1】创建一个新项目：</p>
<p>1) 在 GOPATH 目录之外新建一个目录，并使用go mod init初始化生成 go.mod 文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\chebada.com&gt;go mod init chebada.com</span><br><span class="line">go: creating new go.mod: module chebada.com</span><br></pre></td></tr></tbody></table></figure>
<p>go.mod 文件一旦创建后，它的内容将会被 <code>go toolchain</code> 全面掌控，<code>go toolchain</code> 会在各类命令执行时，比如 <code>go get</code> 、<code>go build</code> 、<code>go mod</code> 等修改和维护 <code>go.mod</code> 文件。</p>
<p>go.mod 提供了 module、require、replace 和 exclude 四个命令：</p>
<ul>
<li>module 语句指定包的名字（路径）；</li>
<li>require 语句指定的依赖项模块；</li>
<li>replace 语句可以替换依赖项模块；</li>
<li>exclude 语句可以忽略依赖项模块。</li>
</ul>
<p>初始化生成的 go.mod 文件如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module chebada.com</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></tbody></table></figure>
<p>2)添加依赖。</p>
<p>新建一个 main.go 文件，写入以下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", func(c echo.Context) error {</span><br><span class="line">        return c.String(http.StatusOK, "Hello, World!")</span><br><span class="line">    })</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行 <code>go run main.go</code> 运行代码会发现 <code>go mod</code> 会自动查找依赖自动下载：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">D:\chebada.com\main&gt;go run echomain.go</span><br><span class="line">go: finding module for package github.com/labstack/echo</span><br><span class="line">go: downloading github.com/labstack/echo v1.4.4</span><br><span class="line">go: downloading github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: found github.com/labstack/echo in github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: finding module for package github.com/labstack/gommon/color</span><br><span class="line">go: finding module for package github.com/labstack/gommon/log</span><br><span class="line">go: finding module for package golang.org/x/crypto/acme/autocert</span><br><span class="line">go: downloading github.com/labstack/gommon v0.3.0</span><br><span class="line">go: downloading golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897</span><br><span class="line">go: found github.com/labstack/gommon/color in github.com/labstack/gommon v0.3.0</span><br><span class="line">go: found golang.org/x/crypto/acme/autocert in golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897</span><br><span class="line">go: downloading github.com/valyala/fasttemplate v1.0.1</span><br><span class="line">go: downloading golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3</span><br><span class="line">go: downloading github.com/mattn/go-colorable v0.1.2</span><br><span class="line">go: downloading github.com/mattn/go-isatty v0.0.9</span><br><span class="line">go: downloading github.com/valyala/bytebufferpool v1.0.0</span><br><span class="line">go: downloading golang.org/x/text v0.3.0</span><br><span class="line"></span><br><span class="line">   ____    __</span><br><span class="line">  / __/___/ /  ___</span><br><span class="line"> / _// __/ _ \/ _ \</span><br><span class="line">/___/\__/_//_/\___/ v3.3.10-dev</span><br><span class="line">High performance, minimalist Go web framework</span><br><span class="line">https://echo.labstack.com</span><br><span class="line">____________________________________O/_______</span><br><span class="line">                                    O\</span><br><span class="line">⇨ http server started on [::]:1323</span><br></pre></td></tr></tbody></table></figure>
<p>现在查看 go.mod 内容：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module chebada.com</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">    github.com/labstack/gommon v0.3.0 // indirect</span><br><span class="line">    golang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897 // indirect</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><code>go module</code> 安装 package 的原则是先拉取最新的 <code>release tag</code>，若无 tag 则拉取最新的 commit，详见 <a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/Modules">Modules</a> 官方介绍。</p>
<p>go 会自动生成一个 go.sum 文件来记录 dependency tree：</p>
<p>go 会自动生成一个 go.sum 文件来记录 dependency tree：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.com/labstack/echo v1.4.4 h1:1bEiBNeGSUKxcPDGfZ/7IgdhJJZx8wV/pICJh4W2NJI=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=</span><br><span class="line">github.com/labstack/gommon v0.3.0 h1:JEeO0bvc78PKdyHxloTKiF8BD5iGrH8T6MSeGvSgob0=</span><br><span class="line">github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=</span><br><span class="line">github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行脚本 <code>go run main.go</code> 发现跳过了检查并安装依赖的步骤。</p>
<p>可以使用命令 <code>go list -m -u all</code> 来检查可以升级的 package，使用 <code>go get -u need-upgrade-package</code> 升级后会将新的依赖版本更新到 go.mod , 也可以使用 <code>go get -u</code> 升级所有依赖。</p>
<p>【示例 2】改造现有项目。</p>
<p>项目目录结构为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─ main.go</span><br><span class="line">│</span><br><span class="line">└─ api</span><br><span class="line">      └─ apis.go</span><br></pre></td></tr></tbody></table></figure>
<p>main.go 源码为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    api "./api"  // 这里使用的是相对路径</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", api.HelloWorld)</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>api/apis.go 源码为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package api</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "net/http"</span><br><span class="line"></span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func HelloWorld(c echo.Context) error {</span><br><span class="line">    return c.JSON(http.StatusOK, "hello world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>1)使用 <code>go mod init ***</code> 初始化 go.mod。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init hello</span><br><span class="line">go: creating new go.mod: module hello</span><br></pre></td></tr></tbody></table></figure>
<p>2)运行go run main.go。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">build _/D_/code/src/api: cannot find module for path _/D_/code/src/api</span><br></pre></td></tr></tbody></table></figure>
<p>首先还是会查找并下载安装依赖，然后运行脚本 main.go，这里会抛出一个错误：</p>
<p>build <em>/D</em>/code/src/api: cannot find module for path <em>/D</em>/code/src/api</p>
<p>但是 go.mod 已经更新：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module hello</span><br><span class="line"></span><br><span class="line">go 1.13</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">    github.com/labstack/gommon v0.3.0 // indirect</span><br><span class="line">    golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413 // indirect</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>那为什么会抛出这个错误呢？</p>
<p>这是因为 main.go 中使用 <code>internal package</code> 的方法跟以前已经不同了，由于 <code>go.mod</code> 会扫描同工作目录下所有 package 并且变更引入方法，必须将 hello 当成路径的前缀，也就是需要写成 <code>import hello/api</code>，以往 <code>GOPATH/dep</code> 模式允许的 <code>import ./api</code> 已经失效</p>
<p>3)更新旧的 package import 方式。</p>
<p>所以 main.go 需要改写成：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    api "hello/api" // 这里使用的是相对路径</span><br><span class="line">    "github.com/labstack/echo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    e := echo.New()</span><br><span class="line">    e.GET("/", api.HelloWorld)</span><br><span class="line">    e.Logger.Fatal(e.Start(":1323"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示：在 Go语言 1.11 版本下使用 <code>go mod</code> 时可能会遇到 <code>go build github.com/valyala/fasttemplate: module requires go 1.12</code> 这种错误，遇到类似这种需要升级到 1.12 的问题，直接升级到Go语言1.12 版本以上就好了。</em></strong></p>
<p>4)到这里就和新创建一个项目没什么区别了。</p>
<p>由于某些已知的原因，并不是所有的 package 都能成功下载，比如：<code>golang.org</code> 下的包。</p>
<p>modules 可以通过在 go.mod 文件中使用 replace 指令替换成 github 上对应的库，比如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Go语言生成二维码"><a href="#Go语言生成二维码" class="headerlink" title="Go语言生成二维码"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5713.html">Go语言生成二维码</a></h2><p>二维码作为一种快速的输入手段越来越流行，支付，添加好友，买东西，扫个二维码即可，可以说二维码已经深深地融入了我们的生活中。那么二维码是如何制作生成的呢？我们如何制作自己的二维码呢？</p>
<h3 id="什么是二维码"><a href="#什么是二维码" class="headerlink" title="什么是二维码"></a>什么是二维码</h3><p>二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，但其长度没有记载数据，而二维条码的长度、宽度均记载着数据。</p>
<p>二维条码有一维条码没有的“定位点”和“容错机制”，容错机制在即使没有辨识到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。</p>
<h3 id="使用Go语言生成二维码图片"><a href="#使用Go语言生成二维码图片" class="headerlink" title="使用Go语言生成二维码图片"></a>使用Go语言生成二维码图片</h3><p>使用Go语言编程时，生成任意内容的二维码是非常方便的，因为我们有 <code>go-qrcode</code> 这个库。该库的源代码托管在 github 上，大家可以从 <a target="_blank" rel="noopener" href="https://github.com/skip2/go-qrcode">github</a> 上下载并使用这个库。</p>
<p>go-qrcode 的使用很简单，假如要为我们的官网 <a target="_blank" rel="noopener" href="http://c.biancheng.net/">http://c.biancheng.net/</a> 生成一张 256*256 的图片，可以使用如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/skip2/go-qrcode"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    qrcode.WriteFile("http://c.biancheng.net/",qrcode.Medium,256,"./golang_qrcode.png")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样我们运行代码的时候，就在当前目录下，生成一张 256*256 的二维码，扫描后就可以自动跳转到我们的官网，如下所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/qrcode.gif" alt="图：二维码"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WriteFile(content string, level RecoveryLevel, size int, filename string) error</span><br></pre></td></tr></tbody></table></figure>
<p>WriteFile 函数的原型定义如上，它有几个参数，大概意思如下：</p>
<ul>
<li>content 表示要生成二维码的内容，可以是任意字符串；</li>
<li>level 表示二维码的容错级别，取值有 Low、Medium、High、Highest；</li>
<li>size 表示生成图片的 width 和 height，像素单位；</li>
<li>filename 表示生成的文件名路径；</li>
<li>RecoveryLevel 类型其实是个 int，它的定义和常量如下：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type RecoveryLevel int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    // Level L: 7% error recovery.</span><br><span class="line">    Low RecoveryLevel = iota</span><br><span class="line"></span><br><span class="line">    // Level M: 15% error recovery. Good default choice.</span><br><span class="line">    Medium</span><br><span class="line"></span><br><span class="line">    // Level Q: 25% error recovery.</span><br><span class="line">    High</span><br><span class="line"></span><br><span class="line">    // Level H: 30% error recovery.</span><br><span class="line">    Highest</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>RecoveryLevel 越高，二维码的容错能力越好。</p>
<h3 id="生成二维码图片字节"><a href="#生成二维码图片字节" class="headerlink" title="生成二维码图片字节"></a>生成二维码图片字节</h3><p>有时候我们不想直接生成一个 PNG 文件存储，我们想对 PNG 图片做一些处理，比如缩放了，旋转了，或者网络传输了等，基于此，我们可以使用 Encode 函数，生成一个 PNG 图片的字节流，这样我们就可以进行各种处理了。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Encode(content string, level RecoveryLevel, size int) ([]byte, error)</span><br></pre></td></tr></tbody></table></figure>
<p>用法和 WriteFile 函数差不多，只不过返回的是一个 []byte 字节数组，这样我们就可以对这个字节数组进行处理了。</p>
<h3 id="自定义二维码"><a href="#自定义二维码" class="headerlink" title="自定义二维码"></a>自定义二维码</h3><p>除了以上两种快捷方式，go-qrcode 库还为我们提供了对二维码的自定义方式，比如我们可以自定义二维码的前景色和背景色等。qrcode.New 函数可以返回一个 <em>QRCode，我们可以对 </em>QRCode 设置，实现对二维码的自定义。</p>
<p>比如我们设置背景色为绿色，前景色为白色的二维码</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "github.com/skip2/go-qrcode"</span><br><span class="line">    "image/color"</span><br><span class="line">    "log"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    qr,err:=qrcode.New("http://c.biancheng.net/",qrcode.Medium)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    } else {</span><br><span class="line">        qr.BackgroundColor = color.RGBA{50,205,50,255}</span><br><span class="line">        qr.ForegroundColor = color.White</span><br><span class="line">        qr.WriteFile(256,"./golang_qrcode.png")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>指定 *QRCode 的 BackgroundColor 和 ForegroundColor 即可，然后调用 WriteFile 方法生成这个二维码文件，如下所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/qrcode2.gif" alt="图：二维码"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func New(content string, level RecoveryLevel) (*QRCode, error)</span><br><span class="line">// A QRCode represents a valid encoded QRCode.</span><br><span class="line">type QRCode struct {</span><br><span class="line">    // Original content encoded.</span><br><span class="line">    Content string</span><br><span class="line">    // QR Code type.</span><br><span class="line">    Level         RecoveryLevel</span><br><span class="line">    VersionNumber int</span><br><span class="line">    // User settable drawing options.</span><br><span class="line">    ForegroundColor color.Color</span><br><span class="line">    BackgroundColor color.Color</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上 QRCode 的这些字段都是可以设置的，这样我们就可以灵活自定义二维码了。</p>
<p><strong>小结：二维码是一种流行的输入技术手段，不光 Go 可以生成，其他语言也可以生成，并且生成的二维码是标准的，都可以扫描和识别，比如 Java 可以通过  <code>https://github.com/kenglxn/QRGen</code> 库来生成。</strong></p>
<h2 id="Context上下文"><a href="#Context上下文" class="headerlink" title="Context上下文"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5714.html">Context上下文</a></h2><p>Context 在 Go1.7 之后就加入到了Go语言标准库中，准确说它是 Goroutine 的上下文，包含 Goroutine 的运行状态、环境、现场等信息。</p>
<p>随着 Context 包的引入，标准库中很多接口因此加上了 Context 参数，例如 <code>database/sql</code> 包，Context 几乎成为了并发控制和超时控制的标准做法。</p>
<h3 id="什么是-Context"><a href="#什么是-Context" class="headerlink" title="什么是 Context"></a>什么是 Context</h3><p>Context 也叫作“上下文”，是一个比较抽象的概念，一般理解为程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元则指的是 Goroutine。</p>
<p>每个 Goroutine 在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个 Context 变量中，传递给要执行的 Goroutine 中。</p>
<p>在网络编程下，当接收到一个网络请求 Request，在处理 Request 时，我们可能需要开启不同的 Goroutine 来获取数据与逻辑处理，即一个请求 Request，会在多个 Goroutine 中处理。而这些 Goroutine 可能需要共享 Request 的一些信息，同时当 Request 被取消或者超时的时候，所有从这个 Request 创建的所有 Goroutine 也应该被结束。</p>
<h3 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h3><p>Context 包的核心就是 Context 接口，其定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Context interface {</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line">    Done() &lt;-chan struct{}</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key interface{}) interface{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>Deadline 方法需要返回当前 Context 被取消的时间，也就是完成工作的截止时间（deadline）；</li>
<li>Done 方法需要返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个Channel；</li>
<li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值：<ul>
<li>如果当前 Context 被取消就会返回 Canceled 错误；</li>
<li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li>
</ul>
</li>
<li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法仅用于传递跨 API 和进程间跟请求域的数据。</li>
</ul>
<h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>Go语言内置两个函数：Background() 和 TODO()，这两个函数分别返回一个实现了 Context 接口的 background 和 todo。</p>
<p>Background() 主要用于 main 函数、初始化以及测试代码中，作为 Context 这个树结构的最顶层的 Context，也就是根 Context。</p>
<p>TODO()，它目前还不知道具体的使用场景，在不知道该使用什么 Context 的时候，可以使用这个。</p>
<p>background 和 todo 本质上都是 emptyCtx 结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的 Context。</p>
<h3 id="With-系列函数"><a href="#With-系列函数" class="headerlink" title="With 系列函数"></a>With 系列函数</h3><p>此外，Context 包中还定义了四个 With 系列函数。</p>
<h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h4><p>WithCancel 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithCancel 返回带有新 Done 通道的父节点的副本，当调用返回的 cancel 函数或当关闭父上下文的 Done 通道时，将关闭返回上下文的 Done 通道，无论先发生什么情况。</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    gen := func(ctx context.Context) &lt;-chan int {</span><br><span class="line">        dst := make(chan int)</span><br><span class="line">        n := 1</span><br><span class="line">        go func() {</span><br><span class="line">            for {</span><br><span class="line">                select {</span><br><span class="line">                case &lt;-ctx.Done():</span><br><span class="line">                    return // return结束该goroutine，防止泄露</span><br><span class="line">                case dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }()</span><br><span class="line">        return dst</span><br><span class="line">    }</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    defer cancel() // 当我们取完需要的整数后调用cancel</span><br><span class="line">    for n := range gen(ctx) {</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        if n == 5 {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，gen 函数在单独的 Goroutine 中生成整数并将它们发送到返回的通道，gen 的调用者在使用生成的整数之后需要取消上下文，以免 gen 启动的内部 Goroutine 发生泄漏。</p>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h4><p>WithDeadline 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithDeadline 函数会返回父上下文的副本，并将 deadline 调整为不迟于 d。如果父上下文的 deadline 已经早于 d，则 WithDeadline(parent, d) 在语义上等同于父上下文。当截止日过期时，当调用返回的 cancel 函数时，或者当父上下文的 Done 通道关闭时，返回上下文的 Done 通道将被关闭，以最先发生的情况为准。</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    d := time.Now().Add(50 * time.Millisecond)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span><br><span class="line">    // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    select {</span><br><span class="line">    case &lt;-time.After(1 * time.Second):</span><br><span class="line">        fmt.Println("overslept")</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">context deadline exceeded</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，定义了一个 50 毫秒之后过期的 deadline，然后我们调用 context.WithDeadline(context.Background(), d) 得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个 select 让主程序陷入等待，等待 1 秒后打印 overslept 退出或者等待 ctx 过期后退出。因为 ctx 50 秒后就过期，所以 ctx.Done() 会先接收到值，然后打印 ctx.Err() 取消原因。</p>
<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h4><p>WithTimeout 的函数签名如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br></pre></td></tr></tbody></table></figure>
<p>WithTimeout 函数返回 WithDeadline(parent, time.Now().Add(timeout))。</p>
<p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 传递带有超时的上下文</span><br><span class="line">    // 告诉阻塞函数在超时结束后应该放弃其工作。</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)</span><br><span class="line">    defer cancel()</span><br><span class="line"></span><br><span class="line">    select {</span><br><span class="line">    case &lt;-time.After(1 * time.Second):</span><br><span class="line">        fmt.Println("overslept")</span><br><span class="line">    case &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err()) // 终端输出"context deadline exceeded"</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">context deadline exceeded</span><br></pre></td></tr></tbody></table></figure>
<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h4><p>WithValue 函数能够将请求作用域的数据与 Context 对象建立关系。函数声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func WithValue(parent Context, key, val interface{}) Context</span><br></pre></td></tr></tbody></table></figure>
<p>WithValue 函数接收 context 并返回派生的 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，函数应接收签名中的那些值，使其显式化。</p>
<p>所提供的键必须是可比较的，并且不应该是 string 类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue 的用户应该为键定义自己的类型，为了避免在分配给接口 <code>{ }</code> 时进行分配，上下文键通常具有具体类型 <code>struct{}</code> 。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "context"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type favContextKey string // 定义一个key类型</span><br><span class="line">    // f:一个从上下文中根据key取value的函数</span><br><span class="line">    f := func(ctx context.Context, k favContextKey) {</span><br><span class="line">        if v := ctx.Value(k); v != nil {</span><br><span class="line">            fmt.Println("found value:", v)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("key not found:", k)</span><br><span class="line">    }</span><br><span class="line">    k := favContextKey("language")</span><br><span class="line">    // 创建一个携带key为k，value为"Go"的上下文</span><br><span class="line">    ctx := context.WithValue(context.Background(), k, "Go")</span><br><span class="line">    f(ctx, k)</span><br><span class="line">    f(ctx, favContextKey("color"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">found value: Go</span><br><span class="line">key not found: color</span><br></pre></td></tr></tbody></table></figure>
<p>使用 Context 的注意事项：</p>
<ul>
<li>不要把 Context 放在结构体中，要以参数的方式显示传递；</li>
<li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数；</li>
<li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO；</li>
<li>Context 的 Value 相关方法应该传递请求域的必要数据，不应该用于传递可选参数；</li>
<li>Context 是线程安全的，可以放心的在多个 Goroutine 中传递。</li>
</ul>
<p><strong>总结:</strong></p>
<p>Go语言中的 Context 的主要作用还是在多个 Goroutine 或者模块之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费，虽然传值也是它的功能之一，但是这个功能我们还是很少用到。</p>
<p>在真正使用传值的功能时我们也应该非常谨慎，不能将请求的所有参数都使用 Context 进行传递，这是一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p>
<h2 id="客户信息管理系统"><a href="#客户信息管理系统" class="headerlink" title="客户信息管理系统"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5716.html">客户信息管理系统</a></h2><p>实现一个基于文本界面的客户关系管理软件，该软件可以实现对客户的插入、修改和删除，并且可以打印客户信息明细表。</p>
<p>软件由一下三个模块组成：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/customermanager.gif" alt="客户关系管理软件"></p>
<p>项目结构如下所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/customerarch.gif" alt="项目结构"></p>
<p>在 costumer.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package model</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明一个Customer结构体，表示一个客户信息</span><br><span class="line">type Customer struct {</span><br><span class="line">    Id int</span><br><span class="line">    Name string</span><br><span class="line">    Gender string</span><br><span class="line">    Age int</span><br><span class="line">    Phone string</span><br><span class="line">    Email string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//使用工厂模式，返回一个Customer的实例</span><br><span class="line">func NewCustomer(id int, name string, gender string, age int, phone string, email string ) Customer {</span><br><span class="line">    return Customer{</span><br><span class="line">        Id : id,</span><br><span class="line">        Name : name,</span><br><span class="line">        Gender : gender,</span><br><span class="line">        Age : age,</span><br><span class="line">        Phone : phone,</span><br><span class="line">        Email : email,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//第二种创建Customer实例方法，不带id</span><br><span class="line">func NewCustomer2(name string, gender string,</span><br><span class="line">    age int, phone string, email string ) Customer {</span><br><span class="line">    return Customer{</span><br><span class="line">        Name : name,</span><br><span class="line">        Gender : gender,</span><br><span class="line">        Age : age,</span><br><span class="line">        Phone : phone,</span><br><span class="line">        Email : email,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//返回用户的信息,格式化的字符串</span><br><span class="line">func (this Customer) GetInfo()  string {</span><br><span class="line">    info := fmt.Sprintf("%v\t %v\t %v\t %v\t %v\t %v\t", this.Id,</span><br><span class="line">        this.Name, this.Gender,this.Age, this.Phone, this.Email)</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 costumerService.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package service</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "../model"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//该CustomerService， 完成对Customer的操作,包括</span><br><span class="line">//增删改查</span><br><span class="line">type CustomerService struct {</span><br><span class="line">    customers []model.Customer</span><br><span class="line">    //声明一个字段，表示当前切片含有多少个客户</span><br><span class="line">    //该字段后面，还可以作为新客户的id+1</span><br><span class="line">    customerNum int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//编写一个方法，可以返回 *CustomerService</span><br><span class="line">func NewCustomerService() *CustomerService {</span><br><span class="line">    //为了能够看到有客户在切片中，我们初始化一个客户</span><br><span class="line">    customerService := &amp;CustomerService{}</span><br><span class="line">    customerService.customerNum = 1</span><br><span class="line">    customer := model.NewCustomer(1, "张三", "男", 20, "010-56253825", "zs@sohu.com")</span><br><span class="line">    customerService.customers = append(customerService.customers, customer)</span><br><span class="line">    return customerService</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//返回客户切片</span><br><span class="line">func (this *CustomerService) List() []model.Customer {</span><br><span class="line">    return this.customers</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//添加客户到customers切片</span><br><span class="line">func (this *CustomerService) Add(customer model.Customer) bool {</span><br><span class="line">    //我们确定一个分配id的规则,就是添加的顺序</span><br><span class="line">    this.customerNum++</span><br><span class="line">    customer.Id = this.customerNum</span><br><span class="line">    this.customers = append(this.customers, customer)</span><br><span class="line">    return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//根据id删除客户(从切片中删除)</span><br><span class="line">func (this *CustomerService) Delete(id int) bool {</span><br><span class="line">    index := this.FindById(id)</span><br><span class="line">    //如果index == -1, 说明没有这个客户</span><br><span class="line">    if index == -1 {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    //如何从切片中删除一个元素</span><br><span class="line">    this.customers = append(this.customers[:index], this.customers[index+1:]...)</span><br><span class="line">    return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//根据id查找客户在切片中对应下标,如果没有该客户，返回-1</span><br><span class="line">func (this *CustomerService) FindById(id int)  int {</span><br><span class="line">    index := -1</span><br><span class="line">    //遍历this.customers 切片</span><br><span class="line">    for i := 0; i &lt; len(this.customers); i++ {</span><br><span class="line">        if this.customers[i].Id == id {</span><br><span class="line">            //找到</span><br><span class="line">            index = i</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return index</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 costumerView.go 中，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "../model"</span><br><span class="line">    "../service"</span><br><span class="line">)</span><br><span class="line">type customerView struct {</span><br><span class="line">    //定义必要字段</span><br><span class="line">    key string //接收用户输入...</span><br><span class="line">    loop bool  //表示是否循环的显示主菜单</span><br><span class="line">    //增加一个字段customerService</span><br><span class="line">    customerService *service.CustomerService</span><br><span class="line">}</span><br><span class="line">//显示所有的客户信息</span><br><span class="line">func (this *customerView) list() {</span><br><span class="line">    //首先，获取到当前所有的客户信息(在切片中)</span><br><span class="line">    customers := this.customerService.List()</span><br><span class="line">    //显示</span><br><span class="line">    fmt.Println("---------------------------客户列表---------------------------")</span><br><span class="line">    fmt.Println("编号\t姓名\t性别\t年龄\t电话\t邮箱")</span><br><span class="line">    for i := 0; i &lt; len(customers); i++ {</span><br><span class="line">        //fmt.Println(customers[i].Id,"\t", customers[i].Name...)</span><br><span class="line">        fmt.Println(customers[i].GetInfo())</span><br><span class="line">    }</span><br><span class="line">    fmt.Printf("\n-------------------------客户列表完成-------------------------\n\n")</span><br><span class="line">}</span><br><span class="line">//得到用户的输入，信息构建新的客户，并完成添加</span><br><span class="line">func (this *customerView) add() {</span><br><span class="line">    fmt.Println("---------------------添加客户---------------------")</span><br><span class="line">    fmt.Print("姓名:")</span><br><span class="line">    name := ""</span><br><span class="line">    fmt.Scanln(&amp;name)</span><br><span class="line">    fmt.Print("性别:")</span><br><span class="line">    gender := ""</span><br><span class="line">    fmt.Scanln(&amp;gender)</span><br><span class="line">    fmt.Print("年龄:")</span><br><span class="line">    age := 0</span><br><span class="line">    fmt.Scanln(&amp;age)</span><br><span class="line">    fmt.Print("电话:")</span><br><span class="line">    phone := ""</span><br><span class="line">    fmt.Scanln(&amp;phone)</span><br><span class="line">    fmt.Print("邮箱:")</span><br><span class="line">    email := ""</span><br><span class="line">    fmt.Scanln(&amp;email)</span><br><span class="line">    //构建一个新的Customer实例</span><br><span class="line">    //注意: id号，没有让用户输入，id是唯一的，需要系统分配</span><br><span class="line">    customer := model.NewCustomer2(name, gender, age, phone, email)</span><br><span class="line">    //调用</span><br><span class="line">    if this.customerService.Add(customer) {</span><br><span class="line">        fmt.Println("---------------------添加完成---------------------")</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("---------------------添加失败---------------------")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//得到用户的输入id，删除该id对应的客户</span><br><span class="line">func (this *customerView) delete() {</span><br><span class="line">    fmt.Println("---------------------删除客户---------------------")</span><br><span class="line">    fmt.Print("请选择待删除客户编号(-1退出)：")</span><br><span class="line">    id := -1</span><br><span class="line">    fmt.Scanln(&amp;id)</span><br><span class="line">    if id == -1 {</span><br><span class="line">        return //放弃删除操作</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("确认是否删除(Y/N)：")</span><br><span class="line">    //这里同学们可以加入一个循环判断，直到用户输入 y 或者 n,才退出..</span><br><span class="line">    choice := ""</span><br><span class="line">    fmt.Scanln(&amp;choice)</span><br><span class="line">    if choice == "y" || choice == "Y" {</span><br><span class="line">        //调用customerService 的 Delete方法</span><br><span class="line">        if this.customerService.Delete(id) {</span><br><span class="line">            fmt.Println("---------------------删除完成---------------------")</span><br><span class="line">        } else {</span><br><span class="line">            fmt.Println("---------------------删除失败，输入的id号不存在----")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//退出软件</span><br><span class="line">func (this *customerView) exit() {</span><br><span class="line">    fmt.Print("确认是否退出(Y/N)：")</span><br><span class="line">    for {</span><br><span class="line">        fmt.Scanln(&amp;this.key)</span><br><span class="line">        if this.key == "Y" || this.key == "y" || this.key == "N" || this.key == "n" {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print("你的输入有误，确认是否退出(Y/N)：")</span><br><span class="line">    }</span><br><span class="line">    if this.key == "Y" || this.key == "y" {</span><br><span class="line">        this.loop = false</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//显示主菜单</span><br><span class="line">func (this *customerView) mainMenu() {</span><br><span class="line">    for {</span><br><span class="line">        fmt.Println("-----------------客户信息管理软件-----------------")</span><br><span class="line">        fmt.Println("                 1 添 加 客 户")</span><br><span class="line">        fmt.Println("                 2 修 改 客 户")</span><br><span class="line">        fmt.Println("                 3 删 除 客 户")</span><br><span class="line">        fmt.Println("                 4 客 户 列 表")</span><br><span class="line">        fmt.Println("                 5 退       出")</span><br><span class="line">        fmt.Print("请选择(1-5)：")</span><br><span class="line">        fmt.Scanln(&amp;this.key)</span><br><span class="line">        switch this.key {</span><br><span class="line">            case "1" :</span><br><span class="line">                this.add()</span><br><span class="line">            case "2" :</span><br><span class="line">                fmt.Println("修 改 客 户")</span><br><span class="line">            case "3" :</span><br><span class="line">                this.delete()</span><br><span class="line">            case "4" :</span><br><span class="line">                this.list()</span><br><span class="line">            case "5" :</span><br><span class="line">                this.exit()</span><br><span class="line">            default :</span><br><span class="line">                fmt.Println("你的输入有误，请重新输入...")</span><br><span class="line">        }</span><br><span class="line">        if !this.loop {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("已退出了客户关系管理系统...")</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    //在main函数中，创建一个customerView,并运行显示主菜单..</span><br><span class="line">    customerView := customerView{</span><br><span class="line">        key : "",</span><br><span class="line">        loop : true,</span><br><span class="line">    }</span><br><span class="line">    //这里完成对customerView结构体的customerService字段的初始化</span><br><span class="line">    customerView.customerService = service.NewCustomerService()</span><br><span class="line">    //显示主菜单..</span><br><span class="line">    customerView.mainMenu()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">D:\code\demo\view&gt;go run customerView.go</span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：1</span><br><span class="line">---------------------添加客户---------------------</span><br><span class="line">姓名:李四</span><br><span class="line">性别:男</span><br><span class="line">年龄:22</span><br><span class="line">电话:15611112222</span><br><span class="line">邮箱:lisi@qq.com</span><br><span class="line">---------------------添加完成---------------------</span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：4</span><br><span class="line">---------------------------客户列表---------------------------</span><br><span class="line">编号    姓名    性别    年龄    电话    邮箱</span><br><span class="line">1        张三    男      20      010-56253825    zs@sohu.com</span><br><span class="line">2        李四    男      22      15611112222     lisi@qq.com</span><br><span class="line"></span><br><span class="line">-------------------------客户列表完成-------------------------</span><br><span class="line"></span><br><span class="line">-----------------客户信息管理软件-----------------</span><br><span class="line">                 1 添 加 客 户</span><br><span class="line">                 2 修 改 客 户</span><br><span class="line">                 3 删 除 客 户</span><br><span class="line">                 4 客 户 列 表</span><br><span class="line">                 5 退       出</span><br><span class="line">请选择(1-5)：</span><br></pre></td></tr></tbody></table></figure>
<h2 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h2><p>电子邮件在日常工作中有很大用途，凡项目或任务，有邮件来往可避免扯皮背锅。而在一些自动化的应用场合，也使用得广泛，特别是系统监控方面，如果在资源使用达到警戒线之前自动发邮件通知运维人员，能消除隐患于前期，而不至于临时临急去做善后方案。</p>
<p>对于多人协合（不管是不是异地）场合，邮件也有用武之地，当有代码或文档更新时，自动发邮件通知项目成员或领导，提醒各方人员知晓并及时更新。</p>
<p>说到发邮件，不得不提用程序的方式实现。下面就来为大家介绍一下怎么使用Go语言来实现发送电子邮件。Go语言拥有大量的库，非常方便使用。</p>
<p>Go语言使用 gomail 包来发送邮箱，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "strings"</span><br><span class="line">    "github.com/go-gomail/gomail"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type EmailParam struct {</span><br><span class="line">    // ServerHost 邮箱服务器地址，如腾讯邮箱为smtp.qq.com</span><br><span class="line">    ServerHost string</span><br><span class="line"></span><br><span class="line">    // ServerPort 邮箱服务器端口，如腾讯邮箱为465</span><br><span class="line">    ServerPort int</span><br><span class="line"></span><br><span class="line">    // FromEmail　发件人邮箱地址</span><br><span class="line">    FromEmail string</span><br><span class="line"></span><br><span class="line">    // FromPasswd 发件人邮箱密码（注意，这里是明文形式），TODO：如果设置成密文？</span><br><span class="line">    FromPasswd string</span><br><span class="line"></span><br><span class="line">    // Toers 接收者邮件，如有多个，则以英文逗号(“,”)隔开，不能为空</span><br><span class="line">    Toers string</span><br><span class="line"></span><br><span class="line">    // CCers 抄送者邮件，如有多个，则以英文逗号(“,”)隔开，可以为空</span><br><span class="line">    CCers string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 全局变量，因为发件人账号、密码，需要在发送时才指定</span><br><span class="line">// 注意，由于是小写，外面的包无法使用</span><br><span class="line">var serverHost, fromEmail, fromPasswd string</span><br><span class="line">var serverPort int</span><br><span class="line">var m *gomail.Message</span><br><span class="line"></span><br><span class="line">func InitEmail(ep *EmailParam) {</span><br><span class="line">    toers := []string{}</span><br><span class="line">    serverHost = ep.ServerHost</span><br><span class="line">    serverPort = ep.ServerPort</span><br><span class="line">    fromEmail = ep.FromEmail</span><br><span class="line">    fromPasswd = ep.FromPasswd</span><br><span class="line"></span><br><span class="line">    m = gomail.NewMessage()</span><br><span class="line">    if len(ep.Toers) == 0 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for _, tmp := range strings.Split(ep.Toers, ",") {</span><br><span class="line">        toers = append(toers, strings.TrimSpace(tmp))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 收件人可以有多个，故用此方式</span><br><span class="line">    m.SetHeader("To", toers...)</span><br><span class="line"></span><br><span class="line">    //抄送列表</span><br><span class="line">    if len(ep.CCers) != 0 {</span><br><span class="line">        for _, tmp := range strings.Split(ep.CCers, ",") {</span><br><span class="line">            toers = append(toers, strings.TrimSpace(tmp))</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        m.SetHeader("Cc", toers...)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 发件人</span><br><span class="line">    // 第三个参数为发件人别名，如"李大锤"，可以为空（此时则为邮箱名称）</span><br><span class="line">    m.SetAddressHeader("From", fromEmail, "")  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// SendEmail body支持html格式字符串</span><br><span class="line">func SendEmail(subject, body string) {</span><br><span class="line"></span><br><span class="line">    // 主题</span><br><span class="line">    m.SetHeader("Subject", subject)</span><br><span class="line"></span><br><span class="line">    // 正文</span><br><span class="line">    m.SetBody("text/html", body)</span><br><span class="line">    d := gomail.NewPlainDialer(serverHost, serverPort, fromEmail, fromPasswd)</span><br><span class="line"></span><br><span class="line">    // 发送</span><br><span class="line">    err := d.DialAndSend(m)</span><br><span class="line">    if err != nil {</span><br><span class="line">        panic(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    serverHost := "smtp.qq.com"</span><br><span class="line">    serverPort := 465</span><br><span class="line">    fromEmail := "xxxxxxx@qq.com"</span><br><span class="line"></span><br><span class="line">    //发件人邮箱</span><br><span class="line">    fromPasswd := "xumkkzfscmxxxxxx"</span><br><span class="line"></span><br><span class="line">    //授权码</span><br><span class="line">    myToers := "xxxxxxx@qq.com"</span><br><span class="line"></span><br><span class="line">    // 收件人邮箱，逗号隔开</span><br><span class="line">    myCCers := "" //"readchy@163.com"</span><br><span class="line"></span><br><span class="line">    subject := "这是主题"</span><br><span class="line">    body := `这是正文&lt;br&gt;</span><br><span class="line">    Hello &lt;a href = "http://c.biancheng.net/"&gt;C语言中文网&lt;/a&gt;`</span><br><span class="line"></span><br><span class="line">    // 结构体赋值</span><br><span class="line">    myEmail := &amp;EmailParam {</span><br><span class="line">        ServerHost: serverHost,</span><br><span class="line">        ServerPort: serverPort,</span><br><span class="line">        FromEmail:  fromEmail,</span><br><span class="line">        FromPasswd: fromPasswd,</span><br><span class="line">        Toers:      myToers,</span><br><span class="line">        CCers:      myCCers,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    InitEmail(myEmail)</span><br><span class="line">    SendEmail(subject, body)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用自定义客户端发放邮件需要以下两个要素:</p>
<ul>
<li><p>1) 发送方的邮箱必须开启 stmt 和 pop3 通道，以 qq 邮箱为例，登陆 qq 邮箱 -&gt; 设置 -&gt; 账户 -&gt; 开启 pop3 和 stmt 服务</p>
</li>
<li><p>2) 开启后会获得该账户的授权码，如果忘记也可以重新生成。</p>
</li>
</ul>
<h2 id="Pingo-插件化开发"><a href="#Pingo-插件化开发" class="headerlink" title="Pingo 插件化开发"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5718.html">Pingo 插件化开发</a></h2><p>Pingo 是一个用来为Go语言程序编写插件的简单独立库，因为 Go 本身是静态链接的，因此所有插件都以外部进程方式存在。Pingo 旨在简化标准 RPC 包，支持 TCP 和 Unix 套接字作为通讯协议。当前还不支持远程插件，如果有需要，远程插件很快会提供。</p>
<p>使用 Pingo 创建一个插件非常简单，首先新建目录，如 “plugins/hello-world” ，然后在该目录下编写 main.go：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 创建新的二进制文件</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/dullgiulio/pingo"</span><br><span class="line"></span><br><span class="line">// 创建要导出的对象</span><br><span class="line">type MyPlugin struct{}</span><br><span class="line"></span><br><span class="line">// 导出的方法，带有rpc签名</span><br><span class="line">func (p *MyPlugin) SayHello(name string, msg *string) error {</span><br><span class="line">    *msg = "Hello, " + name</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    plugin := &amp;MyPlugin{}</span><br><span class="line"></span><br><span class="line">    // 注册要导出的对象</span><br><span class="line">    pingo.Register(plugin)</span><br><span class="line">    // 运行主程序</span><br><span class="line">    pingo.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go build</code> 命令编译并生成可执行文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd plugins/hello-world</span><br><span class="line">go build</span><br></pre></td></tr></tbody></table></figure>
<p>接下来就可以调用该插件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "github.com/dullgiulio/pingo"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 从创建的可执行文件中创建一个新插件。通过 TCP 连接到它</span><br><span class="line">    p := pingo.NewPlugin("tcp", "plugins/hello-world/hello-world")</span><br><span class="line"></span><br><span class="line">    // 启动插件</span><br><span class="line">    p.Start()</span><br><span class="line"></span><br><span class="line">    // 使用完插件后停止它</span><br><span class="line">    defer p.Stop()</span><br><span class="line"></span><br><span class="line">    var resp string</span><br><span class="line"></span><br><span class="line">    // 从先前创建的对象调用函数</span><br><span class="line">    if err := p.Call("MyPlugin.SayHello", "Go developer", &amp;resp); err != nil {</span><br><span class="line">        log.Print(err)</span><br><span class="line">    } else {</span><br><span class="line">        log.Print(resp)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\chebada.com\main&gt;go run pingomain.go</span><br><span class="line">2020/10/24 14:22:57 Hello, Go dqc13215~!</span><br></pre></td></tr></tbody></table></figure>
<h2 id="定时器实现原理及作用"><a href="#定时器实现原理及作用" class="headerlink" title="定时器实现原理及作用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5723.html">定时器实现原理及作用</a></h2><p>对于任何一个正在运行的应用，如何获取准确的绝对时间都非常重要，但是在一个分布式系统中我们很难保证各个节点上绝对时间的一致性，哪怕通过 NTP 这种标准的对时协议也只能把时间的误差控制在毫秒级，所以相对时间在一个分布式系统中显得更为重要，在接下来的讲解中我们将会介绍一下Go语言中的定时器以及它在并发编程中起到什么样的作用。</p>
<p>绝对时间一定不会是完全准确的，它对于一个运行中的分布式系统其实没有太多指导意义，但是由于相对时间的计算不依赖于外部的系统，所以它的计算可以做的比较准确，首先介绍一下Go语言中用于计算相对时间的定时器的实现原理。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>timer 就是Go语言定时器的内部表示，每一个 timer 其实都存储在堆中，tb 就是用于存储当前定时器的桶，而 i 是当前定时器在堆中的索引，我们可以通过这两个变量找到当前定时器在堆中的位置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type timer struct {</span><br><span class="line">    tb *timersBucket</span><br><span class="line">    i  int</span><br><span class="line"></span><br><span class="line">    when   int64</span><br><span class="line">    period int64</span><br><span class="line">    f      func(interface{}, uintptr)</span><br><span class="line">    arg    interface{}</span><br><span class="line">    seq    uintptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>when 表示当前定时器（Timer）被唤醒的时间，而 period 表示两次被唤醒的间隔，每当定时器被唤醒时都会调用 f(args, now) 函数并传入 args 和当前时间作为参数。</p>
<p>然而这里的 timer 作为一个私有结构体其实只是定时器的运行时表示，time 包对外暴露的定时器使用了如下所示的结构体：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Timer struct {</span><br><span class="line">    C &lt;-chan Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Timer 定时器必须通过 NewTimer 或者 AfterFunc 函数进行创建，其中的 runtimeTimer 其实就是上面介绍的 timer 结构体，当定时器失效时，失效的时间就会被发送给当前定时器持有的 Channel C，订阅管道中消息的 Goroutine 就会收到当前定时器失效的时间。</p>
<p>在 time 包中，除了 timer 和 Timer 两个分别用于表示运行时定时器和对外暴露的 API 之外，timersBucket 这个用于存储定时器的结构体也非常重要，它会存储一个处理器上的全部定时器，不过如果当前机器的核数超过了 64 核，也就是机器上的处理器 P 的个数超过了 64 个，多个处理器上的定时器就可能存储在同一个桶中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type timersBucket struct {</span><br><span class="line">    lock         mutex</span><br><span class="line">    gp           *g</span><br><span class="line">    created      bool</span><br><span class="line">    sleeping     bool</span><br><span class="line">    rescheduling bool</span><br><span class="line">    sleepUntil   int64</span><br><span class="line">    waitnote     note</span><br><span class="line">    t            []*timer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每一个 timersBucket 中的 t 就是用于存储定时器指针的切片，每一个运行的Go语言程序都会在内存中存储着 64 个桶，这些桶中都存储定时器的信息：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timersBucket.gif" alt="GOLANG TIMER BUCKET"></p>
<p>每一个桶持有的 timer 切片其实都是一个最小堆，这个最小堆会按照 timer 应该触发的时间对它们进行排序，最小堆最上面的定时器就是最近需要被唤醒的 timer，下面来介绍下定时器的创建和触发过程。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>既然我们已经介绍了定时器的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>，接下来我们就可以开始分析它的常见操作以及工作原理了，在这一节中我们将介绍定时器的创建、触发、time.Sleep 与定时器的关系以及计时器 Ticker 的实现原理。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>time 包对外提供了两种创建定时器的方法，第一种方法就是 NewTimer 接口，这个接口会创建一个用于通知触发时间的 Channel、调用 startTimer 方法并返回一个创建指向 Timer 结构体的指针：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func NewTimer(d Duration) *Timer {</span><br><span class="line">    c := make(chan Time, 1)</span><br><span class="line">    t := &amp;Timer{</span><br><span class="line">        C: c,</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when: when(d),</span><br><span class="line">            f:    sendTime,</span><br><span class="line">            arg:  c,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另一个用于创建 Timer 的方法 AfterFunc 其实也提供了非常相似的结构，与 NewTimer 方法不同的是该方法没有创建一个用于通知触发时间的 Channel，它只会在定时器到期时调用传入的方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func AfterFunc(d Duration, f func()) *Timer {</span><br><span class="line">    t := &amp;Timer{</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when: when(d),</span><br><span class="line">            f:    goFunc,</span><br><span class="line">            arg:  f,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>startTimer 基本上就是创建定时器的入口了，所有定时器的创建和重启基本上都需要调用该函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func startTimer(t *timer) {</span><br><span class="line">    addtimer(t)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func addtimer(t *timer) {</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    tb.addtimerLocked(t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>它会调用 addtimer 函数，这个函数总共做了两件事情，首先通过 assignBucket 方法为当前定时器选择一个 timersBucket 桶，我们会根据当前 Goroutine 所在处理器 P 的 id 选择一个合适的桶，随后调用 addtimerLocked 方法将当前定时器加入桶中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (tb *timersBucket) addtimerLocked(t *timer) bool {</span><br><span class="line">    t.i = len(tb.t)</span><br><span class="line">    tb.t = append(tb.t, t)</span><br><span class="line">    if !siftupTimer(tb.t, t.i) {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    if t.i == 0 {</span><br><span class="line">        if tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when {</span><br><span class="line">            tb.sleeping = false</span><br><span class="line">            notewakeup(&amp;tb.waitnote)</span><br><span class="line">        }</span><br><span class="line">        if tb.rescheduling {</span><br><span class="line">            tb.rescheduling = false</span><br><span class="line">            goready(tb.gp, 0)</span><br><span class="line">        }</span><br><span class="line">        if !tb.created {</span><br><span class="line">            tb.created = true</span><br><span class="line">            go timerproc(tb)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addtimerLocked 会先将最新加入的定时器加到队列的末尾，随后调用 siftupTimer 将当前定时器与四叉树（或者四叉堆）中的父节点进行比较，保证父节点的到期时间一定小于子节点：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerQuadtree.gif" alt="timerQuadtree"></p>
<p>这个四叉树只能保证父节点的到期时间小于子节点，这对于我们来说其实也足够了，因为我们只关心即将被触发的计数器，如果当前定时器是第一个被加入四叉树的定时器，我们还会通过 go timerproc(tb) 启动一个 Goroutine 用于处理当前树中的定时器，这也是处理定时器的核心方法。</p>
<h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>定时器的触发都是由 timerproc 中的一个双层 for 循环控制的，外层的 for 循环主要负责对当前 Goroutine 进行控制，它不仅会负责锁的获取和释放，还会在合适的时机触发当前 Goroutine 的休眠：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func timerproc(tb *timersBucket) {</span><br><span class="line">    tb.gp = getg()</span><br><span class="line">    for {</span><br><span class="line">        tb.sleeping = false</span><br><span class="line">        now := nanotime()</span><br><span class="line">        delta := int64(-1)</span><br><span class="line">        // inner loop</span><br><span class="line">        if delta &lt; 0 {</span><br><span class="line">            tb.rescheduling = true</span><br><span class="line">            goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, 1)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        tb.sleeping = true</span><br><span class="line">        tb.sleepUntil = now + delta</span><br><span class="line">        noteclear(&amp;tb.waitnote)</span><br><span class="line">        notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果距离下一个定时器被唤醒的时间小于 0，当前的 timerproc 就会将 rescheduling 标记设置成 true 并立刻陷入休眠，这其实也意味着当前 timerproc 中不包含任何待处理的定时器，当我们再向该 timerBucket 加入定时器时就会重新唤醒 timerproc Goroutine。</p>
<p>在其他情况下，也就是下一次计数器的响应时间是 now + delta 时，timerproc 中的外层循环会通过 notesleepg 将当前 Goroutine 陷入休眠。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func notetsleepg(n *note, ns int64) bool {</span><br><span class="line">    gp := getg()</span><br><span class="line">    if gp == gp.m.g0 {</span><br><span class="line">        throw("notetsleepg on g0")</span><br><span class="line">    }</span><br><span class="line">    semacreate(gp.m)</span><br><span class="line">    entersyscallblock()</span><br><span class="line">    ok := notetsleep_internal(n, ns, nil, 0)</span><br><span class="line">    exitsyscall()</span><br><span class="line">    return ok</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该函数会先获取当前的 Goroutine 并在当前的 CPU 上创建一个信号量，随后在 entersyscallblock 和 exitsyscall 之间执行系统调用让当前的 Goroutine 陷入休眠并在 ns 纳秒后返回。</p>
<p>内部循环的主要作用就是触发已经到期的定时器，在这个内部循环中，我们会按照以下的流程对当前桶中的定时器进行处理：</p>
<ul>
<li>如果桶中不包含任何定时器就会直接返回并陷入休眠等待定时器加入当前桶；</li>
<li>如果四叉树最上面的定时器还没有到期会通过 notetsleepg 方法陷入休眠等待最近定时器的到期；</li>
<li>如果四叉树最上面的定时器已经到期；</li>
<li>当定时器的 period &gt; 0 就会设置下一次会触发定时器的时间并将当前定时器向下移动到对应的位置；</li>
<li>当定时器的 period &lt;= 0 就会将当前定时器从四叉树中移除；</li>
<li>在每次循环的最后都会从定时器中取出定时器中的函数、参数和序列号并调用函数触发该计数器；</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">for {</span><br><span class="line">    if len(tb.t) == 0 {</span><br><span class="line">        delta = -1</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">    t := tb.t[0]</span><br><span class="line">    delta = t.when - now</span><br><span class="line">    if delta &gt; 0 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">    ok := true</span><br><span class="line">    if t.period &gt; 0 {</span><br><span class="line">        t.when += t.period * (1 + -delta/t.period)</span><br><span class="line">        if !siftdownTimer(tb.t, 0) {</span><br><span class="line">            ok = false</span><br><span class="line">        }</span><br><span class="line">    } else {</span><br><span class="line">        last := len(tb.t) - 1</span><br><span class="line">        if last &gt; 0 {</span><br><span class="line">            tb.t[0] = tb.t[last]</span><br><span class="line">            tb.t[0].i = 0</span><br><span class="line">        }</span><br><span class="line">        tb.t[last] = nil</span><br><span class="line">        tb.t = tb.t[:last]</span><br><span class="line">        if last &gt; 0 {</span><br><span class="line">            if !siftdownTimer(tb.t, 0) {</span><br><span class="line">                ok = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        t.i = -1 // mark as removed</span><br><span class="line">    }</span><br><span class="line">    f := t.f</span><br><span class="line">    arg := t.arg</span><br><span class="line">    seq := t.seq</span><br><span class="line">    f(arg, seq)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 NewTimer 创建的定时器，传入的函数时 sendTime，它会将当前时间发送到定时器持有的 Channel 中，而使用 AfterFunc 创建的定时器，在内层循环中调用的函数就会是调用方传入的函数了。</p>
<h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><p>如果你使用过一段时间的Go语言，一定在项目中使用过 time 包中的 Sleep 方法让当前的 Goroutine 陷入休眠以等待某些条件的完成或者触发一些定时任务，time.Sleep 就是通过如下所示的 timeSleep 方法完成的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func timeSleep(ns int64) {</span><br><span class="line">    if ns &lt;= 0 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    gp := getg()</span><br><span class="line">    t := gp.timer</span><br><span class="line">    if t == nil {</span><br><span class="line">        t = new(timer)</span><br><span class="line">        gp.timer = t</span><br><span class="line">    }</span><br><span class="line">    *t = timer{}</span><br><span class="line">    t.when = nanotime() + ns</span><br><span class="line">    t.f = goroutineReady</span><br><span class="line">    t.arg = gp</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    if !tb.addtimerLocked(t) {</span><br><span class="line">        unlock(&amp;tb.lock)</span><br><span class="line">        badTimer()</span><br><span class="line">    }</span><br><span class="line">    goparkunlock(&amp;tb.lock, waitReasonSleep, traceEvGoSleep, 2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>timeSleep 会创建一个新的 timer 结构体，在初始化的过程中我们会传入当前 Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数 goroutineReady，随后会调用 goparkunlock 将当前 Goroutine 陷入休眠状态，当定时器到期时也会调用 goroutineReady 方法唤醒当前的 Goroutine：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func goroutineReady(arg interface{}, seq uintptr) {</span><br><span class="line">    goready(arg.(*g), 0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>time.Sleep 方法其实只是创建了一个会在到期时唤醒当前 Goroutine 的定时器并通过 goparkunlock 将当前的协程陷入休眠状态等待定时器触发的唤醒。</p>
<h4 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h4><p>除了只用于一次的定时器（Timer）之外，Go语言的 time 包中还提供了用于多次通知的 Ticker 计时器，计时器中包含了一个用于接受通知的 Channel 和一个定时器，这两个字段共同组成了用于连续多次触发事件的计时器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Ticker struct {</span><br><span class="line">    C &lt;-chan Time // The channel on which the ticks are delivered.</span><br><span class="line">    r runtimeTimer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>想要在Go语言中创建一个计时器只有两种方法，一种是使用 NewTicker 方法显示地创建 Ticker 计时器指针，另一种可以直接通过 Tick 方法获取一个会定期发送消息的 Channel：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func NewTicker(d Duration) *Ticker {</span><br><span class="line">    if d &lt;= 0 {</span><br><span class="line">        panic(errors.New("non-positive interval for NewTicker"))</span><br><span class="line">    }</span><br><span class="line">    c := make(chan Time, 1)</span><br><span class="line">    t := &amp;Ticker{</span><br><span class="line">        C: c,</span><br><span class="line">        r: runtimeTimer{</span><br><span class="line">            when:   when(d),</span><br><span class="line">            period: int64(d),</span><br><span class="line">            f:      sendTime,</span><br><span class="line">            arg:    c,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">    startTimer(&amp;t.r)</span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Tick(d Duration) &lt;-chan Time {</span><br><span class="line">    if d &lt;= 0 {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return NewTicker(d).C</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Tick 其实也只是对 NewTicker 的简单封装，从实现上我们就能看出来它其实就是调用了 NewTicker 获取了计时器并返回了计时器中 Channel，两个创建计时器的方法的实现都并不复杂而且费容易理解，所以在这里也就不详细展开介绍了。</p>
<p>需要注意的是每一个 NewTicker 方法开启的计时器都需要在不需要使用时调用 Stop 进行关闭，如果不显示调用 Stop 方法，创建的计时器就没有办法被垃圾回收，而通过 Tick 创建的计时器由于只对外提供了 Channel，所以是一定没有办法关闭的，我们一定要谨慎使用这一接口创建计时器。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>定时器在内部使用四叉树的方式进行实现和存储，当我们在生产环境中使用定时器进行毫秒级别的计时时，在高并发的场景下会有比较明显的性能问题，我们可以通过实验测试一下定时器在高并发时的性能，假设我们有以下的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func runTimers(count int) {</span><br><span class="line">    durationCh := make(chan time.Duration, count)</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup{}</span><br><span class="line">    wg.Add(count)</span><br><span class="line">    for i := 0; i &lt; count; i++ {</span><br><span class="line">        go func() {</span><br><span class="line">            startedAt := time.Now()</span><br><span class="line">            time.AfterFunc(10*time.Millisecond, func() {</span><br><span class="line">                defer wg.Done()</span><br><span class="line">                durationCh &lt;- time.Since(startedAt)</span><br><span class="line">            })</span><br><span class="line">        }()</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    close(durationCh)</span><br><span class="line"></span><br><span class="line">    durations := []time.Duration{}</span><br><span class="line">    totalDuration := 0 * time.Millisecond</span><br><span class="line">    for duration := range durationCh {</span><br><span class="line">        durations = append(durations, duration)</span><br><span class="line">        totalDuration += duration</span><br><span class="line">    }</span><br><span class="line">    averageDuration := totalDuration / time.Duration(count)</span><br><span class="line">    sort.Slice(durations, func(i, j int) bool {</span><br><span class="line">        return durations[i] &lt; durations[j]</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Printf("run %v timers with average=%v, pct50=%v, pct99=%v\n", count, averageDuration, durations[count/2], durations[int(float64(count)*0.99)])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：由于机器和性能的不同，多次运行测试可能会有不一样的结果。</strong></p>
<p>这段代码开了 N 个 Goroutine 并在每一个 Goroutine 中运行一个定时器，我们会在定时器到期时将开始计时到定时器到期所用的时间加入 Channel 并用于之后的统计，在函数的最后我们会计算出 N 个 Goroutine 中定时器到期时间的平均数、50 分位数和 99 分位数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go test ./... -v</span><br><span class="line">=== RUN   TestTimers</span><br><span class="line">run 1000 timers with average=10.367111ms, pct50=10.234219ms, pct99=10.913219ms</span><br><span class="line">run 2000 timers with average=10.431598ms, pct50=10.37367ms, pct99=11.025823ms</span><br><span class="line">run 5000 timers with average=11.873773ms, pct50=11.986249ms, pct99=12.673725ms</span><br><span class="line">run 10000 timers with average=11.954716ms, pct50=12.313613ms, pct99=13.507858ms</span><br><span class="line">run 20000 timers with average=11.456237ms, pct50=10.625529ms, pct99=25.246254ms</span><br><span class="line">run 50000 timers with average=21.223818ms, pct50=14.792982ms, pct99=34.250143ms</span><br><span class="line">run 100000 timers with average=36.010924ms, pct50=31.794761ms, pct99=128.089527ms</span><br><span class="line">run 500000 timers with average=176.676498ms, pct50=138.238588ms, pct99=676.967558ms</span><br><span class="line">--- PASS: TestTimers (1.21s)</span><br></pre></td></tr></tbody></table></figure>
<p>我们将上述代码输出的结果绘制成如下图所示的折线图，其中横轴是并行定时器的个数，纵轴表示定时器从开始到触发时间的差值，三个不同的线分别表示时间的平均值、50 分位数和 99 分位数：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerbranch.gif" alt="timerbranch"></p>
<p>虽然测试的数据可能有一些误差，但是从图中我们也能得出一些跟定时器性能和现象有关的结论：</p>
<ul>
<li>定时器触发的时间一定会晚于创建时传入的时间，假设定时器需要等待 10ms 触发，那它触发的时间一定是晚于 10ms 的；</li>
<li>当并发的定时器数量达到 5000 时，定时器的平均误差达到了 ~18%，99 分位数上的误差达到了 ~26%；</li>
<li>并发定时器的数量超过 5000 之后，定时器的误差就变得非常明显，不能有效、准确地完成计时任务；</li>
</ul>
<p>这其实也是因为定时器从开始到触发的时间间隔非常短，当我们将计时的时间改到 100ms 时就会发现性能问题有比较明显的改善：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/timerbranch2.gif" alt="timerbranch2"></p>
<p>哪怕并行运行了 10w 个定时器，99 分位数的误差也只有 ~12%，我们其实能够发现Go语言标准库中的定时器在计时时间较短并且并发较高时有着非常明显的问题，所以在一些性能非常敏感的基础服务中使用定时器一定要非常注意，它可能达不到我们预期的效果。</p>
<p>不过哪怕我们不主动使用定时器，而是使用 context.WithDeadline 这种方法，由于它底层也会使用定时器实现，所以仍然会受到影响。</p>
<h3 id="定时器总结"><a href="#定时器总结" class="headerlink" title="定时器总结"></a>定时器总结</h3><p>Go语言的定时器在并发编程起到了非常重要的作用，它能够为我们提供比较准确的相对时间，基于它的功能，标准库中还提供了计时器、休眠等接口能够帮助我们在Go语言程序中更好地处理过期和超时等问题。</p>
<p>标准库中的定时器在大多数情况下是能够正常工作并且高效完成任务的，但是在遇到极端情况或者性能敏感场景时，它可能没有办法胜任，而在 10ms 的这个粒度下，目前也没有找到能够使用的定时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/bd026676/">https://wssjdi.github.io/posts/bd026676/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E5%8C%85/">包</a><a class="post-meta__tags" href="/tags/package/">package</a><a class="post-meta__tags" href="/tags/gopath/">gopath</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/eae873a8/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go 并发，Golang并发</div></div></a></div><div class="next-post pull-right"><a href="/posts/d3175357/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go接口</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/2910ec3f/" title="go test单元测试及基准测试"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go test单元测试及基准测试</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>