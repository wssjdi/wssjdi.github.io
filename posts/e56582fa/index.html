<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go结构体 | Wssjdi</title><meta name="description" content="go"><meta name="keywords" content="go,结构体,struct"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/e56582fa/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go结构体"><meta property="og:url" content="https://wssjdi.github.io/posts/e56582fa/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-21T06:20:55.000Z"><meta property="article:modified_time" content="2020-10-21T15:45:58.669Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-21 23:45:58'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%EF%BC%88class%EF%BC%89"><span class="toc-text">关于 Go 语言的类（class）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-text">结构体定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">实例化结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-text">基本的实例化形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">创建指针类型的结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%92%8C-C-C"><span class="toc-text">Go语言和 C&#x2F;C++</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">取结构体的地址实例化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">初始化结构体的成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9C%E9%94%AE%E5%80%BC%E5%AF%B9%E2%80%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">使用“键值对”初始化结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">使用多个值的列表初始化结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">初始化匿名结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">多种方式创建和初始化结构体——模拟构造函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%88%B6%E7%BA%A7%E6%9E%84%E9%80%A0%E8%B0%83%E7%94%A8"><span class="toc-text">带有父子关系的结构体的构造和初始化——模拟父级构造调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="toc-text">方法和接收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-text">为结构体添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%99%A8%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%E4%BD%9C%E7%94%A8%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">接收器——方法作用的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%9F%A2%E9%87%8F%E6%A8%A1%E6%8B%9F%E7%8E%A9%E5%AE%B6%E7%A7%BB%E5%8A%A8"><span class="toc-text">示例：二维矢量模拟玩家移动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-text">为任意类型添加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-text">为基本类型添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E5%8C%85%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">http包中的类型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-%E5%8C%85%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">time 包中的类型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-text">使用事件系统实现事件的响应和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%9F%E4%B8%80%E8%B0%83%E7%94%A8"><span class="toc-text">方法和函数的统一调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">事件系统基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-text">事件注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8"><span class="toc-text">事件调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">使用事件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%86%85%E5%B5%8C%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%B5%8C"><span class="toc-text">类型内嵌和结构体内嵌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">内嵌结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%86%85%E5%B5%8C%E7%89%B9%E6%80%A7"><span class="toc-text">结构内嵌特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%B5%8C%E6%A8%A1%E6%8B%9F%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">结构体内嵌模拟类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">初始化内嵌结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%B5%8C%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">初始化内嵌匿名结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%B5%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E5%90%8D%E5%AD%97%E5%86%B2%E7%AA%81"><span class="toc-text">内嵌结构体成员名字冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%E8%A7%A3%E6%9E%90JSON%E6%95%B0%E6%8D%AE"><span class="toc-text">使用匿名结构体解析JSON数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">定义数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87JSON%E6%95%B0%E6%8D%AE"><span class="toc-text">准备JSON数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BBJSON%E6%95%B0%E6%8D%AE"><span class="toc-text">分离JSON数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8CSetFinalizer"><span class="toc-text">垃圾回收和SetFinalizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%B8%BAJSON%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-text">将结构体数据保存为JSON格式数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">数据结构及入口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-text">序列化主函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%80%BC%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">任意值序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">切片序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">结构体序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E6%80%BB%E7%BB%93"><span class="toc-text">JSON总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">链表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Struct-%E5%AE%9A%E4%B9%89%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">使用 Struct 定义单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9"><span class="toc-text">插入结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AEI-O%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">数据I&#x2F;O对象及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriter-%E5%AF%B9%E8%B1%A1"><span class="toc-text">ReadWriter 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Reader 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Reader-%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建 Reader 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-Reader-%E5%AF%B9%E8%B1%A1"><span class="toc-text">操作 Reader 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Writer-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Writer 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Writer-%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建 Writer 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-Writer-%E5%AF%B9%E8%B1%A1"><span class="toc-text">操作 Writer 对象</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go结构体</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-21T06:20:55.000Z" title="发表于 2020-10-21 14:20:55">2020-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-21T15:45:58.669Z" title="更新于 2020-10-21 23:45:58">2020-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。</p>
<p>Go 语言中的类型可以被实例化，使用 <code>new</code> 或 <code>&amp;</code> 构造的类型实例的类型是类型的指针。</p>
<p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值。</li>
<li>字段名必须唯一。</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<h2 id="关于-Go-语言的类（class）"><a href="#关于-Go-语言的类（class）" class="headerlink" title="关于 Go 语言的类（class）"></a>关于 Go 语言的类（class）</h2><p>Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。</p>
<p>Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。</p>
<h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。</p>
<p>结构体成员也可以称为“字段”，这些字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值；</li>
<li>字段名必须唯一；</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<p>使用关键字 type 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。</p>
<p>结构体的定义格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct {</span><br><span class="line">    字段1 字段1类型</span><br><span class="line">    字段2 字段2类型</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>struct{}：表示结构体类型，<code>type 类型名 struct{}</code> 可以理解为将 struct{} 结构体定义为类型名的类型。</li>
<li>字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。</li>
<li>字段1类型、字段2类型……：表示结构体各个字段的类型。</li>
</ul>
<p>使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Color struct {</span><br><span class="line">    R, G, B byte</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实例化结构体"><a href="#实例化结构体" class="headerlink" title="实例化结构体"></a>实例化结构体</h2><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。</p>
<p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。</p>
<p>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p>
<h3 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a>基本的实例化形式</h3><p>结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。</p>
<p>基本实例化格式如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ins T</span><br></pre></td></tr></tbody></table></figure>
<p>其中，T 为结构体类型，ins 为结构体的实例。</p>
<p>用结构体表示的点结构（Point）的实例化过程请参见下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var p Point</span><br><span class="line">p.X = 10</span><br><span class="line">p.Y = 20</span><br></pre></td></tr></tbody></table></figure>
<p>在例子中，使用 <code>.</code> 来访问结构体的成员变量，如 <code>p.X</code> 和 <code>p.Y</code> 等，结构体成员变量的赋值方法与普通变量一致。</p>
<h3 id="创建指针类型的结构体"><a href="#创建指针类型的结构体" class="headerlink" title="创建指针类型的结构体"></a>创建指针类型的结构体</h3><p>Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</p>
<p>使用 new 的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := new(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>T 为类型，可以是结构体、整型、字符串等。</li>
<li>ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。</li>
</ul>
<p>Go语言让我们可以像访问普通结构体一样使用 <code>.</code> 来访问结构体指针的成员。</p>
<p>下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Player struct{</span><br><span class="line">    Name string</span><br><span class="line">    HealthPoint int</span><br><span class="line">    MagicPoint int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tank := new(Player)</span><br><span class="line">tank.Name = "Canon"</span><br><span class="line">tank.HealthPoint = 300</span><br></pre></td></tr></tbody></table></figure>
<p>经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p>
<h4 id="Go语言和-C-C"><a href="#Go语言和-C-C" class="headerlink" title="Go语言和 C/C++"></a>Go语言和 C/C++</h4><p>在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用 <code>-&gt;</code> 操作符。</p>
<p>在Go语言中，访问结构体指针的成员变量时可以继续使用 <code>.</code> ，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖 <code>（Syntactic sugar）</code> 技术，将 <code>ins.Name</code> 形式转换为 <code>(*ins).Name</code> 。</p>
<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行 <code>&amp;</code> 取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T{}</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>T 表示结构体类型。</li>
<li>ins 为结构体的实例，类型为 <code>*T</code> ，是指针类型。</li>
</ul>
<p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ype Command struct {</span><br><span class="line">    Name    string    // 指令名称</span><br><span class="line">    Var     *int      // 指令绑定的变量</span><br><span class="line">    Comment string    // 指令的注释</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var version int = 1</span><br><span class="line"></span><br><span class="line">cmd := &amp;Command{}</span><br><span class="line">cmd.Name = "version"</span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = "show version"</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，定义 Command 结构体，表示命令行指令</li>
<li>第 3 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步。</li>
<li>第 7 行，命令绑定的目标整型变量：版本号。</li>
<li>第 9 行，对结构体取地址实例化。</li>
<li>第 10～12 行，初始化成员字段。</li>
</ul>
<p>取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func newCommand(name string, varref *int, comment string) *Command {</span><br><span class="line">    return &amp;Command{</span><br><span class="line">        Name:    name,</span><br><span class="line">        Var:     varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cmd = newCommand(</span><br><span class="line">    "version",</span><br><span class="line">    &amp;version,</span><br><span class="line">    "show version",</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="初始化结构体的成员变量"><a href="#初始化结构体的成员变量" class="headerlink" title="初始化结构体的成员变量"></a>初始化结构体的成员变量</h2><p>结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。</p>
<h3 id="使用“键值对”初始化结构体"><a href="#使用“键值对”初始化结构体" class="headerlink" title="使用“键值对”初始化结构体"></a>使用“键值对”初始化结构体</h3><p>结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。</p>
<p>键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。</p>
<p>结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。</p>
<p>1)键值对初始化结构体的书写格式</p>
<p>键值对初始化的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1: 字段1的值,</span><br><span class="line">    字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>结构体类型：定义结构体时的类型名称。</li>
<li>字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。</li>
<li>字段1的值、字段2的值：结构体成员字段的初始值。</li>
</ul>
<p>键值之间以 <code>:</code> 分隔，键值对之间以 <code>,</code> 分隔。</p>
<p>2)使用键值对填充结构体的例子</p>
<p>下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type People struct {</span><br><span class="line">    name  string</span><br><span class="line">    child *People</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">relation := &amp;People{</span><br><span class="line">    name: "爷爷",</span><br><span class="line">    child: &amp;People{</span><br><span class="line">        name: "爸爸",</span><br><span class="line">        child: &amp;People{</span><br><span class="line">                name: "我",</span><br><span class="line">        },</span><br><span class="line">    },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，定义 People 结构体。</li>
<li>第 2 行，结构体的字符串字段。</li>
<li>第 3 行，结构体的结构体指针字段，类型是 *People。</li>
<li>第 6 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。</li>
<li>第 8 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。</li>
</ul>
<p><strong><em>提示：结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</em></strong></p>
<h3 id="使用多个值的列表初始化结构体"><a href="#使用多个值的列表初始化结构体" class="headerlink" title="使用多个值的列表初始化结构体"></a>使用多个值的列表初始化结构体</h3><p>Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。</p>
<p>1)多个值列表初始化结构体的书写格式</p>
<p>多个值使用逗号分隔初始化结构体，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名{</span><br><span class="line">    字段1的值,</span><br><span class="line">    字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用这种格式初始化时，需要注意：</p>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>键值对与值列表的初始化形式不能混用。</li>
</ul>
<p>2)多个值列表初始化结构体的例子</p>
<p>下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Address struct {</span><br><span class="line">    Province    string</span><br><span class="line">    City        string</span><br><span class="line">    ZipCode     int</span><br><span class="line">    PhoneNumber string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">addr := Address{</span><br><span class="line">    "四川",</span><br><span class="line">    "成都",</span><br><span class="line">    610000,</span><br><span class="line">    "0",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println(addr)</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{四川 成都 610000 0}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。</p>
<p>1)匿名结构体定义格式和初始化写法</p>
<p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    // 匿名结构体字段定义</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}{</span><br><span class="line">    // 字段值初始化</span><br><span class="line">    初始化字段1: 字段1的值,</span><br><span class="line">    初始化字段2: 字段2的值,</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>字段1、字段2……：结构体定义的字段名。</li>
<li>初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。</li>
<li>字段类型1、字段类型2……：结构体定义字段的类型。</li>
<li>字段1的值、字段2的值……：结构体初始化字段的初始值。</li>
</ul>
<p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := struct {</span><br><span class="line">    字段1 字段类型1</span><br><span class="line">    字段2 字段类型2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2)使用匿名结构体的例子</p>
<p>在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 打印消息类型, 传入匿名结构体</span><br><span class="line">func printMsgType(msg *struct {</span><br><span class="line">    id   int</span><br><span class="line">    data string</span><br><span class="line">}) {</span><br><span class="line"></span><br><span class="line">    // 使用动词%T打印msg的类型</span><br><span class="line">    fmt.Printf("%T\n", msg)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个匿名结构体</span><br><span class="line">    msg := &amp;struct {  // 定义部分</span><br><span class="line">        id   int</span><br><span class="line">        data string</span><br><span class="line">    }{  // 值初始化部分</span><br><span class="line">        1024,</span><br><span class="line">        "hello",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printMsgType(msg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*struct { id int; data string }</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义 printMsgType() 函数，参数为 msg，类型为 <code>*struct{id int data string}</code> ，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。</li>
<li>第 14 行，使用字符串格式化中的 <code>%T</code> 动词，将 msg 的类型名打印出来。</li>
<li>第 20 行，对匿名结构体进行实例化，同时初始化成员。</li>
<li>第 21 和 22 行，定义匿名结构体的字段。</li>
<li>第 24 和 25 行，给匿名结构体字段赋予初始值。</li>
<li>第 28 行，将 msg 传入 printMsgType() 函数中进行函数调用。</li>
</ul>
<p>匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。</p>
<p>其他编程语言构造函数的一些常见功能及特性如下：</p>
<ul>
<li>每个类可以添加构造函数，多个构造函数使用函数重载实现。</li>
<li>构造函数一般与类名同名，且没有返回值。</li>
<li>构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。</li>
<li>对于 C++ 来说，还有默认构造函数、拷贝构造函数等。</li>
</ul>
<h3 id="多种方式创建和初始化结构体——模拟构造函数重载"><a href="#多种方式创建和初始化结构体——模拟构造函数重载" class="headerlink" title="多种方式创建和初始化结构体——模拟构造函数重载"></a>多种方式创建和初始化结构体——模拟构造函数重载</h3><p>如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByName(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewCatByColor(color string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Color: color,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行定义 Cat 结构，包含颜色和名字字段。</li>
<li>第 6 行定义用名字构造猫结构的函数，返回 Cat 指针。</li>
<li>第 7 行取地址实例化猫的结构体。</li>
<li>第 8 行初始化猫的名字字段，忽略颜色字段。</li>
<li>第 12 行定义用颜色构造猫结构的函数，返回 Cat 指针。</li>
</ul>
<p>在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。</p>
<h3 id="带有父子关系的结构体的构造和初始化——模拟父级构造调用"><a href="#带有父子关系的结构体的构造和初始化——模拟父级构造调用" class="headerlink" title="带有父子关系的结构体的构造和初始化——模拟父级构造调用"></a>带有父子关系的结构体的构造和初始化——模拟父级构造调用</h3><p>黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct {</span><br><span class="line">    Color string</span><br><span class="line">    Name  string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type BlackCat struct {</span><br><span class="line">    Cat  // 嵌入Cat, 类似于派生</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造基类”</span><br><span class="line">func NewCat(name string) *Cat {</span><br><span class="line">    return &amp;Cat{</span><br><span class="line">        Name: name,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// “构造子类”</span><br><span class="line">func NewBlackCat(color string) *BlackCat {</span><br><span class="line">    cat := &amp;BlackCat{}</span><br><span class="line">    cat.Color = color</span><br><span class="line">    return cat</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。</li>
<li>第 11 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。</li>
<li>第 18 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。</li>
<li>第 19 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。</li>
<li>第 20 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。</li>
</ul>
<p>这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。</p>
<p>总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。</p>
<h2 id="方法和接收器"><a href="#方法和接收器" class="headerlink" title="方法和接收器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/69.html">方法和接收器</a></h2><p>在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。</p>
<p>接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误 <code>invalid receiver type…</code> 。</p>
<p>接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。</p>
<p>类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。</p>
<p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。</p>
<p><strong><em>提示:在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</em></strong></p>
<h3 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h3><p>本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。</p>
<p>1)面向过程实现方法<br>面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将一个物品放入背包的过程</span><br><span class="line">func Insert(b *Bag, itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    bag := new(Bag)</span><br><span class="line"></span><br><span class="line">    Insert(bag, 1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。</li>
<li>第 6 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。</li>
<li>第 7 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。</li>
<li>第 12 行，创建背包实例 bag。</li>
<li>第 14 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。</li>
</ul>
<p>Insert() 函数将 <code>*Bag</code> 参数放在第一位，强调 Insert 会操作 <code>*Bag</code> 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p>
<p>2)Go语言的结构体方法</p>
<p>将背包及放入背包的物品中使用Go语言的结构体和方法方式编写，为 <code>*Bag</code> 创建一个方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Bag struct {</span><br><span class="line">    items []int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (b *Bag) Insert(itemid int) {</span><br><span class="line">    b.items = append(b.items, itemid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    b := new(Bag)</span><br><span class="line"></span><br><span class="line">    b.Insert(1001)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 5 行中，<code>Insert(itemid int)</code> 的写法与函数一致，<code>(b *Bag)</code> 表示接收器，即 Insert 作用的对象实例。</p>
<p>每个方法只能有一个接收器，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goreceiver.jpg" alt="图：接收器"></p>
<p>第 13 行中，在 Insert() 转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用 b 的 Insert。</p>
<h3 id="接收器——方法作用的目标"><a href="#接收器——方法作用的目标" class="headerlink" title="接收器——方法作用的目标"></a>接收器——方法作用的目标</h3><p>接收器的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各部分的说明：</p>
<ul>
<li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。</li>
<li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：格式与函数定义一致。</li>
</ul>
<p>接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p>
<p>1)理解指针类型的接收器</p>
<p>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。</p>
<p>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p>
<p>在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义属性结构</span><br><span class="line">type Property struct {</span><br><span class="line">    value int  // 属性值</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置属性值</span><br><span class="line">func (p *Property) SetValue(v int) {</span><br><span class="line"></span><br><span class="line">    // 修改p的成员变量</span><br><span class="line">    p.value = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 取属性值</span><br><span class="line">func (p *Property) Value() int {</span><br><span class="line">    return p.value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化属性</span><br><span class="line">    p := new(Property)</span><br><span class="line"></span><br><span class="line">    // 设置值</span><br><span class="line">    p.SetValue(100)</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(p.Value())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行程序，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，定义一个属性结构，拥有一个整型的成员变量。</li>
<li>第 11 行，定义属性值的方法。</li>
<li>第 14 行，设置属性值方法的接收器类型为指针，因此可以修改成员值，即便退出方法，也有效。</li>
<li>第 18 行，定义获取值的方法。</li>
<li>第 25 行，实例化属性结构。</li>
<li>第 28 行，设置值，此时成员变量变为 100。</li>
<li>第 31 行，获取成员变量。</li>
</ul>
<p>2)理解非指针类型的接收器</p>
<p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p>
<p>点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义点结构</span><br><span class="line">type Point struct {</span><br><span class="line">    X int</span><br><span class="line">    Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 非指针接收器的加方法</span><br><span class="line">func (p Point) Add(other Point) Point {</span><br><span class="line"></span><br><span class="line">    // 成员值与参数相加后返回新的结构</span><br><span class="line">    return Point{p.X + other.X, p.Y + other.Y}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 初始化点</span><br><span class="line">    p1 := Point{1, 1}</span><br><span class="line">    p2 := Point{2, 2}</span><br><span class="line"></span><br><span class="line">    // 与另外一个点相加</span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    fmt.Println(result)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{3 3}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义一个点结构，拥有 X 和 Y 两个整型分量。</li>
<li>第 14 行，为 Point 结构定义一个 Add() 方法，传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如P4 := P1.Add( P2 ).Add( P3 )</li>
<li>第 23 和 24 行，初始化两个点 p1 和 p2。</li>
<li>第 27 行，将 p1 和 p2 相加后返回结果。</li>
<li>第 30 行，打印结果。</li>
</ul>
<p>由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改。</p>
<p>3)指针和非指针接收器的使用</p>
<p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p>
<h3 id="示例：二维矢量模拟玩家移动"><a href="#示例：二维矢量模拟玩家移动" class="headerlink" title="示例：二维矢量模拟玩家移动"></a>示例：二维矢量模拟玩家移动</h3><p>在游戏中，一般使用二维矢量保存玩家的位置，使用矢量运算可以计算出玩家移动的位置，本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。</p>
<p>1)实现二维矢量结构</p>
<p>矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算，在计算机中，使用拥有 X 和 Y 两个分量的 Vec2 结构体实现数学中二维向量的概念，详细实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "math"</span><br><span class="line"></span><br><span class="line">type Vec2 struct {</span><br><span class="line">    X, Y float32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 加</span><br><span class="line">func (v Vec2) Add(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X + other.X,</span><br><span class="line">        v.Y + other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 减</span><br><span class="line">func (v Vec2) Sub(other Vec2) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{</span><br><span class="line">        v.X - other.X,</span><br><span class="line">        v.Y - other.Y,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 乘</span><br><span class="line">func (v Vec2) Scale(s float32) Vec2 {</span><br><span class="line"></span><br><span class="line">    return Vec2{v.X * s, v.Y * s}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 距离</span><br><span class="line">func (v Vec2) DistanceTo(other Vec2) float32 {</span><br><span class="line">    dx := v.X - other.X</span><br><span class="line">    dy := v.Y - other.Y</span><br><span class="line"></span><br><span class="line">    return float32(math.Sqrt(float64(dx*dx + dy*dy)))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 插值</span><br><span class="line">func (v Vec2) Normalize() Vec2 {</span><br><span class="line">    mag := v.X*v.X + v.Y*v.Y</span><br><span class="line">    if mag &gt; 0 {</span><br><span class="line">        oneOverMag := 1 / float32(math.Sqrt(float64(mag)))</span><br><span class="line">        return Vec2{v.X * oneOverMag, v.Y * oneOverMag}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return Vec2{0, 0}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 5 行声明了一个 Vec2 结构体，包含两个方向的单精度浮点数作为成员。</li>
<li>第 10～16 行定义了 Vec2 的 Add() 方法，使用自身 Vec2 和通过 Add() 方法传入的 Vec2 进行相加，相加后，结果以返回值形式返回，不会修改 Vec2 的成员。</li>
<li>第 20 行定义了 Vec2 的减法操作。</li>
<li>第 29 行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale() 方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。</li>
<li>第 35 行定义了计算两个矢量的距离，math.Sqrt() 是开方函数，参数是 float64，在使用时需要转换，返回值也是 float64，需要转换回 float32。</li>
<li>第 43 行定义矢量单位化。</li>
</ul>
<p>2)实现玩家对象</p>
<p>玩家对象负责存储玩家的当前位置、目标位置和速度，使用 MoveTo() 方法为玩家设定移动的目标，使用 Update() 方法更新玩家位置，在 Update() 方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。</p>
<p>① 使用矢量减法，将目标位置（targetPos）减去当前位置（currPos）即可计算出位于两个位置之间的新矢量，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/targetpos.jpg" alt="图：计算玩家方向矢量"></p>
<p>② 使用 Normalize() 方法将方向矢量变为模为 1 的单位化矢量，这里需要将矢量单位化后才能进行后续计算，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/normalize.jpg" alt="图：单位化方向矢量"></p>
<p>③ 获得方向后，将单位化方向矢量根据速度进行等比缩放，速度越快，速度数值越大，乘上方向后生成的矢量就越长（模很大），如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/scale.jpg" alt="图：根据速度缩放方向"></p>
<p>④ 将缩放后的方向添加到当前位置后形成新的位置，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/addpost.jpg" alt="图：缩放后的方向叠加位置形成新位置"></p>
<p>下面是玩家对象的具体代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Player struct {</span><br><span class="line">    currPos   Vec2    // 当前位置</span><br><span class="line">    targetPos Vec2    // 目标位置</span><br><span class="line">    speed     float32 // 移动速度</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 移动到某个点就是设置目标位置</span><br><span class="line">func (p *Player) MoveTo(v Vec2) {</span><br><span class="line"></span><br><span class="line">    p.targetPos = v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取当前的位置</span><br><span class="line">func (p *Player) Pos() Vec2 {</span><br><span class="line">    return p.currPos</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 是否到达</span><br><span class="line">func (p *Player) IsArrived() bool {</span><br><span class="line"></span><br><span class="line">    // 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点</span><br><span class="line">    return p.currPos.DistanceTo(p.targetPos) &lt; p.speed</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 逻辑更新</span><br><span class="line">func (p *Player) Update() {</span><br><span class="line">    if !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 计算出当前位置指向目标的朝向</span><br><span class="line">        dir := p.targetPos.Sub(p.currPos).Normalize()</span><br><span class="line"></span><br><span class="line">        // 添加速度矢量生成新的位置</span><br><span class="line">        newPos := p.currPos.Add(dir.Scale(p.speed))</span><br><span class="line"></span><br><span class="line">        // 移动完成后，更新当前位置</span><br><span class="line">        p.currPos = newPos</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建新玩家</span><br><span class="line">func NewPlayer(speed float32) *Player {</span><br><span class="line"></span><br><span class="line">    return &amp;Player{</span><br><span class="line">        speed: speed,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，结构体 Player 定义了一个玩家的基本属性和方法，结构体的 currPos 表示当前位置，speed 表示速度。</li>
<li>第 10 行，定义玩家的移动方法，逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由 Update() 方法负责。</li>
<li>第 16 行，使用 Pos 方法实现玩家 currPos 的属性访问封装。</li>
<li>第 21 行，判断玩家是否到达目标点，玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。</li>
<li>第 28 行，玩家移动时位置更新的主要实现。</li>
<li>第 29 行，如果已经到达，则不必再更新。</li>
<li>第 32 行，数学中，两矢量相减将获得指向被减矢量的新矢量，Sub() 方法返回的新矢量使用 Normalize() 方法单位化，最终返回的 dir 矢量就是移动方向。</li>
<li>第 35 行，在当前的位置上叠加根据速度缩放的方向计算出新的位置 newPos。</li>
<li>第 38 行，将新位置更新到 currPos，为下一次移动做准备。</li>
<li>第 44 行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。</li>
</ul>
<p>3)处理移动逻辑</p>
<p>将 Player 实例化后，设定玩家移动的最终目标点，之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化玩家对象，并设速度为0.5</span><br><span class="line">    p := NewPlayer(0.5)</span><br><span class="line"></span><br><span class="line">    // 让玩家移动到3,1点</span><br><span class="line">    p.MoveTo(Vec2{3, 1})</span><br><span class="line"></span><br><span class="line">    // 如果没有到达就一直循环</span><br><span class="line">    for !p.IsArrived() {</span><br><span class="line"></span><br><span class="line">        // 更新玩家位置</span><br><span class="line">        p.Update()</span><br><span class="line"></span><br><span class="line">        // 打印每次移动后的玩家位置</span><br><span class="line">        fmt.Println(p.Pos())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 NewPlayer() 函数构造一个 <code>*Player</code> 玩家对象，并设移动速度为 <code>0.5</code> ，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。</li>
<li>第 11 行，设定玩家移动的最终目标为 X 为 3，Y 为 1。</li>
<li>第 14 行，构造一个循环，条件是没有到达时一直循环。</li>
<li>第 17 行，不停地更新玩家位置，如果玩家到达目标，p.IsArrived 将会变为 true。</li>
<li>第 20 行，打印每次更新后玩家的位置。</li>
</ul>
<p>本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。</p>
<h2 id="为任意类型添加方法"><a href="#为任意类型添加方法" class="headerlink" title="为任意类型添加方法"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/70.html">为任意类型添加方法</a></h2><p>Go语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。</p>
<h3 id="为基本类型添加方法"><a href="#为基本类型添加方法" class="headerlink" title="为基本类型添加方法"></a>为基本类型添加方法</h3><p>在Go语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  v == 0 {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  v.IsZero() {</span><br><span class="line">    // v等于0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为基本类型添加方法的详细实现流程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将int定义为MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">// 为MyInt添加IsZero()方法</span><br><span class="line">func (m MyInt) IsZero() bool {</span><br><span class="line">    return m == 0</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为MyInt添加Add()方法</span><br><span class="line">func (m MyInt) Add(other int) int {</span><br><span class="line">    return other + int(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.IsZero())</span><br><span class="line"></span><br><span class="line">    b = 1</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.Add(2))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 type MyInt int 将 int 定义为自定义的 MyInt 类型。</li>
<li>第 11 行，为 MyInt 类型添加 IsZero() 方法，该方法使用了 (m MyInt) 的非指针接收器，数值类型没有必要使用指针接收器。</li>
<li>第 16 行，为 MyInt 类型添加 Add() 方法。</li>
<li>第 17 行，由于 m 的类型是 MyInt 类型，但其本身是 int 类型，因此可以将 m 从 MyInt 类型转换为 int 类型再进行计算。</li>
<li>第 24 行，调用 b 的 IsZero() 方法，由于使用非指针接收器，b的值会被复制进入 IsZero() 方法进行判断。</li>
<li>第 28 行，调用 b 的 Add() 方法，同样也是非指针接收器，结果直接通过 Add() 方法返回。</li>
</ul>
<h3 id="http包中的类型方法"><a href="#http包中的类型方法" class="headerlink" title="http包中的类型方法"></a>http包中的类型方法</h3><p>Go语言提供的 http 包里也大量使用了类型方法，Go语言使用 http 包进行 HTTP 的请求，使用 http 包的 NewRequest() 方法可以创建一个 HTTP 请求，填充请求中的 http 头（req.Header），再调用 http.Client 的 Do 方法，将传入的 HTTP 请求发送出去。</p>
<p>下面代码演示创建一个 HTTP 请求，并且设定 HTTP 头。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "net/http"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    client := &amp;http.Client{}</span><br><span class="line"></span><br><span class="line">    // 创建一个http请求</span><br><span class="line">    req, err := http.NewRequest("POST", "http://www.163.com/", strings.NewReader("key=value"))</span><br><span class="line"></span><br><span class="line">    // 发现错误就打印并退出</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 为请求头添加信息</span><br><span class="line">    req.Header.Add("User-Agent", "myClient")</span><br><span class="line"></span><br><span class="line">    // 开始请求</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line">    // 处理请求的错误</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(string(data))</span><br><span class="line"></span><br><span class="line">    defer resp.Body.Close()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;405 Not Allowed&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor="white"&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;405 Not Allowed&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，实例化 HTTP 的客户端，请求需要通过这个客户端实例发送。</li>
<li>第 14 行，使用 POST 方式向网易的服务器创建一个 HTTP 请求，第三个参数为 HTTP 的 Body 部分，Body 部分的内容来自字符串，但参数只能接受 io.Reader 类型，因此使用 strings.NewReader() 创建一个字符串的读取器，返回的 io.Reader 接口作为 http 的 Body 部分供 NewRequest() 函数读取，创建请求只是构造一个请求对象，不会连接网络。</li>
<li>第 24 行，为创建好的 HTTP 请求的头部添加 User-Agent，作用是表明用户的代理特性。</li>
<li>第 27 行，使用客户端处理请求，此时 client 将 HTTP 请求发送到网易服务器，服务器响应请求后，将信息返回并保存到 resp 变量中。</li>
<li>第 37 行，读取响应的 Body 部分并打印。</li>
</ul>
<p>由于我们构造的请求不是网易服务器所支持的类型，所以服务器返回操作不被运行的 405 错误。</p>
<p>在本例子第 24 行中使用的 req.Header 的类型为 http.Header，就是典型的自定义类型，并且拥有自己的方法，http.Header 的部分定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Header map[string][]string</span><br><span class="line"></span><br><span class="line">func (h Header) Add(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (h Header) Set(key, value string) {</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (h Header) Get(key string) string {</span><br><span class="line">    return textproto.MIMEHeader(h).Get(key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，Header 实际是一个以字符串为键、字符串切片为值的映射。</li>
<li>第 3 行，Add() 为 Header 的方法，map 是一个引用类型，因此即便使用 (h Header) 的非指针接收器，也可以修改 map 的值。</li>
</ul>
<p>为类型添加方法的过程是一个语言层特性，使用类型方法的代码经过编译器编译后的代码运行效率与传统的面向过程或面向对象的代码没有任何区别，因此，为了代码便于理解，可以在编码时使用Go语言的类型方法特性。</p>
<h3 id="time-包中的类型方法"><a href="#time-包中的类型方法" class="headerlink" title="time 包中的类型方法"></a>time 包中的类型方法</h3><p>Go语言提供的 time 包主要用于时间的获取和计算等，在这个包中，也使用了类型方法，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(time.Second.String())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 9 行的 time.Second 是一个常量，下面代码的加粗部分就是 time.Second 的定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond  = 1000 * Nanosecond</span><br><span class="line">    Millisecond  = 1000 * Microsecond</span><br><span class="line">    Second       = 1000 * Millisecond</span><br><span class="line">    Minute       = 60 * Second</span><br><span class="line">    Hour         = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Second 的类型为 Duration，而 Duration 实际是一个 int64 的类型，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></tbody></table></figure>
<p>它拥有一个 String 的方法，部分定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (d Duration) String() string {</span><br><span class="line">    // 一系列生成buf的代码</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    return string(buf[w:])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Duration.String 可以将 Duration 的值转为字符串。</p>
<h2 id="使用事件系统实现事件的响应和处理"><a href="#使用事件系统实现事件的响应和处理" class="headerlink" title="使用事件系统实现事件的响应和处理"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/71.html">使用事件系统实现事件的响应和处理</a></h2><p>Go语言可以将类型的方法与普通函数视为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。这个特性和 C# 中的代理（delegate）类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数或类型的方法。</p>
<p>本节中，首先将用简单的例子了解Go语言是如何将方法与函数视为一个概念，接着会实现一个事件系统，事件系统能有效地将事件触发与响应两端代码解耦。</p>
<h3 id="方法和函数的统一调用"><a href="#方法和函数的统一调用" class="headerlink" title="方法和函数的统一调用"></a>方法和函数的统一调用</h3><p>本节的例子将让一个结构体的方法（class.Do）的参数和一个普通函数（funcDo）的参数完全一致，也就是方法与函数的签名一致。然后使用与它们签名一致的函数变量（delegate）分别赋值方法与函数，接着调用它们，观察实际效果。</p>
<p>详细实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明一个结构体</span><br><span class="line">type class struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 给结构体添加Do方法</span><br><span class="line">func (c *class) Do(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call method do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 普通函数的Do</span><br><span class="line">func funcDo(v int) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("call function do:", v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个函数回调</span><br><span class="line">    var delegate func(int)</span><br><span class="line"></span><br><span class="line">    // 创建结构体实例</span><br><span class="line">    c := new(class)</span><br><span class="line"></span><br><span class="line">    // 将回调设为c的Do方法</span><br><span class="line">    delegate = c.Do</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line"></span><br><span class="line">    // 将回调设为普通函数</span><br><span class="line">    delegate = funcDo</span><br><span class="line"></span><br><span class="line">    // 调用</span><br><span class="line">    delegate(100)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，为结构体添加一个 Do() 方法，参数为整型。这个方法的功能是打印提示和输入的参数值。</li>
<li>第 16 行，声明一个普通函数，参数也是整型，功能是打印提示和输入的参数值。</li>
<li>第 24 行，声明一个 delegate 的变量，类型为 <code>func(int)</code> ，与 funcDo 和 class 的 Do() 方法的参数一致。</li>
<li>第 30 行，将 c.Do 作为值赋给 delegate 变量。</li>
<li>第 33 行，调用 delegate() 函数，传入 100 的参数。此时会调用 c 实例的 Do() 方法。</li>
<li>第 36 行，将 funcDo 赋值给 delegate。</li>
<li>第 39 行，调用 delegate()，传入 100 的参数。此时会调用 funcDo() 方法。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call method do: 100</span><br><span class="line">call function do: 100</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码能运行的基础在于：无论是普通函数还是结构体的方法，只要它们的签名一致，与它们签名一致的函数变量就可以保存普通函数或是结构体方法。</p>
<p>了解了Go语言的这一特性后，我们就可以将这个特性用在事件中。</p>
<h3 id="事件系统基本原理"><a href="#事件系统基本原理" class="headerlink" title="事件系统基本原理"></a>事件系统基本原理</h3><p>事件系统可以将事件派发者与事件处理者解耦。例如，网络底层可以生成各种事件，在网络连接上后，网络底层只需将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。或者再比如，你注册、关注或者订阅某“大V”的社交消息后，“大V”发生的任何事件都会通知你，但他并不用了解粉丝们是如何为她喝彩或者疯狂的。如下图所示为事件系统基本原理图。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/goeventbus.jpg" alt="图：事件系统基本原理"></p>
<p>一个事件系统拥有如下特性：</p>
<ul>
<li>能够实现事件的一方，可以根据事件 ID 或名字注册对应的事件。</li>
<li>事件发起者，会根据注册信息通知这些注册者。</li>
<li>一个事件可以有多个实现方响应。</li>
</ul>
<p>通过下面的步骤详细了解事件系统的构成及使用。</p>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>事件系统需要为外部提供一个注册入口。这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来，详细实现请参考下面代码的 RegisterEvent() 函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 实例化一个通过字符串映射函数切片的map</span><br><span class="line">var eventByName = make(map[string][]func(interface{}))</span><br><span class="line"></span><br><span class="line">// 注册事件，提供事件名和回调函数</span><br><span class="line">func RegisterEvent(name string, callback func(interface{})) {</span><br><span class="line"></span><br><span class="line">    // 通过名字查找事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 在列表切片中添加函数</span><br><span class="line">    list = append(list, callback)</span><br><span class="line"></span><br><span class="line">    // 将修改的事件列表切片保存回去</span><br><span class="line">    eventByName[name] = list</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用事件</span><br><span class="line">func CallEvent(name string, param interface{}) {</span><br><span class="line"></span><br><span class="line">    // 通过名字找到事件列表</span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    // 遍历这个事件的所有回调</span><br><span class="line">    for _, callback := range list {</span><br><span class="line"></span><br><span class="line">        // 传入参数调用回调</span><br><span class="line">        callback(param)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行，创建一个 map 实例，这个 map 通过事件名（string）关联回调列表 <code>（[]func(interface{}）</code> ，同一个事件名称可能存在多个事件回调，因此使用回调列表保存。回调的函数声明为 <code>func(interface{})</code> 。</li>
<li>第 7 行，提供给外部的通过事件名注册响应函数的入口。</li>
<li>第 10 行，eventByName 通过事件名（name）进行查询，返回回调列表 <code>（[]func(interface{}）</code>。</li>
<li>第 13 行，为同一个事件名称在已经注册的事件回调的列表中再添加一个回调函数。</li>
<li>第 16 行，将修改后的函数列表设置到 map 的对应事件名中。</li>
</ul>
<p>拥有事件名和事件回调函数列表的关联关系后，就需要开始准备事件调用的入口了。</p>
<h3 id="事件调用"><a href="#事件调用" class="headerlink" title="事件调用"></a>事件调用</h3><p>事件调用方和注册方是事件处理中完全不同的两个角色。事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理；事件注册方通过事件系统注册应该响应哪些事件及如何使用回调函数处理这些事件。事件调用的详细实现请参考上面代码的 CallEvent() 函数。</p>
<p>代码说明如下：</p>
<ul>
<li>第 20 行，调用事件的入口，提供事件名称 name 和参数 param。事件的参数表示描述事件具体的细节，例如门打开的事件触发时，参数可以传入谁进来了。</li>
<li>第 23 行，通过注册事件回调的 eventByName 和事件名字查询处理函数列表 list。</li>
<li>第 26 行，遍历这个事件列表，如果没有找到对应的事件，list 将是一个空切片。</li>
<li>第 29 行，将每个函数回调传入事件参数并调用，就会触发事件实现方的逻辑处理。</li>
</ul>
<h3 id="使用事件系统"><a href="#使用事件系统" class="headerlink" title="使用事件系统"></a>使用事件系统</h3><p>例子中，在 main() 函数中调用事件系统的 CallEvent 生成 OnSkill 事件，这个事件有两个处理函数，一个是角色的 OnEvent() 方法，还有一个是函数 GlobalEvent()，详细代码实现过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 声明角色的结构体</span><br><span class="line">type Actor struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为角色添加一个事件处理函数</span><br><span class="line">func (a *Actor) OnEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("actor event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 全局事件</span><br><span class="line">func GlobalEvent(param interface{}) {</span><br><span class="line"></span><br><span class="line">    fmt.Println("global event:", param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化一个角色</span><br><span class="line">    a := new(Actor)</span><br><span class="line"></span><br><span class="line">    // 注册名为OnSkill的回调</span><br><span class="line">    RegisterEvent("OnSkill", a.OnEvent)</span><br><span class="line"></span><br><span class="line">    // 再次在OnSkill上注册全局事件</span><br><span class="line">    RegisterEvent("OnSkill", GlobalEvent)</span><br><span class="line">    // 调用事件，所有注册的同名函数都会被调用</span><br><span class="line">    CallEvent("OnSkill", 100)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明一个角色的结构体。在游戏中，角色是常见的对象，本例中，角色也是 OnSkill 事件的响应处理方。</li>
<li>第 10 行，为角色结构添加一个 OnEvent() 方法，这个方法拥有 param 参数，类型为 interface{}，与事件系统的函数（func(interface{})）签名一致。</li>
<li>第 16 行为全局事件响应函数。有时需要全局进行侦听或者处理一些事件，这里使用普通函数实现全局事件的处理。</li>
<li>第 27 行，注册一个 OnSkill 事件，实现代码由 a 的 OnEvent 进行处理。也就是 Actor的OnEvent() 方法。</li>
<li>第 30 行，注册一个 OnSkill 事件，实现代码由 GlobalEvent 进行处理，虽然注册的是同一个名字的事件，但前面注册的事件不会被覆盖，而是被添加到事件系统中，关联 OnSkill 事件的函数列表中。</li>
<li>第 33 行，模拟处理事件，通过 CallEvent() 函数传入两个参数，第一个为事件名，第二个为处理函数的参数。</li>
</ul>
<p>整个例子运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor event: 100</span><br><span class="line">global event: 100</span><br></pre></td></tr></tbody></table></figure>
<p>结果演示，角色和全局的事件会按注册顺序顺序地触发。</p>
<p>一般来说，事件系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统认为所有实现函数都是平等的。也就是说，无论例子中的 a.OnEvent 先注册，还是 GlobalEvent() 函数先注册，最终谁先被调用，都是无所谓的，开发者不应该去关注和要求保证调用的顺序。</p>
<p>一个完善的事件系统还会提供移除单个和所有事件的方法。</p>
<h2 id="类型内嵌和结构体内嵌"><a href="#类型内嵌和结构体内嵌" class="headerlink" title="类型内嵌和结构体内嵌"></a>类型内嵌和结构体内嵌</h2><p>结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。</p>
<p>可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go语言中的继承是通过内嵌或组合来实现的，所以可以说，在Go语言中，相比较于继承，组合更受青睐。</p>
<p>考虑如下的程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type innerS struct {</span><br><span class="line">    in1 int</span><br><span class="line">    in2 int</span><br><span class="line">}</span><br><span class="line">type outerS struct {</span><br><span class="line">    b int</span><br><span class="line">    c float32</span><br><span class="line">    int // anonymous field</span><br><span class="line">    innerS //anonymous field</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    outer := new(outerS)</span><br><span class="line">    outer.b = 6</span><br><span class="line">    outer.c = 7.5</span><br><span class="line">    outer.int = 60</span><br><span class="line">    outer.in1 = 5</span><br><span class="line">    outer.in2 = 10</span><br><span class="line">    fmt.Printf("outer.b is: %d\n", outer.b)</span><br><span class="line">    fmt.Printf("outer.c is: %f\n", outer.c)</span><br><span class="line">    fmt.Printf("outer.int is: %d\n", outer.int)</span><br><span class="line">    fmt.Printf("outer.in1 is: %d\n", outer.in1)</span><br><span class="line">    fmt.Printf("outer.in2 is: %d\n", outer.in2)</span><br><span class="line">    // 使用结构体字面量</span><br><span class="line">    outer2 := outerS{6, 7.5, 60, innerS{5, 10}}</span><br><span class="line">    fmt.Printf("outer2 is:", outer2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer.b is: 6</span><br><span class="line">outer.c is: 7.500000</span><br><span class="line">outer.int is: 60</span><br><span class="line">outer.in1 is: 5</span><br><span class="line">outer.in2 is: 10</span><br><span class="line">outer2 is:{6 7.5 60 {5 10}}</span><br></pre></td></tr></tbody></table></figure>
<p>通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。</p>
<h3 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h3><p>同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type A struct {</span><br><span class="line">    ax, ay int</span><br><span class="line">}</span><br><span class="line">type B struct {</span><br><span class="line">    A</span><br><span class="line">    bx, by float32</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    b := B{A{1, 2}, 3.0, 4.0}</span><br><span class="line">    fmt.Println(b.ax, b.ay, b.bx, b.by)</span><br><span class="line">    fmt.Println(b.A)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">{1 2}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a>结构内嵌特性</h3><p>Go语言的结构体内嵌有如下特性。</p>
<p>1)内嵌的结构体可以直接访问其成员变量</p>
<p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p>
<p>2)内嵌结构体的字段名是它的类型名</p>
<p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c Color</span><br><span class="line">c.BasicColor.R = 1</span><br><span class="line">c.BasicColor.G = 1</span><br><span class="line">c.BasicColor.B = 0</span><br></pre></td></tr></tbody></table></figure>
<p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p>
<h2 id="结构体内嵌模拟类的继承"><a href="#结构体内嵌模拟类的继承" class="headerlink" title="结构体内嵌模拟类的继承"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/73.html">结构体内嵌模拟类的继承</a></h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p>
<p>面向对象的设计原则中也建议对象最好不要使用多重继承，有些面向对象语言从语言层面就禁止了多重继承，如 C# 和 Java 语言。鸟类同时继承自可行走类和飞行类，这显然是存在问题的。在面向对象思想中要正确地实现对象的多重特性，只能使用一些精巧的设计来补救。</p>
<p>Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p>
<p>下面的代码使用Go语言的结构体内嵌实现对象特性组合，请参考下面的代码。</p>
<p>人和鸟的特性：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 可飞行的</span><br><span class="line">type Flying struct{}</span><br><span class="line"></span><br><span class="line">func (f *Flying) Fly() {</span><br><span class="line">    fmt.Println("can fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 可行走的</span><br><span class="line">type Walkable struct{}</span><br><span class="line"></span><br><span class="line">func (f *Walkable) Walk() {</span><br><span class="line">    fmt.Println("can calk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 人类</span><br><span class="line">type Human struct {</span><br><span class="line">    Walkable // 人类能行走</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 鸟类</span><br><span class="line">type Bird struct {</span><br><span class="line">    Walkable // 鸟类能行走</span><br><span class="line">    Flying   // 鸟类能飞行</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化鸟类</span><br><span class="line">    b := new(Bird)</span><br><span class="line">    fmt.Println("Bird: ")</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line"></span><br><span class="line">    // 实例化人类</span><br><span class="line">    h := new(Human)</span><br><span class="line">    fmt.Println("Human: ")</span><br><span class="line">    h.Walk()</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，声明可飞行结构（Flying）。</li>
<li>第 8 行，为可飞行结构添加飞行方法 Fly()。</li>
<li>第 13 行，声明可行走结构（Walkable）。</li>
<li>第 15 行，为可行走结构添加行走方法 Walk()。</li>
<li>第 20 行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备“可行走”特性</li>
<li>第 25 行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。</li>
<li>第 33 行，实例化鸟类结构。</li>
<li>第 35 和 36 行，调用鸟类可以使用的功能，如飞行和行走。</li>
<li>第 39 行，实例化人类结构。</li>
<li>第 41 行，调用人类能使用的功能，如行走。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can calk</span><br><span class="line">Human:</span><br><span class="line">can calk</span><br></pre></td></tr></tbody></table></figure>
<p>使用Go语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go语言会在编译时检查能否使用这些特性。</p>
<h2 id="初始化内嵌结构体"><a href="#初始化内嵌结构体" class="headerlink" title="初始化内嵌结构体"></a>初始化内嵌结构体</h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。</p>
<p>车辆结构的组装和初始化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 引擎</span><br><span class="line">type Engine struct {</span><br><span class="line">    Power int    // 功率</span><br><span class="line">    Type  string // 类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: Engine{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行定义车轮结构。</li>
<li>第 11 行定义引擎结构。</li>
<li>第 17 行定义车结构，由车轮和引擎结构体嵌入。</li>
<li>第 27 行，将 Car 的 Wheel 字段使用 Wheel 结构体进行初始化。</li>
<li>第 32 行，将 Car 的 Engine 字段使用 Engine 结构体进行初始化。</li>
</ul>
<h3 id="初始化内嵌匿名结构体"><a href="#初始化内嵌匿名结构体" class="headerlink" title="初始化内嵌匿名结构体"></a>初始化内嵌匿名结构体</h3><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 车轮</span><br><span class="line">type Wheel struct {</span><br><span class="line">    Size int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 车</span><br><span class="line">type Car struct {</span><br><span class="line">    Wheel</span><br><span class="line">    // 引擎</span><br><span class="line">    Engine struct {</span><br><span class="line">        Power int    // 功率</span><br><span class="line">        Type  string // 类型</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    c := Car{</span><br><span class="line"></span><br><span class="line">        // 初始化轮子</span><br><span class="line">        Wheel: Wheel{</span><br><span class="line">            Size: 18,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        // 初始化引擎</span><br><span class="line">        Engine: struct {</span><br><span class="line">            Power int</span><br><span class="line">            Type  string</span><br><span class="line">        }{</span><br><span class="line">            Type:  "1.4T",</span><br><span class="line">            Power: 143,</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Printf("%+v\n", c)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 14 行中原来的 Engine 结构体被直接定义在 Car 的结构体中。这种嵌入的写法就是将原来的结构体类型转换为 <code>struct{…}</code> 。</li>
<li>第 30 行，需要对 Car 的 Engine 字段进行初始化，由于 Engine 字段的类型并没有被单独定义，因此在初始化其字段时需要先填写 <code>struct{…}</code> 声明其类型。</li>
<li>第 34 行开始填充这个匿名结构体的数据，按“键：值”格式填充。</li>
</ul>
<h2 id="内嵌结构体成员名字冲突"><a href="#内嵌结构体成员名字冲突" class="headerlink" title="内嵌结构体成员名字冲突"></a>内嵌结构体成员名字冲突</h2><p>嵌入结构体内部可能拥有相同的成员名，成员重名时会发生什么？下面通过例子来讲解。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type A struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type B struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type C struct {</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.A.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行和第 11 行分别定义了两个拥有 <code>a int</code> 字段的结构体。</li>
<li>第 15 行的结构体嵌入了 A 和 B 的结构体。</li>
<li>第 21 行实例化 C 结构体。</li>
<li>第 22 行按常规的方法，访问嵌入结构体 A 中的 a 字段，并赋值 1。</li>
<li>第 23 行可以正常输出实例化 C 结构体。</li>
</ul>
<p>接着，将第 22 行修改为如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    c := &amp;C{}</span><br><span class="line">    c.a = 1</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时再编译运行，编译器报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\main.go:22:3: ambiguous selector c.a</span><br></pre></td></tr></tbody></table></figure>
<p>编译器告知 C 的选择器 a 引起歧义，也就是说，编译器无法决定将 1 赋给 C 中的 A 还是 B 里的字段 a。</p>
<p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p>
<h2 id="使用匿名结构体解析JSON数据"><a href="#使用匿名结构体解析JSON数据" class="headerlink" title="使用匿名结构体解析JSON数据"></a>使用匿名结构体解析JSON数据</h2><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。XML、ASN.1和Google的ProtocolBuffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>
<p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的 <code>encoding/json</code> 、<code>encoding/xml</code> 、<code>encoding/asn1</code> 等包提供支持，并且这类包都有着相似的API接口。</p>
<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的 <code>Unicode</code> 字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是 <code>Uhhhh</code> 转义数字来表示一个UTF-16编码，而不是Go语言的rune类型。</p>
<p>手机拥有屏幕、电池、指纹识别等信息，将这些信息填充为JSON格式的数据。如果需要选择性地分离JSON中的数据则较为麻烦。Go语言中的匿名结构体可以方便地完成这个操作。</p>
<p>首先给出完整的代码，然后再讲解每个部分。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p>首先，定义手机的各种数据结构体，如屏幕和电池，参考如下代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义手机屏幕</span><br><span class="line">type Screen struct{</span><br><span class="line">    Size float32//屏幕尺寸</span><br><span class="line">    ResX , ResY int//屏幕水平和垂直分辨率</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//定义电池</span><br><span class="line">type Battery struct{</span><br><span class="line">    Capacity int//容量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码定义了屏幕结构体和电池结构体，它们分别描述屏幕和电池的各种细节参数。</p>
<h3 id="准备JSON数据"><a href="#准备JSON数据" class="headerlink" title="准备JSON数据"></a>准备JSON数据</h3><p>准备手机数据结构，填充数据，将数据序列化为JSON格式的字节数组，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//生成json数据</span><br><span class="line">func genJsonData()[]byte{</span><br><span class="line">    //完整数据结构</span><br><span class="line">    raw := &amp;struct{</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool//序列化时添加的字段：是否有指纹识别</span><br><span class="line">    }{</span><br><span class="line">        //屏幕参数</span><br><span class="line">        Screen:Screen{</span><br><span class="line">            Size:5.5,</span><br><span class="line">            ResX:1920,</span><br><span class="line">            ResY:1080,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //电池参数</span><br><span class="line">        Battery:Battery{</span><br><span class="line">            2910,</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        //是否有指纹识别</span><br><span class="line">        HasTouchID:true,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为json</span><br><span class="line">    jsonData , _ := json.Marshal(raw)</span><br><span class="line">    return jsonData</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行定义了一个匿名结构体。这个结构体内嵌了Screen和Battery结构体，同时临时加入了HasTouchID字段。</li>
<li>第10行，为刚声明的匿名结构体填充屏幕数据。</li>
<li>第17行，填充电池数据。</li>
<li>第22行，填充指纹识别字段。</li>
<li>第26行，使用json.Marshal进行JSON序列化，将raw变量序列化为[]byte格式的JSON数据。</li>
</ul>
<h3 id="分离JSON数据"><a href="#分离JSON数据" class="headerlink" title="分离JSON数据"></a>分离JSON数据</h3><p>调用genJsonData获得JSON数据，将需要的字段填充到匿名结构体实例中，通过json.Unmarshal反序列化JSON数据达成分离JSON数据效果。代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //生成一段json数据</span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(string(jsonData))</span><br><span class="line"></span><br><span class="line">    //只需要屏幕和指纹识别信息的结构和实例</span><br><span class="line">    screenAndTouch := struct{</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到screenAndTouch</span><br><span class="line">    json.Unmarshal(jsonData , &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",screenAndTouch)</span><br><span class="line"></span><br><span class="line">    //只需要电池和指纹识别信息的结构和实例</span><br><span class="line">    batteryAndTouch := struct{</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID bool</span><br><span class="line">    }{}</span><br><span class="line"></span><br><span class="line">    //反序列化到batteryAndTouch</span><br><span class="line">    json.Unmarshal(jsonData,&amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    //输出screenAndTouch的详细结构</span><br><span class="line">    fmt.Printf("%+v\n",batteryAndTouch)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，调用genJsonData()函数，获得[]byte类型的JSON数据。</li>
<li>第6行，将jsonData的[]byte类型的JSON数据转换为字符串格式并打印输出。</li>
<li>第9行，构造匿名结构体，填充Screen结构和HasTouchID字段，第12行中的 <code>{}</code> 表示将结构体实例化。</li>
<li>第15行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第9行定义的结构体格式序列化到screenAndTouch中。</li>
<li>第18行，打印输出screenAndTouch中的详细数据信息。</li>
<li>第21行，构造匿名结构体，填充Battery结构和HasTouchID字段。</li>
<li>第27行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第21行定义的结构体格式序列化到batteryAndTouch中。</li>
<li>第30行，打印输出batteryAndTouch的详细数据信息。</li>
</ul>
<p>完整的代码执行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">{"Size":5.5,"ResX":1920,"ResY":1080,"Capacity":2910,"HasTouchID":true}</span><br><span class="line">{Screen:{Size:5.5 ResX:1920 ResY:1080} HasTouchID:true}</span><br><span class="line">{Battery:{Capacity:2910} HasTouchID:true}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="垃圾回收和SetFinalizer"><a href="#垃圾回收和SetFinalizer" class="headerlink" title="垃圾回收和SetFinalizer"></a>垃圾回收和SetFinalizer</h2><p>Go语言自带垃圾回收机制（GC）。GC 通过独立的进程执行，它会搜索不再使用的变量，并将其释放。需要注意的是，GC 在运行时会占用机器资源。</p>
<p>GC 是自动进行的，如果要手动进行 GC，可以使用 runtime.GC() 函数，显式的执行 GC。显式的进行 GC 只在某些特殊的情况下才有用，比如当内存资源不足时调用 runtime.GC() ，这样会立即释放一大片内存，但是会造成程序短时间的性能下降。</p>
<p>finalizer（终止器）是与对象关联的一个函数，通过 runtime.SetFinalizer 来设置，如果某个对象定义了 finalizer，当它被 GC 时候，这个 finalizer 就会被调用，以完成一些特定的任务，例如发信号或者写日志等。</p>
<p>在Go语言中 SetFinalizer 函数是这样定义的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func SetFinalizer(x, f interface{})</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明如下：</p>
<ul>
<li>参数 x 必须是一个指向通过 new 申请的对象的指针，或者通过对复合字面值取址得到的指针。</li>
<li>参数 f 必须是一个函数，它接受单个可以直接用 x 类型值赋值的参数，也可以有任意个被忽略的返回值。</li>
</ul>
<p>SetFinalizer 函数可以将 x 的终止器设置为 f，当垃圾收集器发现 x 不能再直接或间接访问时，它会清理 x 并调用 f(x)。</p>
<p>另外，x 的终止器会在 x 不能直接或间接访问后的任意时间被调用执行，不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个 os.File 对象时没有调用其 Close 方法，该 os.File 对象可以使用终止器去关闭对应的操作系统文件描述符。</p>
<p>终止器会按依赖顺序执行：如果 A 指向 B，两者都有终止器，且 A 和 B 没有其它关联，那么只有 A 的终止器执行完成，并且 A 被释放后，B 的终止器才可以执行。</p>
<p>如果 <code>*x</code> 的大小为 0 字节，也不保证终止器会执行。</p>
<p>此外，我们也可以使用 <code>SetFinalizer(x, nil)</code> 来清理绑定到 x 上的终止器。</p>
<p><strong><em>提示：终止器只有在对象被 GC 时，才会被执行。其他情况下，都不会被执行，即使程序正常结束或者发生错误。</em></strong></p>
<p>【示例】在函数 entry() 中定义局部变量并设置 finalizer，当函数 entry() 执行完成后，在 main 函数中手动触发 GC，查看 finalizer 的执行情况。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "log"</span><br><span class="line">    "runtime"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line">type Road int</span><br><span class="line">func findRoad(r *Road) {</span><br><span class="line">    log.Println("road:", *r)</span><br><span class="line">}</span><br><span class="line">func entry() {</span><br><span class="line">    var rd Road = Road(999)</span><br><span class="line">    r := &amp;rd</span><br><span class="line">    runtime.SetFinalizer(r, findRoad)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    entry()</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        runtime.GC()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2020/10/21 17:47:28 road: 999</span><br></pre></td></tr></tbody></table></figure>
<h2 id="将结构体数据保存为JSON格式数据"><a href="#将结构体数据保存为JSON格式数据" class="headerlink" title="将结构体数据保存为JSON格式数据"></a>将结构体数据保存为JSON格式数据</h2><p>JSON格式是一种用途广泛的对象文本格式。在Go语言中，结构体可以通过系统提供的json.Marshal()函数进行序列化。为了演示怎样通过反射获取结构体成员及各种值的过程，下面使用反射将结构体序列化为文本数据。</p>
<h3 id="数据结构及入口函数"><a href="#数据结构及入口函数" class="headerlink" title="数据结构及入口函数"></a>数据结构及入口函数</h3><p>将结构体序列化为JSON的步骤如下：</p>
<ul>
<li>准备数据结构体。</li>
<li>准备要序列化的结构体数据。</li>
<li>调用序列化函数。</li>
</ul>
<p>具体代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //声明技能结构</span><br><span class="line">    type Skill struct {</span><br><span class="line">        Name string</span><br><span class="line">        Level int</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //声明角色结构</span><br><span class="line">    type Actor struct {</span><br><span class="line">        Name string</span><br><span class="line">        Age int</span><br><span class="line"></span><br><span class="line">        Skills []Skill</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //填充基本角色数据</span><br><span class="line">    a := Actor {</span><br><span class="line">        Name : "cowboy",</span><br><span class="line">        Age:37,</span><br><span class="line">        Skills:[]Skill {</span><br><span class="line">            {</span><br><span class="line">                Name:"Rollandroll",</span><br><span class="line">                Level:1</span><br><span class="line">            },{</span><br><span class="line">                Name:"Flashyourdogeye",</span><br><span class="line">                Level:2</span><br><span class="line">            },{</span><br><span class="line">                Name:"TimetohaveLunch",</span><br><span class="line">                Level:3</span><br><span class="line">            },</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if result , err := MarshalJson(a) ; err == nil {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4～15行声明了一些结构体，用于描述一个角色的信息。</li>
<li>第18～27行，实例化了Actor结构体，并且填充了一些基本的角色数据。</li>
<li>第35行，调用自己实现的MarshalJson()函数，将Actor实例化的数据转换为JSON字符串。</li>
<li>第36行，如果操作成功将打印出数据。</li>
<li>第38行，如果操作有错误将打印错误。</li>
</ul>
<p>完整代码输出如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"Name":"cowboy","Age":37,"Skills":[{"Name":"Rollandroll","Level":1},{"Name":"Flashyourdogeye","Level":2},{"Name":"TimetohaveLunch","Level":3}]}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="序列化主函数"><a href="#序列化主函数" class="headerlink" title="序列化主函数"></a>序列化主函数</h4><p>MarshalJson()是序列化过程的主要函数入口，通过这个函数会调用不同类型的子序列化函数。MarshalJson()传入一个interface{}的数据，并将这个数据转换为JSON字符串返回，如果发生错误，则返回错误信息。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func MarshalJson(v interface{})(string,error){</span><br><span class="line"></span><br><span class="line">    //准备一个缓冲</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    //将任意值转换为json并输出到缓冲</span><br><span class="line">    if err:= writeAny(&amp;b , reflect.ValueOf(v)) ; err == nil {</span><br><span class="line">        return b.String() , nil</span><br><span class="line">    } else {</span><br><span class="line">        return "" , err</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，使用bytes.Buffer构建一个缓冲，这个对象类似于其他语言中的StringBuilder，在大量字符串连接时，推荐使用这个结构。</li>
<li>第7行，调用writeAny()函数，将bytes.Buffer以指针的方式传入，以方便将各种类型的数据都写入这个bytes.Buffer中。同时，将v转换为反射值对象并传入。</li>
<li>第8行，如果没有错误发生时，将bytes.Buffer的内容转换为字符串井返回。</li>
<li>第10行，发生错误时，远回空字符串结果和错误。</li>
</ul>
<p>MarshalJson()这个函数其实是对writeAny()函数的一个封装，将外部的interface{}类型转换为内部的reflect.Value类型，同时构建输出缓冲，将一些复杂的操作简化，方便外部使用。</p>
<h4 id="任意值序列化"><a href="#任意值序列化" class="headerlink" title="任意值序列化"></a>任意值序列化</h4><p>writeAny()函数传入一个字节缓冲和反射值对象，将反射值对象转换为JSON格式并写入字节缓冲中。</p>
<p>代码如下所示:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//将任意值转换为json并输出到缓冲</span><br><span class="line">func writeAny(buff *bytes.Buffer, value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    switch value.Kind() {</span><br><span class="line">        case reflect.String:</span><br><span class="line">            //写入带有双引号括起来的字符串</span><br><span class="line">            buff.WriteString(strconv.Quote(value.String()))</span><br><span class="line">        case reflect.Int:</span><br><span class="line">            //将整形转换为字符串并写入缓冲</span><br><span class="line">            buff.WriteString(strconv.FormatInt(value.Int(),10))</span><br><span class="line"></span><br><span class="line">        case reflect.Slice:</span><br><span class="line">            return writeSlice(buff,value)</span><br><span class="line"></span><br><span class="line">        case reflect.Struct:</span><br><span class="line">            return writeStruct(buff,value)</span><br><span class="line">        default:</span><br><span class="line">            //遇到不认识的种类，返回错误</span><br><span class="line">            return errors.New("unsupportkind:"+value.Kind().String())</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，根据传入反射值对象的种类进行判断，如字符串、整型、切片及结构体。</li>
<li>第7行，当传入值为字符串种类时，使用reflect.Value的String函数将传入值转换为字符串，再将字符串用双引号括起来，strconv.Quote()函数提供了比较正规的封装。最终使用bytes.Buffer的WriteString()函数，将前面输出的字符串写入缓冲中。</li>
<li>第10行，当传入值为整型时，使用reflect.Value的Int()函数，将传入值转换为整型，再将整型以十进制格式使用strconv.FormatInt()函数格式化为字符串，最后写入缓冲中。</li>
<li>第11行，使用writeSlice()函数把切片序列化为JSON操作。</li>
<li>第14行，使用writeStruct()函数把切片序列化为JSON操作。</li>
<li>第17行，遇到不能识别的类型，函数返回错误。</li>
</ul>
<p>writeAny()函数是整个序列化中非常重要的环节，可以通过扩充switch中的种类扩充序列化能识别的类型。</p>
<h4 id="切片序列化"><a href="#切片序列化" class="headerlink" title="切片序列化"></a>切片序列化</h4><p>writeAny()函数中会调用writeSlice()函数将切片类型转换为JSON格式的字符串并将数据写入缓冲中。代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//将切片转换为json并输出到缓冲</span><br><span class="line">func writeSlice(buff *bytes.Buffer,value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //写入切片开始标记</span><br><span class="line">    buff.WriteString("[")</span><br><span class="line"></span><br><span class="line">    //遍历每个切片元素</span><br><span class="line">    for s:=0 ; s &lt; value.Len() ; s++ {</span><br><span class="line">        sliceValue := value.Index(s)</span><br><span class="line"></span><br><span class="line">        //写入每个切片元素</span><br><span class="line">        writeAny(buff,sliceValue)</span><br><span class="line"></span><br><span class="line">        //写入每个元素尾部逗号，最后一个字段不添加</span><br><span class="line">        if s &lt; value.Len() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入切片结束标记</span><br><span class="line">    buff.WriteString("]")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行和第21行分别写入JSON数组的开始标识 <code>“[”</code> 和结束标识 <code>“]”</code> 。</li>
<li>第8行和第9行，使用reflect.Value的Len()方法和Index()方法遍历切片的所有元素。Len()方法返回切片的长度，Index()方法根据给定的索引找到对应的索引。</li>
<li>第12行，通过reflect.Value类型的Index方法获得reflect.Value类型的sliceValue，再将sliceValue传入writeAny()函数并继续对这个值进行递归序列化。</li>
<li>第15～17行，JSON格式规定：每个数组成员由逗号分隔且最后一个元素后不加逗号，这里就是遵守这个规定。</li>
<li>由于writeAny的功能较为完善，因此序列化切片只需要添加头尾标识符及元素分隔符就可以了。</li>
</ul>
<h4 id="结构体序列化"><a href="#结构体序列化" class="headerlink" title="结构体序列化"></a>结构体序列化</h4><p>在JSON格式中，切片是一系列值的序列，以方括号开头和结尾：结构体由键值对组成，以大括号开始和结束。两种结构的元素均以逗号分隔。序列化结构体的实现过程代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//将结构体序列化为json并输出到缓冲</span><br><span class="line">func writeStruct(buff *bytes.Buffer , value reflect.Value) error {</span><br><span class="line"></span><br><span class="line">    //取值的类型对象</span><br><span class="line">    valueType := value.Type()</span><br><span class="line"></span><br><span class="line">    //写入结构体左大括号</span><br><span class="line">    buff.WriteString("{")</span><br><span class="line"></span><br><span class="line">    //遍历结构体的所有值</span><br><span class="line">    for i:=0 ; i &lt; value.NumField() ; i++ {</span><br><span class="line"></span><br><span class="line">        //获取每个字段的字段值(reflect.Value)</span><br><span class="line">        fieldValue := value.Field(i)</span><br><span class="line"></span><br><span class="line">        //获取每个字段的类型(reflect.StructField)</span><br><span class="line">        fieldType := valueType.Field(i)</span><br><span class="line"></span><br><span class="line">        //写入字段名左双引号</span><br><span class="line">        buff.WriteString(""")</span><br><span class="line"></span><br><span class="line">        //写入字段名</span><br><span class="line">        buff.WriteString(fieldType.Name)</span><br><span class="line"></span><br><span class="line">        //写入字段名右双引号和冒号</span><br><span class="line">        buff.WriteString("":")</span><br><span class="line"></span><br><span class="line">        //写入每个字段值</span><br><span class="line">        writeAny(buff,fieldValue)</span><br><span class="line"></span><br><span class="line">        //写入每个字段尾部逗号，最后一个字段不添加</span><br><span class="line">        if i &lt; value.NumField() - 1 {</span><br><span class="line">            buff.WriteString(",")</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入结构体右大括号</span><br><span class="line">    buff.WriteString("}")</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行，遍历结构体获取值时，习惯性取出反射类型对象。</li>
<li>第8行和第38行，分别写入结构体开头和结尾的标识符。</li>
<li>第11行，根据reflect.Value的NumField()方法遍历结构体的成员值。</li>
<li>第14行，获取每一个结构体成员的反射值对象。</li>
<li>第17行，获取每一个结构体成员的反射类型对象，类型信息必须从类型对象中获取，反射值对象无法提供字段的类型信息，如果尝试从fieldValue.Type()中获得类型对象，那么取到的是值本身的类型对象，而不是结构体成员类型信息。</li>
<li>第20行，写入字段左边的双引号，双引号本身需要使用“”进行转义，从这里开始写入键值对。</li>
<li>第23行，根据结构体成员类型信息写入宇段名。</li>
<li>第26行，写入字段名右边的双引号和冒号。</li>
<li>第29行，递归调用任意值序列化函数writeAny()，将fieldValue继续序列化。</li>
<li>第32行，和切片一样，多个结构体字段间也是以逗号分隔，最后一个字段后面不接逗号。</li>
</ul>
<h4 id="JSON总结"><a href="#JSON总结" class="headerlink" title="JSON总结"></a>JSON总结</h4><p>上面例子只支持整型、字符串、切片和结构体类型序列化为JSON格式。如果需要扩充类型，可以在writeAny()函数中添加。程序功能和结构上还有一些不足，例如：</p>
<ul>
<li>没有处理各种异常情况，切片或结构体为空时应该提前判断，否则会触发岩机。</li>
<li>可以支持结构体标签（StructTag），方便自定义JSON的键名及忽略某些字段的序列化过程，避免这些字段被序列化到JSON中。</li>
<li>支持缩进且可以自定义缩进字符，将JSON序列化后的内容格式化，方便查看。</li>
<li>默认应该序列化为[]byte字节数组，外部自己转换为字符串。在大部分的使用中，JSON一般以字节数组方式解析、存储、传输，很少以字符串方式解析，因此避免字节数组和字符串的转换可以提高一些性能。</li>
</ul>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>使用链表结构可以避免在使用数组时需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表允许插入和移除表上任意位置上的结点，但是不允许随机存取。链表有三种类型：单向链表、双向链表以及循环链表。</p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表中每个结点包含两部分，分别是数据域和指针域，上一个结点的指针指向下一结点，依次相连，形成链表。</p>
<p>这里介绍三个概念：首元结点、头结点和头指针。</p>
<ul>
<li>首元结点：就是链表中存储第一个元素的结点，如下图中 a1 的位置。</li>
<li>头结点：它是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以存储链表的长度或者其它的信息，也可以为空不存储任何信息。</li>
<li>头指针：它是指向链表中第一个结点的指针。若链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向首元结点。</li>
</ul>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/singlelinklist.gif" alt="图：单向链表"></p>
<p>头结点在链表中不是必须的，但增加头结点有以下几点好处：</p>
<ul>
<li>增加了头结点后，首元结点的地址保存在头结点的指针域中，对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。</li>
<li>增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若链表为空的话，那么头结点的指针域为空。</li>
</ul>
<h3 id="使用-Struct-定义单链表"><a href="#使用-Struct-定义单链表" class="headerlink" title="使用 Struct 定义单链表"></a>使用 Struct 定义单链表</h3><p>利用 Struct 可以包容多种数据类型的特性，使用它作为链表的结点是最合适不过了。一个结构体内可以包含若干成员，这些成员可以是基本类型、自定义类型、数组类型，也可以是指针类型。这里可以使用指针类型成员来存放下一个结点的地址。</p>
<p>【示例 1】使用 Struct 定义一个单向链表。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Node struct {</span><br><span class="line">    Data  int</span><br><span class="line">    Next  *node</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中成员 Data 用来存放结点中的有用数据，Next 是指针类型的成员，它指向 Node struct 类型数据，也就是下一个结点的数据类型。</p>
<p>【示例 2】为链表赋值，并遍历链表中的每个结点。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data int</span><br><span class="line">    next *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node) { //遍历</span><br><span class="line">    for p != nil {</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p = p.next //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 1</span><br><span class="line">    var node1 = new(Node)</span><br><span class="line">    node1.data = 2</span><br><span class="line"></span><br><span class="line">    head.next = node1</span><br><span class="line">    var node2 = new(Node)</span><br><span class="line">    node2.data = 3</span><br><span class="line"></span><br><span class="line">    node1.next = node2</span><br><span class="line">    Shownode(head)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{1 0xc00004c1e0}</span><br><span class="line">{2 0xc00004c1f0}</span><br><span class="line">{3 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>单链表的结点插入方法一般使用头插法或者尾插法。</p>
<p>1)头插法</p>
<p>每次插入在链表的头部插入结点，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录头结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        node.next = tail   //将新插入的node的next指向头结点</span><br><span class="line">        tail = &amp;node      //重新赋值头结点</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(tail) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{9 0xc000036270}</span><br><span class="line">{8 0xc000036260}</span><br><span class="line">{7 0xc000036250}</span><br><span class="line">{6 0xc000036240}</span><br><span class="line">{5 0xc000036230}</span><br><span class="line">{4 0xc000036220}</span><br><span class="line">{3 0xc000036210}</span><br><span class="line">{2 0xc000036200}</span><br><span class="line">{1 0xc0000361f0}</span><br><span class="line">{0 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>2)尾插法</p>
<p>每次插入结点在尾部，这也是我们较为习惯的方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">type Node struct {</span><br><span class="line">    data  int</span><br><span class="line">    next  *Node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Shownode(p *Node){   //遍历</span><br><span class="line">    for p != nil{</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">        p=p.next  //移动指针</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var head = new(Node)</span><br><span class="line">    head.data = 0</span><br><span class="line">    var tail *Node</span><br><span class="line">    tail = head   //tail用于记录最末尾的结点的地址，刚开始tail的的指针指向头结点</span><br><span class="line">    for i :=1 ;i&lt;10;i++{</span><br><span class="line">        var node = Node{data:i}</span><br><span class="line">        (*tail).next = &amp;node</span><br><span class="line">        tail = &amp;node</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Shownode(head) //遍历结果</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{0 0xc0000361f0}</span><br><span class="line">{1 0xc000036200}</span><br><span class="line">{2 0xc000036210}</span><br><span class="line">{3 0xc000036220}</span><br><span class="line">{4 0xc000036230}</span><br><span class="line">{5 0xc000036240}</span><br><span class="line">{6 0xc000036250}</span><br><span class="line">{7 0xc000036260}</span><br><span class="line">{8 0xc000036270}</span><br><span class="line">{9 &lt;nil&gt;}</span><br></pre></td></tr></tbody></table></figure>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以速度较慢。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p>
<p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。</p>
<p>循环链表跟单链表唯一的区别就在尾结点。单向链表的尾结点指针指向空地址，表示这就是最后的结点了，而循环链表的尾结点指针是指向链表的头结点，它像一个环一样首尾相连，所以叫作“循环”链表，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/circlelinklist.gif" alt="图：循环链表"></p>
<p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题，尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/doublelinklist.gif" alt="图：双向链表"></p>
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<h2 id="数据I-O对象及操作"><a href="#数据I-O对象及操作" class="headerlink" title="数据I/O对象及操作"></a>数据I/O对象及操作</h2><p>在Go语言中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。在实际开发过程中，无论是实现 web 应用程序，还是控制台输入输出，又或者是网络操作，都不可避免的会遇到 I/O 操作。</p>
<p>Go语言标准库的 bufio 包中，实现了对数据 I/O 接口的缓冲功能。这些功能封装于接口 io.ReadWriter、io.Reader 和 io.Writer 中，并对应创建了 ReadWriter、Reader 或 Writer 对象，在提供缓冲的同时实现了一些文本基本 I/O 操作功能。</p>
<h3 id="ReadWriter-对象"><a href="#ReadWriter-对象" class="headerlink" title="ReadWriter 对象"></a>ReadWriter 对象</h3><p>ReadWriter 对象可以对数据 I/O 接口 io.ReadWriter 进行输入输出缓冲操作，ReadWriter 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReadWriter struct {</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，ReadWriter 对象中存放了一对 Reader 和 Writer 指针，它同时提供了对数据 I/O 对象的读写缓冲功能。</p>
<p>可以使用 NewReadWriter() 函数创建 ReadWriter 对象，该函数的功能是根据指定的 Reader 和 Writer 创建一个 ReadWriter 对象，ReadWriter 对象将会向底层 io.ReadWriter 接口写入数据，或者从 io.ReadWriter 接口读取数据。该函数原型声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</span><br></pre></td></tr></tbody></table></figure>
<p>在函数 NewReadWriter() 中，参数 r 是要读取的来源 Reader 对象，参数 w 是要写入的目的 Writer 对象。</p>
<h3 id="Reader-对象"><a href="#Reader-对象" class="headerlink" title="Reader 对象"></a>Reader 对象</h3><p>Reader 对象可以对数据 I/O 接口 io.Reader 进行输入缓冲操作，Reader 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Reader struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下 Reader 对象没有定义初始值，输入缓冲区最小值为 16。当超出限制时，另创建一个二倍的存储空间</p>
<h3 id="创建-Reader-对象"><a href="#创建-Reader-对象" class="headerlink" title="创建 Reader 对象"></a>创建 Reader 对象</h3><p>可以创建 Reader 对象的函数一共有两个，分别是 NewReader() 和 NewReaderSize()，下面分别介绍。</p>
<p>1)NewReader() 函数</p>
<p>NewReader() 函数的功能是按照缓冲区默认长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReader(rd io.Reader) *Reader</span><br></pre></td></tr></tbody></table></figure>
<p>2)NewReaderSize() 函数</p>
<p>NewReaderSize() 函数的功能是按照指定的缓冲区长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 rd 是 io.Reader 接口，参数 size 是指定的缓冲区字节长度。</p>
<h3 id="操作-Reader-对象"><a href="#操作-Reader-对象" class="headerlink" title="操作 Reader 对象"></a>操作 Reader 对象</h3><p>操作 Reader 对象的方法共有 11 个，分别是 Read()、ReadByte()、ReadBytes()、ReadLine()、ReadRune ()、ReadSlice()、ReadString()、UnreadByte()、UnreadRune()、Buffered()、Peek()，下面分别介绍。</p>
<p>1)Read() 方法</p>
<p>Read() 方法的功能是读取数据，并存放到字节切片 p 中。Read() 执行结束会返回已读取的字节数，因为最多只调用底层的 io.Reader 一次，所以返回的 n 可能小于 len(p)，当字节流结束时，n 为 0，err 为 io. EOF。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>在方法 Read() 中，参数 p 是用于存放读取数据的字节切片。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [128]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>2)ReadByte() 方法</p>
<p>ReadByte() 方法的功能是读取并返回一个字节，如果没有字节可读，则返回错误信息。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadByte() (c byte,err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    c, err := r.ReadByte()</span><br><span class="line">    fmt.Println(string(c), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>3)ReadBytes() 方法</p>
<p>ReadBytes() 方法的功能是读取数据直到遇到第一个分隔符“delim”，并返回读取的字节序列（包括“delim”）。如果 ReadBytes 在读到第一个“delim”之前出错，它返回已读取的数据和那个错误（通常是 io.EOF）。只有当返回的数据不以“delim”结尾时，返回的 err 才不为空值。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadBytes(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>4)ReadLine() 方法</p>
<p>ReadLine() 是一个低级的用于读取一行数据的方法，大多数调用者应该使用 ReadBytes(‘\n’) 或者 ReadString(‘\n’)。ReadLine 返回一行，不包括结尾的回车字符，如果一行太长（超过缓冲区长度），参数 isPrefix 会设置为 true 并且只返回前面的数据，剩余的数据会在以后的调用中返回。</p>
<p>当返回最后一行数据时，参数 isPrefix 会置为 false。返回的字节切片只在下一次调用 ReadLine 前有效。ReadLine 会返回一个非空的字节切片或一个错误，方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Golang is a beautiful language. \r\n I like it!")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    line, prefix, err := r.ReadLine()</span><br><span class="line">    fmt.Println(string(line), prefix, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Golang is a beautiful language.  false &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>5)ReadRune() 方法</p>
<p>ReadRune() 方法的功能是读取一个 UTF-8 编码的字符，并返回其 Unicode 编码和字节数。如果编码错误，ReadRune 只读取一个字节并返回 unicode.ReplacementChar(U+FFFD) 和长度 1。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    ch, size, err := r.ReadRune()</span><br><span class="line">    fmt.Println(string(ch), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>6)ReadSlice() 方法</p>
<p>ReadSlice() 方法的功能是读取数据直到分隔符“delim”处，并返回读取数据的字节切片，下次读取数据时返回的切片会失效。如果 ReadSlice 在查找到“delim”之前遇到错误，它返回读取的所有数据和那个错误（通常是 io.EOF）。</p>
<p>如果缓冲区满时也没有查找到“delim”，则返回 ErrBufferFull 错误。ReadSlice 返回的数据会在下次 I/O 操作时被覆盖，大多数调用者应该使用 ReadBytes 或者 ReadString。只有当 line 不以“delim”结尾时，ReadSlice 才会返回非空 err。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">    line, err = r.ReadSlice(delim)</span><br><span class="line">    fmt.Println(string(line), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br><span class="line">Go语言入门教程 EOF</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure>
<p>7)ReadString() 方法</p>
<p>ReadString() 方法的功能是读取数据直到分隔符“delim”第一次出现，并返回一个包含“delim”的字符串。如果 ReadString 在读取到“delim”前遇到错误，它返回已读字符串和那个错误（通常是 io.EOF）。只有当返回的字符串不以“delim”结尾时，ReadString 才返回非空 err。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadString(delim byte) (line string, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 delim 用于指定分割字节。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("C语言中文网, Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var delim byte = ','</span><br><span class="line">    line, err := r.ReadString(delim)</span><br><span class="line">    fmt.Println(line, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网, &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>8)UnreadByte() 方法</p>
<p>UnreadByte() 方法的功能是取消已读取的最后一个字节（即把字节重新放回读取缓冲区的前部）。只有最近一次读取的单个字节才能取消读取。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) UnreadByte() error</span><br></pre></td></tr></tbody></table></figure>
<p>9)UnreadRune() 方法</p>
<p>UnreadRune() 方法的功能是取消读取最后一次读取的 Unicode 字符。如果最后一次读取操作不是 ReadRune，UnreadRune 会返回一个错误（在这方面它比 UnreadByte 更严格，因为 UnreadByte 会取消上次任意读操作的最后一个字节）。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) UnreadRune() error</span><br></pre></td></tr></tbody></table></figure>
<p>10)Buffered() 方法</p>
<p>Buffered() 方法的功能是返回可从缓冲区读出数据的字节数, 示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    var buf [14]byte</span><br><span class="line">    n, err := r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn := r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">    n, err = r.Read(buf[:])</span><br><span class="line">    fmt.Println(string(buf[:n]), n, err)</span><br><span class="line">    rn = r.Buffered()</span><br><span class="line">    fmt.Println(rn)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go语言入门 14 &lt;nil&gt;</span><br><span class="line">6</span><br><span class="line">教程 6 &lt;nil&gt;</span><br><span class="line">0</span><br></pre></td></tr></tbody></table></figure>
<p>11)Peek() 方法</p>
<p>Peek() 方法的功能是读取指定字节数的数据，这些被读取的数据不会从缓冲区中清除。在下次读取之后，本次返回的字节切片会失效。如果 Peek 返回的字节数不足 n 字节，则会同时返回一个错误说明原因，如果 n 比缓冲区要大，则错误为 ErrBufferFull。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) Peek(n int) ([]byte, error)</span><br></pre></td></tr></tbody></table></figure>
<p>在方法 Peek() 中，参数 n 是希望读取的字节数。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    data := []byte("Go语言入门教程")</span><br><span class="line">    rd := bytes.NewReader(data)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    bl, err := r.Peek(8)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(14)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">    bl, err = r.Peek(20)</span><br><span class="line">    fmt.Println(string(bl), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Go语言 &lt;nil&gt;</span><br><span class="line">Go语言入门 &lt;nil&gt;</span><br><span class="line">Go语言入门教程 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Writer-对象"><a href="#Writer-对象" class="headerlink" title="Writer 对象"></a>Writer 对象</h3><p>Writer 对象可以对数据 I/O 接口 io.Writer 进行输出缓冲操作，Writer 结构定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer struct {</span><br><span class="line">    //contains filtered or unexported fields</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下 Writer 对象没有定义初始值，如果输出缓冲过程中发生错误，则数据写入操作立刻被终止，后续的写操作都会返回写入异常错误。</p>
<h3 id="创建-Writer-对象"><a href="#创建-Writer-对象" class="headerlink" title="创建 Writer 对象"></a>创建 Writer 对象</h3><p>创建 Writer 对象的函数共有两个分别是 NewWriter() 和 NewWriterSize()，下面分别介绍一下。</p>
<p>1)NewWriter() 函数</p>
<p>NewWriter() 函数的功能是按照默认缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewWriter(wr io.Writer) *Writer</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 wr 是 io.Writer 接口，Writer 对象会将数据写入该接口。</p>
<p>2)NewWriterSize() 函数</p>
<p>NewWriterSize() 函数的功能是按照指定的缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewWriterSize(wr io.Writer, size int) *Writer</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 wr 是 io.Writer 接口，参数 size 是指定的缓冲区字节长度。</p>
<h3 id="操作-Writer-对象"><a href="#操作-Writer-对象" class="headerlink" title="操作 Writer 对象"></a>操作 Writer 对象</h3><p>操作 Writer 对象的方法共有 7 个，分别是 Available()、Buffered()、Flush()、Write()、WriteByte()、WriteRune() 和 WriteString() 方法，下面分别介绍。</p>
<p>1)Available() 方法</p>
<p>Available() 方法的功能是返回缓冲区中未使用的字节数，该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Available() int</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Available())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Available())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 4096</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：4080</span><br></pre></td></tr></tbody></table></figure>
<p>2)Buffered() 方法</p>
<p>Buffered() 方法的功能是返回已写入当前缓冲区中的字节数，该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Buffered() int</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    fmt.Println("写入前未使用的缓冲区为：", w.Buffered())</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Buffered())</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println("执行 Flush 方法后，写入的字节数为：", w.Buffered())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该例测试结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写入前未使用的缓冲区为： 0</span><br><span class="line">写入"C语言中文网"后，未使用的缓冲区为：16</span><br><span class="line">执行 Flush 方法后，写入的字节数为： 0</span><br></pre></td></tr></tbody></table></figure>
<p>3)Flush() 方法</p>
<p>Flush() 方法的功能是把缓冲区中的数据写入底层的 io.Writer，并返回错误信息。如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Flush() error</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    w.Write(p)</span><br><span class="line">    fmt.Printf("未执行 Flush 缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Printf("执行 Flush 后缓冲区输出 %q\n", string(wr.Bytes()))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未执行 Flush 缓冲区输出 ""</span><br><span class="line">执行 Flush 后缓冲区输出 "C语言中文网"</span><br></pre></td></tr></tbody></table></figure>
<p>4)Write() 方法</p>
<p>Write() 方法的功能是把字节切片 p 写入缓冲区，返回已写入的字节数 nn。如果 nn 小于 len(p)，则同时返回一个错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 p 是要写入的字节切片。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    p := []byte("C语言中文网")</span><br><span class="line">    n, err := w.Write(p)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>5)WriteByte() 方法</p>
<p>WriteByte() 方法的功能是写入一个字节，如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unc (b *Writer) WriteByte(c byte) error</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 c 是要写入的字节数据，比如 ASCII 字符。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var c byte = 'G'</span><br><span class="line">    err := w.WriteByte(c)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>6)WriteRune() 方法</p>
<p>WriteRune() 方法的功能是以 UTF-8 编码写入一个 Unicode 字符，返回写入的字节数和错误信息。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) WriteRune(r rune) (size int,err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 r 是要写入的 Unicode 字符。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    var r rune = 'G'</span><br><span class="line">    size, err := w.WriteRune(r)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), size, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该例测试结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G 1 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>7)WriteString() 方法</p>
<p>WriteString() 方法的功能是写入一个字符串，并返回写入的字节数和错误信息。如果返回的字节数小于 len(s)，则同时返回一个错误说明原因。该方法原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Writer) WriteString(s string) (int, error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，参数 s 是要写入的字符串。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    wr := bytes.NewBuffer(nil)</span><br><span class="line">    w := bufio.NewWriter(wr)</span><br><span class="line">    s := "C语言中文网"</span><br><span class="line">    n, err := w.WriteString(s)</span><br><span class="line">    w.Flush()</span><br><span class="line">    fmt.Println(string(wr.Bytes()), n, err)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 16 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/e56582fa/">https://wssjdi.github.io/posts/e56582fa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a><a class="post-meta__tags" href="/tags/struct/">struct</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/d3175357/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go接口</div></div></a></div><div class="next-post pull-right"><a href="/posts/fbeb39a4/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/91175219/" title="Go流程控制"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go流程控制</div></div></a></div><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>