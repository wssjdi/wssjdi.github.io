<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go反射（reflect），Golang反射（reflect） | Wssjdi</title><meta name="description" content="golang反射"><meta name="keywords" content="go,go 反射,go reflect"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/b3ea2e2d/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="go反射（reflect），Golang反射（reflect）"><meta property="og:url" content="https://wssjdi.github.io/posts/b3ea2e2d/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="golang反射"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-25T05:33:55.000Z"><meta property="article:modified_time" content="2020-10-25T14:43:24.528Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-25 22:43:24'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect-%E5%8C%85"><span class="toc-text">reflect 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%EF%BC%88reflect-Type%EF%BC%89"><span class="toc-text">反射的类型对象（reflect.Type）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88Type%EF%BC%89%E4%B8%8E%E7%A7%8D%E7%B1%BB%EF%BC%88Kind%EF%BC%89"><span class="toc-text">反射的类型（Type）与种类（Kind）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">指针与指针指向的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用反射获取结构体的成员类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%EF%BC%88Struct-Tag%EF%BC%89"><span class="toc-text">结构体标签（Struct Tag）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%A7%84%E5%88%99%E6%B5%85%E6%9E%90"><span class="toc-text">反射规则浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Go语言中的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%80%E5%AE%9A%E5%BE%8B%EF%BC%9A%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E5%B0%86%E2%80%9C%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E2%80%9D"><span class="toc-text">反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%BA%8C%E5%AE%9A%E5%BE%8B%EF%BC%9A%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E5%B0%86%E2%80%9C%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E2%80%9D"><span class="toc-text">反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%AC%AC%E4%B8%89%E5%AE%9A%E5%BE%8B%EF%BC%9A%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BF%AE%E6%94%B9%E2%80%9C%E5%8F%8D%E5%B0%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E2%80%9D%E5%85%B6%E5%80%BC%E5%BF%85%E9%A1%BB%E6%98%AF%E2%80%9C%E5%8F%AF%E5%86%99%E7%9A%84%E2%80%9D"><span class="toc-text">反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%80%BB%E7%BB%93"><span class="toc-text">反射总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E5%92%8C%E7%81%B5%E6%B4%BB%E6%80%A7%E7%9A%84%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-text">反射——性能和灵活性的双刃剑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%B5%8B%E5%80%BC%E5%AF%B9%E6%AF%94"><span class="toc-text">1)结构体成员赋值对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E6%90%9C%E7%B4%A2%E5%B9%B6%E8%B5%8B%E5%80%BC%E5%AF%B9%E6%AF%94"><span class="toc-text">2)结构体成员搜索并赋值对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="toc-text">3)调用函数对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94"><span class="toc-text">4)基准测试结果对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reflect-TypeOf-%E5%92%8Creflect-Type%EF%BC%88%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="toc-text">reflect.TypeOf()和reflect.Type（通过反射获取类型信息）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%88Type%EF%BC%89%E4%B8%8E%E7%A7%8D%E7%B1%BB%EF%BC%88Kind%EF%BC%89"><span class="toc-text">理解反射的类型（Type）与种类（Kind）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reflect-Elem-%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-text">reflect.Elem()——通过反射获取指针指向的元素类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">通过反射获取结构体的成员类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-text">结构体字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%8D%E5%B0%84%E4%BF%A1%E6%81%AF"><span class="toc-text">获取成员反射信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE-Struct-Tag"><span class="toc-text">结构体标签 Struct Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">结构体标签的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-text">从结构体标签中获取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">结构体标签格式错误导致的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reflect-ValueOf-%E5%92%8Creflect-Value%EF%BC%88%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%80%BC%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="toc-text">reflect.ValueOf()和reflect.Value（通过反射获取值信息）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%80%BC%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-text">使用反射值对象包装任意值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%8F%8D%E5%B0%84%E5%80%BC%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E8%A2%AB%E5%8C%85%E8%A3%85%E7%9A%84%E5%80%BC"><span class="toc-text">从反射值对象获取被包装的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC"><span class="toc-text">通过反射访问结构体成员的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IsNil-%E5%92%8CIsValid-%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E5%8F%8D%E5%B0%84%E5%80%BC%E7%9A%84%E7%A9%BA%E5%92%8C%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">IsNil()和IsValid()——判断反射值的空和有效性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">通过反射修改变量的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E5%8F%8A%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">判定及获取元素的相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">值修改相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8F%AF%E8%A2%AB%E5%AF%BB%E5%9D%80"><span class="toc-text">值可修改条件之一：可被寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%8F%AF%E4%BF%AE%E6%94%B9%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E8%A2%AB%E5%AF%BC%E5%87%BA"><span class="toc-text">值可修改条件之一：被导出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-text">通过类型信息创建实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">通过反射调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inject%E5%BA%93%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">inject库：依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inject-%E5%AE%9E%E8%B7%B5"><span class="toc-text">inject 实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inject-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">inject 原理分析</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">go反射（reflect），Golang反射（reflect）</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-25T05:33:55.000Z" title="发表于 2020-10-25 13:33:55">2020-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-25T14:43:24.528Z" title="更新于 2020-10-25 22:43:24">2020-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p><strong>其它语言中的反射:</strong></p>
<p>C/C++ 语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息。Java、C# 等语言都支持完整的反射功能。</p>
<p>Lua、JavaScript 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。</p>
<p>Go 程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p>
<p>Go语言提供了 reflect 包来访问程序的反射信息。</p>
<h3 id="reflect-包"><a href="#reflect-包" class="headerlink" title="reflect 包"></a>reflect 包</h3><p>Go语言中的反射是由 reflect 包提供支持的，它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。</p>
<h3 id="反射的类型对象（reflect-Type）"><a href="#反射的类型对象（reflect-Type）" class="headerlink" title="反射的类型对象（reflect.Type）"></a>反射的类型对象（reflect.Type）</h3><p>在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a int</span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，定义一个 int 类型的变量。</li>
<li>第 10 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。</li>
<li>第 11 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。</li>
</ul>
<h3 id="反射的类型（Type）与种类（Kind）"><a href="#反射的类型（Type）与种类（Kind）" class="headerlink" title="反射的类型（Type）与种类（Kind）"></a>反射的类型（Type）与种类（Kind）</h3><p>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<p><strong>1)反射种类（Kind）的定义:</strong></p>
<p>Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<p><strong>2)从类型对象中获取类型名称和种类：</strong></p>
<p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>下面的代码中会对常量和结构体进行类型信息获取。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个Enum类型</span><br><span class="line">type Enum int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Zero Enum = 0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">    // 获取Zero常量的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(Zero)</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat struct</span><br><span class="line">Enum int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 17 行，声明结构体类型 cat。</li>
<li>第 20 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。</li>
<li>第 22 行，输出 cat 的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。</li>
<li>第 24 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。</li>
<li>第 26 行，输出 Zero 对应的类型对象的类型名和种类。</li>
</ul>
<h3 id="指针与指针指向的元素"><a href="#指针与指针指向的元素" class="headerlink" title="指针与指针指向的元素"></a>指针与指针指向的元素</h3><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个 <code>*</code> 操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := &amp;cat{}</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("name:'%v' kind:'%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">    // 取类型的元素</span><br><span class="line">    typeOfCat = typeOfCat.Elem()</span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:'' kind:'ptr'</span><br><span class="line">element name: 'cat', element kind: 'struct'</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，创建了 cat 结构体的实例，ins 是一个 <code>*cat</code> 类型的指针变量。</li>
<li>第 15 行，对指针变量获取反射类型信息。</li>
<li>第 17 行，输出指针变量的类型名称和种类。Go语言的反射中对所有指针变量的种类都是 Ptr，但需要注意的是，指针变量的类型名称是空，不是 *cat。</li>
<li>第 19 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。</li>
<li>第 21 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。</li>
</ul>
<h3 id="使用反射获取结构体的成员类型"><a href="#使用反射获取结构体的成员类型" class="headerlink" title="使用反射获取结构体的成员类型"></a>使用反射获取结构体的成员类型</h3><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。</p>
<p>与成员获取相关的 reflect.Type 的方法如下表所示。</p>
<table>
    <caption>结构体成员访问的方法列表</caption>
    <thead><tr><th>方法</th><th>说明</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)StructField</td><td>根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)(StructField,bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息，没有找到时bool返回false，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)StructField</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)(StructField,bool)</td><td>根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<p><strong>1)结构体字段类型</strong></p>
<p>reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（StructTag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。</p>
<p>StructField 的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type StructField struct {</span><br><span class="line">    Name string          // 字段名</span><br><span class="line">    PkgPath string       // 字段路径</span><br><span class="line">    Type      Type       // 字段反射类型对象</span><br><span class="line">    Tag       StructTag  // 字段的结构体标签</span><br><span class="line">    Offset    uintptr    // 字段在结构体中的相对偏移</span><br><span class="line">    Index     []int      // Type.FieldByIndex中的返回的索引值</span><br><span class="line">    Anonymous bool       // 是否为匿名字段</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字段说明如下：</p>
<ul>
<li>Name：为字段名称。</li>
<li>PkgPath：字段在结构体中的路径。</li>
<li>Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。</li>
<li>Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。</li>
<li>Index：FieldByIndex 中的索引顺序。</li>
<li>Anonymous：表示该字段是否为匿名字段。</li>
</ul>
<p><strong>2)获取成员反射信息</strong></p>
<p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<p>反射访问结构体成员类型及信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        // 带有结构体tag的字段</span><br><span class="line">        Type int `json:"type" id:"100"`</span><br><span class="line">    }</span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := cat{Name: "mimi", Type: 1}</span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line">    // 遍历结构体所有成员</span><br><span class="line">    for i := 0; i &lt; typeOfCat.NumField(); i++ {</span><br><span class="line">        // 获取每个成员的结构体字段类型</span><br><span class="line">        fieldType := typeOfCat.Field(i)</span><br><span class="line">        // 输出成员名和tag</span><br><span class="line">        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)</span><br><span class="line">    }</span><br><span class="line">    // 通过字段名, 找到字段类型信息</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line">        // 从tag中取出需要的tag</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: Name  tag: ''</span><br><span class="line">name: Type  tag: 'json:"type" id:"100"'</span><br><span class="line">type 100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，声明了带有两个成员的 cat 结构体。</li>
<li>第 13 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以 ` 开始和结尾的字符串。这个字符串在Go语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。</li>
<li>第 16 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。</li>
<li>第 18 行，获取实例的反射类型对象。</li>
<li>第 20 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。</li>
<li>第 22 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。</li>
<li>第 24 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是 StructField 结构体。</li>
<li>第 27 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，catType 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。</li>
<li>第 29 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。</li>
</ul>
<h3 id="结构体标签（Struct-Tag）"><a href="#结构体标签（Struct-Tag）" class="headerlink" title="结构体标签（Struct Tag）"></a>结构体标签（Struct Tag）</h3><p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。</p>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<p><strong>1)结构体标签的格式:</strong></p>
<p>Tag 在结构体字段后方书写的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:"value1" key2:"value2"`</span><br></pre></td></tr></tbody></table></figure>
<p>结构体标签由一个或多个键值对组成；键与值使用冒号分隔，值用双引号括起来；键值对之间使用一个空格分隔。</p>
<p><strong>2)从结构体标签中获取值：</strong></p>
<p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：<br>— <code>func (tag StructTag) Get(key string) string</code>：根据 Tag 中的键获取对应的值，例如 `key1:”value1” key2:”value2”` 的 Tag 中，可以传入“key1”获得“value1”。</p>
<ul>
<li><code>func (tag StructTag) Lookup(key string) (value string, ok bool)</code> ：根据 Tag 中的键，查询值是否存在。</li>
</ul>
<p><strong>3) 结构体标签格式错误导致的问题：</strong></p>
<p>编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        Type int `json: "type" id:"100"`</span><br><span class="line">    }</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会输出一个空字符串，并不会输出期望的 type。</p>
<p>代码第 11 行中，在 json: 和 “type” 之间增加了一个空格，这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。这个错误在开发中非常容易被疏忽，造成难以察觉的错误。所以将第 12 行代码修改为下面的样子，则可以正常打印。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type cat struct {</span><br><span class="line">    Name string</span><br><span class="line">    Type int `json:"type" id:"100"`</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></tbody></table></figure>
<h2 id="反射规则浅析"><a href="#反射规则浅析" class="headerlink" title="反射规则浅析"></a>反射规则浅析</h2><p>反射是众多编程语言中的一个非常实用的功能，它是一种能够自描述、自控制的应用，Go语言也对反射提供了友好的支持。</p>
<p>Go语言中使用反射可以在编译时不知道类型的情况下更新变量，在运行时查看值、调用方法以及直接对他们的布局进行操作。</p>
<p>由于反射是建立在类型系统（type system）上的，所以我们先来复习一下Go语言中的类型。</p>
<h3 id="Go语言中的类型"><a href="#Go语言中的类型" class="headerlink" title="Go语言中的类型"></a>Go语言中的类型</h3><p>Go语言是一门静态类型的语言，每个变量都有一个静态类型，类型在编译的时候确定下来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">var i int</span><br><span class="line">var j MyInt</span><br></pre></td></tr></tbody></table></figure>
<p>变量 i 的类型是 int，变量 j 的类型是 MyInt，虽然它们有着相同的基本类型，但静态类型却不一样，在没有类型转换的情况下，它们之间无法互相赋值。</p>
<p>接口是一个重要的类型，它意味着一个确定的方法集合，一个接口变量可以存储任何实现了接口的方法的具体值（除了接口本身），例如 io.Reader 和 io.Writer：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Reader is the interface that wraps the basic Read method.</span><br><span class="line">type Reader interface {</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Writer is the interface that wraps the basic Write method.</span><br><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个类型声明实现了 Reader（或 Writer）方法，那么它便实现了 io.Reader（或 io.Writer），这意味着一个 io.Reader 的变量可以持有任何一个实现了 Read 方法的的类型的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = new(bytes.Buffer)</span><br><span class="line">// and so on</span><br></pre></td></tr></tbody></table></figure>
<p>必须要弄清楚的一点是，不管变量 r 中的具体值是什么，r 的类型永远是 io.Reader，由于Go语言是静态类型的，r 的静态类型就是 io.Reader。</p>
<p>在接口类型中有一个极为重要的例子——空接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>它表示了一个空的方法集，一切值都可以满足它，因为它们都有零值或方法。</p>
<p>有人说Go语言的接口是动态类型，这是错误的，它们都是静态类型，虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。我们必须精确地了解这些，因为反射与接口是密切相关的。</p>
<p>关于接口我们就介绍到这里，下面我们看看Go语言的反射三定律。</p>
<h3 id="反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”"><a href="#反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”" class="headerlink" title="反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”"></a>反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”</h3><p><strong>注：这里反射类型指 reflect.Type 和 reflect.Value。</strong></p>
<p>从使用方法上来讲，反射提供了一种机制，允许程序在运行时检查接口变量内部存储的 (value, type) 对。</p>
<p>在最开始，我们先了解下 reflect 包的两种类型 Type 和 Value，这两种类型使访问接口内的数据成为可能，它们对应两个简单的方法，分别是 reflect.TypeOf 和 reflect.ValueOf，分别用来读取接口变量的 reflect.Type 和 reflect.Value 部分。</p>
<p>当然，从 reflect.Value 也很容易获取到 reflect.Type，目前我们先将它们分开。</p>
<p>首先，我们下看 reflect.TypeOf：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    fmt.Println("type:", reflect.TypeOf(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: float64</span><br></pre></td></tr></tbody></table></figure>
<p>大家可能会疑惑，为什么没看到接口？这段代码看起来只是把一个 float64 类型的变量 x 传递给 reflect.TypeOf 并没有传递接口。其实在 reflect.TypeOf 的函数签名里包含一个空接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// TypeOf returns the reflection Type of the value in the interface{}.</span><br><span class="line">func TypeOf(i interface{}) Type</span><br></pre></td></tr></tbody></table></figure>
<p>我们调用 reflect.TypeOf(x) 时，x 被存储在一个空接口变量中被传递过去，然后 reflect.TypeOf 对空接口变量进行拆解，恢复其类型信息。</p>
<p>函数 reflect.ValueOf 也会对底层的值进行恢复：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    fmt.Println("value:", reflect.ValueOf(x))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: 3.4</span><br></pre></td></tr></tbody></table></figure>
<p>类型 reflect.Type 和 reflect.Value 都有很多方法，我们可以检查和使用它们，这里我们举几个例子。</p>
<p>类型 reflect.Value 有一个方法 Type()，它会返回一个 reflect.Type 类型的对象。</p>
<p>Type 和 Value 都有一个名为 Kind 的方法，它会返回一个常量，表示底层数据的类型，常见值有：Uint、Float64、Slice 等。</p>
<p>Value 类型也有一些类似于 Int、Float 的方法，用来提取底层的数据：<br>Int 方法用来提取 int64<br>Float 方法用来提取 float64，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("type:", v.Type())</span><br><span class="line">    fmt.Println("kind is float64:", v.Kind() == reflect.Float64)</span><br><span class="line">    fmt.Println("value:", v.Float())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type: float64</span><br><span class="line">kind is float64: true</span><br><span class="line">value: 3.4</span><br></pre></td></tr></tbody></table></figure>
<p>还有一些用来修改数据的方法，比如 SetInt、SetFloat。在介绍它们之前，我们要先理解“可修改性”（settability），这一特性会在下面进行详细说明。</p>
<p>反射库提供了很多值得列出来单独讨论的属性，下面就来介绍一下。</p>
<p>首先是介绍下 Value 的 getter 和 setter 方法，为了保证 API 的精简，这两个方法操作的是某一组类型范围最大的那个。比如，处理任何含符号整型数，都使用 int64，也就是说 Value 类型的 Int 方法返回值为 int64 类型，SetInt 方法接收的参数类型也是 int64 类型。实际使用时，可能需要转化为实际的类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x uint8 = 'x'</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("type:", v.Type())                            // uint8.</span><br><span class="line">    fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.</span><br><span class="line">    x = uint8(v.Uint())                                       // v.Uint returns a uint64.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: uint8</span><br><span class="line">kind is uint8: true</span><br></pre></td></tr></tbody></table></figure>
<p>其次，反射对象的 Kind 方法描述的是基础类型，而不是静态类型。如果一个反射对象包含了用户定义类型的值，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var x MyInt = 7</span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中，虽然变量 v 的静态类型是 MyInt，而不是 int，但 Kind 方法仍然会返回 reflect.Int。换句话说 Kind 方法不会像 Type 方法一样区分 MyInt 和 int。</p>
<h3 id="反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”"><a href="#反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”" class="headerlink" title="反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”"></a>反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”</h3><p>和物理学中的反射类似，Go语言中的反射也能创造自己反面类型的对象。</p>
<p>根据一个 reflect.Value 类型的变量，我们可以使用 Interface 方法恢复其接口类型的值。事实上，这个方法会把 type 和 value 信息打包并填充到一个接口变量中，然后返回。</p>
<p>其函数声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Interface returns v's value as an interface{}.</span><br><span class="line">func (v Value) Interface() interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>然后，我们可以通过断言，恢复底层的具体值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(float64) // y will have type float64.</span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></tbody></table></figure>
<p>上面这段代码会打印出一个 float64 类型的值，也就是反射类型变量 v 所代表的值。</p>
<p>事实上，我们可以更好地利用这一特性，标准库中的 fmt.Println 和 fmt.Printf 等函数都接收空接口变量作为参数，fmt 包内部会对接口变量进行拆包，因此 fmt 包的打印函数在打印 reflect.Value 类型变量的数据时，只需要把 Interface 方法的结果传给格式化打印程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Interface())</span><br></pre></td></tr></tbody></table></figure>
<p>为什么不直接使用 fmt.Println(v)？因为 v 的类型是 reflect.Value，我们需要的是它的具体值，由于值的类型是 float64，我们也可以用浮点格式化打印它：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf("value is %7.1e\n", v.Interface())</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.4e+00</span><br></pre></td></tr></tbody></table></figure>
<p>同样，这次也不需要对 v.Interface() 的结果进行类型断言，空接口值内部包含了具体值的类型信息，Printf 函数会恢复类型信息。</p>
<p>简单来说 Interface 方法和 ValueOf 函数作用恰好相反，唯一一点是，返回值的静态类型是 interface{}。</p>
<p>Go的反射机制可以将“接口类型的变量”转换为“反射类型的对象”，然后再将“反射类型对象”转换过去。</p>
<h3 id="反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”"><a href="#反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”" class="headerlink" title="反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”"></a>反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”</h3><p>这条定律很微妙，也很容易让人迷惑，但是如果从第一条定律开始看，应该比较容易理解。</p>
<p>下面这段代码虽然不能正常工作，但是非常值得研究：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(7.1) // Error: will panic</span><br></pre></td></tr></tbody></table></figure>
<p>如果运行这段代码，它会抛出一个奇怪的异常：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>这里问题不在于值 <code>7.1</code> 不能被寻址，而是因为变量 v 是“不可写的”，“可写性”是反射类型变量的一个属性，但不是所有的反射类型变量都拥有这个属性。</p>
<p>我们可以通过 CanSet 方法检查一个 reflect.Value 类型变量的“可写性”，对于上面的例子，可以这样写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.Println("settability of v:", v.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: false</span><br></pre></td></tr></tbody></table></figure>
<p>对于一个不具有“可写性”的 Value 类型变量，调用 Set 方法会报出错误。</p>
<p>首先我们要弄清楚什么是“可写性”，“可写性”有些类似于寻址能力，但是更严格，它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。“可写性”最终是由一个反射对象是否存储了原始值而决定的。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></tbody></table></figure>
<p>这里我们传递给 reflect.ValueOf 函数的是变量 x 的一个拷贝，而非 x 本身，想象一下如果下面这行代码能够成功执行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(7.1)</span><br></pre></td></tr></tbody></table></figure>
<p>如果这行代码能够成功执行，它不会更新 x，虽然看起来变量 v 是根据 x 创建的，相反它会更新 x 存在于反射对象 v 内部的一个拷贝，而变量 x 本身完全不受影响。这会造成迷惑，并且没有任何意义，所以是不合法的。“可写性”就是为了避免这个问题而设计的。</p>
<p>这看起来很诡异，事实上并非如此，而且类似的情况很常见。考虑下面这行代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x)</span><br></pre></td></tr></tbody></table></figure>
<p>代码中，我们把变量 x 的一个拷贝传递给函数，因此不期望它会改变 x 的值。如果期望函数 f 能够修改变量 x，我们必须传递 x 的地址（即指向 x 的指针）给函数 f，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(&amp;x)</span><br></pre></td></tr></tbody></table></figure>
<p>反射的工作机制与此相同，如果想通过反射修改变量 x，就要把想要修改的变量的指针传递给反射库。</p>
<p>首先，像通常一样初始化变量 x，然后创建一个指向它的反射对象，命名为 p：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    fmt.Println("type of p:", p.Type())</span><br><span class="line">    fmt.Println("settability of p:", p.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type of p: *float64</span><br><span class="line">settability of p: false</span><br></pre></td></tr></tbody></table></figure>
<p>反射对象 p 是不可写的，但是我们也不像修改 p，事实上我们要修改的是 *p。为了得到 p 指向的数据，可以调用 Value 类型的 Elem 方法。Elem 方法能够对指针进行“解引用”，然后将结果存储到反射 Value 类型对象 v 中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    v := p.Elem()</span><br><span class="line">    fmt.Println("settability of v:", v.CanSet())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: true</span><br></pre></td></tr></tbody></table></figure>
<p>由于变量 v 代表 x， 因此我们可以使用 v.SetFloat 修改 x 的值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x float64 = 3.4</span><br><span class="line">    p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">    v := p.Elem()</span><br><span class="line">    v.SetFloat(7.1)</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7.1</span><br><span class="line">7.1</span><br></pre></td></tr></tbody></table></figure>
<p>反射不太容易理解，reflect.Type 和 reflect.Value 会混淆正在执行的程序，但是它做的事情正是编程语言做的事情。只需要记住：只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>我们一般使用反射修改结构体的字段，只要有结构体的指针，我们就可以修改它的字段。</p>
<p>下面是一个解析结构体变量 t 的例子，用结构体的地址创建反射变量，再修改它。然后我们对它的类型设置了 typeOfT，并用调用简单的方法迭代字段。</p>
<p>需要注意的是，我们从结构体的类型中提取了字段的名字，但每个字段本身是正常的 reflect.Value 对象。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type T struct {</span><br><span class="line">        A int</span><br><span class="line">        B string</span><br><span class="line">    }</span><br><span class="line">    t := T{23, "skidoo"}</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT := s.Type()</span><br><span class="line">    for i := 0; i &lt; s.NumField(); i++ {</span><br><span class="line">        f := s.Field(i)</span><br><span class="line">        fmt.Printf("%d: %s %s = %v\n", i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0: A int = 23</span><br><span class="line">1: B string = skidoo</span><br></pre></td></tr></tbody></table></figure>
<p>T 字段名之所以大写，是因为结构体中只有可导出的字段是“可设置”的。</p>
<p>因为 s 包含了一个可设置的反射对象，我们可以修改结构体字段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    type T struct {</span><br><span class="line">        A int</span><br><span class="line">        B string</span><br><span class="line">    }</span><br><span class="line">    t := T{23, "skidoo"}</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    s.Field(0).SetInt(77)</span><br><span class="line">    s.Field(1).SetString("Sunset Strip")</span><br><span class="line">    fmt.Println("t is now", t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t is now {77 Sunset Strip}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们修改了程序让 s 由 t（而不是 &amp;t）创建，程序就会在调用 SetInt 和 SetString 的地方失败，因为 t 的字段是不可设置的。</p>
<h3 id="反射总结"><a href="#反射总结" class="headerlink" title="反射总结"></a>反射总结</h3><p>反射规则可以总结为如下几条：</p>
<ul>
<li>反射可以将“接口类型变量”转换为“反射类型对象”；</li>
<li>反射可以将“反射类型对象”转换为“接口类型变量”；</li>
<li>如果要修改“反射类型对象”，其值必须是“可写的”。</li>
</ul>
<h2 id="反射——性能和灵活性的双刃剑"><a href="#反射——性能和灵活性的双刃剑" class="headerlink" title="反射——性能和灵活性的双刃剑"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/127.html">反射——性能和灵活性的双刃剑</a></h2><p>现在的一些流行设计思想需要建立在反射基础上，如控制反转（Inversion Of Control，IOC）和依赖注入（Dependency Injection，DI）。Go语言中非常有名的 Web 框架 martini（<code>https://github.com/go-martini/martini</code>）就是通过依赖注入技术进行中间件的实现，例如使用 martini 框架搭建的 http 的服务器如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "github.com/go-martini/martini"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    m := martini.Classic()</span><br><span class="line">    m.Get("/", func() string {</span><br><span class="line">        return "Hello world!"</span><br><span class="line">    })</span><br><span class="line">    m.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 7 行，响应路径 <code>/</code> 的代码使用一个闭包实现。如果希望获得 Go语言中提供的请求和响应接口，可以直接修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.Get("/", func(res http.ResponseWriter, req *http.Request) string {</span><br><span class="line">    // 响应处理代码……</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>martini 的底层会自动通过识别 Get 获得的闭包参数情况，通过动态反射调用这个函数并传入需要的参数。martini 的设计广受好评，但同时也有人指出，其运行效率较低。其中最主要的因素是大量使用了反射。</p>
<p>虽然一般情况下，I/O 的延迟远远大于反射代码所造成的延迟。但是，更低的响应速度和更低的 CPU 占用依然是 Web 服务器追求的目标。因此，反射在带来灵活性的同时，也带上了性能低下的桎梏。</p>
<p>要用好反射这把双刃剑，就需要详细了解反射的性能。下面的一些基准测试从多方面对比了原生调用和反射调用的区别。</p>
<h3 id="1-结构体成员赋值对比"><a href="#1-结构体成员赋值对比" class="headerlink" title="1)结构体成员赋值对比"></a>1)结构体成员赋值对比</h3><p>反射经常被使用在结构体上，因此结构体的成员访问性能就成为了关注的重点。下面例子中使用一个被实例化的结构体，访问它的成员，然后使用 Go语言的基准化测试可以迅速测试出结果。</p>
<p>反射性能测试的完整代码位于./src/chapter12/reflecttest/reflect_test.go，下面是对各个部分的详细说明。</p>
<p>原生结构体的赋值过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个结构体, 拥有一个字段</span><br><span class="line">type data struct {</span><br><span class="line">    Hp int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkNativeAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    // 实例化结构体</span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    // 停止基准测试的计时器</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    // 重置基准测试计时器数据</span><br><span class="line">    b.ResetTimer()</span><br><span class="line"></span><br><span class="line">    // 重新启动基准测试计时器</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    // 根据基准测试数据进行循环测试</span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 结构体成员赋值测试</span><br><span class="line">        v.Hp = 3</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明一个普通结构体，拥有一个成员变量。</li>
<li>第 6 行，使用基准化测试的入口。</li>
<li>第 9 行，实例化 data 结构体，并给 Hp 成员赋值。</li>
<li>第 12～17 行，由于测试的重点必须放在赋值上，因此需要极大程度地降低其他代码的干扰，于是在赋值完成后，将基准测试的计时器复位并重新开始。</li>
<li>第 20 行，将基准测试提供的测试数量用于循环中。</li>
<li>第 23 行，测试的核心代码：结构体赋值。</li>
</ul>
<p>接下来的代码分析使用反射访问结构体成员并赋值的过程。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkReflectAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    // 取出结构体指针的反射值对象并取其元素</span><br><span class="line">    vv := reflect.ValueOf(&amp;v).Elem()</span><br><span class="line"></span><br><span class="line">    // 根据名字取结构体成员</span><br><span class="line">    f := vv.FieldByName("Hp")</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 反射测试设置成员值性能</span><br><span class="line">        f.SetInt(3)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行，取v的地址并转为反射值对象。此时值对象里的类型为 *data，使用值的 Elem() 方法取元素，获得 data 的反射值对象。</li>
<li>第 9 行，使用 FieldByName() 根据名字取出成员的反射值对象。</li>
<li>第 11～13 行，重置基准测试计时器。</li>
<li>第 18 行，使用反射值对象的 SetInt() 方法，给 data 结构的Hp字段设置数值 3。</li>
</ul>
<p>这段代码中使用了反射值对象的 SetInt() 方法，这个方法的源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) SetInt(x int64) {</span><br><span class="line">    v.mustBeAssignable()</span><br><span class="line">    switch k := v.kind(); k {</span><br><span class="line">    default:</span><br><span class="line">        panic(&amp;ValueError{"reflect.Value.SetInt", v.kind()})</span><br><span class="line">    case Int:</span><br><span class="line">        *(*int)(v.ptr) = int(x)</span><br><span class="line">    case Int8:</span><br><span class="line">        *(*int8)(v.ptr) = int8(x)</span><br><span class="line">    case Int16:</span><br><span class="line">        *(*int16)(v.ptr) = int16(x)</span><br><span class="line">    case Int32:</span><br><span class="line">        *(*int32)(v.ptr) = int32(x)</span><br><span class="line">    case Int64:</span><br><span class="line">        *(*int64)(v.ptr) = x</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现，整个设置过程都是指针转换及赋值，没有遍历及内存操作等相对耗时的算法。</p>
<h3 id="2-结构体成员搜索并赋值对比"><a href="#2-结构体成员搜索并赋值对比" class="headerlink" title="2)结构体成员搜索并赋值对比"></a>2)结构体成员搜索并赋值对比</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkReflectFindFieldAndAssign(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    v := data{Hp: 2}</span><br><span class="line"></span><br><span class="line">    vv := reflect.ValueOf(&amp;v).Elem()</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line"></span><br><span class="line">        // 测试结构体成员的查找和设置成员的性能</span><br><span class="line">        vv.FieldByName("Hp").SetInt(3)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码将反射值对象的 FieldByName() 方法与 SetInt() 方法放在循环里进行检测，主要对比测试 FieldByName() 方法对性能的影响。FieldByName() 方法源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) FieldByName(name string) Value {</span><br><span class="line">    v.mustBe(Struct)</span><br><span class="line">    if f, ok := v.typ.FieldByName(name); ok {</span><br><span class="line">        return v.FieldByIndex(f.Index)</span><br><span class="line">    }</span><br><span class="line">    return Value{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>底层代码说明如下：</p>
<ul>
<li>第 3 行，通过名字查询类型对象，这里有一次遍历过程。</li>
<li>第 4 行，找到类型对象后，使用 FieldByIndex() 继续在值中查找，这里又是一次遍历。</li>
</ul>
<p>经过底层代码分析得出，随着结构体字段数量和相对位置的变化，FieldByName() 方法比较严重的低效率问题。</p>
<h3 id="3-调用函数对比"><a href="#3-调用函数对比" class="headerlink" title="3)调用函数对比"></a>3)调用函数对比</h3><p>反射的函数调用，也是使用反射中容易忽视的性能点，下面展示对普通函数的调用过程。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 一个普通函数</span><br><span class="line">func foo(v int) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkNativeCall(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        // 原生函数调用</span><br><span class="line">        foo(0)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkReflectCall(b *testing.B) {</span><br><span class="line"></span><br><span class="line">    // 取函数的反射值对象</span><br><span class="line">    v := reflect.ValueOf(foo)</span><br><span class="line"></span><br><span class="line">    b.StopTimer()</span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    b.StartTimer()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; b.N; i++ {</span><br><span class="line">        // 反射调用函数</span><br><span class="line">        v.Call([]reflect.Value{reflect.ValueOf(2)})</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，一个普通的只有一个参数的函数。</li>
<li>第 10 行，对原生函数调用的性能测试。</li>
<li>第 17 行，根据函数名取出反射值对象。</li>
<li>第 25 行，使用 reflect.ValueOf(2) 将 2 构造为反射值对象，因为反射函数调用的参数必须全是反射值对象，再使用 []reflect.Value 构造多个参数列表传给反射值对象的 Call() 方法进行调用。</li>
</ul>
<p>反射函数调用的参数构造过程非常复杂，构建很多对象会造成很大的内存回收负担。Call() 方法内部就更为复杂，需要将参数列表的每个值从 reflect.Value 类型转换为内存。调用完毕后，还要将函数返回值重新转换为 reflect.Value 类型返回。因此，反射调用函数的性能堪忧。</p>
<h3 id="4-基准测试结果对比"><a href="#4-基准测试结果对比" class="headerlink" title="4)基准测试结果对比"></a>4)基准测试结果对比</h3><p>测试结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v -bench=.</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkNativeAssign-4                        2000000000               0.32 ns/op</span><br><span class="line">BenchmarkReflectAssign-4                       300000000               4.42 ns/op</span><br><span class="line">BenchmarkReflectFindFieldAndAssign-4           20000000               91.6 ns/op</span><br><span class="line">BenchmarkNativeCall-4                          2000000000               0.33 ns/op</span><br><span class="line">BenchmarkReflectCall-4                         10000000               163 ns/op</span><br><span class="line">PASS</span><br></pre></td></tr></tbody></table></figure>
<p>结果分析如下：</p>
<ul>
<li>第 4 行，原生的结构体成员赋值，每一步操作耗时 0.32 纳秒，这是参考基准。</li>
<li>第 5 行，使用反射的结构体成员赋值，操作耗时 4.42 纳秒，比原生赋值多消耗 13 倍的性能。</li>
<li>第 6 行，反射查找结构体成员且反射赋值，操作耗时 91.6 纳秒，扣除反射结构体成员赋值的 4.42 纳秒还富余，性能大概是原生的 272 倍。这个测试结果与代码分析结果很接近。SetInt 的性能可以接受，但 FieldByName() 的性能就非常低。</li>
<li>第 7 行，原生函数调用，性能与原生访问结构体成员接近。</li>
<li>第 8 行，反射函数调用，性能差到“爆棚”，花费了 163 纳秒，操作耗时比原生多消耗 494 倍。</li>
</ul>
<p>经过基准测试结果的数值分析及对比，最终得出以下结论：</p>
<ul>
<li>能使用原生代码时，尽量避免反射操作。</li>
<li>提前缓冲反射值对象，对性能有很大的帮助。</li>
<li>避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。</li>
</ul>
<h2 id="reflect-TypeOf-和reflect-Type（通过反射获取类型信息）"><a href="#reflect-TypeOf-和reflect-Type（通过反射获取类型信息）" class="headerlink" title="reflect.TypeOf()和reflect.Type（通过反射获取类型信息）"></a>reflect.TypeOf()和reflect.Type（通过反射获取类型信息）</h2><p>在 Go语言中通过调用 reflect.TypeOf 函数，我们可以从一个任何非接口类型的值创建一个 reflect.Type 值。reflect.Type 值表示着此非接口值的类型。通过此值，我们可以得到很多此非接口类型的信息。当然，我们也可以将一个接口值传递给一个 reflect.TypeOf 函数调用，但是此调用将返回一个表示着此接口值的动态类型的 reflect.Type 值。</p>
<p>实际上，reflect.TypeOf 函数的唯一参数的类型为 interface{}，reflect.TypeOf 函数将总是返回一个表示着此唯一接口参数值的动态类型的 reflect.Type 值。</p>
<p>那如何得到一个表示着某个接口类型的 reflect.Type 值呢？我们必须通过下面将要介绍的一些间接途径来达到这一目的。</p>
<p>类型 reflect.Type 为一个接口类型，它指定了若干方法（<code>https://golang.google.cn/pkg/reflect/#Type</code>）。 通过这些方法，我们能够观察到一个 reflect.Type 值所表示的 Go类型的各种信息。这些方法中的有的适用于所有种类（<code>https://golang.google.cn/pkg/reflect/#Kind</code>）的类型，有的只适用于一种或几种类型。通过不合适的 reflect.Type 属主值调用某个方法将在运行时产生一个恐慌。</p>
<p>使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。下面通过例子来理解获取类型对象的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line"></span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，定义一个 int 类型的变量。</li>
<li>第 12 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。</li>
<li>第 14 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。</li>
</ul>
<h3 id="理解反射的类型（Type）与种类（Kind）"><a href="#理解反射的类型（Type）与种类（Kind）" class="headerlink" title="理解反射的类型（Type）与种类（Kind）"></a>理解反射的类型（Type）与种类（Kind）</h3><p>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<p><strong>1) 反射种类（Kind）的定义：</strong></p>
<p>Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Invalid Kind = iota  // 非法类型</span><br><span class="line">    Bool                 // 布尔型</span><br><span class="line">    Int                  // 有符号整型</span><br><span class="line">    Int8                 // 有符号8位整型</span><br><span class="line">    Int16                // 有符号16位整型</span><br><span class="line">    Int32                // 有符号32位整型</span><br><span class="line">    Int64                // 有符号64位整型</span><br><span class="line">    Uint                 // 无符号整型</span><br><span class="line">    Uint8                // 无符号8位整型</span><br><span class="line">    Uint16               // 无符号16位整型</span><br><span class="line">    Uint32               // 无符号32位整型</span><br><span class="line">    Uint64               // 无符号64位整型</span><br><span class="line">    Uintptr              // 指针</span><br><span class="line">    Float32              // 单精度浮点数</span><br><span class="line">    Float64              // 双精度浮点数</span><br><span class="line">    Complex64            // 64位复数类型</span><br><span class="line">    Complex128           // 128位复数类型</span><br><span class="line">    Array                // 数组</span><br><span class="line">    Chan                 // 通道</span><br><span class="line">    Func                 // 函数</span><br><span class="line">    Interface            // 接口</span><br><span class="line">    Map                  // 映射</span><br><span class="line">    Ptr                  // 指针</span><br><span class="line">    Slice                // 切片</span><br><span class="line">    String               // 字符串</span><br><span class="line">    Struct               // 结构体</span><br><span class="line">    UnsafePointer        // 底层指针</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。</p>
<p>type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<p><strong>2)从类型对象中获取类型名称和种类的例子:</strong></p>
<p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。</p>
<p>类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>下面的代码中会对常量和结构体进行类型信息获取。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个Enum类型</span><br><span class="line">type Enum int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Zero Enum = 0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">    // 获取Zero常量的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(Zero)</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Println(typeOfA.Name(), typeOfA.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat struct</span><br><span class="line">Enum int</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 18 行，声明结构体类型 cat。</li>
<li>第 22 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。</li>
<li>第 25 行，输出cat的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。</li>
<li>第 28 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。</li>
<li>第 31 行，输出 Zero 对应的类型对象的类型名和种类。</li>
</ul>
<h2 id="reflect-Elem-——通过反射获取指针指向的元素类型"><a href="#reflect-Elem-——通过反射获取指针指向的元素类型" class="headerlink" title="reflect.Elem()——通过反射获取指针指向的元素类型"></a>reflect.Elem()——通过反射获取指针指向的元素类型</h2><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个 <code>*</code> 操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := &amp;cat{}</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("name:'%v' kind:'%v'\n",typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">    // 取类型的元素</span><br><span class="line">    typeOfCat = typeOfCat.Elem()</span><br><span class="line"></span><br><span class="line">    // 显示反射类型对象的名称和种类</span><br><span class="line">    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: ''  kind: 'ptr'</span><br><span class="line">element name: 'cat', element kind: 'struct'</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 15 行，创建了cat结构体的实例，ins 是一个 <code>*cat</code> 类型的指针变量。</li>
<li>第 18 行，对指针变量获取反射类型信息。</li>
<li>第 21 行，输出指针变量的类型名称和种类。Go 语言的反射中对所有指针变量的种类都是 Ptr，但注意，指针变量的类型名称是空，不是 <code>*cat</code> 。</li>
<li>第 24 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。</li>
<li>第 27 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。</li>
</ul>
<h2 id="通过反射获取结构体的成员类型"><a href="#通过反射获取结构体的成员类型" class="headerlink" title="通过反射获取结构体的成员类型"></a>通过反射获取结构体的成员类型</h2><p>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的 NumField() 和 Field() 方法获得结构体成员的详细信息。与成员获取相关的 reflect.Type 的方法如下表所示。</p>
<table>
    <caption>结构体成员访问的方法列表</caption>
    <thead><tr><th>方法</th><th>说明</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)StructField</td><td>根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)(StructField,bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。没有找到时&nbsp;bool返回false，当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)StructField</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)&nbsp;(StructField,bool)</td><td>根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<h3 id="结构体字段类型"><a href="#结构体字段类型" class="headerlink" title="结构体字段类型"></a>结构体字段类型</h3><p>reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（Struct Tag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。StructField 的结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type StructField struct {</span><br><span class="line">    Name string          // 字段名</span><br><span class="line">    PkgPath string       // 字段路径</span><br><span class="line">    Type      Type       // 字段反射类型对象</span><br><span class="line">    Tag       StructTag  // 字段的结构体标签</span><br><span class="line">    Offset    uintptr    // 字段在结构体中的相对偏移</span><br><span class="line">    Index     []int      // Type.FieldByIndex中的返回的索引值</span><br><span class="line">    Anonymous bool       // 是否为匿名字段</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字段说明如下。</p>
<ul>
<li>Name：为字段名称。</li>
<li>PkgPath：字段在结构体中的路径。</li>
<li>Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。</li>
<li>Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。</li>
<li>Index：FieldByIndex 中的索引顺序。</li>
<li>Anonymous：表示该字段是否为匿名字段。</li>
</ul>
<h3 id="获取成员反射信息"><a href="#获取成员反射信息" class="headerlink" title="获取成员反射信息"></a>获取成员反射信息</h3><p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<p>反射访问结构体成员类型及信息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明一个空结构体</span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line"></span><br><span class="line">        // 带有结构体tag的字段</span><br><span class="line">        Type int `json:"type" id:"100"`</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 创建cat的实例</span><br><span class="line">    ins := cat{Name: "mimi", Type: 1}</span><br><span class="line"></span><br><span class="line">    // 获取结构体实例的反射类型对象</span><br><span class="line">    typeOfCat := reflect.TypeOf(ins)</span><br><span class="line"></span><br><span class="line">    // 遍历结构体所有成员</span><br><span class="line">    for i := 0; i &lt; typeOfCat.NumField(); i++ {</span><br><span class="line"></span><br><span class="line">        // 获取每个成员的结构体字段类型</span><br><span class="line">        fieldType := typeOfCat.Field(i)</span><br><span class="line"></span><br><span class="line">        // 输出成员名和tag</span><br><span class="line">        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 通过字段名, 找到字段类型信息</span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line"></span><br><span class="line">        // 从tag中取出需要的tag</span><br><span class="line">        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: Name  tag: ''</span><br><span class="line">name: Type  tag: 'json:"type" id:"100"'</span><br><span class="line">type 100</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明了带有两个成员的 cat 结构体。</li>
<li>第 15 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以`开始和结尾的字符串。这个字符串在 Go 语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。</li>
<li>第 19 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。</li>
<li>第 22 行，获取实例的反射类型对象。</li>
<li>第 25 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。</li>
<li>第 28 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。</li>
<li>第 31 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是StructField 结构体。</li>
<li>第 35 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，cat Type 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。</li>
<li>第 38 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。</li>
</ul>
<h2 id="结构体标签-Struct-Tag"><a href="#结构体标签-Struct-Tag" class="headerlink" title="结构体标签 Struct Tag"></a>结构体标签 Struct Tag</h2><p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。</p>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<p><strong>提示:</strong></p>
<p>结构体标签（Struct Tag）类似于 C# 中的特性（Attribute）。C# 允许在类、字段、方法等前面添加 Attribute，然后在反射系统中可以获取到这个属性系统。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Conditional("DEBUG")]</span><br><span class="line">public static void Message(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg)；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体标签的格式"><a href="#结构体标签的格式" class="headerlink" title="结构体标签的格式"></a>结构体标签的格式</h3><p>Tag 在结构体字段后方书写的格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:"value1" key2:"value2"`</span><br></pre></td></tr></tbody></table></figure>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</p>
<h3 id="从结构体标签中获取值"><a href="#从结构体标签中获取值" class="headerlink" title="从结构体标签中获取值"></a>从结构体标签中获取值</h3><p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：</p>
<ul>
<li><code>func(tag StructTag)Get(key string)string</code></li>
<li>根据 Tag 中的键获取对应的值，例如 `key1:”value1”key2:”value2”` 的 Tag 中，可以传入“key1”获得“value1”。</li>
<li><code>func(tag StructTag)Lookup(key string)(value string,ok bool)</code></li>
<li>根据 Tag 中的键，查询值是否存在。</li>
</ul>
<h3 id="结构体标签格式错误导致的问题"><a href="#结构体标签格式错误导致的问题" class="headerlink" title="结构体标签格式错误导致的问题"></a>结构体标签格式错误导致的问题</h3><p>编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，参见下面这个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type cat struct {</span><br><span class="line">        Name string</span><br><span class="line">        Type int `json: "type" id:"100"`</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    typeOfCat := reflect.TypeOf(cat{})</span><br><span class="line"></span><br><span class="line">    if catType, ok := typeOfCat.FieldByName("Type"); ok {</span><br><span class="line"></span><br><span class="line">        fmt.Println(catType.Tag.Get("json"))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出空字符串，并不会输出期望的 type。</p>
<p>第 12 行中，在json:和”type”之间增加了一个空格。这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。</p>
<p>这个错误在开发中非常容易被疏忽，造成难以察觉的错误。</p>
<h2 id="reflect-ValueOf-和reflect-Value（通过反射获取值信息）"><a href="#reflect-ValueOf-和reflect-Value（通过反射获取值信息）" class="headerlink" title="reflect.ValueOf()和reflect.Value（通过反射获取值信息）"></a>reflect.ValueOf()和reflect.Value（通过反射获取值信息）</h2><p>当我们将一个接口值传递给一个 reflect.ValueOf 函数调用时，此调用返回的是代表着此接口值的动态值的一个 reflect.Value 值。我们必须通过间接的途径获得一个代表一个接口值的 reflect.Value 值。</p>
<p>reflect.Value 类型有很多方法（<code>https://golang.google.cn/pkg/reflect/</code>）。我们可以调用这些方法来观察和操纵一个 reflect.Value 属主值表示的 Go 值。这些方法中的有些适用于所有种类类型的值，有些只适用于一种或几种类型的值。</p>
<p>通过不合适的 reflect.Value 属主值调用某个方法将在运行时产生一个恐慌。请阅读 reflect 代码库中各个方法的文档来获取如何正确地使用这些方法。</p>
<p>一个 reflect.Value 值的 CanSet 方法将返回此 reflect.Value 值代表的 Go 值是否可以被修改（可以被赋值）。如果一个 Go 值可以被修改，则我们可以调用对应的 reflect.Value 值的 Set 方法来修改此 Go 值。注意：reflect.ValueOf 函数直接返回的 reflect.Value 值都是不可修改的。</p>
<p>反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用 reflect.Value 获取和设置变量的值。</p>
<h3 id="使用反射值对象包装任意值"><a href="#使用反射值对象包装任意值" class="headerlink" title="使用反射值对象包装任意值"></a>使用反射值对象包装任意值</h3><p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></tbody></table></figure>
<p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p>
<h3 id="从反射值对象获取被包装的值"><a href="#从反射值对象获取被包装的值" class="headerlink" title="从反射值对象获取被包装的值"></a>从反射值对象获取被包装的值</h3><p>Go语言中可以通过 reflect.Value 重新获得原始值。</p>
<p><strong>1)从反射值对象（reflect.Value）中获取值的方法:</strong></p>
<p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p>
<table>
    <caption>反射值获取原始值的方法</caption>
    <thead><tr><th>方法名</th><th>说&nbsp;明</th></tr></thead>
    <tbody>
        <tr><td>Interface()interface{}</td><td>将值以interface{}&nbsp;类型返回，可以通过类型断言转换为指定类型</td></tr>
        <tr><td>Int()int64</td><td>将值以int类型返回，所有有符号整型均可以此方式返回</td></tr>
        <tr><td>Uint()uint64</td><td>将值以uint类型返回，所有无符号整型均可以此方式返回</td></tr>
        <tr><td>Float()float64</td><td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr>
        <tr><td>Bool()bool</td><td>将值以bool类型返回</td></tr>
        <tr><td>Bytes()[]bytes</td><td>将值以字节数组[]bytes类型返回</td></tr>
        <tr><td>String()string</td><td>将值以字符串类型返回</td></tr>
    </tbody>
</table>

<p><strong>2)从反射值对象（reflect.Value）中获取值的例子:</strong></p>
<p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象</span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line"></span><br><span class="line">    // 获取interface{}类型的值, 通过类型断言转换</span><br><span class="line">    var getA int = valueOfA.Interface().(int)</span><br><span class="line"></span><br><span class="line">    // 获取64位的值, 强制类型转换为int类型</span><br><span class="line">    var getA2 int = int(valueOfA.Int())</span><br><span class="line"></span><br><span class="line">    fmt.Println(getA, getA2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1024 1024</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明一个变量，类型为 int，设置初值为 1024。</li>
<li>第 14 行，获取变量 a 的反射值对象，类型为 reflect.Value，这个过程和 reflect.TypeOf() 类似。</li>
<li>第 17 行，将 valueOfA 反射值对象以 interface{} 类型取出，通过类型断言转换为 int 类型并赋值给 getA。</li>
<li>第 20 行，将 valueOfA 反射值对象通过 Int 方法，以 int64 类型取出，通过强制类型转换，转换为原本的 int 类型。</li>
</ul>
<h2 id="通过反射访问结构体成员的值"><a href="#通过反射访问结构体成员的值" class="headerlink" title="通过反射访问结构体成员的值"></a>通过反射访问结构体成员的值</h2><p>反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。</p>
<table>
    <caption>反射值对象的成员访问方法</caption>
    <thead><tr><th>方&nbsp;法</th><th>备&nbsp;注</th></tr></thead>
    <tbody>
        <tr><td>Field(i int)Value</td><td>根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>NumField()int</td><td>返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByName(name string)Value</td><td>根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByIndex(index[]int)Value</td><td>多层成员访问时，根据[]int提供的每个结构体的字段索引，返回字段的值。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
        <tr><td>FieldByNameFunc(match func(string)bool)Value</td><td>根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机</td></tr>
    </tbody>
</table>

<p>下面代码构造一个结构体包含不同类型的成员。通过 reflect.Value 提供的成员访问函数，可以获得结构体值的各种数据。</p>
<p>反射访问结构体成员值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义结构体</span><br><span class="line">type dummy struct {</span><br><span class="line">    a int</span><br><span class="line">    b string</span><br><span class="line"></span><br><span class="line">    // 嵌入字段</span><br><span class="line">    float32</span><br><span class="line">    bool</span><br><span class="line"></span><br><span class="line">    next *dummy</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 值包装结构体</span><br><span class="line">    d := reflect.ValueOf(dummy{</span><br><span class="line">            next: &amp;dummy{},</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 获取字段数量</span><br><span class="line">    fmt.Println("NumField", d.NumField())</span><br><span class="line"></span><br><span class="line">    // 获取索引为2的字段(float32字段)</span><br><span class="line">    floatField := d.Field(2)</span><br><span class="line"></span><br><span class="line">    // 输出字段类型</span><br><span class="line">    fmt.Println("Field", floatField.Type())</span><br><span class="line"></span><br><span class="line">    // 根据名字查找字段</span><br><span class="line">    fmt.Println("FieldByName(\"b\").Type", d.FieldByName("b").Type())</span><br><span class="line"></span><br><span class="line">    // 根据索引查找值中, next字段的int字段的值</span><br><span class="line">    fmt.Println("FieldByIndex([]int{4, 0}).Type()", d.FieldByIndex([]int{4, 0}).Type())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，定义结构体，结构体的每个字段的类型都不一样。</li>
<li>第 24 行，实例化结构体并包装为 reflect.Value 类型，成员中包含一个  <code>*dummy</code> 的实例。</li>
<li>第 29 行，获取结构体的字段数量。</li>
<li>第 32 和 35 行，获取索引为2的字段值（float32 字段），并且打印类型。</li>
<li>第 38 行，根据b字符串，查找到 b 字段的类型。</li>
<li>第 41 行，[]int{4,0} 中的 4 表示，在 dummy 结构中索引值为 4 的成员，也就是 next。next 的类型为 dummy，也是一个结构体，因此使用 []int{4,0} 中的 0 继续在 next 值的基础上索引，结构为 dummy 中索引值为 0 的 a 字段，类型为 int。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumField 5</span><br><span class="line">Field float32</span><br><span class="line">FieldByName("b").Type string</span><br><span class="line">FieldByIndex([]int{4, 0}).Type() int</span><br></pre></td></tr></tbody></table></figure>
<h2 id="IsNil-和IsValid-——判断反射值的空和有效性"><a href="#IsNil-和IsValid-——判断反射值的空和有效性" class="headerlink" title="IsNil()和IsValid()——判断反射值的空和有效性"></a>IsNil()和IsValid()——判断反射值的空和有效性</h2><p>反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。</p>
<table>
    <caption>反射值对象的零值和有效性判断方法</caption>
    <thead><tr><th>方&nbsp;法</th><th>说&nbsp;明</th></tr></thead>
    <tbody>
        <tr><td>IsNil()bool</td><td colspan="2">返回值是否为nil。如果值类型不是通道（channel）、函数、接口、map、指针或切片时发生panic，类似于语言层的<code style="font-size: 14px;">v==nil</code>操作</td></tr>
        <tr><td>IsValid()&nbsp;bool</td><td>判断值是否有效。&nbsp;当值本身非法时，返回false，例如reflect Value不包含任何值，值为nil等。</td></tr>
    </tbody>
</table>

<p>下面的例子将会对各种方式的空指针进行 IsNil() 和 IsValid() 的返回值判定检测。同时对结构体成员及方法查找 map 键值对的返回值进行 IsValid() 判定，参考下面的代码。</p>
<p>反射值对象的零值和有效性判断：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // *int的空指针</span><br><span class="line">    var a *int</span><br><span class="line">    fmt.Println("var a *int:", reflect.ValueOf(a).IsNil())</span><br><span class="line"></span><br><span class="line">    // nil值</span><br><span class="line">    fmt.Println("nil:", reflect.ValueOf(nil).IsValid())</span><br><span class="line"></span><br><span class="line">    // *int类型的空指针</span><br><span class="line">    fmt.Println("(*int)(nil):", reflect.ValueOf((*int)(nil)).Elem().IsValid())</span><br><span class="line"></span><br><span class="line">    // 实例化一个结构体</span><br><span class="line">    s := struct{}{}</span><br><span class="line"></span><br><span class="line">    // 尝试从结构体中查找一个不存在的字段</span><br><span class="line">    fmt.Println("不存在的结构体成员:", reflect.ValueOf(s).FieldByName("").IsValid())</span><br><span class="line"></span><br><span class="line">    // 尝试从结构体中查找一个不存在的方法</span><br><span class="line">    fmt.Println("不存在的结构体方法:", reflect.ValueOf(s).MethodByName("").IsValid())</span><br><span class="line"></span><br><span class="line">    // 实例化一个map</span><br><span class="line">    m := map[int]int{}</span><br><span class="line"></span><br><span class="line">    // 尝试从map中查找一个不存在的键</span><br><span class="line">    fmt.Println("不存在的键：", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a *int: true</span><br><span class="line">nil: false</span><br><span class="line">(*int)(nil): false</span><br><span class="line">不存在的结构体成员: false</span><br><span class="line">不存在的结构体方法: false</span><br><span class="line">不存在的键： false</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，声明一个 <code>*int</code> 类型的指针，初始值为 nil。</li>
<li>第 12 行，将变量 a 包装为 reflect.Value 并且判断是否为空，此时变量 a 为空指针，因此返回 true。</li>
<li>第 15 行，对 nil 进行 IsValid() 判定（有效性判定），返回 false。</li>
<li>第 18 行，<code>(*int)(nil)</code> 的含义是将 nil 转换为 <code>*int</code>，也就是 <code>*int</code> 类型的空指针。此行将 nil 转换为 <code>*int</code> 类型，并取指针指向元素。由于 nil 不指向任何元素，<code>*int</code> 类型的 nil 也不能指向任何元素，值不是有效的。因此这个反射值使用 Isvalid() 判断时返回 false。</li>
<li>第 21 行，实例化一个结构体。</li>
<li>第 24 行，通过 FieldByName 查找 s 结构体中一个空字符串的成员，如成员不存在，IsValid() 返回 false。</li>
<li>第 27 行，通过 MethodByName 查找 s 结构体中一个空字符串的方法，如方法不存在，IsValid() 返回 false。</li>
<li>第 30 行，实例化一个 map，这种写法与 make 方式创建的 map 等效。</li>
<li>第 33 行，MapIndex() 方法能根据给定的 reflect.Value 类型的值查找 map，并且返回查找到的结果。</li>
</ul>
<p>IsNil() 常被用于判断指针是否为空；IsValid() 常被用于判定返回值是否有效</p>
<h2 id="通过反射修改变量的值"><a href="#通过反射修改变量的值" class="headerlink" title="通过反射修改变量的值"></a>通过反射修改变量的值</h2><p>Go语言中类似 x、x.f[1] 和 <code>*p</code> 形式的表达式都可以表示变量，但是其它如 <code>x + 1</code> 和 f(2) 则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。</p>
<p>对于 reflect.Values 也有类似的区别。有一些 reflect.Values 是可取地址的；其它一些则不可以。考虑以下的声明语句：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := 2 // value type variable?</span><br><span class="line">a := reflect.ValueOf(2) // 2 int no</span><br><span class="line">b := reflect.ValueOf(x) // 2 int no</span><br><span class="line">c := reflect.ValueOf(&amp;x) // &amp;x *int no</span><br><span class="line">d := c.Elem() // 2 int yes (x)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的 Value。</p>
<p>我们可以通过调用 reflect.Value 的 CanAddr 方法来判断其是否可以被取地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a.CanAddr()) // "false"</span><br><span class="line">fmt.Println(b.CanAddr()) // "false"</span><br><span class="line">fmt.Println(c.CanAddr()) // "false"</span><br><span class="line">fmt.Println(d.CanAddr()) // "true"</span><br></pre></td></tr></tbody></table></figure>
<p>每当我们通过指针间接地获取的 reflect.Value 都是可取地址的，即使开始的是一个不可取地址的 Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice 的索引表达式 e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。</p>
<p>以此类推，reflect.ValueOf(e).Index(i) 对于的值也是可取地址的，即使原始的 reflect.ValueOf(e) 不支持也没有关系。</p>
<p>使用 reflect.Value 对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。</p>
<h3 id="判定及获取元素的相关方法"><a href="#判定及获取元素的相关方法" class="headerlink" title="判定及获取元素的相关方法"></a>判定及获取元素的相关方法</h3><p>使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。</p>
<table>
    <caption>反射值对象的判定及获取元素的方法</caption>
    <thead><tr><th>方法名</th><th>备&nbsp;注</th></tr></thead>
    <tbody>
        <tr><td>Elem()Value</td><td>取值指向的元素值，类似于语言层<code style="font-size: 14px;">*</code>操作。当值类型不是指针或接口时发生宕机，空指针时返回nil的Value</td></tr>
        <tr><td>Addr()Value</td><td>对可寻址的值返回其地址，类似于语言层<code style="font-size: 14px;">&amp;</code>操作。当值不可寻址时发生宕机</td></tr>
        <tr><td>CanAddr()bool</td><td>表示值是否可寻址</td></tr><tr><td>CanSet()&nbsp;bool</td><td>返回值能否被修改。要求值可寻址且是导出的字段</td></tr>
    </tbody>
</table>

<h3 id="值修改相关方法"><a href="#值修改相关方法" class="headerlink" title="值修改相关方法"></a>值修改相关方法</h3><p>使用 reflect.Value 修改值的相关方法如下表所示。</p>
<table border="1">
    <caption>反射值对象修改值的方法</caption>
    <thead><tr><th>Set(x Value)</th><th>将值设置为传入的反射值对象的值</th></tr></thead>
    <tbody>
        <tr><td>Setlnt(x int64)</td><td>使用int64设置值。当值的类型不是int、int8、int16、&nbsp;int32、int64时会发生宕机</td></tr>
        <tr><td>SetUint(x uint64)</td><td>使用uint64设置值。当值的类型不是uint、uint8、uint16、uint32、uint64时会发生宕机</td></tr>
        <tr><td>SetFloat(x float64)</td><td>使用float64设置值。当值的类型不是float32、float64时会发生宕机</td></tr>
        <tr><td>SetBool(x bool)</td><td>使用bool设置值。当值的类型不是bod时会发生宕机</td></tr>
        <tr><td>SetBytes(x[]byte)</td><td>设置字节数组[]bytes值。当值的类型不是[]byte时会发生宕机</td></tr>
        <tr><td>SetString(x string)</td><td>设置字符串值。当值的类型不是string时会发生宕机</td></tr>
    </tbody>
</table>

<p>以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。</p>
<p>在已知值的类型时，应尽量使用值对应类型的反射设置值。</p>
<h3 id="值可修改条件之一：可被寻址"><a href="#值可修改条件之一：可被寻址" class="headerlink" title="值可修改条件之一：可被寻址"></a>值可修改条件之一：可被寻址</h3><p>通过反射修改变量值的前提条件之一：这个值必须可以被寻址。简单地说就是这个变量必须能被修改。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象</span><br><span class="line">    valueOfA := reflect.ValueOf(a)</span><br><span class="line"></span><br><span class="line">    // 尝试将a修改为1(此处会发生崩溃)</span><br><span class="line">    valueOfA.SetInt(1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序运行崩溃，打印错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>报错意思是：SetInt 正在使用一个不能被寻址的值。从 reflect.ValueOf 传入的是 a 的值，而不是 a 的地址，这个 reflect.Value 当然是不能被寻址的。将代码修改一下，重新运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明整型变量a并赋初值</span><br><span class="line">    var a int = 1024</span><br><span class="line"></span><br><span class="line">    // 获取变量a的反射值对象(a的地址)</span><br><span class="line">    valueOfA := reflect.ValueOf(&amp;a)</span><br><span class="line"></span><br><span class="line">    // 取出a地址的元素(a的值)</span><br><span class="line">    valueOfA = valueOfA.Elem()</span><br><span class="line"></span><br><span class="line">    // 修改a的值为1</span><br><span class="line">    valueOfA.SetInt(1)</span><br><span class="line"></span><br><span class="line">    // 打印a的值</span><br><span class="line">    fmt.Println(valueOfA.Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对代码的分析：</p>
<ul>
<li>第 14 行中，将变量 a 取值后传给 reflect.ValueOf()。此时 reflect.ValueOf() 返回的 valueOfA 持有变量 a 的地址。</li>
<li>第 17 行中，使用 reflect.Value 类型的 Elem() 方法获取 a 地址的元素，也就是 a 的值。reflect.Value 的 Elem() 方法返回的值类型也是 reflect.Value。</li>
<li>第 20 行，此时 valueOfA 表示的是 a 的值且可以寻址。使用 SetInt() 方法设置值时不再发生崩溃。</li>
<li>第 23 行，正确打印修改的值。</li>
</ul>
<p><strong>提示：</strong></p>
<p>当 reflect.Value 不可寻址时，使用 Addr() 方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的 Addr() 方法类似于语言层的&amp;操作；Elem() 方法类似于语言层的*操作，但并不代表这些方法与语言层操作等效。</p>
<h3 id="值可修改条件之一：被导出"><a href="#值可修改条件之一：被导出" class="headerlink" title="值可修改条件之一：被导出"></a>值可修改条件之一：被导出</h3><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type dog struct {</span><br><span class="line">            legCount int</span><br><span class="line">    }</span><br><span class="line">    // 获取dog实例的反射值对象</span><br><span class="line">    valueOfDog := reflect.ValueOf(dog{})</span><br><span class="line"></span><br><span class="line">    // 获取legCount字段的值</span><br><span class="line">    vLegCount := valueOfDog.FieldByName("legCount")</span><br><span class="line"></span><br><span class="line">    // 尝试设置legCount的值(这里会发生崩溃)</span><br><span class="line">    vLegCount.SetInt(4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序发生崩溃，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span><br></pre></td></tr></tbody></table></figure>
<p>报错的意思是：SetInt() 使用的值来自于一个未导出的字段。</p>
<p>为了能修改这个值，需要将该字段导出。将 dog 中的 legCount 的成员首字母大写，导出 LegCount 让反射可以访问，修改后的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type dog struct {</span><br><span class="line">    LegCount int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vLegCount := valueOfDog.FieldByName("LegCount")</span><br></pre></td></tr></tbody></table></figure>
<p>再次运行程序，发现仍然报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using unaddressable value</span><br></pre></td></tr></tbody></table></figure>
<p>这个错误表示第 13 行构造的 valueOfDog 这个结构体实例不能被寻址，因此其字段也不能被修改。修改代码，取结构体的指针，再通过 reflect.Value 的 Elem() 方法取到值的反射值对象。修改后的完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "reflect"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    type dog struct {</span><br><span class="line">            LegCount int</span><br><span class="line">    }</span><br><span class="line">    // 获取dog实例地址的反射值对象</span><br><span class="line">    valueOfDog := reflect.ValueOf(&amp;dog{})</span><br><span class="line"></span><br><span class="line">    // 取出dog实例地址的元素</span><br><span class="line">    valueOfDog = valueOfDog.Elem()</span><br><span class="line"></span><br><span class="line">    // 获取legCount字段的值</span><br><span class="line">    vLegCount := valueOfDog.FieldByName("LegCount")</span><br><span class="line"></span><br><span class="line">    // 尝试设置legCount的值(这里会发生崩溃)</span><br><span class="line">    vLegCount.SetInt(4)</span><br><span class="line"></span><br><span class="line">    fmt.Println(vLegCount.Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 11 行，将 LegCount 首字母大写导出该字段。</li>
<li>第 14 行，获取 dog 实例指针的反射值对象。</li>
<li>第 17 行，取 dog 实例的指针元素，也就是 dog 的实例。</li>
<li>第 20 行，取 dog 结构体中 LegCount 字段的成员值。</li>
<li>第 23 行，修改该成员值。</li>
<li>第 25 行，打印该成员值。</li>
</ul>
<p>值的修改从表面意义上叫可寻址，换一种说法就是值必须“可被设置”。那么，想修改变量值，一般的步骤是：</p>
<ul>
<li>取这个变量的地址或者这个变量所在的结构体已经是指针类型。</li>
<li>使用 reflect.ValueOf 进行值包装。</li>
<li>通过 Value.Elem() 获得指针值指向的元素值对象（Value），因为值对象（Value）内部对象为指针时，使用 set 设置时会报出宕机错误。</li>
<li>使用 Value.Set 设置值。</li>
</ul>
<h2 id="通过类型信息创建实例"><a href="#通过类型信息创建实例" class="headerlink" title="通过类型信息创建实例"></a>通过类型信息创建实例</h2><p>当已知 reflect.Type 时，可以动态地创建这个类型的实例，实例的类型为指针。例如 reflect.Type 的类型为 int 时，创建 int 的指针，即 <code>*int</code>，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var a int</span><br><span class="line"></span><br><span class="line">    // 取变量a的反射类型对象</span><br><span class="line">    typeOfA := reflect.TypeOf(a)</span><br><span class="line"></span><br><span class="line">    // 根据反射类型对象创建类型实例</span><br><span class="line">    aIns := reflect.New(typeOfA)</span><br><span class="line"></span><br><span class="line">    // 输出Value的类型和种类</span><br><span class="line">    fmt.Println(aIns.Type(), aIns.Kind())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*int ptr</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，获取变量 a 的反射类型对象。</li>
<li>第 16 行，使用 reflect.New() 函数传入变量 a 的反射类型对象，创建这个类型的实例值，值以 reflect.Value 类型返回。这步操作等效于：new(int)，因此返回的是 <code>*int</code> 类型的实例。</li>
<li>第 19 行，打印 aIns 的类型为 <code>*int</code> ，种类为指针。</li>
</ul>
<h2 id="通过反射调用函数"><a href="#通过反射调用函数" class="headerlink" title="通过反射调用函数"></a>通过反射调用函数</h2><p>如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将参数使用反射值对象的切片 []reflect.Value 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。</p>
<p>下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。</p>
<p>反射调用函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 普通函数</span><br><span class="line">func add(a, b int) int {</span><br><span class="line"></span><br><span class="line">    return a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将函数包装为反射值对象</span><br><span class="line">    funcValue := reflect.ValueOf(add)</span><br><span class="line"></span><br><span class="line">    // 构造函数参数, 传入两个整型值</span><br><span class="line">    paramList := []reflect.Value{reflect.ValueOf(10), reflect.ValueOf(20)}</span><br><span class="line"></span><br><span class="line">    // 反射调用函数</span><br><span class="line">    retList := funcValue.Call(paramList)</span><br><span class="line"></span><br><span class="line">    // 获取第一个返回值, 取整数值</span><br><span class="line">    fmt.Println(retList[0].Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9～12 行，定义一个普通的加法函数。</li>
<li>第 17 行，将 add 函数包装为反射值对象。</li>
<li>第 20 行，将 10 和 20 两个整型值使用 reflect.ValueOf 包装为 reflect.Value，再将反射值对象的切片 []reflect.Value 作为函数的参数。</li>
<li>第 23 行，使用 funcValue 函数值对象的 Call() 方法，传入参数列表 paramList 调用 add() 函数。</li>
<li>第 26 行，调用成功后，通过 retList[0] 取返回值的第一个参数，使用 Int 取返回值的整数值。</li>
</ul>
<p><strong>提示：</strong></p>
<p>反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。</p>
<h2 id="inject库：依赖注入"><a href="#inject库：依赖注入" class="headerlink" title="inject库：依赖注入"></a>inject库：依赖注入</h2><p>在介绍 inject 之前我们先来简单介绍一下“依赖注入”和“控制反转”这两个概念。</p>
<p>正常情况下，对函数或方法的调用是我们的主动直接行为，在调用某个函数之前我们需要清楚地知道被调函数的名称是什么，参数有哪些类型等等。</p>
<p>所谓的控制反转就是将这种主动行为变成间接的行为，我们不用直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为称作“控制反转”，库和框架能很好的解释控制反转的概念。</p>
<p>依赖注入是实现控制反转的一种方法，如果说控制反转是一种设计思想，那么依赖注入就是这种思想的一种实现，通过注入参数或实例的方式实现控制反转。如果没有特殊说明，我们可以认为依赖注入和控制反转是一个东西。</p>
<p>控制反转的价值在于解耦，有了控制反转就不需要将代码写死，可以让控制反转的的框架代码读取配置，动态的构建对象，这一点在 Java 的 Spring 框架中体现的尤为突出。</p>
<h3 id="inject-实践"><a href="#inject-实践" class="headerlink" title="inject 实践"></a>inject 实践</h3><p>inject 是依赖注入的Go语言实现，它能在运行时注入参数，调用方法，是 Martini 框架（Go语言中著名的 Web 框架）的基础核心。</p>
<p>在介绍具体实现之前，先来想一个问题，如何通过一个字符串类型的函数名来调用函数？Go语言没有 Java 中的 Class.forName 方法可以通过类名直接构造对象，所以这种方法是行不通的，能想到的方法就是使用 map 实现一个字符串到函数的映射，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func fl() {</span><br><span class="line">    println ("fl")</span><br><span class="line">}</span><br><span class="line">func f2 () {</span><br><span class="line">    println ("f2")</span><br><span class="line">}</span><br><span class="line">funcs := make(map[string] func ())</span><br><span class="line">funcs ["fl"] = fl</span><br><span class="line">funcs ["f2"] = fl</span><br><span class="line">funcs ["fl"]()</span><br><span class="line">funcs ["f2"]()</span><br></pre></td></tr></tbody></table></figure>
<p>但是这有个缺陷，就是 map 的 Value 类型被写成 func()，不同参数和返回值的类型的函数并不能通用。将 map 的 Value 定义为 interface{} 空接口类型即可以解决该问题，但需要借助类型断言或反射来实现，通过类型断言实现等于又绕回去了，反射是一种可行的办法。</p>
<p>inject 包借助反射实现函数的注入调用，下面通过一个示例来看一下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S1 interface{}</span><br><span class="line">type S2 interface{}</span><br><span class="line"></span><br><span class="line">func Format(name string, company S1, level S2, age int) {</span><br><span class="line">    fmt.Printf("name ＝ %s, company=%s, level=%s, age ＝ %d!\n", name, company, level, age)</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    //控制实例的创建</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    //实参注入</span><br><span class="line">    inj.Map("tom")</span><br><span class="line">    inj.MapTo("tencent", (*S1)(nil))</span><br><span class="line">    inj.MapTo("T4", (*S2)(nil))</span><br><span class="line">    inj.Map(23)</span><br><span class="line">    //函数反转调用</span><br><span class="line">    inj.Invoke(Format)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name ＝ tom, company=tencent, level=T4, age ＝ 23!</span><br></pre></td></tr></tbody></table></figure>
<p>可见 inject 提供了一种注入参数调用函数的通用功能，inject.New() 相当于创建了一个控制实例，由其来实现对函数的注入调用。inject 包不但提供了对函数的注入，还实现了对 struct 类型的注入，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S1 interface{}</span><br><span class="line">type S2 interface{}</span><br><span class="line">type Staff struct {</span><br><span class="line">    Name    string `inject`</span><br><span class="line">    Company S1     `inject`</span><br><span class="line">    Level   S2     `inject`</span><br><span class="line">    Age     int    `inject`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建被注入实例</span><br><span class="line">    s := Staff{}</span><br><span class="line">    //控制实例的创建</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    //初始化注入值</span><br><span class="line">    inj.Map("tom")</span><br><span class="line">    inj.MapTo("tencent", (*S1)(nil))</span><br><span class="line">    inj.MapTo("T4", (*S2)(nil))</span><br><span class="line">    inj.Map(23)</span><br><span class="line">    //实现对 struct 注入</span><br><span class="line">    inj.Apply(&amp;s)</span><br><span class="line">    //打印结果</span><br><span class="line">    fmt.Printf("s ＝ %v\n", s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s ＝ {tom tencent T4 23}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到 inject 提供了一种对结构类型的通用注入方法。至此，我们仅仅从宏观层面了解 iniect 能做什么，下面从源码实现角度来分析 inject。</p>
<h3 id="inject-原理分析"><a href="#inject-原理分析" class="headerlink" title="inject 原理分析"></a>inject 原理分析</h3><p>inject 包中只有 2 个文件，一个是 inject.go 文件和一个 inject_test.go 文件，这里我们只需要关注 inject.go 文件即可。</p>
<p>inject.go 短小精悍，包括注释和空行在内才 157 行代码，代码中定义了 4 个接口，包括一个父接口和三个子接口，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Injector interface {</span><br><span class="line">    Applicator</span><br><span class="line">    Invoker</span><br><span class="line">    TypeMapper</span><br><span class="line">    SetParent(Injector)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Applicator interface {</span><br><span class="line">    Apply(interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Invoker interface {</span><br><span class="line">    Invoke(interface{}) ([]reflect.Value, error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type TypeMapper interface {</span><br><span class="line">    Map(interface{}) TypeMapper</span><br><span class="line">    MapTo(interface{}, interface{}) TypeMapper</span><br><span class="line">    Get(reflect.Type) reflect.Value</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Injector 接口是 Applicator、Invoker、TypeMapper 接口的父接口，所以实现了 Injector 接口的类型，也必然实现了 Applicator、Invoker 和 TypeMapper 接口：</p>
<ul>
<li>Applicator 接口只规定了 Apply 成员，它用于注入 struct。</li>
<li>Invoker 接口只规定了 Invoke 成员，它用于执行被调用者。</li>
<li>TypeMapper 接口规定了三个成员，Map 和 MapTo 都用于注入参数，但它们有不同的用法，Get 用于调用时获取被注入的参数。</li>
</ul>
<p>另外 Injector 还规定了 SetParent 行为，它用于设置父 Injector，其实它相当于查找继承。也即通过 Get 方法在获取被注入参数时会一直追溯到 parent，这是个递归过程，直到查找到参数或为 nil 终止。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type injector struct {</span><br><span class="line">    values map[reflect.Type]reflect.Value</span><br><span class="line">    parent Injector</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func InterfaceOf(value interface{}) reflect.Type {</span><br><span class="line">    t := reflect.TypeOf(value)</span><br><span class="line"></span><br><span class="line">    for t.Kind() == reflect.Ptr {</span><br><span class="line">        t = t.Elem()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if t.Kind() != reflect.Interface {</span><br><span class="line">        panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return t</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func New() Injector {</span><br><span class="line">    return &amp;injector{</span><br><span class="line">        values: make(map[reflect.Type]reflect.Value),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>injector 是 inject 包中唯一定义的 struct，所有的操作都是基于 injector struct 来进行的，它有两个成员 values 和 parent。values 用于保存注入的参数，是一个用 reflect.Type 当键、reflect.Value 为值的 map，理解这点将有助于理解 Map 和 MapTo。</p>
<p>New 方法用于初始化 injector struct，并返回一个指向 injector struct 的指针，但是这个返回值被 Injector 接口包装了。</p>
<p>InterfaceOf 方法虽然只有几句实现代码，但它是 Injector 的核心。InterfaceOf 方法的参数必须是一个接口类型的指针，如果不是则引发 panic。InterfaceOf 方法的返回类型是 reflect.Type，大家应该还记得 injector 的成员 values 就是一个 reflect.Type 类型当键的 map。这个方法的作用其实只是获取参数的类型，而不关心它的值。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(inject.InterfaceOf((*interface{})(nil)))</span><br><span class="line">    fmt.Println(inject.InterfaceOf((*SpecialString)(nil)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface {}</span><br><span class="line">main.SpecialString</span><br></pre></td></tr></tbody></table></figure>
<p>InterfaceOf 方法就是用来得到参数类型，而不关心它具体存储的是什么值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func (i *injector) Map(val interface{}) TypeMapper {</span><br><span class="line">    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {</span><br><span class="line">    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)</span><br><span class="line">    return i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) Get(t reflect.Type) reflect.Value {</span><br><span class="line">    val := i.values[t]</span><br><span class="line">    if !val.IsValid() &amp;&amp; i.parent != nil {</span><br><span class="line">        val = i.parent.Get(t)</span><br><span class="line">    }</span><br><span class="line">    return val</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (i *injector) SetParent(parent Injector) {</span><br><span class="line">    i.parent = parent</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Map 和 MapTo 方法都用于注入参数，保存于 injector 的成员 values 中。这两个方法的功能完全相同，唯一的区别就是 Map 方法用参数值本身的类型当键，而 MapTo 方法有一个额外的参数可以指定特定的类型当键。但是 MapTo 方法的第二个参数 ifacePtr 必须是接口指针类型，因为最终 ifacePtr 会作为 InterfaceOf 方法的参数。</p>
<p>为什么需要有 MapTo 方法？因为注入的参数是存储在一个以类型为键的 map 中，可想而知，当一个函数中有一个以上的参数的类型是一样时，后执行 Map 进行注入的参数将会覆盖前一个通过 Map 注入的参数。</p>
<p>SetParent 方法用于给某个 Injector 指定父 Injector。Get 方法通过 reflect.Type 从 injector 的 values 成员中取出对应的值，它可能会检查是否设置了 parent，直到找到或返回无效的值，最后 Get 方法的返回值会经过 IsValid 方法的校验。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "reflect"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("C语言中文网")</span><br><span class="line">    inj.MapTo("Golang", (*SpecialString)(nil))</span><br><span class="line">    inj.Map(20)</span><br><span class="line">    fmt.Println("字符串是否有效？", inj.Get(reflect.TypeOf("Go语言入门教程")).IsValid())</span><br><span class="line">    fmt.Println("特殊字符串是否有效？", inj.Get(inject.InterfaceOf((*SpecialString)(nil))).IsValid())</span><br><span class="line">    fmt.Println("int 是否有效？", inj.Get(reflect.TypeOf(18)).IsValid())</span><br><span class="line">    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map([]byte("test"))</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串是否有效？ true</span><br><span class="line">特殊字符串是否有效？ true</span><br><span class="line">int 是否有效？ true</span><br><span class="line">[]byte 是否有效？ false</span><br><span class="line">[]byte 是否有效？ true</span><br></pre></td></tr></tbody></table></figure>
<p>通过以上例子应该知道 SetParent 是什么样的行为，是不是很像面向对象中的查找链？</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {</span><br><span class="line">    t := reflect.TypeOf(f)</span><br><span class="line"></span><br><span class="line">    var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func</span><br><span class="line">    for i := 0; i &lt; t.NumIn(); i++ {</span><br><span class="line">        argType := t.In(i)</span><br><span class="line">        val := inj.Get(argType)</span><br><span class="line">        if !val.IsValid() {</span><br><span class="line">            return nil, fmt.Errorf("Value not found for type %v", argType)</span><br><span class="line">        }</span><br><span class="line">        in[i] = val</span><br><span class="line">    }</span><br><span class="line">    return reflect.ValueOf(f).Call(in), nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Invoke 方法用于动态执行函数，当然执行前可以通过 Map 或 MapTo 来注入参数，因为通过 Invoke 执行的函数会取出已注入的参数，然后通过 reflect 包中的 Call 方法来调用。Invoke 接收的参数 f 是一个接口类型，但是 f 的底层类型必须为 func，否则会 panic。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">func Say(name string, gender SpecialString, age int) {</span><br><span class="line">    fmt.Printf("My name is %s, gender is %s, age is %d!\n", name, gender, age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("张三")</span><br><span class="line">    inj.MapTo("男", (*SpecialString)(nil))</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map(25)</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    inj.Invoke(Say)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name is 张三, gender is 男, age is 25!</span><br></pre></td></tr></tbody></table></figure>
<p>上面的例子如果没有定义 SpecialString 接口作为 gender 参数的类型，而把 name 和 gender 都定义为 string 类型，那么 gender 会覆盖 name 的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func (inj *injector) Apply(val interface{}) error {</span><br><span class="line">    v := reflect.ValueOf(val)</span><br><span class="line"></span><br><span class="line">    for v.Kind() == reflect.Ptr {</span><br><span class="line">        v = v.Elem()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if v.Kind() != reflect.Struct {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; v.NumField(); i++ {</span><br><span class="line">        f := v.Field(i)</span><br><span class="line">        structField := t.Field(i)</span><br><span class="line">        if f.CanSet() &amp;&amp; structField.Tag == "inject" {</span><br><span class="line">            ft := f.Type()</span><br><span class="line">            v := inj.Get(ft)</span><br><span class="line">            if !v.IsValid() {</span><br><span class="line">                return fmt.Errorf("Value not found for type %v", ft)</span><br><span class="line">            }</span><br><span class="line">            f.Set(v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Apply 方法是用于对 struct 的字段进行注入，参数为指向底层类型为结构体的指针。可注入的前提是：字段必须是导出的（也即字段名以大写字母开头），并且此字段的 tag 设置为 `inject`。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "github.com/codegangsta/inject"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SpecialString interface{}</span><br><span class="line"></span><br><span class="line">type TestStruct struct {</span><br><span class="line">    Name   string `inject`</span><br><span class="line">    Nick   []byte</span><br><span class="line">    Gender SpecialString `inject`</span><br><span class="line">    uid    int           `inject`</span><br><span class="line">    Age    int           `inject`</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    s := TestStruct{}</span><br><span class="line">    inj := inject.New()</span><br><span class="line">    inj.Map("张三")</span><br><span class="line">    inj.MapTo("男", (*SpecialString)(nil))</span><br><span class="line">    inj2 := inject.New()</span><br><span class="line">    inj2.Map(26)</span><br><span class="line">    inj.SetParent(inj2)</span><br><span class="line">    inj.Apply(&amp;s)</span><br><span class="line">    fmt.Println("s.Name =", s.Name)</span><br><span class="line">    fmt.Println("s.Gender =", s.Gender)</span><br><span class="line">    fmt.Println("s.Age =", s.Age)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.Name = 张三</span><br><span class="line">s.Gender = 男</span><br><span class="line">s.Age = 26</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/b3ea2e2d/">https://wssjdi.github.io/posts/b3ea2e2d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/go-%E5%8F%8D%E5%B0%84/">go 反射</a><a class="post-meta__tags" href="/tags/go-reflect/">go reflect</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/543a448f/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go文件处理</div></div></a></div><div class="next-post pull-right"><a href="/posts/eae873a8/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">go 并发，Golang并发</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/91175219/" title="Go流程控制"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go流程控制</div></div></a></div><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>