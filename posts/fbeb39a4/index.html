<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go函数 | Wssjdi</title><meta name="description" content="go"><meta name="keywords" content="go,函数"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/fbeb39a4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go函数"><meta property="og:url" content="https://wssjdi.github.io/posts/fbeb39a4/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-20T09:47:55.000Z"><meta property="article:modified_time" content="2020-10-21T15:45:58.664Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-21 23:45:58'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%88%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-text">函数声明（函数定义）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-text">普通函数声明（定义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">同一种类型返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">带有变量名的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B0%86%E7%A7%92%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B7%E4%BD%93%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">示例：将秒转换为具体的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%95%88%E6%9E%9C%E6%B5%8B%E8%AF%95"><span class="toc-text">示例：函数中的参数传递效果测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">测试数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-text">值传递的测试函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-text">测试流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E2%80%94%E2%80%94%E6%8A%8A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC%E4%BF%9D%E5%AD%98%E5%88%B0%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-text">函数变量——把函数作为值保存到变量中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-text">字符串的链式处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">字符串处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">自定义的处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">字符串处理主流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E5%90%8D%E5%AD%97%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数——没有函数名字的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">定义一个匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E8%B0%83%E7%94%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">在定义时调用匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F"><span class="toc-text">将匿名函数赋值给变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%94%A8%E4%BD%9C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数用作回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E5%B0%81%E8%A3%85"><span class="toc-text">使用匿名函数实现操作封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数类型实现接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">结构体实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数体实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8C%85%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">HTTP包中的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="toc-text">闭包（Closure）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%97%AD%E5%8C%85%E5%86%85%E9%83%A8%E4%BF%AE%E6%94%B9%E5%BC%95%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">在闭包内部修改引用的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%97%AD%E5%8C%85%E7%9A%84%E8%AE%B0%E5%BF%86%E6%95%88%E5%BA%94"><span class="toc-text">示例：闭包的记忆效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">示例：闭包实现生成器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%88%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">可变参数（变参函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">可变参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">任意类型的可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">遍历可变参数列表——获取每一个参数的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E8%8E%B7%E5%BE%97%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">获得可变参数类型——获得每一个参数的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">在多个可变参数函数中传递参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer%EF%BC%88%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%EF%BC%89"><span class="toc-text">defer（延迟执行语句）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F"><span class="toc-text">多个延迟执行语句的处理顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E5%9C%A8%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E6%97%B6%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-text">使用延迟执行语句在函数退出时释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E5%B9%B6%E5%8F%91%E8%A7%A3%E9%94%81"><span class="toc-text">使用延迟并发解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E9%87%8A%E6%94%BE%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84"><span class="toc-text">使用延迟释放文件句柄</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-text">递归函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%98%B6%E4%B9%98"><span class="toc-text">数字阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E7%BB%84%E6%88%90%E9%80%92%E5%BD%92"><span class="toc-text">多个函数组成递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF"><span class="toc-text">处理运行时错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net-%E5%8C%85%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">net 包中的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="toc-text">错误接口的定义格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF"><span class="toc-text">自定义一个错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#errors-%E5%8C%85"><span class="toc-text">errors 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E5%AE%9A%E4%B9%89"><span class="toc-text">在代码中使用错误定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8%E8%A7%A3%E6%9E%90%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-text">示例：在解析中使用自定义错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%95%E6%9C%BA%EF%BC%88panic%EF%BC%89%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C"><span class="toc-text">宕机（panic）——程序终止运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%AE%95%E6%9C%BA"><span class="toc-text">手动触发宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%BE%9D%E8%B5%96%E7%9A%84%E5%BF%85%E5%A4%87%E8%B5%84%E6%BA%90%E7%BC%BA%E5%A4%B1%E6%97%B6%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%AE%95%E6%9C%BA"><span class="toc-text">在运行依赖的必备资源缺失时主动触发宕机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-Compile-expr-string-Regexp-error"><span class="toc-text">func Compile(expr string) (*Regexp, error)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#func-MustCompile-str-string-Regexp"><span class="toc-text">func MustCompile(str string) *Regexp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AE%95%E6%9C%BA%E6%97%B6%E8%A7%A6%E5%8F%91%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5"><span class="toc-text">在宕机时触发延迟执行语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%95%E6%9C%BA%E6%81%A2%E5%A4%8D%EF%BC%88recover%EF%BC%89%E2%80%94%E2%80%94%E9%98%B2%E6%AD%A2%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83"><span class="toc-text">宕机恢复（recover）——防止程序崩溃</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%B4%A9%E6%BA%83%E6%97%B6%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C"><span class="toc-text">让程序在崩溃时继续执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-%E5%92%8C-recover-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">panic 和 recover 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-text">计算函数执行时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E6%9D%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-text">通过内存缓存来提升性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">普通的实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">内存缓存的实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">函数的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6"><span class="toc-text">函数调用规约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80"><span class="toc-text">汇编基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E6%B1%87%E7%BC%96%E7%AE%80%E4%BB%8B"><span class="toc-text">Go 汇编简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E%E5%88%86%E6%9E%90"><span class="toc-text">多值返回分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">闭包底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#func-a-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">func a() 函数分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-text">main() 函数分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-text">Test功能测试函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B5%8B%E8%AF%95"><span class="toc-text">为什么需要测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A7%84%E5%88%99"><span class="toc-text">测试规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%EF%BC%88%E5%8A%9F%E8%83%BD%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-text">单元（功能）测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%EF%BC%88%E5%8E%8B%E5%8A%9B%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-text">性能（压力）测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87%E6%B5%8B%E8%AF%95"><span class="toc-text">覆盖率测试</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go函数</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-20T09:47:55.000Z" title="发表于 2020-10-20 17:47:55">2020-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-21T15:45:58.664Z" title="更新于 2020-10-21 23:45:58">2020-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p>
<p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p>
<p>Go 语言的函数属于“一等公民”（first-class），也就是说：</p>
<ul>
<li>函数本身可以作为值进行传递。</li>
<li>支持匿名函数和闭包（closure）。</li>
<li>函数可以满足接口。</li>
</ul>
<h2 id="函数声明（函数定义）"><a href="#函数声明（函数定义）" class="headerlink" title="函数声明（函数定义）"></a>函数声明（函数定义）</h2><p>函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。</p>
<p>因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</p>
<p>编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。</p>
<p>当函数执行到代码块最后一行 <code>}</code> 之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。</p>
<p>Go语言里面拥三种类型的函数：</p>
<ul>
<li>普通的带有名字的函数</li>
<li>匿名函数或者 lambda 函数</li>
<li>方法</li>
</ul>
<h3 id="普通函数声明（定义）"><a href="#普通函数声明（定义）" class="headerlink" title="普通函数声明（定义）"></a>普通函数声明（定义）</h3><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func 函数名(形式参数列表)(返回值列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</p>
<p>如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func hypot(x, y float64) float64 {</span><br><span class="line">    return math.Sqrt(x*x + y*y)</span><br><span class="line">}</span><br><span class="line">fmt.Println(hypot(3,4)) // "5"</span><br></pre></td></tr></tbody></table></figure>
<p>x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。</p>
<p>如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。</p>
<p>正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func f(i, j, k int, s, t string) { /* ... */ }</span><br><span class="line">func f(i int, j int, k int, s string, t string) { /* ... */ }</span><br></pre></td></tr></tbody></table></figure>
<p>下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符 <code>_</code> 可以强调某个参数未被使用。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func add(x int, y int) int {return x + y}</span><br><span class="line">func sub(x, y int) (z int) { z = x - y; return}</span><br><span class="line">func first(x int, _ int) int { return x }</span><br><span class="line">func zero(int, int) int { return 0 }</span><br><span class="line">fmt.Printf("%T\n", add) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", sub) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", first) // "func(int, int) int"</span><br><span class="line">fmt.Printf("%T\n", zero) // "func(int, int) int"</span><br></pre></td></tr></tbody></table></figure>
<p>函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。</p>
<p>每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p>在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToNetwork()</span><br></pre></td></tr></tbody></table></figure>
<p>在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。</p>
<p>其它编程语言中函数的返回值</p>
<ul>
<li>C/C++ 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果，C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。</li>
<li>C# 语言也没有多返回值特性，C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。</li>
<li>lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。</li>
</ul>
<p>Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</p>
<h4 id="同一种类型返回值"><a href="#同一种类型返回值" class="headerlink" title="同一种类型返回值"></a>同一种类型返回值</h4><p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。</p>
<p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func typedTwoValues() (int, int) {</span><br><span class="line">    return 1, 2</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    a, b := typedTwoValues()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p>
<h4 id="带有变量名的返回值"><a href="#带有变量名的返回值" class="headerlink" title="带有变量名的返回值"></a>带有变量名的返回值</h4><p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p>
<p>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。</p>
<p>下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line"></span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，对两个整型返回值进行命名，分别为 a 和 b。</li>
<li>第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。</li>
<li>第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int) {</span><br><span class="line">    a = 1</span><br><span class="line">    return a, 2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>提示:同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：</em></strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func namedRetValues() (a, b int, int)</span><br></pre></td></tr></tbody></table></figure>
<p>编译报错提示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed named and unnamed function parameters</span><br></pre></td></tr></tbody></table></figure>
<p>意思是：在函数参数中混合使用了命名和非命名参数。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p>
<p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p>
<p>Go语言的函数调用格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></tbody></table></figure>
<p>下面是对各个部分的说明：</p>
<ul>
<li>函数名：需要调用的函数名。</li>
<li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li>
<li>返回值变量列表：多个返回值使用逗号分隔。</li>
</ul>
<p>例如，加法函数调用样式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := add(1,1)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：将秒转换为具体的时间"><a href="#示例：将秒转换为具体的时间" class="headerlink" title="示例：将秒转换为具体的时间"></a>示例：将秒转换为具体的时间</h3><p>使用一个数值表示时间中的“秒”值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。</p>
<p>【示例】将秒解析为时间单位：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    // 定义每分钟的秒数</span><br><span class="line">    SecondsPerMinute = 60</span><br><span class="line"></span><br><span class="line">    // 定义每小时的秒数</span><br><span class="line">    SecondsPerHour = SecondsPerMinute * 60</span><br><span class="line"></span><br><span class="line">    // 定义每天的秒数</span><br><span class="line">    SecondsPerDay = SecondsPerHour * 24</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将传入的“秒”解析为3种时间单位</span><br><span class="line">func resolveTime(seconds int) (day int, hour int, minute int) {</span><br><span class="line"></span><br><span class="line">    day = seconds / SecondsPerDay</span><br><span class="line">    hour = seconds / SecondsPerHour</span><br><span class="line">    minute = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将返回值作为打印参数</span><br><span class="line">    fmt.Println(resolveTime(1000))</span><br><span class="line"></span><br><span class="line">    // 只获取小时和分钟</span><br><span class="line">    _, hour, minute := resolveTime(18000)</span><br><span class="line">    fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">    // 只获取天</span><br><span class="line">    day, _, _ := resolveTime(90000)</span><br><span class="line">    fmt.Println(day)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 16</span><br><span class="line">5 300</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，定义每分钟的秒数。</li>
<li>第 10 行，定义每小时的秒数，SecondsPerHour 常量值会在编译期间计算出结果。</li>
<li>第 13 行，定义每天的秒数。</li>
<li>第 17 行，定义 resolveTime() 函数，根据输入的秒数，返回 3 个整型值，含义分别是秒数对应的天数、小时数和分钟数（取整）。</li>
<li>第 29 行中，给定 1000 秒，对应是 16（16.6667 取整）分钟的秒数，resolveTime() 函数返回的 3 个变量会传递给 fmt.Println() 函数进行打印，因为 fmt.Println() 使用了可变参数，可以接收不定量的参数。</li>
<li>第 32 行，将 resolveTime() 函数中的 3 个返回值使用变量接收，但是第一个返回参数使用匿名函数接收，表示忽略这个变量。</li>
<li>第 36 行，忽略后两个返回值，只使用第一个返回值。</li>
</ul>
<h3 id="示例：函数中的参数传递效果测试"><a href="#示例：函数中的参数传递效果测试" class="headerlink" title="示例：函数中的参数传递效果测试"></a>示例：函数中的参数传递效果测试</h3><p>Go语言中传入和返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。</p>
<p>下面通过一个例子来详细了解Go语言的参数值传递。请先看完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import"fmt"</span><br><span class="line"></span><br><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Data struct {</span><br><span class="line">    complax []int //测试切片在参数传递中的效果</span><br><span class="line">    instance InnerData //实例分配的innerData</span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct {</span><br><span class="line">    a int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="测试数据类型"><a href="#测试数据类型" class="headerlink" title="测试数据类型"></a>测试数据类型</h4><p>为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用于测试值传递效果的结构体</span><br><span class="line">type Datas truct{</span><br><span class="line">    complax []int//测试切片在参数传递中的效果</span><br><span class="line"></span><br><span class="line">    instance InnerData//实例分配的innerData</span><br><span class="line"></span><br><span class="line">    ptr *InnerData//将ptr声明为InnerData的指针类型</span><br><span class="line">}</span><br><span class="line">//代表各种结构体字段</span><br><span class="line">type InnerData struct{</span><br><span class="line">    aint</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，将Data声明为结构体类型，结构体是拥有多个字段的复杂结构。</li>
<li>第3行，complax为整型切片类型，切片是一种动态类型，内部以指针存在。</li>
<li>第5行，instance成员以InnerData类型作为Data的成员。</li>
<li>第7行，将ptr声明为InnerData的指针类型。</li>
<li>第11行，声明一个内嵌的结构InnerData。</li>
</ul>
<h4 id="值传递的测试函数"><a href="#值传递的测试函数" class="headerlink" title="值传递的测试函数"></a>值传递的测试函数</h4><p>本节中定义的passByValue()函数用于值传递的测试，该函数的参数和返回值都是Data类型。在调用中，Data的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量。代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//值传递测试函数</span><br><span class="line">func passByValue(inFunc Data) Data {</span><br><span class="line"></span><br><span class="line">    //输出参数的成员情况</span><br><span class="line">    fmt.Printf("inFuncvalue:%+vn",inFunc)</span><br><span class="line"></span><br><span class="line">    //打印inFunc的指针</span><br><span class="line">    fmt.Printf("inFuncptr:%pn",&amp;inFunc)</span><br><span class="line"></span><br><span class="line">    return inFunc</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行，使用格式化的%+v动词输出in变量的详细结构，以便观察Data结构在传递前后的内部数值的变化情况。</li>
<li>第8行，打印传入参数inFunc的指针地址。在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。</li>
<li>第10行，将传入的变量作为返回值返回，返回的过程将发生值复制。</li>
</ul>
<h4 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h4><p>测试流程会准备一个Data格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针。通过调用测试函数，传入Data结构数据，并获得返回值，对比输入和输出后的Data结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备传入函数的结构</span><br><span class="line">    in := Data {</span><br><span class="line">        complax:[]int{1,2,3},</span><br><span class="line">        instance:InnerData{5,},</span><br><span class="line">        ptr:&amp;InnerData{1},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //输入结构的成员情况</span><br><span class="line">    fmt.Printf("invalue:%+vn",in)</span><br><span class="line"></span><br><span class="line">    //输入结构的指针地址</span><br><span class="line">    fmt.Printf("inptr:%pn",&amp;in)</span><br><span class="line"></span><br><span class="line">    //传入结构体，返回同类型的结构体</span><br><span class="line">    out := passByValue(in)</span><br><span class="line"></span><br><span class="line">    //输出结构的成员情况</span><br><span class="line">    fmt.Printf("outvalue:%+vn",out)</span><br><span class="line"></span><br><span class="line">    //输出结构的指针地址</span><br><span class="line">    fmt.Printf("outptr:%pn",&amp;out)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第3行，创建一个Data结构的实例in。</li>
<li>第4行，将切片数据赋值到in的complax成员。</li>
<li>第5行，为in的instance成员赋值InnerData结构的数据。</li>
<li>第6行，为in的ptr成员赋值InnerData的指针类型数据。</li>
<li>第10行，打印输入结构的成员情况。</li>
<li>第13行，打印输入结构的指针地址。</li>
<li>第16行，传入in结构，调用passByvalue()测试函数获得out返回，此时，passByValue()函数会打印in传入后的数据成员情况。</li>
<li>第19行，打印返回值out变量的成员情况。</li>
<li>第22行，打印输出结构的地址。<br>运行代码，输出结果为：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninptr:0xc0000b4330ninFuncvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}ninFuncptr:0xc0000b43c0no</span><br><span class="line">utvalue:{complax:[1 2 3] instance:{a:5} ptr:0xc0000a0068}noutptr:0xc0000b4390n</span><br></pre></td></tr></tbody></table></figure>
<p>从运行结果中发现：</p>
<ul>
<li>所有的Data结构的指针地址发生了变化，意味着所有的结构都是一块新的内存，无论是将Data结构传入函数内部，还是通过函数返回值传回Data都会发生复制行为。</li>
<li>所有的Data结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。</li>
<li>Data结构的ptr成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。</li>
</ul>
<h3 id="函数变量——把函数作为值保存到变量中"><a href="#函数变量——把函数作为值保存到变量中" class="headerlink" title="函数变量——把函数作为值保存到变量中"></a>函数变量——把函数作为值保存到变量中</h3><p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func fire() {</span><br><span class="line">    fmt.Println("fire")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var f func()</span><br><span class="line"></span><br><span class="line">    f = fire</span><br><span class="line"></span><br><span class="line">    f()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fire</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 7 行，定义了一个 fire() 函数。</li>
<li>第 13 行，将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil。</li>
<li>第 15 行，将 fire() 函数作为值，赋给函数变量 f，此时 f 的值为 fire() 函数。</li>
<li>第 17 行，使用函数变量 f 进行函数调用，实际调用的是 fire() 函数。</li>
</ul>
<h3 id="字符串的链式处理"><a href="#字符串的链式处理" class="headerlink" title="字符串的链式处理"></a>字符串的链式处理</h3><p>使用SQL语言从数据库中获取数据时，可以对原始数据进行排序（sortby）、分组（groupby）和去重（distinct）等操作。SQL将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。</p>
<p>对数据的操作进行多步骤的处理被称为链式处理。本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。</p>
<p>完整代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(strstring) string {</span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list:=[]string {"goscanner","goparser","gocompiler","goprinter","goformater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><p>字符串处理函数（StringProccess）需要外部提供数据源：一个字符串切片 <code>（list[]string）</code>，另外还要提供一个链式处理函数的切片 <code>（chain[]func(string)string）</code>，链式处理切片中的一个处理函数的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(string) string</span><br></pre></td></tr></tbody></table></figure>
<p>这种处理函数能够接受一个字符串输入，处理后输出。</p>
<p>strings包中将字符串变为小写就是一种处理函数的形式，<code>strings.ToLower()</code> 函数能够将传入的字符串的每一个字符变为小写，<code>strings.ToLower</code>定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ToLower(s string) string</span><br></pre></td></tr></tbody></table></figure>
<p>字符串处理函数（StringProccess）内部遍历每一个数据源提供的字符串，每个字符串都需要经过一系列链式处理函数处理后被重新放回切片，参见下面代码。</p>
<p>字符串的链式处理：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//字符串处理函数，传入字符串切片和处理链</span><br><span class="line">func StringProccess(list[]string , chain[] func (string) string){</span><br><span class="line"></span><br><span class="line">    //遍历每一个字符串</span><br><span class="line">    for index , str := range list {</span><br><span class="line"></span><br><span class="line">        //第一个需要处理的字符串</span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        //遍历每一个处理链</span><br><span class="line">        for _ , proc := range chain {</span><br><span class="line"></span><br><span class="line">            //输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span><br><span class="line">            result = proc(result)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //将结果放回切片</span><br><span class="line">        list[index] = result</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，传入字符串切片list作为数据源，一系列的处理函数作为chain处理链。</li>
<li>第5行，遍历字符串切片的每个字符串，依次对每个字符串进行处理。</li>
<li>第8行，将当前字符串保存到result变量中，作为第一个处理函数的参数。</li>
<li>第11行，遍历每一个处理函数，将字符串按顺序经过这些处理函数处理。</li>
<li>第14行，result变量即是每个处理函数的输入变量，处理后的变量又会重新保存到result变量中。</li>
<li>第18行，将处理完的字符串保存回切片中。</li>
</ul>
<h4 id="自定义的处理函数"><a href="#自定义的处理函数" class="headerlink" title="自定义的处理函数"></a>自定义的处理函数</h4><p>处理函数可以是系统提供的处理函数，如将字符串变大写或小写，也可以使用自定义函数。本例中的字符串处理的逻辑是使用一个自定义的函数实现移除指定go前缀的过程，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//自定义的移除前缀的处理函数</span><br><span class="line">func removePrefix(str string) string {</span><br><span class="line"></span><br><span class="line">    return strings.TrimPrefix(str,"go")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此函数使用了strings.TrimPrefix()函数实现移除字符串的指定前缀。处理后，移除前缀的字符串结果将通过removePrefix()函数的返回值返回。</p>
<h4 id="字符串处理主流程"><a href="#字符串处理主流程" class="headerlink" title="字符串处理主流程"></a>字符串处理主流程</h4><p>字符串处理的主流程包含以下几个步骤：</p>
<ul>
<li>准备要处理的字符串列表。</li>
<li>准备字符串处理链。</li>
<li>处理字符串列表。</li>
<li>打印输出后的字符串列表。</li>
</ul>
<p>详细流程参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //待处理的字符串列表</span><br><span class="line">    list := []string {"go scanner","go parser","go compiler","go printer","go formater",}</span><br><span class="line"></span><br><span class="line">    //处理函数链</span><br><span class="line">    chain := []func( string ) string {removePrefix,strings.TrimSpace,strings.ToUpper,}</span><br><span class="line"></span><br><span class="line">    //处理字符串</span><br><span class="line">    StringProccess( list , chain)</span><br><span class="line"></span><br><span class="line">    //输出处理好的字符串</span><br><span class="line">    for _ , str := range list {</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，定义字符串切片，字符串包含go前缀及空格。</li>
<li>第13行，准备处理每个字符串的处理链，处理的顺序与函数在切片中的位置一致。removePrefix()为自定义的函数，功能是移除go前缀；移除前缀的字符串左边有一个空格，使用strings.TrimSpace移除，这个函数的定义刚好符合处理函数的格式：func(string)string；strings.ToUpper用于将字符串转为大写。</li>
<li>第20行，传入字符串切片和字符串处理链，通过StringProcess()函数对字符串进行处理。</li>
<li>第23行，遍历字符串切片的每一个字符串，打印处理好的字符串结果。</li>
</ul>
<p><strong><em>提示:链式处理器是一种常见的编程设计。Netty是使用Java语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty中就有类似的链式处理器的设计。</em></strong></p>
<p>Netty可以使用类似的处理链对封包进行收发编码及处理。Netty的开发者可以分为3种：</p>
<ul>
<li>第一种是Netty底层开发者</li>
<li>第二种是每个处理环节的开发者</li>
<li>第三种是业务实现者，在实际开发环节中，后两种开发者往往是同一批开发者。</li>
</ul>
<p>链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。</p>
<h2 id="匿名函数——没有函数名字的函数"><a href="#匿名函数——没有函数名字的函数" class="headerlink" title="匿名函数——没有函数名字的函数"></a>匿名函数——没有函数名字的函数</h2><p>Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。</p>
<h3 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a>定义一个匿名函数</h3><p>匿名函数的定义格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数列表)(返回参数列表){</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的定义就是没有名字的普通函数定义。</p>
<h4 id="在定义时调用匿名函数"><a href="#在定义时调用匿名函数" class="headerlink" title="在定义时调用匿名函数"></a>在定义时调用匿名函数</h4><p>匿名函数可以在声明后调用，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}(100)</span><br></pre></td></tr></tbody></table></figure>
<p>注意第3行 <code>}</code> 后的 <code>(100)</code> ，表示对匿名函数进行调用，传递参数为 100。</p>
<h4 id="将匿名函数赋值给变量"><a href="#将匿名函数赋值给变量" class="headerlink" title="将匿名函数赋值给变量"></a>将匿名函数赋值给变量</h4><p>匿名函数可以被赋值，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将匿名函数体保存到f()中</span><br><span class="line">f := func(data int) {</span><br><span class="line">    fmt.Println("hello", data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 使用f()调用</span><br><span class="line">f(100)</span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p>
<h3 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a>匿名函数用作回调函数</h3><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 遍历切片的每个元素, 通过给定函数进行元素访问</span><br><span class="line">func visit(list []int, f func(int)) {</span><br><span class="line"></span><br><span class="line">    for _, v := range list {</span><br><span class="line">        f(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用匿名函数打印切片内容</span><br><span class="line">    visit([]int{1, 2, 3, 4}, func(v int) {</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。</li>
<li>第 18 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。</li>
<li>第 19～20 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。</li>
</ul>
<p>匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TrimFunc(s string, f func(rune) bool) string {</span><br><span class="line">    return TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用匿名函数实现操作封装"><a href="#使用匿名函数实现操作封装" class="headerlink" title="使用匿名函数实现操作封装"></a>使用匿名函数实现操作封装</h3><p>下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var skillParam = flag.String("skill", "", "skill to perform")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    var skill = map[string]func(){</span><br><span class="line">        "fire": func() {</span><br><span class="line">            fmt.Println("chicken fire")</span><br><span class="line">        },</span><br><span class="line">        "run": func() {</span><br><span class="line">            fmt.Println("soldier run")</span><br><span class="line">        },</span><br><span class="line">        "fly": func() {</span><br><span class="line">            fmt.Println("angel fly")</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if f, ok := skill[*skillParam]; ok {</span><br><span class="line">        f()</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("skill not found")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义命令行参数 skill，从命令行输入 <code>--skill</code> 可以将 <code>=</code> 后的字符串传入 skillParam 指针变量。</li>
<li>第 12 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。</li>
<li>第 14 行，定义一个从字符串映射到 <code>func()</code> 的 map，然后填充这个 map。</li>
<li>第 15～23 行，初始化 map 的键值对，值为匿名函数。</li>
<li>第 26 行，skillParam 是一个 <code>*string</code> 类型的指针变量，使用 <code>*skillParam</code> 获取到命令行传过来的值，并在 <code>map</code> 中查找对应命令行参数指定的字符串的函数。</li>
<li>第 29 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。</li>
</ul>
<p>运行代码，结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fly</span><br><span class="line">angel fly</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=fire</span><br><span class="line">chicken fire</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=run</span><br><span class="line">soldier run</span><br><span class="line"></span><br><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go --skill=go</span><br><span class="line">skill not found</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数类型实现接口"><a href="#函数类型实现接口" class="headerlink" title="函数类型实现接口"></a>函数类型实现接口</h2><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将对结构体与函数实现接口的过程进行对比。</p>
<p>完整的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明接口变量</span><br><span class="line">    var invoker Invoker</span><br><span class="line"></span><br><span class="line">    // 实例化结构体</span><br><span class="line">    s := new(Struct)</span><br><span class="line"></span><br><span class="line">    // 将实例化的结构体赋值到接口</span><br><span class="line">    invoker = s</span><br><span class="line"></span><br><span class="line">    // 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line"></span><br><span class="line">    // 将匿名函数转为FuncCaller类型，再赋值给接口</span><br><span class="line">    invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">        fmt.Println("from function", v)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 使用接口调用FuncCaller.Call，内部会调用函数本体</span><br><span class="line">    invoker.Call("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">from struct hello</span><br><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure>
<p>有如下一个接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 调用器接口</span><br><span class="line">type Invoker interface {</span><br><span class="line">    // 需要实现一个Call()方法</span><br><span class="line">    Call(interface{})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个接口需要实现 Call() 方法，调用时会传入一个 interface{} 类型的变量，这种类型的变量表示任意类型的值。</p>
<p>接下来，使用结构体进行接口实现。</p>
<h3 id="结构体实现接口"><a href="#结构体实现接口" class="headerlink" title="结构体实现接口"></a>结构体实现接口</h3><p>结构体实现 Invoker 接口的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 结构体类型</span><br><span class="line">type Struct struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (s *Struct) Call(p interface{}) {</span><br><span class="line">    fmt.Println("from struct", p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义结构体，该例子中的结构体无须任何成员，主要展示实现 Invoker 的方法。</li>
<li>第 6 行，Call() 为结构体的方法，该方法的功能是打印 from struct 和传入的 interface{} 类型的值。</li>
</ul>
<p>将定义的 Struct 类型实例化，并传入接口中进行调用，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 实例化结构体</span><br><span class="line">s := new(Struct)</span><br><span class="line"></span><br><span class="line">// 将实例化的结构体赋值到接口</span><br><span class="line">invoker = s</span><br><span class="line"></span><br><span class="line">// 使用接口调用实例化结构体的方法Struct.Call</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明 Invoker 类型的变量。</li>
<li>第 5 行，使用 new 将结构体实例化，此行也可以写为 <code>s := &amp;Struct</code>。</li>
<li>第 8 行，s 类型为 <code>*Struct</code> ，已经实现了 Invoker 接口类型，因此赋值给 invoker 时是成功的。</li>
<li>第 11 行，通过接口的 <code>Call()</code> 方法，传入 hello ，此时将调用 Struct 结构体的 <code>Call()</code> 方法。</li>
</ul>
<p>接下来，对比下函数实现结构体的差异。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from struct hello</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数体实现接口"><a href="#函数体实现接口" class="headerlink" title="函数体实现接口"></a>函数体实现接口</h3><p>函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义为类型</span><br><span class="line">type FuncCaller func(interface{})</span><br><span class="line"></span><br><span class="line">// 实现Invoker的Call</span><br><span class="line">func (f FuncCaller) Call(p interface{}) {</span><br><span class="line"></span><br><span class="line">    // 调用f()函数本体</span><br><span class="line">    f(p)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，将 func(interface{}) 定义为 FuncCaller 类型。</li>
<li>第 5 行，FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。</li>
<li>第 8 行，FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。</li>
</ul>
<p>上面代码只是定义了函数类型，需要函数本身进行逻辑处理，FuncCaller 无须被实例化，只需要将函数转换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明接口变量</span><br><span class="line">var invoker Invoker</span><br><span class="line"></span><br><span class="line">// 将匿名函数转为FuncCaller类型, 再赋值给接口</span><br><span class="line">invoker = FuncCaller(func(v interface{}) {</span><br><span class="line">    fmt.Println("from function", v)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">// 使用接口调用FuncCaller.Call, 内部会调用函数本体</span><br><span class="line">invoker.Call("hello")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，声明接口变量。</li>
<li>第 5 行，将 func(v interface{}){} 匿名函数转换为 FuncCaller 类型（函数签名才能转换），此时 FuncCaller 类型实现了 Invoker 的 Call() 方法，赋值给 invoker 接口是成功的。</li>
<li>第 10 行，使用接口方法调用。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from function hello</span><br></pre></td></tr></tbody></table></figure>
<h3 id="HTTP包中的例子"><a href="#HTTP包中的例子" class="headerlink" title="HTTP包中的例子"></a>HTTP包中的例子</h3><p>HTTP 包中包含有 Handler 接口定义，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler interface {</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Handler 用于定义每个 HTTP 的请求和响应的处理过程。</p>
<p>同时，也可以使用处理函数实现接口，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="line"></span><br><span class="line">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</span><br><span class="line">    f(w, r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。</p>
<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数 + 引用环境 = 闭包</span><br></pre></td></tr></tbody></table></figure>
<p>同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/closure.jpg" alt="图：闭包与函数引用"></p>
<p>一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。</p>
<p><strong><em>其它编程语言中的闭包</em></strong></p>
<p>闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。</p>
<p>闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。</p>
<p>在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。</p>
<p>闭包在各种语言中的实现也是不尽相同的，在 Lua 语言中，无论闭包还是函数都属于 Prototype 概念，被捕获的变量以 Upvalue 的形式引用到闭包中。</p>
<p>C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。</p>
<h3 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a>在闭包内部修改引用的变量</h3><p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 准备一个字符串</span><br><span class="line">str := "hello world"</span><br><span class="line"></span><br><span class="line">// 创建一个匿名函数</span><br><span class="line">foo := func() {</span><br><span class="line"></span><br><span class="line">    // 匿名函数中访问str</span><br><span class="line">    str = "hello dude"</span><br><span class="line">}</span><br><span class="line">// 调用匿名函数</span><br><span class="line">foo()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，准备一个字符串用于修改。</li>
<li>第 5 行，创建一个匿名函数。</li>
<li>第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。</li>
<li>第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。</li>
</ul>
<p>代码输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello dude</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：闭包的记忆效应"><a href="#示例：闭包的记忆效应" class="headerlink" title="示例：闭包的记忆效应"></a>示例：闭包的记忆效应</h3><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p>
<p>累加器的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 提供一个值, 每次调用函数会指定对值进行累加</span><br><span class="line">func Accumulate(value int) func() int {</span><br><span class="line"></span><br><span class="line">    // 返回一个闭包</span><br><span class="line">    return func() int {</span><br><span class="line"></span><br><span class="line">        // 累加</span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        // 返回一个累加值</span><br><span class="line">        return value</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator := Accumulate(1)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator)</span><br><span class="line"></span><br><span class="line">    // 创建一个累加器, 初始值为1</span><br><span class="line">    accumulator2 := Accumulate(10)</span><br><span class="line"></span><br><span class="line">    // 累加1并打印</span><br><span class="line">    fmt.Println(accumulator2())</span><br><span class="line"></span><br><span class="line">    // 打印累加器的函数地址</span><br><span class="line">    fmt.Printf("%p\n", &amp;accumulator2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">0xc000006028</span><br><span class="line">11</span><br><span class="line">0xc000006038</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。</li>
<li>第 11 行，返回一个闭包函数，每次返回会创建一个新的函数实例。</li>
<li>第 14 行，对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</li>
<li>第 17 行，将修改后的值通过闭包的返回值返回。</li>
<li>第 24 行，创建一个累加器，初始值为 1，返回的 accumulator 是类型为 func()int 的函数变量。</li>
<li>第 27 行，调用 accumulator() 时，代码从 11 行开始执行匿名函数逻辑，直到第 17 行返回。</li>
<li>第 32 行，打印累加器的函数地址。</li>
</ul>
<p>对比输出的日志发现 accumulator 与 accumulator2 输出的函数地址不同，因此它们是两个不同的闭包实例。</p>
<p>每调用一次 accumulator 都会自动对引用的变量进行累加。</p>
<h3 id="示例：闭包实现生成器"><a href="#示例：闭包实现生成器" class="headerlink" title="示例：闭包实现生成器"></a>示例：闭包实现生成器</h3><p>闭包的记忆效应被用于实现类似于<a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">设计模式</a>中工厂模式的生成器，下面的例子展示了创建一个玩家生成器的过程。</p>
<p>玩家生成器的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 创建一个玩家生成器, 输入名称, 输出生成器</span><br><span class="line">func playerGen(name string) func() (string, int) {</span><br><span class="line"></span><br><span class="line">    // 血量一直为150</span><br><span class="line">    hp := 150</span><br><span class="line"></span><br><span class="line">    // 返回创建的闭包</span><br><span class="line">    return func() (string, int) {</span><br><span class="line"></span><br><span class="line">        // 将变量引用到闭包中</span><br><span class="line">        return name, hp</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建一个玩家生成器</span><br><span class="line">    generator := playerGen("high noon")</span><br><span class="line"></span><br><span class="line">    // 返回玩家的名字和血量</span><br><span class="line">    name, hp := generator()</span><br><span class="line"></span><br><span class="line">    // 打印值</span><br><span class="line">    fmt.Println(name, hp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high noon 150</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，playerGen() 需要提供一个名字来创建一个玩家的生成函数。</li>
<li>第 11 行，声明并设定 hp 变量为 150。</li>
<li>第 14～18 行，将 hp 和 name 变量引用到匿名函数中形成闭包。</li>
<li>第 24 行中，通过 playerGen 传入参数调用后获得玩家生成器。</li>
<li>第 27 行，调用这个玩家生成器函数，可以获得玩家的名称和血量。</li>
</ul>
<p>闭包还具有一定的封装性，第 11 行的变量是 playerGen 的局部变量，playerGen 的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。</p>
<h2 id="可变参数（变参函数）"><a href="#可变参数（变参函数）" class="headerlink" title="可变参数（变参函数）"></a>可变参数（变参函数）</h2><p>在C语言时代大家一般都用过 printf() 函数，从那个时候开始其实已经在感受可变参数的魅力和价值，如同C语言中的 printf() 函数，Go语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能。</p>
<p>本节我们将介绍可变参数的用法。合适地使用可变参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等。</p>
<h3 id="可变参数类型"><a href="#可变参数类型" class="headerlink" title="可变参数类型"></a>可变参数类型</h3><p>可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面这段代码的意思是，函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int，所以它可以用如下方式调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myfunc(2, 3, 4)</span><br><span class="line">myfunc(1, 3, 7, 13)</span><br></pre></td></tr></tbody></table></figure>
<p>形如 <code>...type</code> 格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖 <code>（syntactic sugar）</code> ，即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。</p>
<p>从内部实现机理上来说，类型 <code>...type</code> 本质上是一个数组切片，也就是 <code>[]type</code> ，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。</p>
<p>假如没有 <code>...type</code> 这样的语法糖，开发者将不得不这么写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc2(args []int) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从函数的实现角度来看，这没有任何影响，该怎么写就怎么写，但从调用方来说，情形则完全不同：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myfunc2([]int{1, 3, 7, 13})</span><br></pre></td></tr></tbody></table></figure>
<p>大家会发现，我们不得不加上 <code>[]int{}</code> 来构造一个数组切片实例，但是有了 <code>...type</code> 这个语法糖，我们就不用自己来处理了。</p>
<h3 id="任意类型的可变参数"><a href="#任意类型的可变参数" class="headerlink" title="任意类型的可变参数"></a>任意类型的可变参数</h3><p>之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Printf(format string, args ...interface{}) {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用 <code>interface{}</code> 传递任意类型数据是Go语言的惯例用法，使用 <code>interface{}</code> 仍然是类型安全的，这和 C/C++ 不太一样，下面通过示例来了解一下如何分配传入 <code>interface{}</code> 类型的数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func MyPrintf(args ...interface{}) {</span><br><span class="line">    for _, arg := range args {</span><br><span class="line">        switch arg.(type) {</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, "is an int value.")</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, "is a string value.")</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, "is an int64 value.")</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, "is an unknown type.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var v1 int = 1</span><br><span class="line">    var v2 int64 = 234</span><br><span class="line">    var v3 string = "hello"</span><br><span class="line">    var v4 float32 = 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该程序的输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 is an int value.</span><br><span class="line">234 is an int64 value.</span><br><span class="line">hello is a string value.</span><br><span class="line">1.234 is an unknown type.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历可变参数列表——获取每一个参数的值"><a href="#遍历可变参数列表——获取每一个参数的值" class="headerlink" title="遍历可变参数列表——获取每一个参数的值"></a>遍历可变参数列表——获取每一个参数的值</h3><p>可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个函数, 参数数量为0~n, 类型约束为字符串</span><br><span class="line">func joinStrings(slist ...string) string {</span><br><span class="line"></span><br><span class="line">    // 定义一个字节缓冲, 快速地连接字符串</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line">    // 遍历可变参数列表slist, 类型为[]string</span><br><span class="line">    for _, s := range slist {</span><br><span class="line">        // 将遍历出的字符串连续写入字节数组</span><br><span class="line">        b.WriteString(s)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将连接好的字节数组转换为字符串并输出</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 输入3个字符串, 将它们连成一个字符串</span><br><span class="line">    fmt.Println(joinStrings("pig ", "and", " rat"))</span><br><span class="line">    fmt.Println(joinStrings("hammer", " mom", " and", " hawk"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pig and rat</span><br><span class="line">hammer mom and hawk</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义了一个可变参数的函数，slist 的类型为 []string，每一个参数的类型都是 string，也就是说，该函数只接受字符串类型作为参数。</li>
<li>第 11 行，bytes.Buffer 在这个例子中的作用类似于 StringBuilder，可以高效地进行字符串连接操作。</li>
<li>第 13 行，遍历 slist 可变参数，s 为每个参数的值，类型为 string。</li>
<li>第 15 行，将每一个传入参数放到 bytes.Buffer 中。</li>
<li>第 19 行，将 bytes.Buffer 中的数据转换为字符串作为函数返回值返回。</li>
<li>第 24 行，输入 3 个字符串，使用 joinStrings() 函数将参数连接为字符串输出。</li>
<li>第 25 行，输入 4 个字符串，连接后输出。</li>
</ul>
<p>如果要获取可变参数的数量，可以使用 len() 函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。</p>
<h3 id="获得可变参数类型——获得每一个参数的类型"><a href="#获得可变参数类型——获得每一个参数的类型" class="headerlink" title="获得可变参数类型——获得每一个参数的类型"></a>获得可变参数类型——获得每一个参数的类型</h3><p>当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型，下面的代码演示将一系列不同类型的值传入 printTypeValue() 函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。</p>
<p>打印类型及值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printTypeValue(slist ...interface{}) string {</span><br><span class="line"></span><br><span class="line">    // 字节缓冲作为快速字符串连接</span><br><span class="line">    var b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    // 遍历参数</span><br><span class="line">    for _, s := range slist {</span><br><span class="line"></span><br><span class="line">        // 将interface{}类型格式化为字符串</span><br><span class="line">        str := fmt.Sprintf("%v", s)</span><br><span class="line"></span><br><span class="line">        // 类型的字符串描述</span><br><span class="line">        var typeString string</span><br><span class="line"></span><br><span class="line">        // 对s进行类型断言</span><br><span class="line">        switch s.(type) {</span><br><span class="line">        case bool:    // 当s为布尔类型时</span><br><span class="line">            typeString = "bool"</span><br><span class="line">        case string:    // 当s为字符串类型时</span><br><span class="line">            typeString = "string"</span><br><span class="line">        case int:    // 当s为整型类型时</span><br><span class="line">            typeString = "int"</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 写字符串前缀</span><br><span class="line">        b.WriteString("value: ")</span><br><span class="line"></span><br><span class="line">        // 写入值</span><br><span class="line">        b.WriteString(str)</span><br><span class="line"></span><br><span class="line">        // 写类型前缀</span><br><span class="line">        b.WriteString(" type: ")</span><br><span class="line"></span><br><span class="line">        // 写类型字符串</span><br><span class="line">        b.WriteString(typeString)</span><br><span class="line"></span><br><span class="line">        // 写入换行符</span><br><span class="line">        b.WriteString("\n")</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    return b.String()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 将不同类型的变量通过printTypeValue()打印出来</span><br><span class="line">    fmt.Println(printTypeValue(100, "str", true))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value: 100 type: int</span><br><span class="line">value: str type: string</span><br><span class="line">value: true type: bool</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，printTypeValue() 输入不同类型的值并输出类型和值描述。</li>
<li>第 11 行，bytes.Buffer 字节缓冲作为快速字符串连接。</li>
<li>第 14 行，遍历 slist 的每一个元素，类型为 interface{}。</li>
<li>第 17 行，使用 fmt.Sprintf 配合%v动词，可以将 interface{} 格式的任意值转为字符串。</li>
<li>第 20 行，声明一个字符串，作为变量的类型名。</li>
<li>第 23 行，switch s.(type) 可以对 interface{} 类型进行类型断言，也就是判断变量的实际类型。</li>
<li>第 24～29 行为 s 变量可能的类型，将每种类型的对应类型字符串赋值到 typeString 中。</li>
<li>第 33～42 行为写输出格式的过程。</li>
</ul>
<h3 id="在多个可变参数函数中传递参数"><a href="#在多个可变参数函数中传递参数" class="headerlink" title="在多个可变参数函数中传递参数"></a>在多个可变参数函数中传递参数</h3><p>可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加 <code>...</code> ，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。</p>
<p>下面的例子模拟 print() 函数及实际调用的 rawPrint() 函数，两个函数都拥有可变参数，需要将参数从 print 传递到 rawPrint 中。</p>
<p>可变参数传递：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 实际打印的函数</span><br><span class="line">func rawPrint(rawList ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 遍历可变参数切片</span><br><span class="line">    for _, a := range rawList {</span><br><span class="line"></span><br><span class="line">        // 打印参数</span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印函数封装</span><br><span class="line">func print(slist ...interface{}) {</span><br><span class="line"></span><br><span class="line">    // 将slist可变参数切片完整传递给下一个函数</span><br><span class="line">    rawPrint(slist...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    print(1, 2, 3)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 9～13 行，遍历 rawPrint() 的参数列表 rawList 并打印。</li>
<li>第 20 行，将变量在 print 的可变参数列表中添加 <code>...</code> 后传递给 rawPrint()。</li>
<li>第 25 行，传入 1、2、3 这 3 个整型值并进行打印。</li>
</ul>
<p>如果尝试将第 20 行修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rawPrint("fmt", slist)</span><br></pre></td></tr></tbody></table></figure>
<p>再次执行代码，将输出：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3]</span><br></pre></td></tr></tbody></table></figure>
<p>此时，slist（类型为 <code>[]interface{}</code> ）将被作为一个整体传入 rawPrint()，rawPrint() 函数中遍历的变量也就是 slist 的切片值。</p>
<p>可变参数使用 <code>...</code> 进行传递与切片间使用 append 连接是同一个特性。</p>
<h2 id="defer（延迟执行语句）"><a href="#defer（延迟执行语句）" class="headerlink" title="defer（延迟执行语句）"></a>defer（延迟执行语句）</h2><p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</p>
<p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p>
<h3 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a>多个延迟执行语句的处理顺序</h3><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出），下面的代码是将一系列的数值打印语句按顺序延迟处理，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer begin")</span><br><span class="line"></span><br><span class="line">    // 将defer放入延迟调用栈</span><br><span class="line">    defer fmt.Println(1)</span><br><span class="line"></span><br><span class="line">    defer fmt.Println(2)</span><br><span class="line"></span><br><span class="line">    // 最后一个放入, 位于栈顶, 最先调用</span><br><span class="line">    defer fmt.Println(3)</span><br><span class="line"></span><br><span class="line">    fmt.Println("defer end")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer begin</span><br><span class="line">defer end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>结果分析如下：</p>
<ul>
<li>代码的延迟顺序与最终的执行顺序是反向的。</li>
<li>延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。</li>
</ul>
<h3 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a>使用延迟执行语句在函数退出时释放资源</h3><p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p>
<p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。</p>
<h4 id="使用延迟并发解锁"><a href="#使用延迟并发解锁" class="headerlink" title="使用延迟并发解锁"></a>使用延迟并发解锁</h4><p>在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    // 一个演示用的映射</span><br><span class="line">    valueByKey      = make(map[string]int)</span><br><span class="line">    // 保证使用映射时的并发安全的互斥锁</span><br><span class="line">    valueByKeyGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 根据键读取值</span><br><span class="line">func readValue(key string) int {</span><br><span class="line">    // 对共享资源加锁</span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">    // 取值</span><br><span class="line">    v := valueByKey[key]</span><br><span class="line">    // 对共享资源解锁</span><br><span class="line">    valueByKeyGuard.Unlock()</span><br><span class="line">    // 返回值</span><br><span class="line">    return v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，实例化一个 map，键是 string 类型，值为 int。</li>
<li>第 5 行，map 默认不是并发安全的，准备一个 sync.Mutex 互斥量保护 map 的访问。</li>
<li>第 9 行，readValue() 函数给定一个键，从 map 中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。</li>
<li>第 11 行，使用互斥量加锁。</li>
<li>第 13 行，从 map 中获取值。</li>
<li>第 15 行，使用互斥量解锁。</li>
<li>第 17 行，返回获取到的 map 值。</li>
</ul>
<p>使用 defer 语句对上面的语句进行简化，参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func readValue(key string) int {</span><br><span class="line"></span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line"></span><br><span class="line">    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用</span><br><span class="line">    defer valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    return valueByKey[key]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中第 6~8 行是对前面代码的修改和添加的代码，代码说明如下：</p>
<ul>
<li>第 6 行在互斥量加锁后，使用 defer 语句添加解锁，该语句不会马上执行，而是等 readValue() 函数返回时才会被执行。</li>
<li>第 8 行，从 map 查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。</li>
</ul>
<h4 id="使用延迟释放文件句柄"><a href="#使用延迟释放文件句柄" class="headerlink" title="使用延迟释放文件句柄"></a>使用延迟释放文件句柄</h4><p>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源，在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 根据文件名查询其大小</span><br><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    // 根据文件名打开文件, 返回文件句柄和错误</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    // 如果打开时发生错误, 返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件状态信息</span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    // 如果获取信息时发生错误, 关闭文件并返回文件大小为0</span><br><span class="line">    if err != nil {</span><br><span class="line">        f.Close()</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 取文件大小</span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // 关闭文件</span><br><span class="line">    f.Close()</span><br><span class="line"></span><br><span class="line">    // 返回文件大小</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义获取文件大小的函数，返回值是 64 位的文件大小值。</li>
<li>第 5 行，使用 os 包提供的函数 Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。</li>
<li>第 8 行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为 0。</li>
<li>第 13 行，此时文件句柄 f 可以正常使用，使用 f 的方法 Stat() 来获取文件的信息，获取信息时，可能也会发生错误。</li>
<li>第 16～19 行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用 f 的 Close() 方法来关闭文件，否则会发生资源泄露。</li>
<li>第 22 行，获取文件大小。</li>
<li>第 25 行，关闭文件、释放资源。</li>
<li>第 28 行，返回获取到的文件大小。</li>
</ul>
<p>在上面的例子中，第 25 行是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func fileSize(filename string) int64 {</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 延迟调用Close, 此时Close不会被调用</span><br><span class="line">    defer f.Close()</span><br><span class="line"></span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        // defer机制触发, 调用Close关闭文件</span><br><span class="line">        return 0</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    // defer机制触发, 调用Close关闭文件</span><br><span class="line">    return size</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对比前面代码修改的部分，代码说明如下：</p>
<ul>
<li>第 10 行，在文件正常打开后，使用 defer，将 f.Close() 延迟调用，注意，不能将这一句代码放在第 4 行空行处，一旦文件打开错误，f 将为空，在延迟语句触发时，将触发宕机错误。</li>
<li>第 16 行和第 22 行，defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源。</li>
</ul>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>很对编程语言都支持递归函数，Go语言也不例外，所谓递归函数指的是在函数内部调用函数自身的函数，从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，如计算给定数字阶乘、产生斐波系列等。</p>
<p>构成递归需要具备以下条件：</p>
<ul>
<li>一个问题可以被拆分成多个子问题；</li>
<li>拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；</li>
<li>不能无限制的调用本身，子问题需要有退出递归状态的条件。</li>
</ul>
<p><strong><em>注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。</em></strong></p>
<p>下面通过几个示例来演示一下递归函数的使用。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>下面我们就以递归函数的经典示例 —— 斐波那契数列为例，演示如何通过Go语言编写的递归函数来打印斐波那契数列。</p>
<p>数列的形式如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, …</span><br></pre></td></tr></tbody></table></figure>
<p>使用Go语言递归函数实现斐波那契数列的具体代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("fibonacci(%d) is: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(1) is: 1</span><br><span class="line">fibonacci(2) is: 1</span><br><span class="line">fibonacci(3) is: 2</span><br><span class="line">fibonacci(4) is: 3</span><br><span class="line">fibonacci(5) is: 5</span><br><span class="line">fibonacci(6) is: 8</span><br><span class="line">fibonacci(7) is: 13</span><br><span class="line">fibonacci(8) is: 21</span><br><span class="line">fibonacci(9) is: 34</span><br><span class="line">fibonacci(10) is: 55</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数字阶乘"><a href="#数字阶乘" class="headerlink" title="数字阶乘"></a>数字阶乘</h3><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作 <code>n!</code> ，“基斯顿·卡曼”在 1808 年发明了 <code>n!</code> 这个运算符号。</p>
<p>例如，<code>n!=1×2×3×…×n</code> ，阶乘亦可以递归方式定义：<code>0!=1，n!=(n-1)!×n</code> 。</p>
<p>使用递归函数计算给定数的阶乘，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func Factorial(n uint64) (result uint64) {</span><br><span class="line">    if n &gt; 0 {</span><br><span class="line">        result = n * Factorial(n-1)</span><br><span class="line">        return result</span><br><span class="line">    }</span><br><span class="line">    return 1</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    var i int = 10</span><br><span class="line">    fmt.Printf("%d 的阶乘是 %d\n", i, Factorial(uint64(i)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 的阶乘是 3628800</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多个函数组成递归"><a href="#多个函数组成递归" class="headerlink" title="多个函数组成递归"></a>多个函数组成递归</h3><p>Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Printf("%d is even: is %t\n", 16, even(16)) // 16 is even: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 17, odd(17))</span><br><span class="line">    // 17 is odd: is true</span><br><span class="line">    fmt.Printf("%d is odd: is %t\n", 18, odd(18))</span><br><span class="line">    // 18 is odd: is false</span><br><span class="line">}</span><br><span class="line">func even(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return odd(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func odd(nr int) bool {</span><br><span class="line">    if nr == 0 {</span><br><span class="line">        return false</span><br><span class="line">    }</span><br><span class="line">    return even(RevSign(nr) - 1)</span><br><span class="line">}</span><br><span class="line">func RevSign(nr int) int {</span><br><span class="line">    if nr &lt; 0 {</span><br><span class="line">        return -nr</span><br><span class="line">    }</span><br><span class="line">    return nr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行效果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 is even: is true</span><br><span class="line">17 is odd: is true</span><br><span class="line">18 is odd: is false</span><br></pre></td></tr></tbody></table></figure>
<h2 id="处理运行时错误"><a href="#处理运行时错误" class="headerlink" title="处理运行时错误"></a>处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p>
<ul>
<li>一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。</li>
<li>在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。</li>
</ul>
<p>Go语言没有类似 Java 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p>
<p>Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p>
<h3 id="net-包中的例子"><a href="#net-包中的例子" class="headerlink" title="net 包中的例子"></a>net 包中的例子</h3><p>net.Dial() 是Go语言系统包 net 即中的一个函数，一般用于创建一个 Socket 连接。</p>
<p>net.Dial 拥有两个返回值，即 Conn 和 error，这个函数是阻塞的，因此在 Socket 操作后，会返回 Conn 连接对象和 error，如果发生错误，error 会告知错误的类型，Conn 会返回空。</p>
<p>根据Go语言的错误处理机制，Conn 是其重要的返回值，因此，为这个函数增加一个错误返回，类似为 error，参见下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func Dial(network, address string) (Conn, error) {</span><br><span class="line">    var d Dialer</span><br><span class="line">    return d.Dial(network, address)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 io 包中的 Writer 接口也拥有错误返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>io 包中还有 Closer 接口，只有一个错误返回，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="错误接口的定义格式"><a href="#错误接口的定义格式" class="headerlink" title="错误接口的定义格式"></a>错误接口的定义格式</h3><p>error 是 Go 系统声明的接口类型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误</p>
<h3 id="自定义一个错误"><a href="#自定义一个错误" class="headerlink" title="自定义一个错误"></a>自定义一个错误</h3><p>返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var err = errors.New("this is an error")</span><br></pre></td></tr></tbody></table></figure>
<p>错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。</p>
<h4 id="errors-包"><a href="#errors-包" class="headerlink" title="errors 包"></a>errors 包</h4><p>Go语言的 errors 中对 New 的定义非常简单，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建错误对象</span><br><span class="line">func New(text string) error {</span><br><span class="line">    return &amp;errorString{text}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 错误字符串</span><br><span class="line">type errorString struct {</span><br><span class="line">    s string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 返回发生何种错误</span><br><span class="line">func (e *errorString) Error() string {</span><br><span class="line">    return e.s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，将 errorString 结构体实例化，并赋值错误描述的成员。</li>
<li>第 7 行，声明 errorString 结构体，拥有一个成员，描述错误内容。</li>
<li>第 12 行，实现 error 接口的 Error() 方法，该方法返回成员中的错误描述。</li>
</ul>
<h4 id="在代码中使用错误定义"><a href="#在代码中使用错误定义" class="headerlink" title="在代码中使用错误定义"></a>在代码中使用错误定义</h4><p>下面的代码会定义一个除法函数，当除数为 0 时，返回一个预定义的除数为 0 的错误。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义除数为0的错误</span><br><span class="line">var errDivisionByZero = errors.New("division by zero")</span><br><span class="line"></span><br><span class="line">func div(dividend, divisor int) (int, error) {</span><br><span class="line"></span><br><span class="line">    // 判断除数为0的情况并返回</span><br><span class="line">    if divisor == 0 {</span><br><span class="line">        return 0, errDivisionByZero</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 正常计算，返回空错误</span><br><span class="line">    return dividend / divisor, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    fmt.Println(div(1, 0))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 division by zero</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 9 行，预定义除数为 0 的错误。</li>
<li>第 11 行，声明除法函数，输入被除数和除数，返回商和错误。</li>
<li>第 14 行，在除法计算中，如果除数为 0，计算结果为无穷大，为了避免这种情况，对除数进行判断，并返回商为 0 和除数为 0 的错误对象。</li>
<li>第 19 行，进行正常的除法计算，没有发生错误时，错误对象返回 nil。</li>
</ul>
<h3 id="示例：在解析中使用自定义错误"><a href="#示例：在解析中使用自定义错误" class="headerlink" title="示例：在解析中使用自定义错误"></a>示例：在解析中使用自定义错误</h3><p>使用 errors.New 定义的错误字符串的错误类型是无法提供丰富的错误信息的，那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。</p>
<p>下面代码将实现一个解析错误（ParseError），这种错误包含两个内容，分别是文件名和行号，解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，就需要将文件名和行号返回。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个解析错误</span><br><span class="line">type ParseError struct {</span><br><span class="line">    Filename string // 文件名</span><br><span class="line">    Line     int    // 行号</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现error接口，返回错误描述</span><br><span class="line">func (e *ParseError) Error() string {</span><br><span class="line">    return fmt.Sprintf("%s:%d", e.Filename, e.Line)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一些解析错误</span><br><span class="line">func newParseError(filename string, line int) error {</span><br><span class="line">    return &amp;ParseError{filename, line}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var e error</span><br><span class="line">    // 创建一个错误实例，包含文件名和行号</span><br><span class="line">    e = newParseError("main.go", 1)</span><br><span class="line"></span><br><span class="line">    // 通过error接口查看错误描述</span><br><span class="line">    fmt.Println(e.Error())</span><br><span class="line"></span><br><span class="line">    // 根据错误接口具体的类型，获取详细错误信息</span><br><span class="line">    switch detail := e.(type) {</span><br><span class="line">    case *ParseError: // 这是一个解析错误</span><br><span class="line">        fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)</span><br><span class="line">    default: // 其他类型的错误</span><br><span class="line">        fmt.Println("other error")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go:1</span><br><span class="line">Filename: main.go Line: 1</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，声明了一个解析错误的结构体，解析错误包含有 2 个成员，分别是文件名和行号。</li>
<li>第 14 行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。</li>
<li>第 19 行，根据给定的文件名和行号创建一个错误实例。</li>
<li>第 25 行，声明一个错误接口类型。</li>
<li>第 27 行，创建一个实例，这个错误接口内部是 <code>*ParserError</code> 类型，携带有文件名 main.go 和行号 1。</li>
<li>第 30 行，调用 Error() 方法，通过第 15 行返回错误的详细信息。</li>
<li>第 33 行，通过错误断言，取出发生错误的详细类型。</li>
<li>第 34 行，通过分析这个错误的类型，得知错误类型为 <code>*ParserError</code> ，此时可以获取到详细的错误信息。</li>
<li>第 36 行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。</li>
</ul>
<p>错误对象都要实现 error 接口的 Error() 方法，这样，所有的错误都可以获得字符串的描述，如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。</p>
<h2 id="宕机（panic）——程序终止运行"><a href="#宕机（panic）——程序终止运行" class="headerlink" title="宕机（panic）——程序终止运行"></a>宕机（panic）——程序终止运行</h2><p>Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。</p>
<p>宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，宕机有时也是一种合理的止损方法。</p>
<p>一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。</p>
<p>对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。</p>
<p>虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。</p>
<h3 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a>手动触发宕机</h3><p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。</p>
<p>Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    panic("crash")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行崩溃并输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">panic: crash</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:4 +0x40</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func panic(v interface{})    //panic() 的参数可以是任意类型的。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在运行依赖的必备资源缺失时主动触发宕机"><a href="#在运行依赖的必备资源缺失时主动触发宕机" class="headerlink" title="在运行依赖的必备资源缺失时主动触发宕机"></a>在运行依赖的必备资源缺失时主动触发宕机</h3><p>regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。</p>
<p>编译正则表达式函数有两种，具体如下：</p>
<h4 id="func-Compile-expr-string-Regexp-error"><a href="#func-Compile-expr-string-Regexp-error" class="headerlink" title="func Compile(expr string) (*Regexp, error)"></a>func Compile(expr string) (*Regexp, error)</h4><p>编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。</p>
<h4 id="func-MustCompile-str-string-Regexp"><a href="#func-MustCompile-str-string-Regexp" class="headerlink" title="func MustCompile(str string) *Regexp"></a>func MustCompile(str string) *Regexp</h4><p>当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。</p>
<p>MustCompile 的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func MustCompile(str string) *Regexp {</span><br><span class="line">    regexp, error := Compile(str)</span><br><span class="line">    if error != nil {</span><br><span class="line">        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())</span><br><span class="line">    }</span><br><span class="line">    return regexp</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。</li>
<li>第 2 行，Compile() 是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。</li>
<li>第 3 和第 4 行判断如果有错，则使用 panic() 触发宕机。</li>
<li>第 6 行，没有错误时返回正则表达式对象。</li>
</ul>
<p>手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。</p>
<h3 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a>在宕机时触发延迟执行语句</h3><p>当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    defer fmt.Println("宕机后要做的事情1")</span><br><span class="line">    defer fmt.Println("宕机后要做的事情2")</span><br><span class="line">    panic("宕机")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">宕机后要做的事情2</span><br><span class="line">宕机后要做的事情1</span><br><span class="line">panic: 宕机</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    D:/code/main.go:8 +0xf8</span><br><span class="line">exit status 2</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 6 行和第 7 行使用 defer 语句延迟了 2 个语句。</li>
<li>第 8 行发生宕机。</li>
</ul>
<p>宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。</p>
<h2 id="宕机恢复（recover）——防止程序崩溃"><a href="#宕机恢复（recover）——防止程序崩溃" class="headerlink" title="宕机恢复（recover）——防止程序崩溃"></a>宕机恢复（recover）——防止程序崩溃</h2><p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p>
<p>通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
<p><strong><em>提示:在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。</em></strong></p>
<p>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。</p>
<h3 id="让程序在崩溃时继续执行"><a href="#让程序在崩溃时继续执行" class="headerlink" title="让程序在崩溃时继续执行"></a>让程序在崩溃时继续执行</h3><p>下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。</p>
<p>保护运行函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 崩溃时需要传递的上下文信息</span><br><span class="line">type panicContext struct {</span><br><span class="line">    function string // 所在函数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 保护方式允许一个函数</span><br><span class="line">func ProtectRun(entry func()) {</span><br><span class="line"></span><br><span class="line">    // 延迟处理的函数</span><br><span class="line">    defer func() {</span><br><span class="line"></span><br><span class="line">        // 发生宕机时，获取panic传递的上下文并打印</span><br><span class="line">        err := recover()</span><br><span class="line"></span><br><span class="line">        switch err.(type) {</span><br><span class="line">        case runtime.Error: // 运行时错误</span><br><span class="line">            fmt.Println("runtime error:", err)</span><br><span class="line">        default: // 非运行时错误</span><br><span class="line">            fmt.Println("error:", err)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    entry()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("运行前")</span><br><span class="line"></span><br><span class="line">    // 允许一段手动触发的错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机前")</span><br><span class="line"></span><br><span class="line">        // 使用panic传递上下文</span><br><span class="line">        panic(&amp;panicContext{</span><br><span class="line">            "手动触发panic",</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">        fmt.Println("手动宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    // 故意造成空指针访问错误</span><br><span class="line">    ProtectRun(func() {</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机前")</span><br><span class="line"></span><br><span class="line">        var a *int</span><br><span class="line">        *a = 1</span><br><span class="line"></span><br><span class="line">        fmt.Println("赋值宕机后")</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    fmt.Println("运行后")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行前</span><br><span class="line">手动宕机前</span><br><span class="line">error: &amp;{手动触发panic}</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">运行后</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 9 行声明描述错误的结构体，保存执行错误的函数。</li>
<li>第 17 行使用 defer 将闭包延迟执行，当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。</li>
<li>第 20 行，recover() 获取到 panic 传入的参数。</li>
<li>第 22 行，使用 switch 对 err 变量进行类型断言。</li>
<li>第 23 行，如果错误是有 Runtime 层抛出的运行时错误，如空指针访问、除数为 0 等情况，打印运行时错误。</li>
<li>第 25 行，其他错误，打印传递过来的错误数据。</li>
<li>第 44 行，使用 panic 手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover 就会获取到这个结构体信息，并打印出来。</li>
<li>第 57 行，模拟代码中空指针赋值造成的错误，此时会由 Runtime 层抛出错误，被 ProtectRun() 函数的 recover() 函数捕获到。</li>
</ul>
<h3 id="panic-和-recover-的关系"><a href="#panic-和-recover-的关系" class="headerlink" title="panic 和 recover 的关系"></a>panic 和 recover 的关系</h3><p>panic 和 recover 的组合有如下特性：</p>
<ul>
<li>有 panic 没 recover，程序宕机。</li>
<li>有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li>
</ul>
<p><strong><em>提示:虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。</em></strong></p>
<p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。</p>
<p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>
<h2 id="计算函数执行时间"><a href="#计算函数执行时间" class="headerlink" title="计算函数执行时间"></a>计算函数执行时间</h2><p>函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，要得到函数的运行时间，最简单的办法就是在函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，这个时间间隔就是函数的运行时间。</p>
<p>在Go语言中我们可以使用 time 包中的 Since() 函数来获取函数的运行时间，Go语言官方文档中对 Since() 函数的介绍是这样的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Since(t Time) Duration</span><br></pre></td></tr></tbody></table></figure>
<p>Since() 函数返回从 t 到现在经过的时间，等价于 <code>time.Now().Sub(t)</code> 。</p>
<p>【示例】使用 Since() 函数获取函数的运行时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Since(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数执行完成耗时： 39.8933ms</span><br></pre></td></tr></tbody></table></figure>
<p>上面我们提到了 <code>time.Now().Sub()</code> 的功能类似于 Since() 函数，想要使用 <code>time.Now().Sub()</code> 获取函数的运行时间只需要把我们上面代码的第 14 行简单修改一下就行。</p>
<p>【示例 2】使用 time.Now().Sub() 获取函数的运行时间。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func test() {</span><br><span class="line">    start := time.Now() // 获取当前时间</span><br><span class="line">    sum := 0</span><br><span class="line">    for i := 0; i &lt; 100000000; i++ {</span><br><span class="line">        sum++</span><br><span class="line">    }</span><br><span class="line">    elapsed := time.Now().Sub(start)</span><br><span class="line">    fmt.Println("该函数执行完成耗时：", elapsed)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该函数执行完成耗时： 36.8769ms</span><br></pre></td></tr></tbody></table></figure>
<p>由于计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。</p>
<h2 id="通过内存缓存来提升性能"><a href="#通过内存缓存来提升性能" class="headerlink" title="通过内存缓存来提升性能"></a>通过内存缓存来提升性能</h2><p>前面我们介绍了递归函数，递归函数的缺点就是比较消耗内存，而且效率比较低，那么我们要怎样提高程序的执行效率呢？</p>
<p>当在进行大量计算的时候，提升性能最直接有效的一种方式是避免重复计算，通过在内存中缓存并重复利用缓存从而避免重复执行相同计算的方式称为内存缓存。</p>
<p>下面我们以经典的递归求斐波那契数列为例，来对比一下普通实现方法和加入内存缓存后程序的执行情况。</p>
<h3 id="普通的实现方法"><a href="#普通的实现方法" class="headerlink" title="普通的实现方法"></a>普通的实现方法</h3><p>普通方法的实现思路是，要计算数列中第 n 个数字，需要先得到它前面的两个数，以此类推。这么做的弊端是会产生大量的重复计算，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result := 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt;= 40; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res int) {</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 1.2324148s</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出，获取第 40 位的数字所需要的时间是 1.2324148 秒（这个时间可能根据计算机性能的差异，略有不同）。</p>
<h3 id="内存缓存的实现方法"><a href="#内存缓存的实现方法" class="headerlink" title="内存缓存的实现方法"></a>内存缓存的实现方法</h3><p>内存缓存的实现思路是在计算得到第 n 个数的同时，将它的值保存到数组中索引为 n 的位置上，在后续的计算中先在数组中查找所需要的值是否计算过，如果找到了，则直接从数组中获取，如果没找到，则再进行计算，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const LIM = 41</span><br><span class="line"></span><br><span class="line">var fibs [LIM]uint64</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var result uint64 = 0</span><br><span class="line">    start := time.Now()</span><br><span class="line">    for i := 1; i &lt; LIM; i++ {</span><br><span class="line">        result = fibonacci(i)</span><br><span class="line">        fmt.Printf("数列第 %d 位: %d\n", i, result)</span><br><span class="line">    }</span><br><span class="line">    end := time.Now()</span><br><span class="line">    delta := end.Sub(start)</span><br><span class="line">    fmt.Printf("程序的执行时间为: %s\n", delta)</span><br><span class="line">}</span><br><span class="line">func fibonacci(n int) (res uint64) {</span><br><span class="line">    // 记忆化：检查数组中是否已知斐波那契（n）</span><br><span class="line">    if fibs[n] != 0 {</span><br><span class="line">        res = fibs[n]</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    if n &lt;= 2 {</span><br><span class="line">        res = 1</span><br><span class="line">    } else {</span><br><span class="line">        res = fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line">    }</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">数列第 1 位: 1</span><br><span class="line">数列第 2 位: 1</span><br><span class="line">数列第 3 位: 2</span><br><span class="line">数列第 4 位: 3</span><br><span class="line">数列第 5 位: 5</span><br><span class="line">数列第 6 位: 8</span><br><span class="line">数列第 7 位: 13</span><br><span class="line">数列第 8 位: 21</span><br><span class="line">数列第 9 位: 34</span><br><span class="line">数列第 10 位: 55</span><br><span class="line">数列第 11 位: 89</span><br><span class="line">数列第 12 位: 144</span><br><span class="line">数列第 13 位: 233</span><br><span class="line">数列第 14 位: 377</span><br><span class="line">数列第 15 位: 610</span><br><span class="line">数列第 16 位: 987</span><br><span class="line">数列第 17 位: 1597</span><br><span class="line">数列第 18 位: 2584</span><br><span class="line">数列第 19 位: 4181</span><br><span class="line">数列第 20 位: 6765</span><br><span class="line">数列第 21 位: 10946</span><br><span class="line">数列第 22 位: 17711</span><br><span class="line">数列第 23 位: 28657</span><br><span class="line">数列第 24 位: 46368</span><br><span class="line">数列第 25 位: 75025</span><br><span class="line">数列第 26 位: 121393</span><br><span class="line">数列第 27 位: 196418</span><br><span class="line">数列第 28 位: 317811</span><br><span class="line">数列第 29 位: 514229</span><br><span class="line">数列第 30 位: 832040</span><br><span class="line">数列第 31 位: 1346269</span><br><span class="line">数列第 32 位: 2178309</span><br><span class="line">数列第 33 位: 3524578</span><br><span class="line">数列第 34 位: 5702887</span><br><span class="line">数列第 35 位: 9227465</span><br><span class="line">数列第 36 位: 14930352</span><br><span class="line">数列第 37 位: 24157817</span><br><span class="line">数列第 38 位: 39088169</span><br><span class="line">数列第 39 位: 63245986</span><br><span class="line">数列第 40 位: 102334155</span><br><span class="line">程序的执行时间为: 12.0316ms</span><br></pre></td></tr></tbody></table></figure>
<p>通过运行结果可以看出，同样获取数列第 40 位的数字，使用内存缓存后所用的时间为 12.0316 毫秒，对比之前未使用内存缓存时的执行效率，可见内存缓存的优势还是相当明显的。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>Go语言中提供了MD5、SHA-1等几种哈希函数，下面我们用例子做一个介绍，代码如下所示</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestString := "Hi,pandaman!"</span><br><span class="line">    Md5Inst := md5.New()</span><br><span class="line">    Md5Inst.Write( []byte(TestString))</span><br><span class="line">    Result := Md5Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">    Sha1Inst := sha1.New()</span><br><span class="line">    Sha1Inst.Write([]byte(TestString))</span><br><span class="line">    Result = Sha1Inst.Sum([]byte(""))</span><br><span class="line">    fmt.Printf("%x\n",Result)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个程序的执行结果为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">70af690adf124b2e828b4d8904ad142a</span><br><span class="line">49d37c25ef2a62b4cfcf3689c649510390e14875</span><br></pre></td></tr></tbody></table></figure>
<p>再举一个例子，对文件内容计算SHA1，具体代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "crypto/md5"</span><br><span class="line">    "crypto/sha1"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    TestFile := "goPstrAnalysis.go"</span><br><span class="line">    infile , inerr := os.Open(TestFile)</span><br><span class="line">    if inerr == nil {</span><br><span class="line">        md5h := md5.New()</span><br><span class="line">        io.Copy( md5h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n" , md5h.Sum([]byte("")),TestFile)</span><br><span class="line">        sha1h := sha1.New()</span><br><span class="line">        io.Copy( sha1h , infile )</span><br><span class="line">        fmt.Printf("%x %s\n",sha1h.Sum([]byte("")),TestFile)</span><br><span class="line">    }else{</span><br><span class="line">        fmt.Println(inerr)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">7350776e62ab13bc1a8be3812ba32211 goPstrAnalysis.go</span><br><span class="line">da39a3ee5e6b4b0d3255bfef95601890afd80709 goPstrAnalysis.go</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数的底层实现"><a href="#函数的底层实现" class="headerlink" title="函数的底层实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4784.html">函数的底层实现</a></h2><p>基于堆栈式的程序执行模型决定了函数是语言的一个核心元素，分析Go语言函数的底层实现，对理解整个程序的执行过程有很大的帮助，研究底层实现有两种办法，一种是看语言编译器源码，分析其对函数的各个特性的处理逻辑，另一种是反汇编，将可执行程序反汇编出来。</p>
<p>本节使用反汇编这种短、平、快的方法，首先介绍Go语言的函数调用规约，接着介绍Go语言使用<a target="_blank" rel="noopener" href="http://c.biancheng.net/asm/">汇编语言</a>的基本概念，然后通过反汇编技术来剖析Go语言函数某些特性的底层实现。</p>
<h3 id="函数调用规约"><a href="#函数调用规约" class="headerlink" title="函数调用规约"></a>函数调用规约</h3><p>Go语言函数使用的是 caller-save 的模式，即由调用者负责保存寄存器，所以在函数的头尾不会出现 <code>push ebp; mov esp ebp</code> 这样的代码，相反其是在主调函数调用被调函数的前后有一个保存现场和恢复现场的动作。</p>
<p>主调函数保存和恢复现场的通用逻辑如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//开辟栈空间，压栈 BP 保存现场</span><br><span class="line">    SUBQ $x, SP    //为函数开辟裁空间</span><br><span class="line">    MOVQ BP, y(SP) //保存当前函数 BP 到 y(SP）位置， y 为相对 SP 的偏移量</span><br><span class="line">    LEAQ y(SP), BP //重直 BP，使其指向刚刚保存 BP 旧值的位置，这里主要</span><br><span class="line">                   //是方便后续 BP 的恢复</span><br><span class="line">//弹出栈，恢复 BP</span><br><span class="line">    MOVQ y(SP), BP //恢复 BP 的值为调用前的值</span><br><span class="line">    ADDQ $x, SP    //恢复 SP 的值为函数开始时的位</span><br></pre></td></tr></tbody></table></figure>
<h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><p>Go 编译器产生的汇编代码是一种中间抽象态，它不是对机器码的映射，而是和平台无关的一个中间态汇编描述，所以汇编代码中有些寄存器是真实的，有些是抽象的，几个抽象的寄存器如下：</p>
<ul>
<li>SB (Static base pointer)：静态基址寄存器，它和全局符号一起表示全局变量的地址。</li>
<li>FP (Frame pointer)：栈帧寄存器，该寄存器指向当前函数调用栈帧的栈底位置。</li>
<li>PC (Program counter)：程序计数器，存放下一条指令的执行地址，很少直接操作该寄存器，一般是 CALL、RET 等指令隐式的操作。</li>
<li>SP (Stack pointer)：栈顶寄存器，一般在函数调用前由主调函数设置 SP 的值对栈空间进行分配或回收。</li>
</ul>
<h4 id="Go-汇编简介"><a href="#Go-汇编简介" class="headerlink" title="Go 汇编简介"></a>Go 汇编简介</h4><p>1) Go 汇编器采用 AT&amp;T 风格的汇编，早期的实现来自 plan9 汇编器，源操作数在前，目的操作数在后。</p>
<p>2) Go 内嵌汇编和反汇编产生的代码并不是一一对应的，汇编编译器对内嵌汇编程序自动做了调整，主要差别就是增加了保护现场，以及函数调用前的保持 PC 、SP 偏移地址重定位等逻辑，反汇编代码更能反映程序的真实执行逻辑。</p>
<p>3) Go 的汇编代码并不是和具体硬件体系结构的机器码一一对应的，而是一种半抽象的描述，寄存器可能是抽象的，也可能是具体的。</p>
<p>下面代码的分析基于 AMD64 位架构下的 Linux 环境。</p>
<h3 id="多值返回分析"><a href="#多值返回分析" class="headerlink" title="多值返回分析"></a>多值返回分析</h3><p>多值返回函数 swap 的源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func swap (a, b int) (x int, y int) {</span><br><span class="line">    x = b</span><br><span class="line">    y = a</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    swap(10, 20)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译生成汇编如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//- S 产生汇编的代码</span><br><span class="line">//- N 禁用优化</span><br><span class="line">//- 1 禁用内联</span><br><span class="line"></span><br><span class="line">GOOS=linux GOARCH=amd64 go tool compile -1 -N -S swap.go &gt;swap.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>汇编代码分析:</p>
<p>1) swap 函数和 main 函数汇编代码分析。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">"".swap STEXT nosplit size=39 args=0x20 locals=0x0</span><br><span class="line">    0x0000 00000 (swap.go:4) TEXT  "".swap(SB), NOSPLIT, $0 - 32</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $0, gclocals.ff19ed39bdde8a01a800918ac3ef0ec7(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4) FUNCDATA  $1, gclocals.33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x0000 00000 (swap.go:4)  MOVQ  $0, "".x+24(SP)</span><br><span class="line">    0x0009 00009 (swap.go:4)  MOVQ  $0, "".y+32(SP)</span><br><span class="line">    0x0012 00018 (swap.go:5)  MOVQ  "".b+16(SP), AX</span><br><span class="line">    0x0017 00023 (swap.go:5)  MOVQ  AX, "".x+24(SP)</span><br><span class="line">    0xOO1c 00028 (swap.go:6)  MOVQ  "".a+8(SP), AX</span><br><span class="line">    0x0021 00033 (swap.go:6)  MOVQ  AX, "".y+32(SP)</span><br><span class="line">    0x0026 00038 (swap.go:7)  RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"".main STEXT size=68 args=0x0 locals=0x28</span><br><span class="line">    0x0000 00000 (swap.go:10) TEXT "".main(SB), $40 - 0</span><br><span class="line">    0x0000 00000 (swap.go:10) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (swap.go:10) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (swap.go:10) JLS 61</span><br><span class="line">    0x000f 00015 (swap.go:10) SUBQ $40, SP</span><br><span class="line">    0x0013 00019 (swap.go:10) MOVQ BP, 32 (SP)</span><br><span class="line">    0x0018 00024 (swap.go:10) LEAQ 32(SP), BP</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $0, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:10) FUNCDATA $1, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x001d 00029 (swap.go:11) MOVQ $10, (SP)</span><br><span class="line">    0x0025 00037 (swap.go:11) MOVQ $20 , 8 (SP)</span><br><span class="line">    0x002e 00046 (swap.go:11) PCDATA $0 , $0</span><br><span class="line">    0x002e 00046 (swap.go:11) CALL "". swap(SB)</span><br><span class="line">    0x0033 00051 (swap.go:12) MOVQ 32(SP), BP</span><br><span class="line">    0x0038 00056 (swap.go:12) ADDQ $40, SP</span><br><span class="line">    0x003c 00060 (swap.go:12) RET</span><br><span class="line">    0x003d 00061 (swap.go:12) NOP</span><br><span class="line">    0x003d 00061 (swap.go:10) PCDATA $0, $ - 1</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第 5 行初始化返回值 x 为 0。</li>
<li>第 6 行初始化返回值 y 为 0。</li>
<li>第 7～8 行取第 2 个参数赋值给返回值 x。</li>
<li>第 9～10 行取第 1 个参数赋值给返回值 y。</li>
<li>第 11 行函数返回，同时进行栈回收，FUNCDATA 和垃圾收集可以忽略。</li>
<li>第 15～24 行 main 函数堆栈初始化：开辟栈空间，保存 BP 寄存器。</li>
<li>第 25 行初始化 add 函数的调用参数 1 的值为 10。</li>
<li>第 26 行初始化 add 函数的调用参数 2 的值为 20。</li>
<li>第 28 行调用 swap 函数，注意 call 隐含一个将 swap 下一条指令地址压栈的动作，即 sp=sp+8。</li>
<li>所以可以看到在 swap 里面的所有变量的相对位置都发生了变化，都在原来的地址上 ＋8。</li>
<li>第 29～30 行恢复栈空间。</li>
</ul>
<p>从汇编的代码得知：</p>
<ul>
<li>函数的调用者负责环境准备，包括为参数和返回值开辟栈空间。</li>
<li>寄存器的保存和恢复也由调用方负责。</li>
<li>函数调用后回收栈空间，恢复 BP 也由主调函数负责。</li>
</ul>
<p>函数的多值返回实质上是在栈上开辟多个地址分别存放返回值，这个并没有什么特别的地方，如果返回值是存放到堆上的，则多了一个复制的动作。</p>
<p>main 调用 swap 函数栈的结构如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gofuncstack.gif" alt="图：Go函数栈"></p>
<p>函数调用前己经为返回值和参数分配了栈空间，分配顺序是从右向左的，先是返回值，然后是参数，通用的栈模型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">＋----------＋</span><br><span class="line"> | 返回值 y   |</span><br><span class="line"> |------------|</span><br><span class="line"> | 返回值 x   |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 b    |</span><br><span class="line"> |------------|</span><br><span class="line"> |  参数 a    |</span><br><span class="line">＋----------＋</span><br></pre></td></tr></tbody></table></figure>
<p>函数的多返回值是主调函数预先分配好空间来存放返回值，被调函数执行时将返回值复制到该返回位置来实现的。</p>
<h3 id="闭包底层实现"><a href="#闭包底层实现" class="headerlink" title="闭包底层实现"></a>闭包底层实现</h3><p>下面通过汇编和源码对照的方式看一下 Go 闭包的内部实现。</p>
<p>程序源码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">//函数返回引用了外部变量 i 的闭包</span><br><span class="line">func a(i int) func () {</span><br><span class="line">    return func() {</span><br><span class="line">        print(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f := a (1)</span><br><span class="line">    f ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译汇编如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S c2_7_4a.go &gt;c2_7_4a.s 2&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>关键汇编代码及分析如下：</p>
<p>函数 a 和函数 main 对应的汇编代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"".a STEXT size=91 args=0x10 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) TEXT "".a(SB), $24-16</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:3) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:3) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:3) JLS 84</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:3) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:3) MOVQ BP , 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:3) LEAQ 16(SP), BP</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $0, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb (SB)</span><br><span class="line">    0x001d 00029 (c2_7_4a.go:4) LEAQ type.noalg.struct{ F uintptr; "".i int}(SB), AX</span><br><span class="line">    0x0024 00036 (c2_7_4a.go:4) MOVQ AX, (SP)</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) PCDATA $0, $0</span><br><span class="line">    0x0028 00040 (c2_7_4a.go:4) CALL runtime.newobject(SB)</span><br><span class="line">    0x002d 00045 (c2_7_4a.go:4) MOVQ 8(SP), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:4) LEAQ "".a.funcl(SB), CX</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:4) MOVQ CX, (AX)</span><br><span class="line">    0x003c 00060 (c2_7_4a.go:3) MOVQ "".i+32(SP), CX</span><br><span class="line">    0x0041 00065 (c2_7_4a.go:4) MOVQ CX, 8(AX)</span><br><span class="line">    0x0045 00069 (c2_7_4a.go:4) MOVQ AX, "".~r1+40(SP)</span><br><span class="line">    0x004a 00074 (c2_7_4a.go:4) MOVQ 16(SP), BP</span><br><span class="line">    0x004f 00079 (c2_7_4a.go:4) ADDQ $24, SP</span><br><span class="line">"".main STEXT size=69 args=0x0 locals=0x18</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) TEXT "".main(SB), $24-0</span><br><span class="line">    0x0000 00000 (c2_7_4a.go:9) MOVQ (TLS), CX</span><br><span class="line">    0x0009 00009 (c2_7_4a.go:9) CMPQ SP, 16(CX)</span><br><span class="line">    0x000d 00013 (c2_7_4a.go:9) JLS 62</span><br><span class="line">    0x000f 00015 (c2_7_4a.go:9) SUBQ $24, SP</span><br><span class="line">    0x0013 00019 (c2_7_4a.go:9) MOVQ BP, 16(SP)</span><br><span class="line">    0x0018 00024 (c2_7_4a.go:9) LEAQ 16(SP), BP</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $0, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:9) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)</span><br><span class="line">    0x00ld 00029 (c2_7_4a.go:10) MOVQ $1, (SP)</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) PCDATA $0, $0</span><br><span class="line">    0x0025 00037 (c2_7_4a.go:10) CALL "".a(SB)</span><br><span class="line">    0x002a 00042 (c2_7_4a.go:10) MOVQ 8(SP), DX</span><br><span class="line">    0x002f 00047 (c2_7_4a.go:11) MOVQ (DX), AX</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) PCDATA $0, $0</span><br><span class="line">    0x0032 00050 (c2_7_4a.go:11) CALL AX</span><br><span class="line">    0x0034 00052 (c2_7_4a.go:15) MOVQ 16(SP), BP</span><br><span class="line">    0x0039 00057 (c2_7_4a.go:15) ADDQ $24, SP</span><br><span class="line">    0x003d 00061 (c2_7_4a.go:15) RET</span><br></pre></td></tr></tbody></table></figure>
<h4 id="func-a-函数分析"><a href="#func-a-函数分析" class="headerlink" title="func a() 函数分析"></a>func a() 函数分析</h4><ul>
<li>第 1～10 行环境准备。</li>
<li>第 11 行这里我们看到 <code>type.noalg.struct { F uintptr; "".i int }(SB)</code> 这个符号是一个闭包类型的数据，闭包类型的<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>如下：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    i int</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>闭包的结构很简单，一个是函数指针，另一个是对外部环境的引用。注意，这里仅仅是打印 i，并没有修改 i，Go语言编译器并没有传递地址而是传递值。</p>
<ul>
<li>第 11 行将闭包类型元信息放到 (SP) 位置，(SP) 地址存放的是 CALL 函数调用的第一个参数。</li>
<li><p>第 14 行创建闭包对象，我们来看一下 runtime.newobject 的函数原型，该函数的输入参数是一个类型信息，返回值是根据该类型信息构造出来的对象地址。</p>
  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/malloc.go</span><br><span class="line">func newobject(typ *_type) unsafe.Pointer</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 15 行将 newobject 返回的对象地址复制给 AX 寄存器。</p>
</li>
<li>第 16 行将 a 函数里面的匿名函数 a.func 指针复制到 CX 寄存器。</li>
<li>第 17 行将 CX 寄存器中存放的 a.func 函数指针复制到闭包对象的函数指针位置。</li>
<li>第 18、19 行将外部闭包变量 i 的值复制到闭包对象的 i 处。</li>
<li>第 20 行复制闭包对象指针值到函数返回值位置 <code>"".～r1+40(SP)</code>。</li>
</ul>
<h4 id="main-函数分析"><a href="#main-函数分析" class="headerlink" title="main() 函数分析"></a>main() 函数分析</h4><ul>
<li>第 23～32 行准备环境。</li>
<li>第 33 行将立即数 1 复制到 (SP) 位置，为后续的 CALL 指令准备参数。</li>
<li>第 35 行调用函数 a()。</li>
<li>第 36 行复制函数返回值到 DX 寄存器。</li>
<li>第 37 行间接寻址，复制闭包对象中的函数指针到 AX 寄存器。</li>
<li>第 39 行调用 AX 寄存器指向的函数。</li>
<li>第 40～42 行恢复环境，并返回。</li>
</ul>
<p>通过汇编代码的分析，我们清楚地看到 Go 实现闭包是通过返回一个如下的结构来实现的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Closure struct {</span><br><span class="line">    F uintptr</span><br><span class="line">    env *Type</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>F 是返回的匿名函数指针，env 是对外部环境变量的引用集合，如果闭包内没有修改外部变量，则 Go 编译器直接优化为值传递，如上面的例子中的代码所示，反之则是通过指针传递的。</p>
<h2 id="Test功能测试函数详解"><a href="#Test功能测试函数详解" class="headerlink" title="Test功能测试函数详解"></a>Test功能测试函数详解</h2><p>Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。</p>
<h3 id="为什么需要测试"><a href="#为什么需要测试" class="headerlink" title="为什么需要测试"></a>为什么需要测试</h3><p>完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少 bug，有两种有效的方式分别是代码审核和测试，Go语言中提供了 testing 包来实现单元测试功能。</p>
<h3 id="测试规则"><a href="#测试规则" class="headerlink" title="测试规则"></a>测试规则</h3><p>要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以 <code>_test.go</code> 结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func TestXxx( t *testing.T ){</span><br><span class="line">    //......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编写测试用例有以下几点需要注意：</p>
<ul>
<li>测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；</li>
<li>测试用例的文件名必须以_test.go结尾；</li>
<li>需要使用 import 导入 testing 包；</li>
<li>测试函数的名称要以Test或Benchmark开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；</li>
<li>单元测试则以 <code>(t *testing.T)</code> 作为参数，性能测试以 <code>(t *testing.B)</code> 做为参数；</li>
<li>测试用例文件使用 <code>go test</code> 命令来执行，源码中不需要 <code>main()</code> 函数作为入口，所有以 <code>_test.go</code> 结尾的源码文件内以 <code>Test</code> 开头的函数都会自动执行。</li>
</ul>
<p>Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。</p>
<h3 id="单元（功能）测试"><a href="#单元（功能）测试" class="headerlink" title="单元（功能）测试"></a>单元（功能）测试</h3><p>在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">// 根据长宽获取面积</span><br><span class="line">func GetArea(weight int, height int) int {</span><br><span class="line">    return weight * height</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行测试命令，运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -v</span><br><span class="line">=== RUN   TestGetArea</span><br><span class="line">--- PASS: TestGetArea (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.535s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="性能（压力）测试"><a href="#性能（压力）测试" class="headerlink" title="性能（压力）测试"></a>性能（压力）测试</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -bench="."</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/dubbogo/dubbo-go-proxy/com/chebada</span><br><span class="line">BenchmarkGetArea-4      1000000000</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   1.217s</span><br></pre></td></tr></tbody></table></figure>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。</p>
<p>将 demo_test.go 代码改造成如下所示的样子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package demo</span><br><span class="line"></span><br><span class="line">import "testing"</span><br><span class="line"></span><br><span class="line">func TestGetArea(t *testing.T) {</span><br><span class="line">    area := GetArea(40, 50)</span><br><span class="line">    if area != 2000 {</span><br><span class="line">        t.Error("测试失败")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func BenchmarkGetArea(t *testing.B) {</span><br><span class="line">    for i := 0; i &lt; t.N; i++ {</span><br><span class="line">        GetArea(40, 50)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行测试命令，运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 14.3% of statements</span><br><span class="line">ok      github.com/dubbogo/dubbo-go-proxy/com/chebada   0.517s</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/fbeb39a4/">https://wssjdi.github.io/posts/fbeb39a4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0/">函数</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e56582fa/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go结构体</div></div></a></div><div class="next-post pull-right"><a href="/posts/91175219/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go流程控制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/2910ec3f/" title="go test单元测试及基准测试"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go test单元测试及基准测试</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>