<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go文件处理 | Wssjdi</title><meta name="description" content="go文件处理"><meta name="keywords" content="go,go 文件处理"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/543a448f/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="go文件处理"><meta property="og:url" content="https://wssjdi.github.io/posts/543a448f/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go文件处理"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-25T13:25:55.000Z"><meta property="article:modified_time" content="2020-10-25T15:02:01.992Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-25 23:02:01'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-text">自定义数据文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">JSON文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-JSON-%E6%96%87%E4%BB%B6"><span class="toc-text">写 JSON 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-JSON-%E6%96%87%E4%BB%B6"><span class="toc-text">读 JSON 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">XML文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-XML-%E6%96%87%E4%BB%B6"><span class="toc-text">写 XML 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-XML-%E6%96%87%E4%BB%B6"><span class="toc-text">读 XML 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Gob%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="toc-text">使用Gob传输数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-gob-%E6%96%87%E4%BB%B6"><span class="toc-text">创建 gob 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-gob-%E6%96%87%E4%BB%B6"><span class="toc-text">读取 gob 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">纯文本文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%BA%AF%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">写纯文本文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E7%BA%AF%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-text">读纯文本文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">二进制文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99Go%E8%AF%AD%E8%A8%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">写Go语言二进制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BBGo%E8%AF%AD%E8%A8%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">读Go语言二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">自定义二进制文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">写自定义二进制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">读自定义二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">zip归档文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-zip-%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-text">创建 zip 归档文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-zip-%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-text">读取 zip 归档文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tar%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">tar归档文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-tar-%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-text">创建 tar 归档文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B-tar-%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="toc-text">解压 tar 归档文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8buffer%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">使用buffer读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-bufio-%E5%8C%85%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text">使用 bufio 包写入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-bufio-%E5%8C%85%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">使用 bufio 包读取文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="toc-text">并发目录遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EINI%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%9C%80%E8%A6%81%E7%9A%84%E5%80%BC"><span class="toc-text">从INI配置文件中读取需要的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INI-%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">INI 文件的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-INI-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%96%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">从 INI 文件中取值的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%A1%8C%E6%96%87%E6%9C%AC"><span class="toc-text">读取行文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%AE%B5"><span class="toc-text">读取段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%94%AE%E5%80%BC"><span class="toc-text">读取键值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E3%80%81%E8%BF%BD%E5%8A%A0%E3%80%81%E8%AF%BB%E5%8F%96%E3%80%81%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件的写入、追加、读取、复制操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E6%93%8D%E4%BD%9C"><span class="toc-text">文件锁操作</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">go文件处理</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-25T13:25:55.000Z" title="发表于 2020-10-25 21:25:55">2020-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-25T15:02:01.992Z" title="更新于 2020-10-25 23:02:01">2020-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本章我们将带领大家深入了解一下 Go语言中的文件处理，重点在于文件而非目录或者通用的文件系统，特别是如何读写标准格式（如 XML 和 JSON 格式）的文件以及自定义的纯文本和二进制格式文件。</p>
<p>由于前面的内容已覆盖 Go语言的所有特性，现在我们可以灵活地使用 Go语言提供的所有工具。我们会充分利用这种灵活性并利用闭包来避免重复性的代码，同时在某些情况下充分利用 Go语言对面向对象的支持，特别是对为函数添加方法的支持。</p>
<h2 id="自定义数据文件"><a href="#自定义数据文件" class="headerlink" title="自定义数据文件"></a>自定义数据文件</h2><p>对一个程序非常普遍的需求包括维护内部数据结构，为数据交换提供导入导出功能，也支持使用外部工具来处理数据。</p>
<p>由于我们这里的关注重点是文件处理，因此我们纯粹只关心如何从程序内部数据结构中读取数据并将其写入标准和自定义格式的文件中，以及如何从标准和自定义格式文件中读取数据并写入程序的内部数据结构中。</p>
<p>本节中，我们会为所有的例子使用相同的数据，以便直接比较不同的文件格式。所有的代码都来自 invoicedate 程序（在 invoicedata 目录中的 invoicedata.go &gt; gob.go、inv.go、jsn.go、txt.go 和 xml.go 等文件中）。</p>
<p>该程序接受两个文件名作为命令行参数，一个用于读，另一个用于写（它们必须是不同的文件）。程序从第一个文件中读取数据（以其后缀所表示的任何格式），并将数据写入第二个文件（也是以其后缀所表示的任何格式）。</p>
<p>由 invoicedata 程序创建的文件可跨平台使用，也就是说，无论是什么格式，Windows 上创建的文件都可在 Mac OS X 以及 Linux 上读取，反之亦然。Gzip 格式压缩的文件（如 invoices.gob.gz）可以无缝读写。</p>
<p>这些数据由一个 []invoice 组成，也就是说，是一个保存了指向 Invoice 值的指针的切片。每一个发票数据都保存在一个 invoice 类型的值中，同时每一个发票数据都以 []*Item 的形式保存着 0 个或者多个项。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Invoice struct {</span><br><span class="line">    Id          int</span><br><span class="line">    Customerld  int</span><br><span class="line">    Raised      time.Time</span><br><span class="line">    Due         time.Time</span><br><span class="line">    Paid        bool</span><br><span class="line">    Note        string</span><br><span class="line">    Items       []*Item</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Item struct {</span><br><span class="line">    Id       st ring</span><br><span class="line">    Price    float64</span><br><span class="line">    Quantity int</span><br><span class="line">    Note     string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这两个结构体用于保存数据。下表给出了一些非正式的对比，展示了每种格式下读写相同的 50000 份随机发票数据所需的时间，以及以该格式所存储文件的大小。</p>
<p>计时按秒计，并向上舍入到最近的十分之一秒。我们应该把计时结果认为是无绝对单位的，因为不同硬件以及不 同负载情况下该值都不尽相同。大小一栏以千字节（KB）算，该值在所有机器上应该都是相同的。</p>
<p>对于该数据集，虽然未压缩文件的大小千差万别，但压缩文件的大小都惊人的相似。而代码的 函数不包括所有格式通用的代码（例如，那些用于压缩和解压缩以及定义结构体的代码）。</p>
<table>
    <tbody>
        <tr><th>后缀</th><th>读取</th><th>写入</th><th>大小(KiB)</th><th>读/写LOC</th><th>格式</th></tr>
        <tr><td>.gob</td><td>0.3</td><td>0.2</td><td>7948</td><td rowspan="2">21+11=32</td><td rowspan="2">Go二进制</td></tr>
        <tr><td>.gob.gz</td><td>0.5</td><td>1.5</td><td>2589</td></tr>
        <tr><td>jsn</td><td>4.5</td><td>2.2</td><td>16283</td><td rowspan="2">32+17=49</td><td rowspan="2">JSON</td></tr>
        <tr><td>.jsn.gz</td><td>4.5</td><td>3.4</td><td>2678</td></tr>
        <tr><td>.xml</td><td>6.7</td><td>1.2</td><td>18917</td><td rowspan="2">45+30=75</td><td rowspan="2">XML</td></tr>
        <tr><td>.xml.gz</td><td>6.9</td><td>2.7</td><td>2730</td></tr>
        <tr><td>..txt</td><td>1.9</td><td>1.0</td><td>12375</td><td rowspan="2">86+53=139</td><td rowspan="2">纯文本（UTF-8）</td></tr>
        <tr><td>.txt.gz</td><td>2.2</td><td>2.2</td><td>2514</td></tr>
        <tr><td>.inv</td><td>1.7</td><td>3.5</td><td>7250</td><td rowspan="2">128+87=215</td><td rowspan="2">自定义二进制</td></tr>
        <tr><td>.inv.gz</td><td>1.6</td><td>2.6</td><td>2400</td></tr>
    </tbody>
</table>

<p>这些读写时间和文件大小在我们的合理预期范围内，除了纯文本格式的读写异常快之外。这得益于 fmt 包优秀的打印和扫描函数，以及我们设计的易于解析的自定义文本格式。</p>
<p>对于 JSON 和 XML 格式，我们只简单地存储了日期部分而非存储默认的 time.Time 值（一个 ISO-8601 日期/时间字符串），通过牺牲一些速度和增加一些额外代码稍微减小了文件的大小。</p>
<p>例如，如果让JSON代码自己来处理time.Time值，它能够运行得更快，并且其代码行数与 Go语言二进制编码差不多。</p>
<p>对于二进制数据，Go语言的二进制格式是最便于使用的。它非常快且极端紧凑，所需的代码非常少，并且相对容易适应数据的变化。然而，如果我们使用的自定义类型不原生支持 gob 编码，我们必须让该类型满足 gob.Encoder 和 gob. Decoder 接口，这样会导致 gob 格式的 读写相当得慢，并且文件大小也会膨胀。</p>
<p>对于可读的数据，XML 可能是最好使用的格式，特别是作为一种数据交换格式时非常有用。与处理 JSON 格式相比，处理 XML 格式需要更多行代码。这是因为 Go [没有一个 xml.Marshaler 接口，也因为我们这里使用了并行的数据类型 （XMLInvoice 和 XMLItem）来帮助映射 XML 数据和发票数据（invoice 和 Item）。</p>
<p>使用 XML 作为外部存储格式的应用程序可能不需要并行的数据类型或者也不需要 invoicedata 程序这样的 转换，因此就有可能比 invoicedata 例子中所给出的更快，并且所需的代码也更少。</p>
<p>除了读写速度和文件大小以及代码行数之外，还有另一个问题值得考虑：格式的稳健性。例如，如果我们为 Invoice 结构体和 Item 结构体添加了一个字段，那么就必须再改变文件的格式。我们的代码适应读写新格式并继续支持读旧格式的难易程度如何？如果我们为文件格式定义版本，这样的变化就很容易被适应（会以本章一个练习的形式给岀），除了让 JSON 格式同时适应读写新旧格式稍微复杂一点之外。</p>
<p>除了 Invoice 和 Item 结构体之外，所有文件格式都共享以下常量：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const （</span><br><span class="line">    fileType        = "INVOICES"        //用于纯文本格式</span><br><span class="line">    magicNumber     = 0xl25D            // 用于二进制格式</span><br><span class="line">    fileVersion     = 100               //用于所有的格式</span><br><span class="line">    dataFormat      = "2006-01-02"      //必须总是使用该日期</span><br><span class="line">）</span><br></pre></td></tr></tbody></table></figure>
<p>magicNumber 用于唯一标记发票文件。fileVersion 用于标记发票文件的版本，该标记便于之后修改程序来适应数据格式的改变。dataFormat 稍后介绍，它表 示我们希望数据如何按照可读的格式进行格式化。</p>
<p>同时，我们也创建了一对接口。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type InvoiceMarshaler interface {</span><br><span class="line">    Marshallnvoices（writer io.Writer, invoices []*Invoice） error</span><br><span class="line">}</span><br><span class="line">type InvoiceUnmarshaler interface {</span><br><span class="line">    Unmarshallnvoices(reader io.Reader) ([]*Invoice, error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样做的目的是以统一的方式针对特定格式使用 reader 和 writer。例如，下列函数是 invoicedata 程序用来从一个打开的文件中读取发票数据的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func readinvoices(reader io.Reader, suffix string)([]*Invoice, error) {</span><br><span class="line">    var unmarshaler InvoicesUnmarshaler</span><br><span class="line">    switch suffix {</span><br><span class="line">        case ".gobn:</span><br><span class="line">            unmarshaler = GobMarshaler{}</span><br><span class="line">        case H.inv":</span><br><span class="line">            unmarshaler = InvMarshaler{}</span><br><span class="line">        case ,f. jsn", H. jsonn:</span><br><span class="line">            unmarshaler = JSONMarshaler{}</span><br><span class="line">        case ".txt”：</span><br><span class="line">            unmarshaler = TxtMarshaler{}</span><br><span class="line">        case ".xml":</span><br><span class="line">            unmarshaler = XMLMarshaler{}</span><br><span class="line">    }</span><br><span class="line">    if unmarshaler != nil {</span><br><span class="line">        return unmarshaler.Unmarshallnvoices(reader)</span><br><span class="line">    }</span><br><span class="line">    return nil, fmt.Errorf("unrecognized input suffix: %s", suffix)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中，reader 是任何能够满足 io.Reader 接口的值，例如，一个打开的文件 ( 其类型为 <code>*os . File</code>)&gt; 一个 gzip 解码器 ( 其类型为 <code>*gzip. Reader</code>) 或者一个 string. Readero 字符串 suffix 是文件的后缀名 ( 从 <code>.gz</code> 文件中解压之后)。</p>
<p>在接下来的小节中我们将会看到 GobMarshaler 和 InvMarshaler 等自定义的类型，它们提供了 MarshmlTnvoices() 和 Unmarshallnvoices() 方法 (因此满足 InvoicesMarshaler 和 InvoicesUnmarshaler 接口)。</p>
<h2 id="JSON文件的读写操作"><a href="#JSON文件的读写操作" class="headerlink" title="JSON文件的读写操作"></a>JSON文件的读写操作</h2><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。它基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p>
<p>JSON 是一种使用 UTF-8 编码的纯文本格式，采用完全独立于语言的文本格式，由于写起来比 XML 格式方便，并且更为紧凑，同时所需的处理时间也更少，致使 JSON 格式越来越流行，特别是在通过网络连接传送数据方面。</p>
<p>开发人员可以使用 JSON 传输简单的字符串、数字、布尔值，也可以传输一个数组或者一个更复杂的复合结构。在 Web 开发领域中，JSON 被广泛应用于 Web 服务端程序和客户端之间的数据通信。</p>
<p>Go语言内建对 JSON 的支持，使用内置的 encoding/json 标准库，开发人员可以轻松使用Go程序生成和解析 JSON 格式的数据。</p>
<p>JSON 结构如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"key1":"value1","key2":value2,"key3":["value3","value4","value5"]}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="写-JSON-文件"><a href="#写-JSON-文件" class="headerlink" title="写 JSON 文件"></a>写 JSON 文件</h3><p>使用Go语言创建一个 json 文件非常方便，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := []Website{{"Golang", "http://c.biancheng.net/golang/", []string{"http://c.biancheng.net/cplus/", "http://c.biancheng.net/linux_tutorial/"}}, {"Java", "http://c.biancheng.net/java/", []string{"http://c.biancheng.net/socket/", "http://c.biancheng.net/python/"}}}</span><br><span class="line"></span><br><span class="line">    // 创建文件</span><br><span class="line">    filePtr, err := os.Create("info.json")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer filePtr.Close()</span><br><span class="line"></span><br><span class="line">    // 创建Json编码器</span><br><span class="line">    encoder := json.NewEncoder(filePtr)</span><br><span class="line"></span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误", err.Error())</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 info.json 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        "Name":"Golang",</span><br><span class="line">        "Url":"http://c.biancheng.net/golang/",</span><br><span class="line">        "Course":[</span><br><span class="line">            "http://c.biancheng.net/golang/102/",</span><br><span class="line">            "http://c.biancheng.net/golang/concurrent/"</span><br><span class="line">        ]</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        "Name":"Java",</span><br><span class="line">        "Url":"http://c.biancheng.net/java/",</span><br><span class="line">        "Course":[</span><br><span class="line">            "http://c.biancheng.net/java/10/",</span><br><span class="line">            "http://c.biancheng.net/python/"</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读-JSON-文件"><a href="#读-JSON-文件" class="headerlink" title="读 JSON 文件"></a>读 JSON 文件</h3><p>读 JSON 数据与写 JSON 数据一样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/json"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePtr, err := os.Open("./info.json")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败 [Err:%s]", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer filePtr.Close()</span><br><span class="line">    var info []Website</span><br><span class="line">    // 创建json解码器</span><br><span class="line">    decoder := json.NewDecoder(filePtr)</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err.Error())</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">[{Golang http://c.biancheng.net/golang/ [http://c.biancheng.net/golang/102/ http://c.biancheng.net/golang/concurrent/]} {Java http://c.biancheng.net/java/ [http://c.biancheng.net/java/10/ http://c.biancheng.net/python/]}]</span><br></pre></td></tr></tbody></table></figure>
<p>顺便提一下，还有一种叫做 BSON (Binary JSON) 的格式与 JSON 非常类似，与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。</p>
<h2 id="XML文件的读写操作"><a href="#XML文件的读写操作" class="headerlink" title="XML文件的读写操作"></a>XML文件的读写操作</h2><p>XML（extensible Markup Language）格式被广泛用作一种数据交换格式，并且自成一种文件格式。与上一节介绍的 JSON 相比 XML 要复杂得多，而且手动写起来相对乏味得多。</p>
<p>在 JSON 还未像现在这么广泛使用时，XML 的使用相当广泛。XML 作为一种数据交换和信息传递的格式，使用还是很广泛的，现在很多开放平台接口，基本都会支持 XML 格式。</p>
<p>Go语言内置的 encoding/xml 包可以用在结构体和 XML 格式之间进行编解码，其方式跟 encoding/json 包类似。然而与 JSON 相比 XML 的编码和解码在功能上更苛刻得多，这是由于 encoding/xml 包要求结构体的字段包含格式合理的标签，而 JSON 格式却不需要。</p>
<h3 id="写-XML-文件"><a href="#写-XML-文件" class="headerlink" title="写 XML 文件"></a>写 XML 文件</h3><p>使用 encoidng/xml 包可以很方便的将 xml 数据存储到文件中，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/xml"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //实例化对象</span><br><span class="line">    info := Website{"C语言中文网", "http://c.biancheng.net/golang/", []string{"Go语言入门教程", "Golang入门教程"}}</span><br><span class="line">    f, err := os.Create("./info.xml")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line">    //序列化到文件中</span><br><span class="line">    encoder := xml.NewEncoder(f)</span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误：", err.Error())</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录生成一个 info.xml 文件，文件的内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Website name="C语言中文网"&gt;</span><br><span class="line">    &lt;Url&gt;http://c.biancheng.net/golang/&lt;/Url&gt;</span><br><span class="line">    &lt;Course&gt;Go语言入门教程&lt;/Course&gt;</span><br><span class="line">    &lt;Course&gt;Golang入门教程&lt;/Course&gt;</span><br><span class="line">&lt;/Website&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读-XML-文件"><a href="#读-XML-文件" class="headerlink" title="读 XML 文件"></a>读 XML 文件</h3><p>读 XML 文件比写 XML 文件稍微复杂，特别是在必须处理一些我们自定义字段的时候（例如日期）。但是，如果我们使用合理的打上 XML 标签的结构体，就不会复杂。示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/xml"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Name   string `xml:"name,attr"`</span><br><span class="line">    Url    string</span><br><span class="line">    Course []string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //打开xml文件</span><br><span class="line">    file, err := os.Open("./info.xml")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败：%v", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    info := Website{}</span><br><span class="line">    //创建 xml 解码器</span><br><span class="line">    decoder := xml.NewDecoder(file)</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("解码失败：%v", err)</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">{C语言中文网 http://c.biancheng.net/golang/ [Go语言入门教程 Golang入门教程]}</span><br></pre></td></tr></tbody></table></figure>
<p>正如写 XML 时一样，我们无需关心对所读取的 XML 数据进行转义，xml.NewDecoder.Decode() 函数会自动处理这些。</p>
<p>xml 包还支持更为复杂的标签，包括嵌套。例如标签名为 ‘xml:”Books&gt;Author”‘ 产生的是 <code>&lt;Books&gt;&lt;Author&gt;content&lt;/Author&gt;&lt;/Books&gt;</code> 这样的 XML 内容。同时除了 ‘xml:”, attr”‘ 之外，该包还支持 ‘xml:”,chardata”‘ 这样的标签表示将该字段当做字符数据来写，支持 ‘xml:”,innerxml”‘ 这样的标签表示按照字面量来写该字段，以及 ‘xml:”,comment”‘ 这样的标签表示将该字段当做 XML 注释。因此，通过使用标签化的结构体，我们可以充分利用好这些方便的编码解码函数，同时合理控制如何读写 XML 数据。</p>
<h2 id="使用Gob传输数据"><a href="#使用Gob传输数据" class="headerlink" title="使用Gob传输数据"></a>使用Gob传输数据</h2><p>为了让某个数据结构能够在网络上传输或能够保存至文件，它必须被编码然后再解码。当然已经有许多可用的编码方式了，比如 JSON、XML、Google 的 protocol buffers 等等。而现在又多了一种，由Go语言 encoding/gob 包提供的方式。</p>
<p>Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）。类似于 Python 的“pickle”和 Java 的“Serialization”。</p>
<p>Gob 和 JSON 的 pack 之类的方法一样，由发送端使用 Encoder 对数据结构进行编码。在接收端收到消息之后，接收端使用 Decoder 将序列化的数据变化成本地变量。</p>
<p>Go语言可以通过 JSON 或 Gob 来序列化 struct 对象，虽然 JSON 的序列化更为通用，但利用 Gob 编码可以实现 JSON 所不能支持的 struct 的方法序列化，利用 Gob 包序列化 struct 保存到本地也十分简单。</p>
<p>Gob 不是可外部定义、语言无关的编码方式，它的首选的是二进制格式，而不是像 JSON 或 XML 那样的文本格式。Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</p>
<p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。它和 JSON 或 XML 有什么不同呢？Gob 特定的用于纯 Go 的环境中，例如两个用Go语言写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</p>
<p>Gob 文件或流是完全自描述的，它里面包含的所有类型都有一个对应的描述，并且都是可以用Go语言解码，而不需要了解文件的内容。</p>
<p>只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作。解码客户端会继续识别以前存在的字段，并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</p>
<p>假如有下面这样一个结构体 T：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type T struct { X, Y, Z int }</span><br><span class="line">var t = T{X: 7, Y: 0, Z: 8}</span><br></pre></td></tr></tbody></table></figure>
<p>而在接收时可以用一个结构体 U 类型的变量 u 来接收这个值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type U struct { X, Y *int8 }</span><br><span class="line">var u U</span><br></pre></td></tr></tbody></table></figure>
<p>在接收时，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）和 JSON 的使用方式一样，Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()，相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode 。</p>
<h3 id="创建-gob-文件"><a href="#创建-gob-文件" class="headerlink" title="创建 gob 文件"></a>创建 gob 文件</h3><p>下面通过简单的示例程序来演示Go语言是如何创建 gob 文件的，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := map[string]string{</span><br><span class="line">        "name":    "C语言中文网",</span><br><span class="line">        "website": "http://c.biancheng.net/golang/",</span><br><span class="line">    }</span><br><span class="line">    name := "demo.gob"</span><br><span class="line">    File, _ := os.OpenFile(name, os.O_RDWR|os.O_CREATE, 0777)</span><br><span class="line">    defer File.Close()</span><br><span class="line">    enc := gob.NewEncoder(File)</span><br><span class="line">    if err := enc.Encode(info); err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成 demo.gob 文件，文件的内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0eff 8104 0102 ff82 0001 0c01 0c00 0041</span><br><span class="line">ff82 0002 046e 616d 6510 43e8 afad e8a8</span><br><span class="line">80e4 b8ad e696 87e7 bd91 0777 6562 7369</span><br><span class="line">7465 1e68 7474 703a 2f2f 632e 6269 616e</span><br><span class="line">... ...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读取-gob-文件"><a href="#读取-gob-文件" class="headerlink" title="读取 gob 文件"></a>读取 gob 文件</h3><p>读取 gob 文件与创建 gob 文件同样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var M map[string]string</span><br><span class="line">    File, _ := os.Open("demo.gob")</span><br><span class="line">    D := gob.NewDecoder(File)</span><br><span class="line">    D.Decode(&amp;M)</span><br><span class="line">    fmt.Println(M)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">map[name:C语言中文网 website:http://c.biancheng.net/golang/]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="纯文本文件的读写操作"><a href="#纯文本文件的读写操作" class="headerlink" title="纯文本文件的读写操作"></a>纯文本文件的读写操作</h2><p>Go语言提供了很多文件操作的支持，在不同场景下，有对应的处理方式，本节我们来介绍一下文本文件的读写操作。</p>
<h3 id="写纯文本文件"><a href="#写纯文本文件" class="headerlink" title="写纯文本文件"></a>写纯文本文件</h3><p>由于Go语言的 fmt 包中打印函数强大而灵活，写纯文本数据非常简单直接，示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建一个新文件，写入内容</span><br><span class="line">    filePath := "./output.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("打开文件错误= %v \n", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //及时关闭</span><br><span class="line">    defer file.Close()</span><br><span class="line">    //写入内容</span><br><span class="line">    str := "http://c.biancheng.net/golang/\n" // \n\r表示换行  txt文件要看到换行效果要用 \r\n</span><br><span class="line">    //写入时，使用带缓存的 *Writer</span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        writer.WriteString(str)</span><br><span class="line">    }</span><br><span class="line">    //因为 writer 是带缓存的，因此在调用 WriterString 方法时，内容是先写入缓存的</span><br><span class="line">    //所以要调用 flush方法，将缓存的数据真正写入到文件中。</span><br><span class="line">    writer.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面代码会在当前目录下生成一个 output.txt 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读纯文本文件"><a href="#读纯文本文件" class="headerlink" title="读纯文本文件"></a>读纯文本文件</h3><p>打开并读取一个纯文本格式的数据跟写入纯文本格式数据一样简单。要解析文本来重建原始数据可能稍微复杂，这需根据格式的复杂性而定。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //打开文件</span><br><span class="line">    file, err := os.Open("./output.txt")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败 = ", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭 file 句柄，否则会有内存泄漏</span><br><span class="line">    defer file.Close()</span><br><span class="line">    //创建一个 *Reader ， 是带缓冲的</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    for {</span><br><span class="line">        str, err := reader.ReadString('\n') //读到一个换行就结束</span><br><span class="line">        if err == io.EOF {                  //io.EOF 表示文件的末尾</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print(str)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("文件读取结束...")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">http://c.biancheng.net/golang/</span><br><span class="line">文件读取结束...</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二进制文件的读写操作"><a href="#二进制文件的读写操作" class="headerlink" title="二进制文件的读写操作"></a>二进制文件的读写操作</h2><p>Go语言的二进制（gob）格式是一个自描述的二进制序列。从其内部表示来看，Go语言的二进制格式由一个 0 块或者更多块的序列组成，其中的每一块都包含一个字节数，一个由 0 个或者多个 typeId-typeSpecification 对组成的序列，以及一个 typeId-value 对。</p>
<p>如果 typeId-value 对的 typeId 是预先定义好的（例如 bool、int 和 string 等），则这些 typeId-typeSpecification 对可以省略。否则就用类型对来描述一个自定义类型（如一个自定义的结构体）。类型对和值对之间的 typeId 没有区别。</p>
<p>正如我们将看到的，我们无需了解其内部结构就可以使用 gob 格式， 因为 encoding/gob 包会在幕后为我们打理好一切底层细节。</p>
<p>Go语言中的 encoding/gob 包也提供了与 encoding/json 包一样的编码解码功能，并且容易使用。通常而言如果对肉眼可读性不做要求，gob 格式是Go语言上用于文件存储和网络传输最为方便的格式。</p>
<h3 id="写Go语言二进制文件"><a href="#写Go语言二进制文件" class="headerlink" title="写Go语言二进制文件"></a>写Go语言二进制文件</h3><p>下面通过一个简单的示例来演示一下Go语言是如何生成一个二进制文件的，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    info := "http://c.biancheng.net/golang/"</span><br><span class="line">    file, err := os.Create("./output.gob")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件创建失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    encoder := gob.NewEncoder(file)</span><br><span class="line">    err = encoder.Encode(info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("编码错误", err.Error())</span><br><span class="line">        return</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("编码成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 output.gob 文件，文件内容如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">210c 001e 6874 7470 3a2f 2f63 2e62 6961</span><br><span class="line">6e63 6865 6e67 2e6e 6574 2f67 6f6c 616e</span><br><span class="line">672f </span><br></pre></td></tr></tbody></table></figure>
<h3 id="读Go语言二进制文件"><a href="#读Go语言二进制文件" class="headerlink" title="读Go语言二进制文件"></a>读Go语言二进制文件</h3><p>读 gob 数据和写一样简单，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "encoding/gob"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Open("./output.gob")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    decoder := gob.NewDecoder(file)</span><br><span class="line">    info := ""</span><br><span class="line">    err = decoder.Decode(&amp;info)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err.Error())</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("解码成功")</span><br><span class="line">        fmt.Println(info)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">解码成功</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="自定义二进制文件的读写操作"><a href="#自定义二进制文件的读写操作" class="headerlink" title="自定义二进制文件的读写操作"></a>自定义二进制文件的读写操作</h2><p>虽然Go语言的 encoding/gob 包非常易用，而且使用时所需代码量也非常少，但是我们仍有可能需要创建自定义的二进制格式。自定义的二进制格式有可能做到最紧凑的数据表示，并且读写速度可以非常快。</p>
<p>不过，在实际使用中，我们发现以Go语言二进制格式的读写通常比自定义格式要快非常多，而且创建的文件也不会大很多。但如果我们必须通过满足 gob.GobEncoder 和 gob.GobDecoder 接口来处理一些不可被 gob 编码的数据，这些优势就有可能会失去。</p>
<p>在有些情况下我们可能需要与一些使用自定义二进制格式的软件交互，因此了解如何处理二进制文件就非常有用。</p>
<h3 id="写自定义二进制文件"><a href="#写自定义二进制文件" class="headerlink" title="写自定义二进制文件"></a>写自定义二进制文件</h3><p>Go语言的 encoding/binary 包中的 binary.Write() 函数使得以二进制格式写数据非常简单，函数原型如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Write(w io.Writer, order ByteOrder, data interface{}) error</span><br></pre></td></tr></tbody></table></figure>
<p>Write 函数可以将参数 data 的 binary 编码格式写入参数 w 中，参数 data 必须是定长值、定长值的切片、定长值的指针。参数 order 指定写入数据的字节序，写入结构体时，名字中有 <code>_</code> 的字段会置为 0。</p>
<p>下面通过一个简单的示例程序来演示一下 Write 函数的使用，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "encoding/binary"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Url int32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Create("output.bin")</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        info := Website{</span><br><span class="line">            int32(i),</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("文件创建失败 ", err.Error())</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        defer file.Close()</span><br><span class="line"></span><br><span class="line">        var bin_buf bytes.Buffer</span><br><span class="line">        binary.Write(&amp;bin_buf, binary.LittleEndian, info)</span><br><span class="line">        b := bin_buf.Bytes()</span><br><span class="line">        _, err = file.Write(b)</span><br><span class="line"></span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("编码失败", err.Error())</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("编码成功")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的程序会在当前目录下生成 output.bin 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0100 0000 0200 0000 0300 0000 0400 0000</span><br><span class="line">0500 0000 0600 0000 0700 0000 0800 0000</span><br><span class="line">0900 0000 0a00 0000</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读自定义二进制文件"><a href="#读自定义二进制文件" class="headerlink" title="读自定义二进制文件"></a>读自定义二进制文件</h3><p>读取自定义的二进制数据与写自定义二进制数据一样简单。我们无需解析这类数据，只需使用与写数据时相同的字节顺序将数据读进相同类型的值中。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bytes"</span><br><span class="line">    "encoding/binary"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Website struct {</span><br><span class="line">    Url int32</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file, err := os.Open("output.bin")</span><br><span class="line">    defer file.Close()</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err.Error())</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    m := Website{}</span><br><span class="line">    for i := 1; i &lt;= 10; i++ {</span><br><span class="line">        data := readNextBytes(file, 4)</span><br><span class="line">        buffer := bytes.NewBuffer(data)</span><br><span class="line">        err = binary.Read(buffer, binary.LittleEndian, &amp;m)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println("二进制文件读取失败", err)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("第", i, "个值为：", m)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func readNextBytes(file *os.File, number int) []byte {</span><br><span class="line">    bytes := make([]byte, number)</span><br><span class="line"></span><br><span class="line">    _, err := file.Read(bytes)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("解码失败", err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return bytes</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">第 1 个值为: {1}</span><br><span class="line">第 2 个值为: {2}</span><br><span class="line">第 3 个值为: {3}</span><br><span class="line">第 4 个值为: {4}</span><br><span class="line">第 5 个值为: {5}</span><br><span class="line">第 6 个值为: {6}</span><br><span class="line">第 7 个值为: {7}</span><br><span class="line">第 8 个值为: {8}</span><br><span class="line">第 9 个值为: {9}</span><br><span class="line">第 10 个值为: {10}</span><br></pre></td></tr></tbody></table></figure>
<p>至此，我们完成了对自定义二进制数据的读和写操作。只要小心选择表示长度的整数符号和大小，并将该长度值写在变长值（如切片）的内容之前，那么使用二进制数据进行工作并不难。</p>
<p>Go语言对二进制文件的支持还包括随机访问。这种情况下，我们必须使用 os.OpenFile() 函数来打开文件（而非 os.Open()），并给它传入合理的权限标志和模式（例如 os.O_RDWR 表示可读写）参数。</p>
<p>然后，就可以使用 os.File.Seek() 方法来在文件中定位并读写，或者使用 os.File.ReadAt() 和 os.File.WriteAt() 方法来从特定的字节偏移中读取或者写入数据。</p>
<p>Go语言还提供了其他常用的方法，包括 os.File.Stat() 方法，它返回的 os.FileInfo 包含了文件大小、权限以及日期时间等细节信息。</p>
<h2 id="zip归档文件的读写操作"><a href="#zip归档文件的读写操作" class="headerlink" title="zip归档文件的读写操作"></a>zip归档文件的读写操作</h2><p>Go语言的标准库提供了对几种压缩格式的支持，其中包括 gzip，因此 Go 程序可以无缝地读写 <code>.gz</code> 扩展名的 gzip 压缩文件或非 <code>.gz</code> 扩展名的非压缩文件。此外标准库也提供了读和写 <code>.zip</code> 文件、<code>tar</code> 包文件（<code>.tar</code> 和 <code>.tar.gz</code>），以及读 <code>.bz2</code> 文件（即 <code>.tar</code> <code>.bz2</code> 文件）的功能。</p>
<p>本节我们将主要介绍 zip 归档文件的读写操作。</p>
<h3 id="创建-zip-归档文件"><a href="#创建-zip-归档文件" class="headerlink" title="创建 zip 归档文件"></a>创建 zip 归档文件</h3><p>Go语言提供了 archive/zip 包来操作压缩文件，下面通过一个简单的的示例演示如何使用Go语言来创建一个 zip 文件，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/zip"</span><br><span class="line">    "bytes"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 创建一个缓冲区用来保存压缩文件内容</span><br><span class="line">    buf := new(bytes.Buffer)</span><br><span class="line"></span><br><span class="line">    // 创建一个压缩文档</span><br><span class="line">    w := zip.NewWriter(buf)</span><br><span class="line"></span><br><span class="line">    // 将文件加入压缩文档</span><br><span class="line">    var files = []struct {</span><br><span class="line">        Name, Body string</span><br><span class="line">    }{</span><br><span class="line">        {"Golang.txt", "http://c.biancheng.net/golang/"},</span><br><span class="line">    }</span><br><span class="line">    for _, file := range files {</span><br><span class="line">        f, err := w.Create(file.Name)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">        _, err = f.Write([]byte(file.Body))</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 关闭压缩文档</span><br><span class="line">    err := w.Close()</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 将压缩文档内容写入文件</span><br><span class="line">    f, err := os.OpenFile("file.zip", os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    buf.WriteTo(f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的文件会在当前目录下生成 file.zip 文件，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/zipfile.gif" alt="zipfile"></p>
<h3 id="读取-zip-归档文件"><a href="#读取-zip-归档文件" class="headerlink" title="读取 zip 归档文件"></a>读取 zip 归档文件</h3><p>读取一个 <code>.zip</code> 归档文件与创建一个归档文件一样简单，只是如果归档文件中包含带有路径的文件名，就必须重建目录结构。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/zip"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 打开一个zip格式文件</span><br><span class="line">    r, err := zip.OpenReader("file.zip")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf(err.Error())</span><br><span class="line">    }</span><br><span class="line">    defer r.Close()</span><br><span class="line"></span><br><span class="line">    // 迭代压缩文件中的文件，打印出文件中的内容</span><br><span class="line">    for _, f := range r.File {</span><br><span class="line">        fmt.Printf("文件名: %s\n", f.Name)</span><br><span class="line">        rc, err := f.Open()</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf(err.Error())</span><br><span class="line">        }</span><br><span class="line">        _, err = io.CopyN(os.Stdout, rc, int64(f.UncompressedSize64))</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf(err.Error())</span><br><span class="line">        }</span><br><span class="line">        rc.Close()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">文件名: Golang.txt</span><br><span class="line">http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="tar归档文件的读写操作"><a href="#tar归档文件的读写操作" class="headerlink" title="tar归档文件的读写操作"></a>tar归档文件的读写操作</h2><p>接下来介绍一下 tar 归档文件的创建及读取。</p>
<h3 id="创建-tar-归档文件"><a href="#创建-tar-归档文件" class="headerlink" title="创建 tar 归档文件"></a>创建 tar 归档文件</h3><p>tar 是一种打包格式，但不对文件进行压缩，所以打包后的文档一般远远大于 zip 和 tar.gz，因为不需要压缩的原因，所以打包的速度是非常快的，打包时 CPU 占用率也很低。</p>
<p>tar 的目的在于方便文件的管理，比如在我们的生活中，有很多小物品分散在房间的各个角落，为了方便整洁可以将这些零散的物品整理进一个箱子中，而 tar 的功能就类似这样。</p>
<p>创建 tar 归档文件与创建 .zip 归档文件非常类似，主要不同点在于我们将所有数据都写入相同的 writer 中，并且在写入文件的数据之前必须写入完整的头部，而非仅仅是一个文件名。</p>
<p>tar 打包实现原理如下：</p>
<ul>
<li>创建一个文件 x.tar，然后向 x.tar 写入 tar 头部信息；</li>
<li>打开要被 tar 的文件，向 x.tar 写入头部信息，然后向 x.tar 写入文件信息；</li>
<li>当有多个文件需要被 tar 时，重复第二步直到所有文件都被写入到 x.tar 中；</li>
<li>关闭 x.tar，完成打包。</li>
</ul>
<p>下面通过示例程序简单演示一下Go语言 tar 打包的实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/tar"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := os.Create("./output.tar") //创建一个 tar 文件</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line"></span><br><span class="line">    tw := tar.NewWriter(f)</span><br><span class="line">    defer tw.Close()</span><br><span class="line"></span><br><span class="line">    fileinfo, err := os.Stat("./main.exe") //获取文件相关信息</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    hdr, err := tar.FileInfoHeader(fileinfo, "")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = tw.WriteHeader(hdr) //写入头文件信息</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    f1, err := os.Open("./main.exe")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    m, err := io.Copy(tw, f1) //将main.exe文件中的信息写入压缩包中</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录下生成一个 output.tar 文件，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/trafile.gif" alt="trafile"></p>
<h3 id="解压-tar-归档文件"><a href="#解压-tar-归档文件" class="headerlink" title="解压 tar 归档文件"></a>解压 tar 归档文件</h3><p>解压 tar 归档文件比创建 tar 归档文档稍微简单些。首先需要将其打开，然后从这个 tar 头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据即可。</p>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "archive/tar"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    f, err := os.Open("output.tar")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer f.Close()</span><br><span class="line">    r := tar.NewReader(f)</span><br><span class="line">    for hdr, err := r.Next(); err != io.EOF; hdr, err = r.Next() {</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        fileinfo := hdr.FileInfo()</span><br><span class="line">        fmt.Println(fileinfo.Name())</span><br><span class="line">        f, err := os.Create("123" + fileinfo.Name())</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">        defer f.Close()</span><br><span class="line">        _, err = io.Copy(f, r)</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的程序会将 tar 包的文件解压到当前目录中，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/4-20011Q42I5302.gif" alt="tarfile1"></p>
<p>至此，我们完成了对压缩和归档文件及常规文件处理的介绍。Go语言使用 io.Reader、io.ReadCloser、io.Writer 和 io.WriteCloser 等接口处理文件的方式让开发者可以使用相同的编码模式来读写文件或者其他流（如网络流或者甚至是字符串），从而大大降低了难度。</p>
<h2 id="使用buffer读取文件"><a href="#使用buffer读取文件" class="headerlink" title="使用buffer读取文件"></a>使用buffer读取文件</h2><p>buffer 是缓冲器的意思，Go语言要实现缓冲读取需要使用到 bufio 包。bufio 包本身包装了 io.Reader 和 io.Writer 对象，同时创建了另外的 Reader 和 Writer 对象，因此对于文本 I/O 来说，bufio 包提供了一定的便利性。</p>
<p>buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。</p>
<h3 id="使用-bufio-包写入文件"><a href="#使用-bufio-包写入文件" class="headerlink" title="使用 bufio 包写入文件"></a>使用 bufio 包写入文件</h3><p>bufio 和 io 包中有很多操作都是相似的，唯一不同的地方是 bufio 提供了一些缓冲的操作，如果对文件 I/O 操作比较频繁的，使用 bufio 包能够提高一定的性能。</p>
<p>在 bufio 包中，有一个 Writer 结构体，而其相关的方法支持一些写入操作，如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Writer 是一个空的结构体，一般需要使用 NewWriter 或者 NewWriterSize 来初始化一个结构体对象</span><br><span class="line">type Writer struct {</span><br><span class="line">        // contains filtered or unexported fields</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//NewWriterSize 和 NewWriter 函数</span><br><span class="line">//返回默认缓冲大小的 Writer 对象(默认是4096)</span><br><span class="line">func NewWriter(w io.Writer) *Writer</span><br><span class="line"></span><br><span class="line">//指定缓冲大小创建一个 Writer 对象</span><br><span class="line">func NewWriterSize(w io.Writer, size int) *Writer</span><br><span class="line"></span><br><span class="line">//Writer 对象相关的写入数据的方法</span><br><span class="line"></span><br><span class="line">//把 p 中的内容写入 buffer，返回写入的字节数和错误信息。如果 nn &lt; len(p)，返回错误信息中会包含为什么写入的数据比较短</span><br><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br><span class="line">//将 buffer 中的数据写入 io.Writer</span><br><span class="line">func (b *Writer) Flush() error</span><br><span class="line"></span><br><span class="line">//以下三个方法可以直接写入到文件中</span><br><span class="line">//写入单个字节</span><br><span class="line">func (b *Writer) WriteByte(c byte) error</span><br><span class="line">//写入单个 Unicode 指针返回写入字节数错误信息</span><br><span class="line">func (b *Writer) WriteRune(r rune) (size int, err error)</span><br><span class="line">//写入字符串并返回写入字节数和错误信息</span><br><span class="line">func (b *Writer) WriteString(s string) (int, error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    name := "demo.txt"</span><br><span class="line">    content := "http://c.biancheng.net/golang/"</span><br><span class="line"></span><br><span class="line">    fileObj, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    defer fileObj.Close()</span><br><span class="line">    writeObj := bufio.NewWriterSize(fileObj, 4096)</span><br><span class="line"></span><br><span class="line">    //使用 Write 方法,需要使用 Writer 对象的 Flush 方法将 buffer 中的数据刷到磁盘</span><br><span class="line">    buf := []byte(content)</span><br><span class="line">    if _, err := writeObj.Write(buf); err == nil {</span><br><span class="line">        if err := writeObj.Flush(); err != nil {</span><br><span class="line">            panic(err)</span><br><span class="line">        }</span><br><span class="line">        fmt.Println("数据写入成功")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的代码会在当前目录之下生成 demo.txt 文件，并将 <code>“http://c.biancheng.net/golang/”</code> 写入到该文件中。</p>
<h3 id="使用-bufio-包读取文件"><a href="#使用-bufio-包读取文件" class="headerlink" title="使用 bufio 包读取文件"></a>使用 bufio 包读取文件</h3><p>使用 bufio 包读取文件也非常方便，我们先来看下 bufio 包的相关的 Reader 函数方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//首先定义了一个用来缓冲 io.Reader 对象的结构体，同时该结构体拥有以下相关的方法</span><br><span class="line">type Reader struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//NewReader 函数用来返回一个默认大小 buffer 的 Reader 对象（默认大小是 4096） 等同于 NewReaderSize(rd,4096)</span><br><span class="line">func NewReader(rd io.Reader) *Reader</span><br><span class="line"></span><br><span class="line">//该函数返回一个指定大小 buffer（size 最小为 16）的 Reader 对象，如果 io.Reader 参数已经是一个足够大的 Reader，它将返回该 Reader</span><br><span class="line">func NewReaderSize(rd io.Reader, size int) *Reader</span><br><span class="line"></span><br><span class="line">//该方法返回从当前 buffer 中能被读到的字节数</span><br><span class="line">func (b *Reader) Buffered() int</span><br><span class="line"></span><br><span class="line">//Discard 方法跳过后续的 n 个字节的数据，返回跳过的字节数。如果 0 &lt;= n &lt;= b.Buffered()，该方法将不会从 io.Reader 中成功读取数据</span><br><span class="line">func (b *Reader) Discard(n int) (discarded int, err error)</span><br><span class="line"></span><br><span class="line">//Peekf 方法返回缓存的一个切片，该切片只包含缓存中的前 n 个字节的数据</span><br><span class="line">func (b *Reader) Peek(n int) ([]byte, error)</span><br><span class="line"></span><br><span class="line">//把 Reader 缓存对象中的数据读入到 []byte 类型的 p 中，并返回读取的字节数。读取成功，err 将返回空值</span><br><span class="line">func (b *Reader) Read(p []byte) (n int, err error)</span><br><span class="line"></span><br><span class="line">//返回单个字节，如果没有数据返回 err</span><br><span class="line">func (b *Reader) ReadByte() (byte, error)</span><br><span class="line"></span><br><span class="line">//该方法在 b 中读取 delimz 之前的所有数据，返回的切片是已读出的数据的引用，切片中的数据在下一次的读取操作之前是有效的。如果未找到 delim，将返回查找结果并返回 nil 空值。因为缓存的数据可能被下一次的读写操作修改，因此一般使用 ReadBytes 或者 ReadString，他们返回的都是数据拷贝</span><br><span class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span><br><span class="line"></span><br><span class="line">//功能同 ReadSlice，返回数据的拷贝</span><br><span class="line">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</span><br><span class="line"></span><br><span class="line">//功能同 ReadBytes，返回字符串</span><br><span class="line">func (b *Reader) ReadString(delim byte) (string, error)</span><br><span class="line"></span><br><span class="line">//该方法是一个低水平的读取方式，一般建议使用 ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner 来代替。ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片，用于读取一行数据，不包括行尾标记（\n 或 \r\n）</span><br><span class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span><br><span class="line"></span><br><span class="line">//读取单个 UTF-8 字符并返回一个 rune 和字节大小</span><br><span class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strconv"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fileObj, err := os.Open("demo.txt")</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败：", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer fileObj.Close()</span><br><span class="line">    //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空</span><br><span class="line">    reader := bufio.NewReader(fileObj)</span><br><span class="line">    buf := make([]byte, 1024)</span><br><span class="line">    //读取 Reader 对象中的内容到 []byte 类型的 buf 中</span><br><span class="line">    info, err := reader.Read(buf)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("读取的字节数:" + strconv.Itoa(info))</span><br><span class="line">    //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉</span><br><span class="line">    fmt.Println("读取的文件内容:", string(buf))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">读取的字节数:30</span><br><span class="line">读取的文件内容: http://c.biancheng.net/golang/</span><br></pre></td></tr></tbody></table></figure>
<h2 id="并发目录遍历"><a href="#并发目录遍历" class="headerlink" title="并发目录遍历"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5406.html">并发目录遍历</a></h2><p>我们将构建一个程序，根据命令行指定的输入，报告一个或多个目录的磁盘使用情况，类似于 UNIX 的du命令。该程序大多数工作是由下面的 walkDir 函数完成，它使用 dirents 辅助函数来枚举目录中的条目，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树，并在 filesizes 上发送每个已找到文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ioutil.ReadDir 函数返回一个 os.FileInfo 类型的 slice，针对单个文件同样的信息可以通过调用 os.Stat 函数来返回。对每一个子目录，walkDir 递归调用它自己，对于每一个文件，walkDir 发送一条消息到 fileSizes 通道，消息的内容为文件所占用的字节数。</p>
<p>程序的完整代码如下所示，代码中 main 函数使用两个 goroutine，后台 goroutine 调用 walkDir 遍历命令行上指定的每一个目录，最后关闭 fileSizes 通道；主 goroutine 计算从通道中接收的文件的大小的和，最后输出总数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    flag.Parse()</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    go func() {</span><br><span class="line">        for _, root := range roots {</span><br><span class="line">            walkDir(root, fileSizes)</span><br><span class="line">        }</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">    for size := range fileSizes {</span><br><span class="line">        nfiles++</span><br><span class="line">        nbytes += size</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在输出结果前，程序等待较长时间：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go run main.go D:/code</span><br><span class="line">18681 files  0.5 GB</span><br></pre></td></tr></tbody></table></figure>
<p>如果程序可以通知它的进度，将会更友好，但是仅把 printDiskUsage 调用移动到循环内部会使它输出数千行结果，所以这里对上面的程序进行一些调整，在有 <code>-v</code> 标识的时候周期性的输出当前目录的总和，如果只想看到最终的结果省略 <code>-v</code> 即可。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var verbose = flag.Bool("v", false, "显示详细进度")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // ...启动后台 goroutine...</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    flag.Parse()</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line">    // 遍历文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    go func() {</span><br><span class="line">        for _, root := range roots {</span><br><span class="line">            walkDir(root, fileSizes)</span><br><span class="line">        }</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line">    // 定期打印结果</span><br><span class="line">    var tick &lt;-chan time.Time</span><br><span class="line">    if *verbose {</span><br><span class="line">        tick = time.Tick(500 * time.Millisecond)</span><br><span class="line">    }</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">loop:</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case size, ok := &lt;-fileSizes:</span><br><span class="line">            if !ok {</span><br><span class="line">                break loop // fileSizes 关闭</span><br><span class="line">            }</span><br><span class="line">            nfiles++</span><br><span class="line">            nbytes += size</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            printDiskUsage(nfiles, nbytes)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes) // 最终总数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小</span><br><span class="line">func walkDir(dir string, fileSizes chan&lt;- int64) {</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            walkDir(subdir, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// dirents 返回 dir 目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du1: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为这个程序没有使用 range 循环，所以第一个 select 情况必须显式判断 fileSizes 通道是否已经关闭，使用两个返回值的形式进行接收操作。如果通道已经关闭，程序退出循环。标签化的 break 语句将跳出 select 和 for 循环的逻辑。没有标签的 break 只能跳出 select 的逻辑，导致循环的下一次迭代。</p>
<p>运行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go run main.go -v D:\</span><br><span class="line">296077 files  57.9 GB</span><br><span class="line">302142 files  58.0 GB</span><br><span class="line">306669 files  58.1 GB</span><br><span class="line">314725 files  58.2 GB</span><br><span class="line">320050 files  58.3 GB</span><br><span class="line">341713 files  58.6 GB</span><br><span class="line">346102 files  64.2 GB</span><br></pre></td></tr></tbody></table></figure>
<p>此程序的弊端也很明显，它依然会耗费太长的时间。</p>
<p>所以，下面为每一个 walkDir 的调用创建一个新的 goroutine。它使用 sync.WaitGroup 来为当前存活的 walkDir 调用计数，一个 goroutine 在计数器减为 0 的时候关闭 fileSizes 通道。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "flag"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "sync"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var verbose = flag.Bool("v", false, "显示详细进度")</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // ...确定根目录...</span><br><span class="line">    flag.Parse()</span><br><span class="line">    // 确定初始目录</span><br><span class="line">    roots := flag.Args()</span><br><span class="line">    if len(roots) == 0 {</span><br><span class="line">        roots = []string{"."}</span><br><span class="line">    }</span><br><span class="line">    // 并行遍历每一个文件树</span><br><span class="line">    fileSizes := make(chan int64)</span><br><span class="line">    var n sync.WaitGroup</span><br><span class="line">    for _, root := range roots {</span><br><span class="line">        n.Add(1)</span><br><span class="line">        go walkDir(root, &amp;n, fileSizes)</span><br><span class="line">    }</span><br><span class="line">    go func() {</span><br><span class="line">        n.Wait()</span><br><span class="line">        close(fileSizes)</span><br><span class="line">    }()</span><br><span class="line">    // 定期打印结果</span><br><span class="line">    var tick &lt;-chan time.Time</span><br><span class="line">    if *verbose {</span><br><span class="line">        tick = time.Tick(500 * time.Millisecond)</span><br><span class="line">    }</span><br><span class="line">    var nfiles, nbytes int64</span><br><span class="line">loop:</span><br><span class="line">    for {</span><br><span class="line">        select {</span><br><span class="line">        case size, ok := &lt;-fileSizes:</span><br><span class="line">            if !ok {</span><br><span class="line">                break loop // fileSizes 关闭</span><br><span class="line">            }</span><br><span class="line">            nfiles++</span><br><span class="line">            nbytes += size</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            printDiskUsage(nfiles, nbytes)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printDiskUsage(nfiles, nbytes) // 最终总数</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func printDiskUsage(nfiles, nbytes int64) {</span><br><span class="line">    fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) {</span><br><span class="line">    defer n.Done()</span><br><span class="line">    for _, entry := range dirents(dir) {</span><br><span class="line">        if entry.IsDir() {</span><br><span class="line">            n.Add(1)</span><br><span class="line">            subdir := filepath.Join(dir, entry.Name())</span><br><span class="line">            go walkDir(subdir, n, fileSizes)</span><br><span class="line">        } else {</span><br><span class="line">            fileSizes &lt;- entry.Size()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// sema是一个用于限制目录并发数的计数信号量</span><br><span class="line">var sema = make(chan struct{}, 20)</span><br><span class="line"></span><br><span class="line">// dirents返回directory目录中的条目</span><br><span class="line">func dirents(dir string) []os.FileInfo {</span><br><span class="line">    sema &lt;- struct{}{}        // 获取令牌</span><br><span class="line">    defer func() { &lt;-sema }() // 释放令牌</span><br><span class="line">    entries, err := ioutil.ReadDir(dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Fprintf(os.Stderr, "du: %v\n", err)</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>尽管系统与系统之间有很多的不同，但是这个版本的速度比前一个版本快几倍。</p>
<h2 id="从INI配置文件中读取需要的值"><a href="#从INI配置文件中读取需要的值" class="headerlink" title="从INI配置文件中读取需要的值"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5407.html">从INI配置文件中读取需要的值</a></h2><p>INI 文件是 Initialization File 的缩写，即初始化文件，是 Windows 的系统配置文件所采用的存储格式，统管 Windows 的各项配置。INI 文件格式由节（section）和键（key）构成，一般用于操作系统、虚幻游戏引擎、GIT 版本管理中，这种配置文件的文件扩展名为.ini。</p>
<p>下面是从 GIT 版本管理的配置文件中截取的一部分内容，展示 INI 文件的样式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line"></span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">hideDotFiles = dotGitOnly</span><br><span class="line">[remote "origin"]</span><br><span class="line">url = https://github.com/davyxu/cellnet</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch "master"]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br></pre></td></tr></tbody></table></figure>
<h3 id="INI-文件的格式"><a href="#INI-文件的格式" class="headerlink" title="INI 文件的格式"></a>INI 文件的格式</h3><p>INI 文件由多行文本组成，整个配置由 <code>[ ]</code> 拆分为多个“段”（section）。每个段中又以 <code>＝</code> 分割为“键”和“值”。</p>
<p>INI 文件以 <code>;</code> 置于行首视为注释，注释后将不会被处理和识别，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[sectionl]</span><br><span class="line">key1=value1</span><br><span class="line">;key2=value2</span><br><span class="line">[section2]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="从-INI-文件中取值的函数"><a href="#从-INI-文件中取值的函数" class="headerlink" title="从 INI 文件中取值的函数"></a>从 INI 文件中取值的函数</h3><p>熟悉了 INI 文件的格式后，下面我们创建一个 example.ini 文件，并将从 GIT 版本管理配置文件中截取的一部分内容复制到该文件中。</p>
<p>准备好 example.ini 文件后，下面我们开始尝试读取该 INI 文件，并从文件中获取需要的数据，完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 根据文件名，段名，键名获取ini的值</span><br><span class="line">func getValue(filename, expectSection, expectKey string) string {</span><br><span class="line">    // 打开文件</span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    // 文件找不到，返回空</span><br><span class="line">    if err != nil {</span><br><span class="line">        return ""</span><br><span class="line">    }</span><br><span class="line">    // 在函数结束时，关闭文件</span><br><span class="line">    defer file.Close()</span><br><span class="line">    // 使用读取器读取文件</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    // 当前读取的段的名字</span><br><span class="line">    var sectionName string</span><br><span class="line">    for {</span><br><span class="line">        // 读取文件的一行</span><br><span class="line">        linestr, err := reader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        // 切掉行的左右两边的空白字符</span><br><span class="line">        linestr = strings.TrimSpace(linestr)</span><br><span class="line">        // 忽略空行</span><br><span class="line">        if linestr == "" {</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        // 忽略注释</span><br><span class="line">        if linestr[0] == ';' {</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        // 行首和尾巴分别是方括号的，说明是段标记的起止符</span><br><span class="line">        if linestr[0] == '[' &amp;&amp; linestr[len(linestr)-1] == ']' {</span><br><span class="line">            // 将段名取出</span><br><span class="line">            sectionName = linestr[1 : len(linestr)-1]</span><br><span class="line">            // 这个段是希望读取的</span><br><span class="line">        } else if sectionName == expectSection {</span><br><span class="line">            // 切开等号分割的键值对</span><br><span class="line">            pair := strings.Split(linestr, "=")</span><br><span class="line">            // 保证切开只有1个等号分割的简直情况</span><br><span class="line">            if len(pair) == 2 {</span><br><span class="line">                // 去掉键的多余空白字符</span><br><span class="line">                key := strings.TrimSpace(pair[0])</span><br><span class="line">                // 是期望的键</span><br><span class="line">                if key == expectKey {</span><br><span class="line">                    // 返回去掉空白字符的值</span><br><span class="line">                    return strings.TrimSpace(pair[1])</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return ""</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(getValue("example.ini", "remote \"origin\"", "fetch"))</span><br><span class="line">    fmt.Println(getValue("example.ini", "core", "hideDotFiles"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本例并不是将整个 INI 文件读取保存后再获取需要的字段数据并返回，这里使用 getValue() 函数，每次从指定文件中找到需要的段（Section）及键（Key）对应的值。</p>
<p>getValue() 函数的声明如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func getValue(filename, expectSection, expectKey string) string</span><br></pre></td></tr></tbody></table></figure>
<p>参数说明如下。</p>
<ul>
<li>filename：INI 文件的文件名。</li>
<li>expectSection：期望读取的段。</li>
<li>expectKey：期望读取段中的键。</li>
</ul>
<p>getValue() 函数的实际使用例子参考代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    fmt.Println(getValue("example.ini", "remote \"origin\"", "fetch"))</span><br><span class="line">    fmt.Println(getValue("example.ini", "core", "hideDotFiles"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行上面的示例程序，输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+refs/heads/*:refs/remotes/origin/*</span><br><span class="line">dotGitOnly</span><br></pre></td></tr></tbody></table></figure>
<p>输出内容中“+refs/heads/<em>:refs/remotes/origin/</em>”表示 INI 文件中 <code>[remote "origin"]</code> 的 “fetch” 键对应的值；dotGitOnly 表示 INI 文件中 <code>[core]</code> 中键名为 “hideDotFiles” 的值。</p>
<p><strong>注意 main 函数的第 2 行中，由于段名中包含双引号，所以使用\进行转义。</strong></p>
<p>getValue() 函数的逻辑由 4 部分组成：即读取文件、读取行文本、读取段和读取键值组成。接下来分步骤了解 getValue() 函数的详细处理过程。</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>Go语言的 OS 包中提供了文件打开函数 os.Open()，文件读取完成后需要及时关闭，否则文件会发生占用，系统无法释放缓冲资源。参考下面代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 打开文件</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">// 文件找不到，返回空</span><br><span class="line">if err != nil {</span><br><span class="line">    return ""</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在函数结束时，关闭文件</span><br><span class="line">defer file.Close()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，filename 是由 getValue() 函数参数提供的 INI 的文件名。使用 os.Open() 函数打开文件，如果成功打开，会返回文件句柄，同时返回打开文件时可能发生的错误：err。</li>
<li>第 5 行，如果文件打开错误，err 将不为 nil，此时 getValue() 函数返回一个空的字符串，表示无法从给定的 INI 文件中获取到需要的值。</li>
<li>第 10 行，使用 defer 延迟执行函数，defer 并不会在这一行执行，而是延迟在任何一个 getValue() 函数的返回点，也就是函数退出的地方执行。调用 file.Close() 函数后，打开的文件就会被关闭并释放系统资源。</li>
</ul>
<p>INI 文件已经打开了，接下来就可以开始读取 INI 的数据了。</p>
<h3 id="读取行文本"><a href="#读取行文本" class="headerlink" title="读取行文本"></a>读取行文本</h3><p>INI 文件的格式是由多行文本组成，因此需要构造一个循环，不断地读取 INI 文件的所有行。Go语言总是将文件以二进制格式打开，通过不同的读取方式对二进制文件进行操作。Go语言对二进制读取有专门的代码，bufio 包即可以方便地以比较常见的方式读取二进制文件。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 使用读取器读取文件</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">// 当前读取的段的名字</span><br><span class="line">var sectionName string</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    // 读取文件的一行</span><br><span class="line">    linestr, err := reader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 切掉行的左右两边的空白字符</span><br><span class="line">    linestr = strings.TrimSpace(linestr)</span><br><span class="line"></span><br><span class="line">    // 忽略空行</span><br><span class="line">    if linestr == "" {</span><br><span class="line">        continue</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 忽略注释</span><br><span class="line">    if linestr[0] == ';' {</span><br><span class="line">        continue</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //读取段和键值的代码</span><br><span class="line">    //...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，使用 bufio 包提供的 NewReader() 函数，传入文件并构造一个读取器。</li>
<li>第 5 行，提前声明段的名字字符串，方便后面的段和键值读取。</li>
<li>第 7 行，构建一个读取循环，不断地读取文件中的每一行。</li>
<li>第 10 行，使用 reader.ReadString() 从文件中读取字符串，直到碰到\n，也就是行结束。这个函数返回读取到的行字符串（包括\n）和可能的读取错误 err，例如文件读取完毕。</li>
<li>第 16 行，每一行的文本可能会在标识符两边混杂有空格、回车符、换行符等不可见的空白字符，使用 strings.TrimSpace() 可以去掉这些空白字符。</li>
<li>第 19 行，可能存在空行的情况，继续读取下一行，忽略空行。</li>
<li>第 24 行，当行首的字符为;分号时，表示这一行是注释行，忽略一整行的读取。</li>
</ul>
<p>读取 INI 文本文件时，需要注意各种异常情况。文本中的空白符就是经常容易忽略的部分，空白符在调试时完全不可见，需要打印出字符的 ASCII 码才能辨别。</p>
<p>抛开各种异常情况拿到了每行的行文本 linestr 后，就可以方便地读取 INI 文件的段和键值了。</p>
<h3 id="读取段"><a href="#读取段" class="headerlink" title="读取段"></a>读取段</h3><p>行字符串 linestr 已经去除了空白字符串，段的起止符又以 <code>[</code> 开头，以 <code>]</code> 结尾，因此可以直接判断行首和行尾的字符串匹配段的起止符匹配时读取的是段，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sectionvalue.gif" alt="sectionvalue"></p>
<p>此时，段只是一个标识，而无任何内容，因此需要将段的名字取出保存在 sectionName（己在之前的代码中定义）中，待读取段后面的键值对时使用。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 行首和尾巴分别是方括号的，说明是段标记的起止符</span><br><span class="line">if linestr[0] == '[' &amp;&amp; linestr[len(linestr)-1] == ']' {</span><br><span class="line"></span><br><span class="line">    // 将段名取出</span><br><span class="line">    sectionName = linestr[1 : len(linestr)-1]</span><br><span class="line"></span><br><span class="line">    // 这个段是希望读取的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，<code>linestr[0]</code> 表示行首的字符，<code>len(linestr)-1</code> 取出字符串的最后一个字符索引随后取出行尾的字符。根据两个字符串是否匹配方括号，断定当前行是否为段。</li>
<li>第 5 行，linestr 两边的 <code>[</code> 和 <code>]</code> 去掉，取出中间的段名保存在 sectionName 中，留着后面的代码用。</li>
</ul>
<h3 id="读取键值"><a href="#读取键值" class="headerlink" title="读取键值"></a>读取键值</h3><p>这里代码紧接着前面的代码。当前行不是段时（不以 <code>[</code> 开头），那么行内容一定是键值对。别忘记此时 getValue() 的参数对段有匹配要求。找到能匹配段的键值对后，开始对键值对进行解析，参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">else if sectionName == expectSection {</span><br><span class="line"></span><br><span class="line">    // 切开等号分割的键值对</span><br><span class="line">    pair := strings.Split(linestr, "=")</span><br><span class="line"></span><br><span class="line">    // 保证切开只有1个等号分割的简直情况</span><br><span class="line">    if len(pair) == 2 {</span><br><span class="line"></span><br><span class="line">        // 去掉键的多余空白字符</span><br><span class="line">        key := strings.TrimSpace(pair[0])</span><br><span class="line"></span><br><span class="line">        // 是期望的键</span><br><span class="line">        if key == expectKey {</span><br><span class="line"></span><br><span class="line">            // 返回去掉空白字符的值</span><br><span class="line">            return strings.TrimSpace(pair[1])</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，当前的段匹配期望的段时，进行后面的解析。</li>
<li>第 4 行，对行内容（linestr）通过 <code>strings.Split()</code> 函数进行切割，INI 的键值对使用 <code>=</code> 分割，分割后 <code>strings.Split()</code> 函数会返回字符串切片，其类型为  <code>[]string</code> 。这里只考虑一个=的情况，因此被分割后 <code>strings.Split()</code> 函数返回的字符串切片有 2 个元素。</li>
<li>第 7 行，只考虑切割出 2 个元素的情况。其他情况会被忽略， 键值如没有 <code>=</code> 、行中多余一个 <code>=</code> 等情况。</li>
<li>第 10 行，<code>pair[0]</code> 表示 <code>=</code> 左边的键。使用 <code>strings.TrimSpace()</code> 函数去掉空白符，如下图所示。</li>
<li>第 13 行，键值对切割出后，还需要判断键是否为期望的键。</li>
<li>第 16 行，匹配期望的键时，将 <code>pair[1]</code> 中保存的键对应的值经过去掉空白字符处理后作为函数返回值返回。</li>
</ul>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/inivalue.gif" alt="图：lNI 的键值解析"></p>
<h2 id="文件的写入、追加、读取、复制操作"><a href="#文件的写入、追加、读取、复制操作" class="headerlink" title="文件的写入、追加、读取、复制操作"></a>文件的写入、追加、读取、复制操作</h2><p>Go语言的 os 包下有一个 OpenFile 函数，其原型如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</span><br></pre></td></tr></tbody></table></figure>
<p>其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的。</p>
<p>下面列举了一些常用的 flag 文件处理参数：</p>
<ul>
<li>O_RDONLY：只读模式打开文件；</li>
<li>O_WRONLY：只写模式打开文件；</li>
<li>O_RDWR：读写模式打开文件；</li>
<li>O_APPEND：写操作时将数据附加到文件尾部（追加）；</li>
<li>O_CREATE：如果不存在将创建一个新文件；</li>
<li>O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；</li>
<li>O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；</li>
<li>O_TRUNC：如果可能，在打开时清空文件。</li>
</ul>
<p>【示例 1】：创建一个新文件 golang.txt，并在其中写入 5 句 <code>“http://c.biancheng.net/golang/”</code>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //创建一个新文件，写入内容 5 句 “http://c.biancheng.net/golang/”</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("http://c.biancheng.net/golang/ \n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后会在指定目录下生成一个 golang.txt 文件，打开该文件如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext.gif" alt="golangtext"></p>
<p>【示例 2】：打开一个存在的文件，在原来的内容追加内容“C语言中文网”</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("C语言中文网 \r\n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后，打开 golang.txt 文件发现内容追加成功，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext1.gif" alt="golangtext1"></p>
<p>【示例 3】：打开一个存在的文件，将原来的内容读出来，显示在终端，并且追加 5 句“Hello，C语言中文网”。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    filePath := "e:/code/golang.txt"</span><br><span class="line">    file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println("文件打开失败", err)</span><br><span class="line">    }</span><br><span class="line">    //及时关闭file句柄</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    //读原来文件的内容，并且显示在终端</span><br><span class="line">    reader := bufio.NewReader(file)</span><br><span class="line">    for {</span><br><span class="line">        str, err := reader.ReadString('\n')</span><br><span class="line">        if err == io.EOF {</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        fmt.Print(str)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //写入文件时，使用带缓存的 *Writer</span><br><span class="line">    write := bufio.NewWriter(file)</span><br><span class="line">    for i := 0; i &lt; 5; i++ {</span><br><span class="line">        write.WriteString("Hello，C语言中文网。 \r\n")</span><br><span class="line">    }</span><br><span class="line">    //Flush将缓存的文件真正写入到文件中</span><br><span class="line">    write.Flush()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功之后，会在控制台打印出文件的内容，并在文件中追加指定的内容，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext2.gif" alt="golangtext2"></p>
<p>【示例 4】：编写一个程序，将一个文件的内容复制到另外一个文件（注：这两个文件都已存在）</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "io/ioutil"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    file1Path := "e:/code/golang.txt"</span><br><span class="line">    file2Path := "e:/code/other.txt"</span><br><span class="line">    data, err := ioutil.ReadFile(file1Path)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败=%v\n", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    err = ioutil.WriteFile(file2Path, data, 0666)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("文件打开失败=%v\n", err)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行成功后，发现内容已经复制成功，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/golangtext3.gif" alt="golangtext3"></p>
<h2 id="文件锁操作"><a href="#文件锁操作" class="headerlink" title="文件锁操作"></a>文件锁操作</h2><p>我们使用Go语言开发一些程序的时候，往往出现多个进程同时操作同一份文件的情况，这很容易导致文件中的数据混乱。这时我们就需要采用一些手段来平衡这些冲突，文件锁（flock）应运而生，下面我们就来介绍一下。</p>
<p>对于 flock，最常见的例子就是 Nginx，进程运行起来后就会把当前的 PID 写入这个文件，当然如果这个文件已经存在了，也就是前一个进程还没有退出，那么 Nginx 就不会重新启动，所以 flock 还可以用来检测进程是否存在。</p>
<p>flock 是对于整个文件的建议性锁。也就是说，如果一个进程在一个文件（inode）上放了锁，其它进程是可以知道的（建议性锁不强求进程遵守）。最棒的一点是，它的第一个参数是文件描述符，在此文件描述符关闭时，锁会自动释放。而当进程终止时，所有的文件描述符均会被关闭。所以很多时候就不用考虑类似原子锁解锁的事情。</p>
<p>在具体介绍前，先上代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "sync"</span><br><span class="line">    "syscall"</span><br><span class="line">    "time"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//文件锁</span><br><span class="line">type FileLock struct {</span><br><span class="line">    dir string</span><br><span class="line">    f   *os.File</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func New(dir string) *FileLock {</span><br><span class="line">    return &amp;FileLock{</span><br><span class="line">        dir: dir,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//加锁</span><br><span class="line">func (l *FileLock) Lock() error {</span><br><span class="line">    f, err := os.Open(l.dir)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return err</span><br><span class="line">    }</span><br><span class="line">    l.f = f</span><br><span class="line">    err = syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return fmt.Errorf("cannot flock directory %s - %s", l.dir, err)</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//释放锁</span><br><span class="line">func (l *FileLock) Unlock() error {</span><br><span class="line">    defer l.f.Close()</span><br><span class="line">    return syscall.Flock(int(l.f.Fd()), syscall.LOCK_UN)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    test_file_path, _ := os.Getwd()</span><br><span class="line">    locked_file := test_file_path</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup{}</span><br><span class="line"></span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(num int) {</span><br><span class="line">            flock := New(locked_file)</span><br><span class="line">            err := flock.Lock()</span><br><span class="line">            if err != nil {</span><br><span class="line">                wg.Done()</span><br><span class="line">                fmt.Println(err.Error())</span><br><span class="line">                return</span><br><span class="line">            }</span><br><span class="line">            fmt.Printf("output : %d\n", num)</span><br><span class="line">            wg.Done()</span><br><span class="line">        }(i)</span><br><span class="line">    }</span><br><span class="line">    wg.Wait()</span><br><span class="line">    time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Windows 系统下运行上面的代码会出现下面的错误：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">undefined: syscall.Flock</span><br><span class="line">undefined: syscall.LOCK_EX</span><br><span class="line">undefined: syscall.LOCK_NB</span><br><span class="line">undefined: syscall.Flock</span><br><span class="line">undefined: syscall.LOCK_UN</span><br></pre></td></tr></tbody></table></figure>
<p>这是因为 Windows 系统不支持 pid 锁，所以我们需要在 Linux 或 Mac 系统下才能正常运行上面的程序。</p>
<p>上面代码中演示了同时启动 10 个 goroutinue，但在程序运行过程中，只有一个 goroutine 能获得文件锁（flock）。其它的 goroutinue 在获取不到 flock 后，会抛出异常的信息。这样即可达到同一文件在指定的周期内只允许一个进程访问的效果。</p>
<p>代码中文件锁的具体调用：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)</span><br></pre></td></tr></tbody></table></figure>
<p>我们采用了 syscall.LOCK_EX、syscall.LOCK_NB，这是什么意思呢？</p>
<p>flock 属于建议性锁，不具备强制性。一个进程使用 flock 将文件锁住，另一个进程可以直接操作正在被锁的文件，修改文件中的数据，原因在于 flock 只是用于检测文件是否被加锁，针对文件已经被加锁，另一个进程写入数据的情况，内核不会阻止这个进程的写入操作，也就是建议性锁的内核处理策略。</p>
<p>flock 主要三种操作类型：</p>
<ul>
<li>LOCK_SH：共享锁，多个进程可以使用同一把锁，常被用作读共享锁；</li>
<li>LOCK_EX：排他锁，同时只允许一个进程使用，常被用作写锁；</li>
<li>LOCK_UN：释放锁。</li>
</ul>
<p>进程使用 flock 尝试锁文件时，如果文件已经被其他进程锁住，进程会被阻塞直到锁被释放掉，或者在调用 flock 的时候，采用 LOCK_NB 参数。在尝试锁住该文件的时候，发现已经被其他服务锁住，会返回错误，错误码为 EWOULDBLOCK。</p>
<p>flock 锁的释放非常具有特色，即可调用 LOCK_UN 参数来释放文件锁，也可以通过关闭 fd 的方式来释放文件锁（flock 的第一个参数是 fd），意味着 flock 会随着进程的关闭而被自动释放掉。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/543a448f/">https://wssjdi.github.io/posts/543a448f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/go-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">go 文件处理</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/b3ea2e2d/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">go反射（reflect），Golang反射（reflect）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/91175219/" title="Go流程控制"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go流程控制</div></div></a></div><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>