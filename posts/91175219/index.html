<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go流程控制 | Wssjdi</title><meta name="description" content="go"><meta name="keywords" content="go,流程控制"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/91175219/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go流程控制"><meta property="og:url" content="https://wssjdi.github.io/posts/91175219/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-20T05:53:55.000Z"><meta property="article:modified_time" content="2020-10-20T09:42:15.260Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-20 17:42:15'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else"><span class="toc-text">if else</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%86%99%E6%B3%95"><span class="toc-text">特殊写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">for (循环结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B%E5%BE%AA%E7%8E%AF%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-text">for 中的初始语句——开始循环时执行的语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%98%AF%E5%90%A6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BC%80%E5%85%B3"><span class="toc-text">for 中的条件表达式——控制是否循环的开关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF%E6%97%B6%E5%B8%A6%E5%8F%AF%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-text">结束循环时带可执行语句的无限循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-text">无限循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">只有一个循环条件的循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9D%9F%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%AF%8F%E6%AC%A1%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9D%9F%E6%97%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-text">for 中的结束语句——每次循环结束时执行的语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="toc-text">输出九九乘法表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-range-%E9%94%AE%E5%80%BC%E5%BE%AA%E7%8E%AF"><span class="toc-text">for range (键值循环)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E2%80%94%E2%80%94%E8%8E%B7%E5%BE%97%E7%B4%A2%E5%BC%95%E5%92%8C%E5%80%BC"><span class="toc-text">遍历数组、切片——获得索引和值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94%E8%8E%B7%E5%BE%97%E5%AD%97%E7%AC%A6"><span class="toc-text">遍历字符串——获得字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-map%E2%80%94%E2%80%94%E8%8E%B7%E5%BE%97-map-%E7%9A%84%E9%94%AE%E5%92%8C%E5%80%BC"><span class="toc-text">遍历 map——获得 map 的键和值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%80%9A%E9%81%93%EF%BC%88channel%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E6%94%B6%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE"><span class="toc-text">遍历通道（channel）——接收通道数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%81%8D%E5%8E%86%E4%B8%AD%E9%80%89%E6%8B%A9%E5%B8%8C%E6%9C%9B%E8%8E%B7%E5%BE%97%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">在遍历中选择希望获得的变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-case"><span class="toc-text">switch case</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95"><span class="toc-text">基本写法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%88%86%E6%94%AF%E5%A4%9A%E5%80%BC"><span class="toc-text">一分支多值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">分支表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%B6%8A-case-%E7%9A%84-fallthrough%E2%80%94%E2%80%94%E5%85%BC%E5%AE%B9C%E8%AF%AD%E8%A8%80%E7%9A%84-case-%E8%AE%BE%E8%AE%A1"><span class="toc-text">跨越 case 的 fallthrough——兼容C语言的 case 设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goto%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-text">goto语句——跳转到指定的标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-goto-%E9%80%80%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF"><span class="toc-text">使用 goto 退出多层循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-goto-%E9%9B%86%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-text">使用 goto 集中处理错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%EF%BC%88%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-text">break（跳出循环）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue%EF%BC%88%E7%BB%A7%E7%BB%AD%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-text">continue（继续下一次循环）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="toc-text">示例：聊天机器人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1"><span class="toc-text">示例：词频统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BC%A9%E8%BF%9B%E6%8E%92%E5%BA%8F"><span class="toc-text">示例：缩进排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">示例：二分查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">示例：冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%86%99%E6%B3%95"><span class="toc-text">四种冒泡排序写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">Go语言分布式id生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#worker-id-%E5%88%86%E9%85%8D"><span class="toc-text">worker_id 分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86-snowflake-%E5%AE%9E%E7%8E%B0"><span class="toc-text">标准 snowflake 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sonyflake"><span class="toc-text">sonyflake</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go流程控制</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-20T05:53:55.000Z" title="发表于 2020-10-20 13:53:55">2020-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-20T09:42:15.260Z" title="更新于 2020-10-20 17:42:15">2020-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go 语言的常用流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<p>Go 语言中的基本流程控制语句，包括分支语句（if 和 switch）、循环（for）和跳转（goto）语句。另外，还有循环控制语句（break 和 continue），前者的功能是中断循环或者跳出 switch 判断，后者的功能是继续 for 的下一个循环。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号{}括起来的代码块，否则就忽略该代码块继续执行后续的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition {</span><br><span class="line">    // do something</span><br><span class="line">} else {</span><br><span class="line">    // do something</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果存在第三个分支，则可以使用下面这种三个独立分支的形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 {</span><br><span class="line">    // do something</span><br><span class="line">} else if condition2 {</span><br><span class="line">    // do something else</span><br><span class="line">}else {</span><br><span class="line">    // catch-all or default</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。</p>
<p>关键字 if 和 else 之后的左大括号 <code>{</code> 必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号 <code>}</code> 必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p>
<p>非法的 Go 代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x{</span><br><span class="line">}</span><br><span class="line">else { // 无效的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号 <code>}</code> 与对应的 if 关键字垂直对齐。</p>
<p>在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过下面的例子来了解 if 的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ten int = 11</span><br><span class="line">if ten &gt; 10 {</span><br><span class="line">    fmt.Println("&gt;10")</span><br><span class="line">} else {</span><br><span class="line">    fmt.Println("&lt;=10")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;10</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，声明整型变量并赋值 11。</li>
<li>第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。</li>
<li>第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。</li>
</ul>
<h3 id="特殊写法"><a href="#特殊写法" class="headerlink" title="特殊写法"></a>特殊写法</h3><p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := Connect(); err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p>
<p>err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p>
<p>这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</p>
<p><strong><em>提示:在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</em></strong></p>
<h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for (循环结构)"></a>for (循环结构)</h2><p>与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 C++ 中非常接近：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">    sum += i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号()括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 <code>for(;;){}</code> 和 <code>do{} while(1);</code> ，而直接简化为如下的写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum := 0</span><br><span class="line">for {</span><br><span class="line">    sum++</span><br><span class="line">    if sum &gt; 100 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用循环语句时，需要注意的有以下几点：</p>
<ul>
<li>左花括号 <code>{</code> 必须与 for 处于同一行。</li>
<li>Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li>
<li>Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ {</span><br><span class="line">    for i := 0; i &lt; 10; i++ {</span><br><span class="line">        if i &gt; 5 {</span><br><span class="line">            break JLoop</span><br><span class="line">        }</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">JLoop:</span><br><span class="line">// ...</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中，break 语句终止的是 JLoop 标签处的外层循环。</p>
<h3 id="for-中的初始语句——开始循环时执行的语句"><a href="#for-中的初始语句——开始循环时执行的语句" class="headerlink" title="for 中的初始语句——开始循环时执行的语句"></a>for 中的初始语句——开始循环时执行的语句</h3><p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。</p>
<p>初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step := 2</span><br><span class="line">for ; step &gt; 0; step-- {</span><br><span class="line">    fmt.Println(step)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p>
<h3 id="for-中的条件表达式——控制是否循环的开关"><a href="#for-中的条件表达式——控制是否循环的开关" class="headerlink" title="for 中的条件表达式——控制是否循环的开关"></a>for 中的条件表达式——控制是否循环的开关</h3><p>每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。</p>
<h4 id="结束循环时带可执行语句的无限循环"><a href="#结束循环时带可执行语句的无限循环" class="headerlink" title="结束循环时带可执行语句的无限循环"></a>结束循环时带可执行语句的无限循环</h4><p>下面代码忽略条件表达式，但是保留结束语句，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for ; ; i++ {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。</li>
<li>第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。</li>
</ul>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>上面的代码还可以改写为更美观的写法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line"></span><br><span class="line">    if i &gt; 10 {</span><br><span class="line">        break</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。</li>
<li>第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。</li>
</ul>
<p>无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。</p>
<h4 id="只有一个循环条件的循环"><a href="#只有一个循环条件的循环" class="headerlink" title="只有一个循环条件的循环"></a>只有一个循环条件的循环</h4><p>在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line"></span><br><span class="line">for i &lt;= 10 {</span><br><span class="line">    i++</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在代码第 3 行中，将之前使用 <code>if i&gt;10{}</code> 判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。</p>
<p>上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h3 id="for-中的结束语句——每次循环结束时执行的语句"><a href="#for-中的结束语句——每次循环结束时执行的语句" class="headerlink" title="for 中的结束语句——每次循环结束时执行的语句"></a>for 中的结束语句——每次循环结束时执行的语句</h3><p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p>
<h3 id="输出九九乘法表"><a href="#输出九九乘法表" class="headerlink" title="输出九九乘法表"></a>输出九九乘法表</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 遍历, 决定处理第几行</span><br><span class="line">    for y := 1; y &lt;= 9; y++ {</span><br><span class="line"></span><br><span class="line">        // 遍历, 决定这一行有多少列</span><br><span class="line">        for x := 1; x &lt;= y; x++ {</span><br><span class="line">            fmt.Printf("%d*%d=%d ", x, y, x*y)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 手动生成回车</span><br><span class="line">        fmt.Println()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2 2*2=4</span><br><span class="line">1*3=3 2*3=6 3*3=9</span><br><span class="line">1*4=4 2*4=8 3*4=12 4*4=16</span><br><span class="line">1*5=5 2*5=10 3*5=15 4*5=20 5*5=25</span><br><span class="line">1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36</span><br><span class="line">1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49</span><br><span class="line">1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64</span><br><span class="line">1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，生成 1～9 的数字，对应乘法表的每一行，也就是被乘数。</li>
<li>第 11 行，乘法表每一行中的列数随着行数的增加而增加，这一行的 x 表示该行有多少列。</li>
<li>第 16 行，打印一个空行，实际作用就是换行。</li>
</ul>
<p>这段程序按行优先打印，打印完一行，换行（第 16 行），接着执行下一行乘法表直到整个数值循环完毕。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range (键值循环)"></a>for range (键值循环)</h2><p>for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, val := range coll {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for pos, char := range str {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>每个 rune 字符和索引在 for range 循环中是一一对应的，它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。</p>
<p>通过 for range 遍历的返回值有一定的规律：</p>
<ul>
<li>数组、切片、字符串返回索引和值。</li>
<li>map 返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ul>
<h3 id="遍历数组、切片——获得索引和值"><a href="#遍历数组、切片——获得索引和值" class="headerlink" title="遍历数组、切片——获得索引和值"></a>遍历数组、切片——获得索引和值</h3><p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d  value:%d\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key:0  value:1</span><br><span class="line">key:1  value:2</span><br><span class="line">key:2  value:3</span><br><span class="line">key:3  value:4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历字符串——获得字符"><a href="#遍历字符串——获得字符" class="headerlink" title="遍历字符串——获得字符"></a>遍历字符串——获得字符</h3><p>Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。</p>
<p>下面这段代码展示了如何遍历字符串：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = "hello 你好"</span><br><span class="line">for key, value := range str {</span><br><span class="line">    fmt.Printf("key:%d value:0x%x\n", key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key:0 value:0x68</span><br><span class="line">key:1 value:0x65</span><br><span class="line">key:2 value:0x6c</span><br><span class="line">key:3 value:0x6c</span><br><span class="line">key:4 value:0x6f</span><br><span class="line">key:5 value:0x20</span><br><span class="line">key:6 value:0x4f60</span><br><span class="line">key:9 value:0x597d</span><br></pre></td></tr></tbody></table></figure>
<p>代码中的变量 value，实际类型是 rune 类型，以十六进制打印出来就是字符的编码。</p>
<h3 id="遍历-map——获得-map-的键和值"><a href="#遍历-map——获得-map-的键和值" class="headerlink" title="遍历 map——获得 map 的键和值"></a>遍历 map——获得 map 的键和值</h3><p>对于 map 类型来说，for range 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们是一对一对出现的，下面的代码演示了如何遍历 map。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for key, value := range m {</span><br><span class="line">    fmt.Println(key, value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello 100</span><br><span class="line">world 200</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</em></strong></p>
<h3 id="遍历通道（channel）——接收通道数据"><a href="#遍历通道（channel）——接收通道数据" class="headerlink" title="遍历通道（channel）——接收通道数据"></a>遍历通道（channel）——接收通道数据</h3><p>for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。</p>
<p>下面代码为我们展示了通道的遍历：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line"></span><br><span class="line">    c &lt;- 1</span><br><span class="line">    c &lt;- 2</span><br><span class="line">    c &lt;- 3</span><br><span class="line">    close(c)</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">for v := range c {</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行创建了一个整型类型的通道。</li>
<li>第 3 行启动了一个 goroutine，其逻辑的实现体现在第 5～8 行，实现功能是往通道中推送数据 1、2、3，然后结束并关闭通道。</li>
<li>这段 goroutine 在声明结束后，在第 9 行马上被执行。</li>
<li>从第 11 行开始，使用 for range 对通道 c 进行遍历，其实就是不断地从通道中取数据，直到通道被关闭。</li>
</ul>
<h3 id="在遍历中选择希望获得的变量"><a href="#在遍历中选择希望获得的变量" class="headerlink" title="在遍历中选择希望获得的变量"></a>在遍历中选择希望获得的变量</h3><p>在使用 for range 循环遍历某个对象时，一般不会同时需要 key 或者 value，这个时候可以采用一些技巧，让代码变得更简单，下面将前面的例子修改一下，参考下面的代码示例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]int{</span><br><span class="line">    "hello": 100,</span><br><span class="line">    "world": 200,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, value := range m {</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">200</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子中将 key 变成了下划线 <code>_</code> ，这里的下划线就是匿名变量。</p>
<ul>
<li>可以理解为一种占位符。</li>
<li>匿名变量本身不会进行空间分配，也不会占用一个变量的名字。</li>
<li>在 for range 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。</li>
</ul>
<p>再看一个匿名变量的例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, _ := range []int{1, 2, 3, 4} {</span><br><span class="line">    fmt.Printf("key:%d \n", key)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key:0</span><br><span class="line">key:1</span><br><span class="line">key:2</span><br><span class="line">key:3</span><br></pre></td></tr></tbody></table></figure>
<p>在该例子中，value 被设置为匿名变量，只使用 key，而 key 本身就是切片的索引，所以例子输出索引。</p>
<p>我们总结一下 for 的功能：</p>
<ul>
<li>Go语言的 for 包含初始化语句、条件表达式、结束语句，这 3 个部分均可缺省。</li>
<li>for range 支持对数组、切片、字符串、map、通道进行遍历操作。</li>
<li>在需要时，可以使用匿名变量对 for range 的变量进行选取。</li>
</ul>
<h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。</p>
<p>相对于C语言和 Java 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。</p>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = "hello"</span><br><span class="line">switch a {</span><br><span class="line">case "hello":</span><br><span class="line">    fmt.Println(1)</span><br><span class="line">case "world":</span><br><span class="line">    fmt.Println(2)</span><br><span class="line">default:</span><br><span class="line">    fmt.Println(0)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。</p>
<h4 id="一分支多值"><a href="#一分支多值" class="headerlink" title="一分支多值"></a>一分支多值</h4><p>当出现多个 case 要放在一起的时候，可以写成下面这样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = "mum"</span><br><span class="line">switch a {</span><br><span class="line">case "mum", "daddy":</span><br><span class="line">    fmt.Println("family")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不同的 case 表达式使用逗号分隔。</p>
<h4 id="分支表达式"><a href="#分支表达式" class="headerlink" title="分支表达式"></a>分支表达式</h4><p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var r int = 11</span><br><span class="line">switch {</span><br><span class="line">case r &gt; 10 &amp;&amp; r &lt; 20:</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意，这种情况的 switch 后面不再需要跟判断变量。</p>
<h3 id="跨越-case-的-fallthrough——兼容C语言的-case-设计"><a href="#跨越-case-的-fallthrough——兼容C语言的-case-设计" class="headerlink" title="跨越 case 的 fallthrough——兼容C语言的 case 设计"></a>跨越 case 的 fallthrough——兼容C语言的 case 设计</h3><p>在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = "hello"</span><br><span class="line">switch {</span><br><span class="line">case s == "hello":</span><br><span class="line">    fmt.Println("hello")</span><br><span class="line">    fallthrough</span><br><span class="line">case s != "world":</span><br><span class="line">    fmt.Println("world")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></tbody></table></figure>
<p>新编写的代码，不建议使用 fallthrough。</p>
<h2 id="goto语句——跳转到指定的标签"><a href="#goto语句——跳转到指定的标签" class="headerlink" title="goto语句——跳转到指定的标签"></a>goto语句——跳转到指定的标签</h2><p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p>
<h3 id="使用-goto-退出多层循环"><a href="#使用-goto-退出多层循环" class="headerlink" title="使用 goto 退出多层循环"></a>使用 goto 退出多层循环</h3><p>下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    var breakAgain bool</span><br><span class="line"></span><br><span class="line">    // 外循环</span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        // 内循环</span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            // 满足某个条件时, 退出循环</span><br><span class="line">            if y == 2 {</span><br><span class="line"></span><br><span class="line">                // 设置退出标记</span><br><span class="line">                breakAgain = true</span><br><span class="line"></span><br><span class="line">                // 退出本次循环</span><br><span class="line">                break</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 根据标记, 还需要退出一次循环</span><br><span class="line">        if breakAgain {</span><br><span class="line">                break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 10 行，构建外循环。</li>
<li>第 13 行，构建内循环。</li>
<li>第 16 行，当 y==2 时需要退出所有的 for 循环。</li>
<li>第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。</li>
<li>第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。</li>
<li>第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。</li>
<li>第 34 行，退出所有循环后，打印 done。</li>
</ul>
<p>将上面的代码使用Go语言的 goto 语句进行优化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    for x := 0; x &lt; 10; x++ {</span><br><span class="line"></span><br><span class="line">        for y := 0; y &lt; 10; y++ {</span><br><span class="line"></span><br><span class="line">            if y == 2 {</span><br><span class="line">                // 跳转到标签</span><br><span class="line">                goto breakHere</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 手动返回, 避免执行进入标签</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">    // 标签</span><br><span class="line">breakHere:</span><br><span class="line">    fmt.Println("done")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。</li>
<li>第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。</li>
<li>第 23 行，定义 breakHere 标签。</li>
</ul>
<p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p>
<h3 id="使用-goto-集中处理错误"><a href="#使用-goto-集中处理错误" class="headerlink" title="使用 goto 集中处理错误"></a>使用 goto 集中处理错误</h3><p>多处错误处理存在代码重复时是非常棘手的，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">err := firstCheckError()</span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = secondCheckError()</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Println("done")</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，执行某逻辑，返回错误。</li>
<li>第 2～6 行，如果发生错误，打印错误退出进程。</li>
<li>第 8 行，执行某逻辑，返回错误。</li>
<li>第 10～14 行，发生错误后退出流程。</li>
<li>第 16 行，没有任何错误，打印完成。</li>
</ul>
<p>在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。</p>
<p>使用 goto 语句来实现同样的逻辑：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> err := firstCheckError()</span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = secondCheckError()</span><br><span class="line"></span><br><span class="line">    if err != nil {</span><br><span class="line">        goto onExit</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fmt.Println("done")</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">onExit:</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    exitProcess()</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。</li>
<li>第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。</li>
</ul>
<h2 id="break（跳出循环）"><a href="#break（跳出循环）" class="headerlink" title="break（跳出循环）"></a>break（跳出循环）</h2><p>Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。</p>
<p>跳出指定循环：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            case 3:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                break OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 7 行，外层循环的标签。</li>
<li>第 8 行和第 9 行，双层循环。</li>
<li>第 10 行，使用 switch 进行数值分支判断。</li>
<li>第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。</li>
</ul>
<h2 id="continue（继续下一次循环）"><a href="#continue（继续下一次循环）" class="headerlink" title="continue（继续下一次循环）"></a>continue（继续下一次循环）</h2><p>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line"></span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明：</p>
<ul>
<li>第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。</li>
</ul>
<h3 id="示例：聊天机器人"><a href="#示例：聊天机器人" class="headerlink" title="示例：聊天机器人"></a>示例：聊天机器人</h3><p>结合咱们之前的学习，本节带领大家来编写一个聊天机器人的雏形，下面的代码中展示了一个简单的聊天程序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    // 准备从标准输入读取数据。</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println("Please input your name:")</span><br><span class="line">    // 读取数据直到碰到 \n 为止。</span><br><span class="line">    input, err := inputReader.ReadString('\n')</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">        // 异常退出。</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    } else {</span><br><span class="line">        // 用切片操作删除最后的 \n 。</span><br><span class="line">        name := input[:len(input)-2]</span><br><span class="line">        fmt.Printf("Hello, %s! What can I do for you?\n", name)</span><br><span class="line">    }</span><br><span class="line">    for {</span><br><span class="line">        input, err = inputReader.ReadString('\n')</span><br><span class="line">        if err != nil {</span><br><span class="line">            fmt.Printf("An error occurred: %s\n", err)</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        input = input[:len(input)-2]</span><br><span class="line">        // 全部转换为小写。</span><br><span class="line">        input = strings.ToLower(input)</span><br><span class="line">        switch input {</span><br><span class="line">        case "":</span><br><span class="line">            continue</span><br><span class="line">        case "nothing", "bye":</span><br><span class="line">            fmt.Println("Bye!")</span><br><span class="line">            // 正常退出。</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println("Sorry, I didn't catch you.")</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个聊天程序在问候用户之后会不断地询问“是否可以帮忙”，但是实际上它什么忙也帮不上，因为它现在什么也听不懂，除了 nothing 和 bye，一看到这两个词，它就会与用户“道别”，停止运行，现在试运行一下这个命令源码文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Please input your name:</span><br><span class="line">Robert</span><br><span class="line">Hello, Robert! What can I do for you?</span><br><span class="line">A piece of cake , please .</span><br><span class="line">Sorry, I didn't catch you.</span><br><span class="line">bye</span><br><span class="line">Bye!</span><br></pre></td></tr></tbody></table></figure>
<p>注意，其中的“-&gt;”符号之后的内容是我们输入的。</p>
<h3 id="示例：词频统计"><a href="#示例：词频统计" class="headerlink" title="示例：词频统计"></a>示例：词频统计</h3><p>从数据挖掘到语言学习本身，文本分析功能的应用非常广泛，本一节我们来分析一个例子，它是文本分析最基本的一种形式：统计出一个文件里单词出现的频率。</p>
<p>示例中频率统计后的结果以两种不同的方式显示，一种是将单词按照字母顺序把单词和频率排列出来，另一种是按照有序列表的方式把频率和对应的单词显示出来，完整的示例代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "bufio"</span><br><span class="line">    "fmt"</span><br><span class="line">    "io"</span><br><span class="line">    "log"</span><br><span class="line">    "os"</span><br><span class="line">    "path/filepath"</span><br><span class="line">    "runtime"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">    "unicode"</span><br><span class="line">    "unicode/utf8"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader,</span><br><span class="line">    frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax ||</span><br><span class="line">                utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序的运行结果如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">go run .\main.go small-file.txt</span><br><span class="line">Word       Frequency</span><br><span class="line">ability                     1</span><br><span class="line">about                     1</span><br><span class="line">above                     3</span><br><span class="line">years                      1</span><br><span class="line">you                    128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Frequency → Words</span><br><span class="line">    1 ability, about, absence, absolute, absolutely, abuse, accessible, ...</span><br><span class="line">    2 accept, acquired, after, against, applies, arrange, assumptions, ...</span><br><span class="line">...</span><br><span class="line">128    you</span><br><span class="line">151    or</span><br><span class="line">192    to</span><br><span class="line">221    of</span><br><span class="line">345    the</span><br></pre></td></tr></tbody></table></figure>
<p>其中，small-file.txt 为待统计的文件名，它不是固定的，可以根据实际情况自行调整。由于输出的结果太多，所以上面只截取了部分内容。</p>
<p>通过上面的输出结果可以看出，第一种输出是比较直接的，我们可以使用一个map[string]int类型的结构来保存每一个单词的频率，但是要得到第二种输出结果我们需要将整个映射反转成多值类型的映射，如map[int][]string，也就是说，键是频率而值则是所有具有这个频率的单词。</p>
<p>接下来我们将从程序的 main() 函数开始，从上到下分析。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {</span><br><span class="line">        fmt.Printf("usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n",</span><br><span class="line">            filepath.Base(os.Args[0]))</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    frequencyForWord := map[string]int{} // 与:make(map[string]int)相同</span><br><span class="line">    for _, filename := range commandLineFiles(os.Args[1:]) {</span><br><span class="line">        updateFrequencies(filename, frequencyForWord)</span><br><span class="line">    }</span><br><span class="line">    reportByWords(frequencyForWord)</span><br><span class="line">    wordsForFrequency := invertStringIntMap(frequencyForWord)</span><br><span class="line">    reportByFrequency(wordsForFrequency)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>main() 函数首先分析命令行参数，之后再进行相应处理。</p>
<p>我们使用复合语法创建一个空的映射，用来保存从文件读到的每一个单词和对应的频率，接着我们遍历从命令行得到的每一个文件，分析每一个文件后更新 frequencyForWord 的数据。</p>
<p>得到第一个映射之后，我们就可以输出第一个报告了（按照字母顺序排列的列表），然后我们创建一个反转的映射，输出第二个报告（按出现频率统计并排序的列表）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func commandLineFiles(files []string) []string {</span><br><span class="line">    if runtime.GOOS == "windows" {</span><br><span class="line">        args := make([]string, 0, len(files))</span><br><span class="line">        for _, name := range files {</span><br><span class="line">            if matches, err := filepath.Glob(name); err != nil {</span><br><span class="line">                args = append(args, name) // 无效模式</span><br><span class="line">            } else if matches != nil {</span><br><span class="line">                args = append(args, matches...)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return args</span><br><span class="line">    }</span><br><span class="line">    return files</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 Unix 类系统（如 Linux 或 Mac OS X 等）的命令行工具默认会自动处理通配符（也就是说，<code>*.txt</code> 能匹配任意后缀为 <code>.txt</code> 的文件，如 <code>README.txt</code> 和 <code>INSTALL.txt</code> 等），而 Windows 平台的命令行工具（CMD）不支持通配符，所以如果用户在命令行输入 <code>*.txt</code>，那么程序只能接收到 <code>*.txt</code> 。</p>
<p>为了保持平台之间的一致性，这里使用 commandLineFiles() 函数来实现跨平台的处理，当程序运行在 Windows 平台时，实现文件名通配功能。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func updateFrequencies(filename string, frequencyForWord map[string]int) {</span><br><span class="line">    var file *os.File</span><br><span class="line">    var err error</span><br><span class="line">    if file, err = os.Open(filename); err != nil {</span><br><span class="line">        log.Println("failed to open the file: ", err)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    defer file.Close()</span><br><span class="line">    readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>updateFrequencies() 函数纯粹就是用来处理文件的，它打开给定的文件，并使用 defer 在函数返回时关闭文件，这里我们将文件作为一个 <code>*bufio.Reader</code>（使用 bufio.NewReader() 函数创建）传给 readAndUpdateFrequencies() 函数，因为这个函数是以字符串的形式一行一行地读取数据的，所以实际的工作都是在 readAndUpdateFrequencies() 函数里完成的，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) {</span><br><span class="line">    for {</span><br><span class="line">        line, err := reader.ReadString('\n')</span><br><span class="line">        for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {</span><br><span class="line">            if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 {</span><br><span class="line">                frequencyForWord[strings.ToLower(word)] += 1</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if err != nil {</span><br><span class="line">            if err != io.EOF {</span><br><span class="line">                log.Println("failed to finish reading the file: ", err)</span><br><span class="line">            }</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第一部分的代码我们应该很熟悉了，用了一个无限循环来一行一行地读一个文件，当读到文件结尾或者出现错误的时候就退出循环，将错误报告给用户但并不退出程序，因为还有很多其他的文件需要去处理。</p>
<p>任意一行都可能包括标点、数字、符号或者其他非单词字符，所以我们需要逐个单词地去读，将每一行分隔成若干个单词并使用 SplitOnNonLetters() 函数忽略掉非单词的字符，并且过滤掉字符串开头和结尾的空白。</p>
<p>只需要记录含有两个以上（包括两个）字母的单词，可以通过使用 if 语句，如 utf8.RuneCountlnString(word) &gt; 1 来完成。</p>
<p>上面描述的 if 语句有一点性能损耗，因为它会分析整个单词，所以在这个程序里我们增加了一个判断条件，用来检査这个单词的字节数是否大于 utf8.UTFMax（utf8.UTFMax 是一个常量，值为 4，用来表示一个 UTF-8 字符最多需要几个字节）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func SplitOnNonLetters(s string) []string {</span><br><span class="line">    notALetter := func(char rune) bool { return !unicode.IsLetter(char) }</span><br><span class="line">    return strings.FieldsFunc(s, notALetter)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SplitOnNonLetters() 函数用来在非单词字符上对一个字符串进行切分，首先我们为 strings.FieldsFunc() 函数创建一个匿名函数 notALetter，如果传入的是字符那就返回 false，否则返回 true，然后返回调用函数 strings.FieldsFunc() 的结果，调用的时候将给定的字符串和 notALetter 作为它的参数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func reportByWords(frequencyForWord map[string]int) {</span><br><span class="line">    words := make([]string, 0, len(frequencyForWord))</span><br><span class="line">    wordWidth, frequencyWidth := 0, 0</span><br><span class="line">    for word, frequency := range frequencyForWord {</span><br><span class="line">        words = append(words, word)</span><br><span class="line">        if width := utf8.RuneCountInString(word); width &gt; wordWidth {</span><br><span class="line">            wordWidth = width</span><br><span class="line">        }</span><br><span class="line">        if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth {</span><br><span class="line">            frequencyWidth = width</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    sort.Strings(words)</span><br><span class="line">    gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")</span><br><span class="line">    fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")</span><br><span class="line">    for _, word := range words {</span><br><span class="line">        fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,</span><br><span class="line">            frequencyForWord[word])</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>计算出了 frequencyForWord 之后，调用 reportByWords() 将它的数据打印出来，因为我们需要将输出结果按照字母顺序排序好，所以首先要创建一个空的容量足够大的 []string 切片来保存所有在 frequencyForWord 里的单词。</p>
<p>第一个循环遍历映射里的所有项，把每个单词追加到 words 字符串切片里去，使用 append() 函数只需要把给定的单词追加到第 len(words) 个索引位置上即可，words 的长度会自动增加 1。</p>
<p>得到了 words 切片之后，对它进行排序，这个在 readAndUpdateFrequencies() 函数中已经处理好了。</p>
<p>经过排序之后我们打印两列标题，第一个是 “Word”，为了能让 Frequency 最后一个字符 y 右对齐，需要在 “Word” 后打印一些空格，通过 <code>%*s</code> 可以实现的打印固定长度的空白，也可以使用 <code>%s</code> 来打印 strings.Repeat(“ “, gap) 返回的字符串。</p>
<p>最后，我们将单词和它们的频率用两列方式按照字母顺序打印出来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func invertStringIntMap(intForString map[string]int) map[int][]string {</span><br><span class="line">    stringsForInt := make(map[int][]string, len(intForString))</span><br><span class="line">    for key, value := range intForString {</span><br><span class="line">        stringsForInt[value] = append(stringsForInt[value], key)</span><br><span class="line">    }</span><br><span class="line">    return stringsForInt</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的函数首先创建一个空的映射，用来保存反转的结果，但是我们并不知道它到底要保存多少个项，因此我们假设它和原来的映射容量一样大，然后简单地遍历原来的映射，将它的值作为键保存到反转的映射里，并将键增加到对应的值里去，新的映射的值就是一个字符串切片，即使原来的映射有多个键对应同一个值，也不会丢掉任何数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func reportByFrequency(wordsForFrequency map[int][]string) {</span><br><span class="line">    frequencies := make([]int, 0, len(wordsForFrequency))</span><br><span class="line">    for frequency := range wordsForFrequency {</span><br><span class="line">        frequencies = append(frequencies, frequency)</span><br><span class="line">    }</span><br><span class="line">    sort.Ints(frequencies)</span><br><span class="line">    width := len(fmt.Sprint(frequencies[len(frequencies)-1]))</span><br><span class="line">    fmt.Println("Frequency → Words")</span><br><span class="line">    for _, frequency := range frequencies {</span><br><span class="line">        words := wordsForFrequency[frequency]</span><br><span class="line">        sort.Strings(words)</span><br><span class="line">        fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数的结构和 reportByWords() 函数很相似，它首先创建一个切片用来保存频率，并按照频率升序排列，然后再计算需要容纳的最大长度并以此作为第一列的宽度，之后输出报告的标题，最后，遍历输出所有的频率并按照字母升序输出对应的单词，如果一个频率有超过两个对应的单词则单词之间使用逗号分隔开。</p>
<h3 id="示例：缩进排序"><a href="#示例：缩进排序" class="headerlink" title="示例：缩进排序"></a>示例：缩进排序</h3><p>演示如何将字符串按照等级（缩进级别）进行排序，完整代码如下所示。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">    "strings"</span><br><span class="line">)</span><br><span class="line">var original = []string{</span><br><span class="line">    "Nonmetals",</span><br><span class="line">    "    Hydrogen",</span><br><span class="line">    "    Carbon",</span><br><span class="line">    "    Nitrogen",</span><br><span class="line">    "    Oxygen",</span><br><span class="line">    "Inner Transitionals",</span><br><span class="line">    "    Lanthanides",</span><br><span class="line">    "        Europium",</span><br><span class="line">    "        Cerium",</span><br><span class="line">    "    Actinides",</span><br><span class="line">    "        Uranium",</span><br><span class="line">    "        Plutonium",</span><br><span class="line">    "        Curium",</span><br><span class="line">    "Alkali Metals",</span><br><span class="line">    "    Lithium",</span><br><span class="line">    "    Sodium",</span><br><span class="line">    "    Potassium",</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println("|     Original      |       Sorted      |")</span><br><span class="line">    fmt.Println("|-------------------|-------------------|")</span><br><span class="line">    sorted := SortedIndentedStrings(original) // 最初是 []string</span><br><span class="line">    for i := range original {                 // 在全局变量中设置</span><br><span class="line">        fmt.Printf("|%-19s|%-19s|\n", original[i], sorted[i])</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意 SortedIndentedStrings() 函数有一个很重要的前提就是，字符串的缩进是通过读到的空格或缩进的个数来决定的，下面来看一下输出结果，为了方便对比，这里将排序前的结果放在左边，排序后的结果放在右边。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|     Original      |       Sorted      |</span><br><span class="line">|-------------------|-------------------|</span><br><span class="line">|Nonmetals          |Alkali Metals      |</span><br><span class="line">|    Hydrogen       |    Lithium        |</span><br><span class="line">|    Carbon         |    Potassium      |</span><br><span class="line">|    Nitrogen       |    Sodium         |</span><br><span class="line">|    Oxygen         |Inner Transitionals|</span><br><span class="line">|Inner Transitionals|    Actinides      |</span><br><span class="line">|    Lanthanides    |        Curium     |</span><br><span class="line">|        Europium   |        Plutonium  |</span><br><span class="line">|        Cerium     |        Uranium    |</span><br><span class="line">|    Actinides      |    Lanthanides    |</span><br><span class="line">|        Uranium    |        Cerium     |</span><br><span class="line">|        Plutonium  |        Europium   |</span><br><span class="line">|        Curium     |Nonmetals          |</span><br><span class="line">|Alkali Metals      |    Carbon         |</span><br><span class="line">|    Lithium        |    Hydrogen       |</span><br><span class="line">|    Sodium         |    Nitrogen       |</span><br><span class="line">|    Potassium      |    Oxygen         |</span><br></pre></td></tr></tbody></table></figure>
<p>其中，SortedIndentedStrings() 函数和它的辅助函数使用到了递归、函数引用以及指向切片的指针等。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Entry struct {</span><br><span class="line">    key      string</span><br><span class="line">    value    string</span><br><span class="line">    children Entries</span><br><span class="line">}</span><br><span class="line">type Entries []Entry</span><br><span class="line">func (entries Entries) Len() int { return len(entries) }</span><br><span class="line">func (entries Entries) Less(i, j int) bool {</span><br><span class="line">    return entries[i].key &lt; entries[j].key</span><br><span class="line">}</span><br><span class="line">func (entries Entries) Swap(i, j int) {</span><br><span class="line">    entries[i], entries[j] = entries[j], entries[i]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>sort.Interface 接口定义了 3 个方法 Len()、Less() 和 Swap()，它们的函数签名和 Entries 中的同名方法是一样的，这就意味着我们可以使用标准库里的 sort.Sort() 函数来对一个 Entries 进行排序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func SortedIndentedStrings(slice []string) []string {</span><br><span class="line">    entries := populateEntries(slice)</span><br><span class="line">    return sortedEntries(entries)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>导出的函数 SortedIndentedStrings() 就做了这个工作，虽然我们已经对它进行了重构，让它把所有东西都传递给辅助函数，函数 populateEntries() 传入一个 []string 并返回一个对应的 Entries（[]Entry 类型）。</p>
<p>而函数 sortedEntries() 需要传入一个 Entries，然后返回一个排过序的 []string（根据缩进的级别进行排序）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func populateEntries(slice []string) Entries {</span><br><span class="line">    indent, indentSize := computeIndent(slice)</span><br><span class="line">    entries := make(Entries, 0)</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        i, level := 0, 0</span><br><span class="line">        for strings.HasPrefix(item[i:], indent) {</span><br><span class="line">            i += indentSize</span><br><span class="line">            level++</span><br><span class="line">        }</span><br><span class="line">        key := strings.ToLower(strings.TrimSpace(item))</span><br><span class="line">        addEntry(level, key, item, &amp;entries)</span><br><span class="line">    }</span><br><span class="line">    return entries</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateEntries() 函数首先以字符串的形式得到给定切片里的一级缩进（如有 4 个空格的字符串）和它占用的字节数，然后创建一个空的 Entries，并遍历切片里的每一个字符串，判断该字符串的缩进级别，再创建一个用于排序的键。</p>
<p>下一步，调用自定义函数 addEntry()，将当前字符串的级别、键、字符串本身，以及指向 entries 的地址作为参数，这样 addEntry() 就能创建一个新的 Entry 并能够正确地将它追加到 entries 里去，最后返回 entries。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func computeIndent(slice []string) (string, int) {</span><br><span class="line">    for _, item := range slice {</span><br><span class="line">        if len(item) &gt; 0 &amp;&amp; (item[0] == ' ' || item[0] == '\t') {</span><br><span class="line">            whitespace := rune(item[0])</span><br><span class="line">            for i, char := range item[1:] {</span><br><span class="line">                if char != whitespace {</span><br><span class="line">                    i++</span><br><span class="line">                    return strings.Repeat(string(whitespace), i), i</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return "", 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>computeIndent() 函数主要是用来判断缩进使用的是什么字符，例如空格或者缩进符等，以及一个缩进级别占用多少个这样的字符。</p>
<p>因为第一级的字符串可能没有缩进，所以函数必须迭代所有的字符串，一旦它发现某个字符串的行首是空格或者缩进，函数马上返回表示缩进的字符以及一个缩进所占用的字符数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addEntry(level int, key, value string, entries *Entries) {</span><br><span class="line">    if level == 0 {</span><br><span class="line">        *entries = append(*entries, Entry{key, value, make(Entries, 0)})</span><br><span class="line">    } else {</span><br><span class="line">        addEntry(level-1, key, value,</span><br><span class="line">            &amp;((*entries)[entries.Len()-1].children))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>addEntry() 是一个递归函数，它创建一个新的 Entry，如果这个 Entry 的 level 是 0，那就直接增加到 entries 里去，否则，就将它作为另一个 Entry 的子集。</p>
<p>我们必须确定这个函数传入的是一个 *Entries 而不是传递一个 entries 引用（切片的默认行为），因为我们是要将数据追加到 entries 里，追加到一个引用会导致无用的本地副本且原来的数据实际上并没有被修改。</p>
<p>如果 level 是 0，表明这个字符串是顶级项，因此必须将它直接追加到 <code>*entries</code> ，实际上情况要更复杂一些，因为 level 是相对传入的 <code>*entries</code> 而言的，第一次调用 addEntry() 时，<code>*entries</code> 是一个第一级的 Entries，但函数进入递归后，*entries 就可能是某个 Entry 的子集。</p>
<p>我们使用内置的 append() 函数来追加新的 Entry，并使用 <code>*</code> 操作符获得 entries 指针指向的值，这就保证了任何改变对调用者来说都是可见的，新增的 Entry 包含给定的 key 和 value，以及一个空的子 Entries，这是递归的结束条件。</p>
<p>如果 level 大于 0，则我们必须将它追加到上一级 Entry 的 children 字段里去，这里我们只是简单地递归调用 addEntry() 函数，最后一个参数可能是我们目前为止见到的最复杂的表达式了。</p>
<p>子表达式 entries.Len() - 1 产生一个 int 型整数，表示 <code>*entries</code> 指向的 Entries 值的最后一个条目的索引位置（注意 Entries.Len() 传入的是一个 Entries 值而不是 <code>*Entries</code> 指针，不过Go语言也可以自动对 entries 指针进行解引用并调用相应的方法）。</p>
<p>完整的表达式（&amp;(…) 除外）访问了 Entries 最后一个 Entry 的 children 字段（这也是一个 Entries 类型），所以如果把这个表达式作为一个整体，实际上我们是将 Entries 里最后一个 Entry 的 children 字段的内存地址作为递归调用的参数，因为 addEntry() 最后一个参数是 *Entries 类型的。</p>
<p>为了帮助大家弄清楚到底发生了什么，下面的代码和上述代码中 else 代码块中的那个调用是一样的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theEntries := *entries</span><br><span class="line">lastEntry := &amp;theEntries[theEntries.Len()-1]</span><br><span class="line">addEntry(level-1, key, value, &amp;lastEntry.children)</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们创建 theEntries 变量用来保存 *entries 指针指向的值，这里没有什么开销因为不会产生复制，实际上 theEntries 相当于一个指向 Entries 值的别名。</p>
<p>然后我们取得最后一项的内存地址（即一个指针），如果不取地址的话就会取到最后一项的副本，最后递归调用 addEntry() 函数，并将最后一项的 children 字段的地址作为参数传递给它。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func sortedEntries(entries Entries) []string {</span><br><span class="line">    var indentedSlice []string</span><br><span class="line">    sort.Sort(entries)</span><br><span class="line">    for _, entry := range entries {</span><br><span class="line">        populateIndentedStrings(entry, &amp;indentedSlice)</span><br><span class="line">    }</span><br><span class="line">    return indentedSlice</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当调用 sortedEntries() 函数的时候，Entries 显示的结构和原先程序输出的字符串是一样的，每一个缩进的字符串都是上一级缩进的子级，而且还可能有下一级的缩进，依次类推。</p>
<p>创建了 Entries 之后，SortedIndentedStrings() 函数调用上面这个函数去生成一个排好序的字符串切片 []string，这个函数首先创建一个空的 []string 用来保存最后的结果，然后对 entries 进行排序。</p>
<p>Entries 实现了 sort.Interface 接口，因此我们可以直接使用 sort.Sort() 函数根据 Entry 的 key 字段来对 Entries 进行排序（这是 Entries.Less() 的实现方式），这个排序只是作用于第一级的 Entry，对其他未排序的子集是没有任何影响的。</p>
<p>为了能够对 children 字段以及 children 的 children 等进行递归排序，函数遍历第一级的每一个项并调用 populateIndentedStrings() 函数，传入这个 Entry 类型的项和一个指向 []string 切片的指针。</p>
<p>切片可以传递给函数并由函数更新内容（如替换切片里的某些项），但是这里需要往切片里新增一些数据，所以这里将一个指向切片的指针（也就是指针的指针）作为参数传进去，并将指针指向的内容设置为 append() 函数的返回结果，可能是一个新的切片，也可能是原先的切片。</p>
<p>另一种办法就是传入切片的值，然后返回 append() 之后的切片，但是必须将返回的结果赋值给原来的切片变量（例如 slice = function(slice)），不过这么做的话，很难正确地使用递归函数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func populateIndentedStrings(entry Entry, indentedSlice *[]string) {</span><br><span class="line">    *indentedSlice = append(*indentedSlice, entry.value)</span><br><span class="line">    sort.Sort(entry.children)</span><br><span class="line">    for _, child := range entry.children {</span><br><span class="line">        populateIndentedStrings(child, indentedSlice)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>populateIndentedStrings() 函数将顶级项追加到创建的切片，然后对顶级项的子项进行排序，并递归调用自身对每一个子项做同样的处理，这就相当于对每一项的子项以及子项的子项等都做了排序，所以整个字符串切片就是已经排好序的了。</p>
<h3 id="示例：二分查找算法"><a href="#示例：二分查找算法" class="headerlink" title="示例：二分查找算法"></a>示例：二分查找算法</h3><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找算法的前提是传入的序列是有序的（降序或升序），并且有一个目标值。</p>
<p>二分查找的核心思想是将 n 个元素分成大致相等的两部分，取中间值 <code>a[n/2]</code> 与 x 做比较，如果 <code>x=a[n/2]</code> ，则找到 x ，算法中止，如果 <code>x&lt;a[n/2]</code> ，则只要在数组 a 的左半部分继续搜索 x，如果 <code>x&gt;a[n/2]</code> ，则只要在数组 a 的右半部搜索 x。</p>
<p>二分查找虽然性能比较优秀，但应用场景也比较有限，底层必须依赖数组，并且还要求数据是有序的，对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁插入、删除操作的数据。</p>
<p>程序实现：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">二分查找函数，假设有序数组的顺序是从小到大</span><br><span class="line">*/</span><br><span class="line">func BinaryFind(arr *[]int, leftIndex int, rightIndex int, findValue int) {</span><br><span class="line"></span><br><span class="line">    //判断leftIndex是否大于rightIndex</span><br><span class="line">    if leftIndex &gt; rightIndex {</span><br><span class="line">        fmt.Println("未找到")</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    //先找到中间的下标</span><br><span class="line">    middle := (leftIndex + rightIndex) / 2</span><br><span class="line"></span><br><span class="line">    if (*arr)[middle] &gt; findValue {</span><br><span class="line">        fmt.Printf("小于中间 middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, leftIndex, middle-1, findValue)</span><br><span class="line">        //要查找的数，范围应该在leftIndex与 middle-1 之间</span><br><span class="line">        BinaryFind(arr, leftIndex, middle-1, findValue)</span><br><span class="line"></span><br><span class="line">    } else if (*arr)[middle] &lt; findValue {</span><br><span class="line">        fmt.Printf("大于中间  middle：%d, leftIndex： %d rightIndex：%d findValue：%d \n", middle, middle+1, rightIndex, findValue)</span><br><span class="line">        //要查找的数，范围应该在middle+1与 rightIndex 之间</span><br><span class="line">        BinaryFind(arr, middle+1, rightIndex, findValue)</span><br><span class="line"></span><br><span class="line">    } else {</span><br><span class="line">        fmt.Printf("找到了，下标为：%v \n", middle)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    //定义一个数组</span><br><span class="line">    arr := []int{1, 3, 7, 12, 17, 20, 30, 50, 55, 75}</span><br><span class="line">    BinaryFind(&amp;arr, 0, len(arr)-1, 30)</span><br><span class="line">    fmt.Println("main arr=", arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大于中间  middle：4, leftIndex： 0 rightIndex：9 findValue：30</span><br><span class="line">小于中间  middle：7, leftIndex： 5 rightIndex：9 findValue：30</span><br><span class="line">大于中间  middle：5, leftIndex： 5 rightIndex：6 findValue：30</span><br><span class="line">找到了，下标为：6</span><br><span class="line">main arr= [1 3 7 12 17 20 30 50 55 75]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="示例：冒泡排序"><a href="#示例：冒泡排序" class="headerlink" title="示例：冒泡排序"></a>示例：冒泡排序</h3><p>冒泡排序法是一种最简单的交换类排序方法，它是通过相邻数据的交换逐步将无序列表排列为有序列表。</p>
<p>冒泡排序的基本原理是重复地循环遍历要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大或者首字母从 Z 到 A）错误就把两个元素的位置交换过来，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>冒泡排序的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p>下面通过一个实例来演示一下冒泡排序，完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">   "fmt"</span><br><span class="line">)</span><br><span class="line">/**</span><br><span class="line">冒泡排序</span><br><span class="line">*/</span><br><span class="line">func main() {</span><br><span class="line">    arr := [...]int{21,32,12,33,34,34,87,24}</span><br><span class="line">    var n = len(arr)</span><br><span class="line">    fmt.Println("--------没排序前--------\n",arr)</span><br><span class="line">    for i := 0; i &lt;= n-1; i++ {</span><br><span class="line">        fmt.Println("--------第",i+1,"次冒泡--------")</span><br><span class="line">        for j := i; j &lt;= n-1; j++ {</span><br><span class="line">            if arr[i] &gt; arr[j] {</span><br><span class="line">                t := arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = t</span><br><span class="line">            }</span><br><span class="line">            fmt.Println(arr)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("--------最终结果--------\n",arr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">--------没排序前--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">--------第 1 次冒泡--------</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[21 32 12 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">--------第 2 次冒泡--------</span><br><span class="line">[12 32 21 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">--------第 3 次冒泡--------</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 32 33 34 34 87 24]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">--------第 4 次冒泡--------</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 33 34 34 87 32]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">--------第 5 次冒泡--------</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 34 34 87 33]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 6 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">--------第 7 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 87 34]</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------第 8 次冒泡--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br><span class="line">--------最终结果--------</span><br><span class="line">[12 21 24 32 33 34 34 87]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="四种冒泡排序写法"><a href="#四种冒泡排序写法" class="headerlink" title="四种冒泡排序写法"></a>四种冒泡排序写法</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//用于计数排序中访问了多少次序列</span><br><span class="line">var cnt int= 0</span><br><span class="line"></span><br><span class="line">//最原始的冒泡排序</span><br><span class="line">func buble_sort(a []int){</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{//相邻元素两两比较</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//增加标志判断是否发生交换，如果没有发生交换，表明序列有序，结束比较，直接退出</span><br><span class="line">func flag_sort(a []int){</span><br><span class="line">    flag := true//默认序列有序</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        for j := 0; j &lt; len(a)-1-i; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false//发生交换--表明序列无序--需要进行下一次比较</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++//每完成一次内循环就访问了一次序列</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//除了标志位以外，记录最后一次发生交换的下标，更能减少不必要的比较</span><br><span class="line">func better_sort(a []int){</span><br><span class="line">    flag := true</span><br><span class="line">    k := len(a)-1//控制内部比较循环</span><br><span class="line">    n := 0//记录最后一次发生交换的下标</span><br><span class="line">    cnt = 0</span><br><span class="line">    for i := 0; i &lt; len(a)-1; i++ {</span><br><span class="line">        flag = true//每次访问待排序序列之初默认序列有序</span><br><span class="line">        n = 0//每次访问待排序序列之初默认序列有序，没有发生交换，最后交换的下标就是0</span><br><span class="line">        for j := 0; j &lt; k; j++{</span><br><span class="line">            if (a[j] &gt; a[j+1]) {</span><br><span class="line">                a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">                flag = false</span><br><span class="line">                n = j//保存最后一次交换的下标</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        if flag {//如果这趟走完，没有发生交换，则原数组有序</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">        k = n//最后一次交换的位置给k，减少比较的次数</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//鸡尾酒冒泡排序--先从低到高，再从高到低--分为两大步骤，结合标志判断</span><br><span class="line">func cocktail_sort(a []int) {</span><br><span class="line">    left := 0</span><br><span class="line">    right := len(a) - 1</span><br><span class="line">    cnt = 0</span><br><span class="line">    flag := true</span><br><span class="line">    for(left &lt; right){</span><br><span class="line">        flag = true</span><br><span class="line">        for i :=left; i &lt; right; i++{// 前半轮,将最大元素放到后面</span><br><span class="line">            if (a[i] &gt; a[i+1]) {</span><br><span class="line">                a[i], a[i+1] = a[i+1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        right--</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for i :=right; i &gt; left; i--{// 后半轮,将最小元素放到前面</span><br><span class="line">            if (a[i] &lt; a[i-1]) {</span><br><span class="line">                a[i], a[i-1] = a[i-1], a[i]</span><br><span class="line">                flag = false</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cnt++</span><br><span class="line">        left++</span><br><span class="line">        if flag {//如果此次序列访问没有发生交换--表明序列有序--结束排序，避免多余的遍历</span><br><span class="line">            break</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    b := [...]int{8,7,6,1,4,3,2,5}</span><br><span class="line">    buble_sort(b[:])</span><br><span class="line">    fmt.Println(b,cnt)</span><br><span class="line"></span><br><span class="line">    c := []int{2,3,4,5,6,1}</span><br><span class="line">    cocktail_sort(c)</span><br><span class="line">    fmt.Println(c,cnt)</span><br><span class="line"></span><br><span class="line">    d := []int{8,7,6,1,4,3,2,5}</span><br><span class="line">    flag_sort(d)</span><br><span class="line">    fmt.Println(d,cnt)</span><br><span class="line"></span><br><span class="line">    e := []int{2,3,4,5,6,1}</span><br><span class="line">    better_sort(e)</span><br><span class="line">    fmt.Println(e,cnt)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Go语言分布式id生成器"><a href="#Go语言分布式id生成器" class="headerlink" title="Go语言分布式id生成器"></a>Go语言分布式id生成器</h3><p>有时我们需要能够⽣成类似 MySQL 自增 ID 这样不断增大，同时又不会重复的 ID。以支持业务中的⾼并发场景。比较典型的是电商促销时短时间内会有大量的订单涌入到系统，比如每秒 10w+。明星出轨时会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。</p>
<p>在插入数据库之前，我们需要给这些消息、订单先打上一个 ID，然后再插⼊到我们的数据库。对这个 ID 的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进⾏排序。</p>
<p>Twitter 的 snowflake 算法是这种场景下的一个典型解法。先来看看 snowflake 是怎么回事，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/snowflake.gif" alt="图：snowflake 中的比特位分布"></p>
<p>⾸先确定我们的数值是 64 位的 int64 类型，被划分为了四部分，不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的 ID，然后再五位来表示机器的实例 ID，最后是 12 位的循环自增 ID（到达 1111,1111,1111 后会归 0）。</p>
<p>这样的机制可以⽀持我们在同一台机器上，同一毫秒内产⽣ 2 ^ 12 = 4096 条消息。一秒共 409.6 万条消息。从值域上来讲完全够⽤了。</p>
<p>数据中心加上实例 ID 共有 10 位，可以⽀持我们每数据中心部署 32 台机器，所有数据中心共 1024 台实例。</p>
<p>表示 timestamp 的 41 位，可以⽀持我们使用 69 年。当然，我们的时间毫秒计数不会真的从 1970 年开始记，那样我们的系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的 timestamp 实际上只是相对于某个时间的增量，比如我们的系统上线是 2018-08-01，那么我们可以把这个 timestamp 当作是从 2018-08-01 00:00:00.000 的偏移量。</p>
<h4 id="worker-id-分配"><a href="#worker-id-分配" class="headerlink" title="worker_id 分配"></a>worker_id 分配</h4><p>timestamp、datacenter_id、worker_id 和 sequence_id 这四个字段中，timestamp 和 sequence_id 是由程序在运⾏期⽣成的。但 datacenter_id 和 worker_id 需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的 ID 有冲突）。</p>
<p>一般不同数据中⼼的机器，会提供对应的获取数据中心 ID 的 API，所以 datacenter_id 我们可以在部署阶段轻松地获取到。而 worker_id 是我们逻辑上给机器分配的一个 ID，这个要怎么办呢？比较简单的想法是由能够提供这种自增 ID 功能的工具来支持，比如 MySQL:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into a (ip) values("10.1.2.101");</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; select last_insert_id();</span><br><span class="line">+------------------+</span><br><span class="line">| last_insert_id()     |</span><br><span class="line">+------------------+</span><br><span class="line">| 2                          |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>
<p>从 MySQL 中获取到 worker_id 之后，就把这个 worker_id 直接持久化到本地，以避免每次上线时都需要获取新的 worker_id，让单实例的 worker_id 可以始终保持不变。</p>
<p>当然，使用 MySQL 相当于给我们简单的 id 生成服务增加了一个外部依赖，依赖越多，我们的服务的可运维性就越差。</p>
<p>考虑到集群中即使有单个 ID 生成服务的实例挂了，也就是损失一段时间的一部分 ID，所以我们也可以更简单暴力一些，把 worker_id 直接写在 worker 的配置中，上线时由部署脚本完成 worker_id 字段替换</p>
<h4 id="标准-snowflake-实现"><a href="#标准-snowflake-实现" class="headerlink" title="标准 snowflake 实现"></a>标准 snowflake 实现</h4><p>github.com/bwmarrin/snowflake 是一个相当轻量化的 snowflake 的 Go 实现。其文档对各位使用的定义如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosnowflake.gif" alt="图：snowflake库"></p>
<p>和标准的 snowflake 完全一致。使用上比较简单：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "github.com/bwmarrin/snowflake"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    n, err := snowflake.NewNode(1)</span><br><span class="line">    if err != nil {</span><br><span class="line">        println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    for i := 0; i &lt; 3; i++ {</span><br><span class="line">        id := n.Generate()</span><br><span class="line">        fmt.Println("id", id)</span><br><span class="line">        fmt.Println(</span><br><span class="line">            "node: ", id.Node(),</span><br><span class="line">            "step: ", id.Step(),</span><br><span class="line">            "time: ", id.Time(),</span><br><span class="line">            "\n",</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\go_workspace\dubbo-go-proxy\com\chebada&gt;go run gohello.go</span><br><span class="line">go: finding module for package github.com/bwmarrin/snowflake</span><br><span class="line">go: downloading github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">go: found github.com/bwmarrin/snowflake in github.com/bwmarrin/snowflake v0.3.0</span><br><span class="line">id 1318484268032200704</span><br><span class="line">node:  1 step:  0 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200705</span><br><span class="line">node:  1 step:  1 time:  1603186120409</span><br><span class="line"></span><br><span class="line">id 1318484268032200706</span><br><span class="line">node:  1 step:  2 time:  1603186120409</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC</span><br><span class="line">// You may customize this to set a different epoch for your application.</span><br><span class="line">Epoch int64 = 1288834974657</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Node</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">NodeBits uint8 = 10</span><br><span class="line"></span><br><span class="line">// Number of bits to use for Step</span><br><span class="line">// Remember, you have a total 22 bits to share between Node/Step</span><br><span class="line">StepBits uint8 = 12</span><br></pre></td></tr></tbody></table></figure>
<p>Epoch 就是本节开头讲的起始时间，NodeBits 指的是机器编号的位⻓，StepBits 指的是自增序列的位⻓。</p>
<h4 id="sonyflake"><a href="#sonyflake" class="headerlink" title="sonyflake"></a>sonyflake</h4><p>sonyflake 是 Sony 公司的一个开源项目，基本思路和 snowflake 差不多，不过位分配上稍有不同，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/sonyflake.gif" alt="图：sonyflake"></p>
<p>这⾥的时间只用了 39 个 bit，但时间的单位变成了 10ms，所以理论上比 41 位表示的时间还要久（174 年）。</p>
<p>Sequence ID 和之前的定义一致，Machine ID 其实就是节点 ID。sonyflake 与众不同的地方在于其在启动阶段的参数配置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func NewSonyflake(st Settings) *Sonyflake</span><br></pre></td></tr></tbody></table></figure>
<p>Settings 数据结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Settings struct {</span><br><span class="line">    StartTime time.Time</span><br><span class="line">    MachineID func() (uint16, error)</span><br><span class="line">    CheckMachineID func(uint16) bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>StartTime 选项和我们之前的 Epoch 差不多，如果不设置的话，默认是从 2014-09-01 00:00:00 +0000 UTC 开始。</p>
<p>MachineID 可以由用户自定义的函数，如果用户不定义的话，会默认将本机 IP 的低 16 位作为 machineid。</p>
<p>CheckMachineID 是由用户提供的检查 MachineID 是否冲突的函数。这里的设计还是比较巧秒的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查 MachineID 是否冲突的逻辑。如果公司有现成的 Redis 集群，那么我们可以很轻松地用 Redis 的集合类型来检查冲突。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD base64_encoding_of_last16bits MzI0Mgo=</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure>
<p>使用起来也比较简单，这里省略了一些逻辑简单的函数：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">    "time"</span><br><span class="line">    "github.com/sony/sonyflake"</span><br><span class="line">)</span><br><span class="line">func getMachineID() (uint16, error) {</span><br><span class="line">    var machineID uint16</span><br><span class="line">    var err error</span><br><span class="line">    machineID = readMachineIDFromLocalFile()</span><br><span class="line">    if machineID == 0 {</span><br><span class="line">        machineID, err = generateMachineID()</span><br><span class="line">        if err != nil {</span><br><span class="line">            return 0, err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return machineID, nil</span><br><span class="line">}</span><br><span class="line">func checkMachineID(machineID uint16) bool {</span><br><span class="line">    saddResult, err := saddMachineIDToRedisSet()</span><br><span class="line">    if err != nil || saddResult == 0 {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    err := saveMachineIDToLocalFile(machineID)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return true</span><br><span class="line">    }</span><br><span class="line">    return false</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    t, _ := time.Parse("2006-01-02", "2018-01-01")</span><br><span class="line">    settings := sonyflake.Settings{</span><br><span class="line">        StartTime: t,</span><br><span class="line">        MachineID: getMachineID,</span><br><span class="line">        CheckMachineID: checkMachineID,</span><br><span class="line">    }</span><br><span class="line">    sf := sonyflake.NewSonyflake(settings)</span><br><span class="line">    id, err := sf.NextID()</span><br><span class="line">    if err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/91175219/">https://wssjdi.github.io/posts/91175219/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">流程控制</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/fbeb39a4/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go函数</div></div></a></div><div class="next-post pull-right"><a href="/posts/5c78a85/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go容器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/2910ec3f/" title="go test单元测试及基准测试"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go test单元测试及基准测试</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>