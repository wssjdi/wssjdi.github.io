<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go接口 | Wssjdi</title><meta name="description" content="go"><meta name="keywords" content="go,接口,面向接口编程"><meta name="author" content="Wssjdi"><meta name="copyright" content="Wssjdi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/favicon.svg"><link rel="canonical" href="https://wssjdi.github.io/posts/d3175357/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//pingjs.qq.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Go接口"><meta property="og:url" content="https://wssjdi.github.io/posts/d3175357/"><meta property="og:site_name" content="Wssjdi"><meta property="og:description" content="go"><meta property="og:image" content="//goproxy.cn/assets/images/logo.svg"><meta property="article:published_time" content="2020-10-21T15:49:55.000Z"><meta property="article:modified_time" content="2020-10-22T10:28:35.119Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/css/index.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var _mtac = {};
(function() {
    var mta = document.createElement("script");
    mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
    mta.setAttribute("name", "MTAH5");
    mta.setAttribute("sid", "500730411");
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(mta, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":200,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: Wssjdi","link":"链接: ","source":"来源: Wssjdi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"I,LOVE,YOU,不负,杯中酒,不负,心上人,不做,寂寞的,奴隶,不做,孤独的,鬼","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: '//cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-10-22 18:28:35'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '2'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Wssjdi" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-text">接口声明（定义）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">接口声明的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%86%99%E6%B3%95"><span class="toc-text">开发中常见的接口及写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%80%EF%BC%9A%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%80%E8%87%B4"><span class="toc-text">接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%A2%AB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BA%8C%EF%BC%9A%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E5%9D%87%E8%A2%AB%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口被实现的条件二：接口中所有方法均被实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类型与接口的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">一个类型可以实现多个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">多个类型可以实现相同的接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84nil%E5%88%A4%E6%96%AD"><span class="toc-text">接口的nil判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E-nil-%E4%B8%8D%E7%9B%B8%E7%AD%89"><span class="toc-text">接口与 nil 不相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0-nil-%E7%B1%BB%E5%9E%8B%E5%80%BC%E8%BF%94%E5%9B%9E%E6%97%B6%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E-nil"><span class="toc-text">发现 nil 类型值返回时直接返回 nil</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%AE%80%E8%BF%B0"><span class="toc-text">类型断言简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">实现日志系统（支持多种输出方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">日志对外接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%99%A8"><span class="toc-text">文件写入器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%86%99%E5%85%A5%E5%99%A8"><span class="toc-text">命令行写入器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-text">使用日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%88%E5%80%9F%E5%8A%A9sort-Interface%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-text">排序（借助sort.Interface接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8sort-Interface%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">使用sort.Interface接口进行排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BE%BF%E6%8D%B7%E6%8E%92%E5%BA%8F"><span class="toc-text">常见类型的便捷排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">对结构体数据进行排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B5%8C%E5%A5%97%E7%BB%84%E5%90%88"><span class="toc-text">接口的嵌套组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8C%85%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E7%BB%84%E5%90%88"><span class="toc-text">系统包中的接口嵌套组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E7%BB%84%E5%90%88"><span class="toc-text">在代码中使用接口嵌套组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">接口和类型之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">类型断言的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">将接口转换为其他接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-text">将接口转换为其他类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%EF%BC%88interface-%EF%BC%89"><span class="toc-text">空接口类型（interface{}）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%80%BC%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-text">将值保存到空接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%A9%BA%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-text">从空接口获取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-text">空接口的值比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%BB%A5%E4%BF%9D%E5%AD%98%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-text">使用空接口实现可以保存任意值的字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96"><span class="toc-text">值设置和获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E6%AE%B5%E7%9A%84%E6%89%80%E6%9C%89%E9%94%AE%E5%80%BC%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE"><span class="toc-text">遍历字段的所有键值关联数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4"><span class="toc-text">初始化和清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8"><span class="toc-text">使用字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF%EF%BC%88switch%E5%88%A4%E6%96%AD%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">类型分支（switch判断空接口中变量的类型）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F"><span class="toc-text">类型断言的书写格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用类型分支判断基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E6%94%AF%E5%88%A4%E6%96%AD%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用类型分支判断接口类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error%E6%8E%A5%E5%8F%A3%EF%BC%9A%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-text">error接口：返回错误信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#error-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">error 基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义错误类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">接口内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iface-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">iface 数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">接口调用过程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E4%BB%A3%E4%BB%B7"><span class="toc-text">接口调用代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">空接口数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E5%99%A8"><span class="toc-text">表达式求值器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">实现Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">Web服务器的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">搭建一个简单的 Web 服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E7%A8%8B%E5%BA%8F%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">部署程序到Linux服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8"><span class="toc-text">音乐播放器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88FSM%EF%BC%89"><span class="toc-text">实现有限状态机（FSM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">二叉树数据结构的应用</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(//goproxy.cn/assets/images/logo.svg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wssjdi</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 作者</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Go接口</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-21T15:49:55.000Z" title="发表于 2020-10-21 23:49:55">2020-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-22T10:28:35.119Z" title="更新于 2020-10-22 18:28:35">2020-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p>
<p>Go 语言中使用组合实现对象特性的描述。对象的内部使用结构体内嵌组合对象应该具有的特性，对外通过接口暴露能使用的特性。</p>
<p>Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p>
<p>其它编程语言中的接口</p>
<p>接口是一种较为常见的特性，很多语言都有接口特性。C/C++、C# 语言中的接口都可以多重派生实现接口组合；在苹果的 Objective C 中与接口类似的功能被称为 Protocol，这种叫法比接口更形象、具体。</p>
<p>非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p>
<h2 id="接口声明（定义）"><a href="#接口声明（定义）" class="headerlink" title="接口声明（定义）"></a>接口声明（定义）</h2><p>Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。</p>
<p>但是Go语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</p>
<p>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</p>
<p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</p>
<p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p>
<h3 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a>接口声明的格式</h3><p>每个接口类型由数个方法组成。接口的形式代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface{</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。</li>
<li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type writer interface{</span><br><span class="line">    Write([]byte) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="开发中常见的接口及写法"><a href="#开发中常见的接口及写法" class="headerlink" title="开发中常见的接口及写法"></a>开发中常见的接口及写法</h3><p>Go语言提供的很多包中都有接口，例如 io 包中提供的 Writer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个接口可以调用 Write() 方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。</p>
<p>类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用 String() 方法时，都可以获得对象对应的字符串。在 fmt 包中定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Stringer 接口在Go语言中的使用频率非常高，功能类似于 Java 或者 C# 语言里的 ToString 的操作。</p>
<p>Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。</p>
<p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p>
<p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p>
<p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p>
<h3 id="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><a href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致" class="headerlink" title="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"></a>接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</h3><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p>
<p>为了抽象数据写入的过程，定义 DataWriter 接口来描述数据写入需要实现的方法，接口中的 WriteData() 方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现 WriteData 方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现 DataWriter 接口的 WriteData 方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考下面的代码。</p>
<p>数据写入器的抽象：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义文件结构，用于实现DataWriter</span><br><span class="line">type file struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现DataWriter接口的WriteData方法</span><br><span class="line">func (d *file) WriteData(data interface{}) error {</span><br><span class="line"></span><br><span class="line">    // 模拟写入数据</span><br><span class="line">    fmt.Println("WriteData:", data)</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 实例化file</span><br><span class="line">    f := new(file)</span><br><span class="line"></span><br><span class="line">    // 声明一个DataWriter的接口</span><br><span class="line">    var writer DataWriter</span><br><span class="line"></span><br><span class="line">    // 将接口赋值f，也就是*file类型</span><br><span class="line">    writer = f</span><br><span class="line"></span><br><span class="line">    // 使用DataWriter接口进行数据写入</span><br><span class="line">    writer.WriteData("data")</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行，定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，输入一个 interface{} 类型的 data，返回一个 error 结构表示可能发生的错误。</li>
<li>第 17 行，file 的 WriteData() 方法使用指针接收器。输入一个 interface{} 类型的 data，返回 error。</li>
<li>第 27 行，实例化 file 赋值给 f，f 的类型为 <code>*file</code> 。</li>
<li>第 30 行，声明 DataWriter 类型的 writer 接口变量。</li>
<li>第 33 行，将 <code>*file</code> 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。</li>
<li>第 36 行，DataWriter 接口类型的 writer 使用 WriteData() 方法写入一个字符串。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteData: data</span><br></pre></td></tr></tbody></table></figure>
<p>本例中调用及实现关系如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writewriter.jpg" alt="图：WriteWriter的实现过程"></p>
<p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p>
<p>1)函数名不一致导致的报错</p>
<p>在以上代码的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改 file 结构的 WriteData() 方法名，将这个方法签名（第17行）修改为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (d *file) WriteDataX(data interface{}) error {</span><br></pre></td></tr></tbody></table></figure>
<p>编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing WriteData method)</span><br></pre></td></tr></tbody></table></figure>
<p>报错的位置在第 33 行。报错含义是：不能将 f 变量（类型 <code>*file</code>）视为 DataWriter 进行赋值。原因：<code>*file</code> 类型未实现 DataWriter 接口（丢失 WriteData 方法）。</p>
<p>WriteDataX 方法的签名本身是合法的。但编译器扫描到第 33 行代码时，发现尝试将 <code>*file</code> 类型赋值给 DataWriter 时，需要检查 <code>*file</code> 类型是否完全实现了 DataWriter 接口。显然，编译器因为没有找到 DataWriter 需要的 WriteData() 方法而报错。</p>
<p>2)实现接口的方法签名不一致导致的报错</p>
<p>将修改的代码恢复后，再尝试修改 WriteData() 方法，把 data 参数的类型从 interface{} 修改为 int 类型，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (d *file) WriteData(data int) error {</span><br></pre></td></tr></tbody></table></figure>
<p>编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (wrong type for WriteData method)</span><br><span class="line">                have WriteData(int) error</span><br><span class="line">                want WriteData(interface {}) error</span><br></pre></td></tr></tbody></table></figure>
<p>这次未实现 DataWriter 的理由变为（错误的 WriteData() 方法类型）发现 <code>WriteData(int)error</code> ，期望 <code>WriteData(interface{})error</code> 。</p>
<p>这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。</p>
<h3 id="接口被实现的条件二：接口中所有方法均被实现"><a href="#接口被实现的条件二：接口中所有方法均被实现" class="headerlink" title="接口被实现的条件二：接口中所有方法均被实现"></a>接口被实现的条件二：接口中所有方法均被实现</h3><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p>
<p>在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个数据写入器</span><br><span class="line">type DataWriter interface {</span><br><span class="line">    WriteData(data interface{}) error</span><br><span class="line"></span><br><span class="line">    // 能否写入</span><br><span class="line">    CanWrite() bool</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">        *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></tbody></table></figure>
<p>需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。</p>
<p>Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p>
<p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p>
<p><strong><em>提示:传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。</em></strong></p>
<p>对于Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。</p>
<h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><p>在Go语言中类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系</p>
<h3 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a>一个类型可以实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。</p>
<p>Socket 和文件一样，在使用完毕后，也需要对资源进行释放。</p>
<p>把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Socket struct {</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line">func (s *Socket) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Socket 结构的 Write() 方法实现了 io.Writer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同时，Socket 结构也实现了 io.Closer 接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/gosocket.jpg" alt="图：接口的使用和实现过程"></p>
<p>在代码中使用 Socket 结构实现的 Writer 接口和 Closer 接口代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用io.Writer的代码, 并不知道Socket和io.Closer的存在</span><br><span class="line">func usingWriter( writer io.Writer){</span><br><span class="line">    writer.Write( nil )</span><br><span class="line">}</span><br><span class="line">// 使用io.Closer, 并不知道Socket和io.Writer的存在</span><br><span class="line">func usingCloser( closer io.Closer) {</span><br><span class="line">    closer.Close()</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    // 实例化Socket</span><br><span class="line">    s := new(Socket)</span><br><span class="line">    usingWriter(s)</span><br><span class="line">    usingCloser(s)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。</p>
<h3 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p>
<p>Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 一个服务需要满足能够开启和写日志的功能</span><br><span class="line">type Service interface {</span><br><span class="line">    Start()  // 开启服务</span><br><span class="line">    Log(string)  // 日志输出</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 日志器</span><br><span class="line">type Logger struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Log()方法</span><br><span class="line">func (g *Logger) Log(l string) {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 游戏服务</span><br><span class="line">type GameService struct {</span><br><span class="line">    Logger  // 嵌入日志器</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现Service的Start()方法</span><br><span class="line">func (g *GameService) Start() {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义服务接口，一个服务需要实现 Start() 方法和日志方法。</li>
<li>第 8 行，定义能输出日志的日志器结构。</li>
<li>第 12 行，为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。</li>
<li>第 17 行，定义 GameService 结构。</li>
<li>第 18 行，在 GameService 中嵌入 Logger 日志器，以实现日志功能。</li>
<li>第 22 行，GameService 的 Start() 方法实现了 Service 的 Start() 方法。</li>
</ul>
<p>此时，实例化 GameService，并将实例赋给 Service，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s Service = new(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(“hello”)</span><br></pre></td></tr></tbody></table></figure>
<p>s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。</p>
<h2 id="接口的nil判断"><a href="#接口的nil判断" class="headerlink" title="接口的nil判断"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/128.html">接口的nil判断</a></h2><p>nil 在 Go 语言中只能被赋值给指针和接口。接口在底层的实现有两个部分：type 和 data。在源码中，显式地将 nil 赋值给接口时，接口的 type 和 data 都将为 nil。此时，接口与 nil 值判断是相等的。但如果将一个带有类型的 nil 赋值给接口时，只有 data 为 nil，而 type 为 nil，此时，接口与 nil 判断将不相等。</p>
<h3 id="接口与-nil-不相等"><a href="#接口与-nil-不相等" class="headerlink" title="接口与 nil 不相等"></a>接口与 nil 不相等</h3><p>下面代码使用 MyImplement() 实现 fmt 包中的 Stringer 接口，这个接口的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Stringer interface {</span><br><span class="line">    String() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 GetStringer() 函数中将返回这个接口。通过 *MyImplement 指针变量置为 nil 提供 GetStringer 的返回值。在 main() 中，判断 GetStringer 与 nil 是否相等，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义一个结构体</span><br><span class="line">type MyImplement struct{}</span><br><span class="line"></span><br><span class="line">// 实现fmt.Stringer的String方法</span><br><span class="line">func (m *MyImplement) String() string {</span><br><span class="line"></span><br><span class="line">    return "hi"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 在函数中返回fmt.Stringer接口</span><br><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    // 赋nil</span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    // 返回变量</span><br><span class="line">    return s</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 判断返回值是否为nil</span><br><span class="line">    if GetStringer() == nil {</span><br><span class="line">        fmt.Println("GetStringer() == nil")</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println("GetStringer() != nil")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，实现 fmt.Stringer 的 String() 方法。</li>
<li>第 21 行，s 变量此时被 fmt.Stringer 接口包装后，实际类型为 *MyImplement，值为 nil 的接口。</li>
<li>第 27 行，使用 GetStringer() 的返回值与 nil 判断时，虽然接口里的 value 为 nil，但 type 带有 *MyImplement 信息，使用 == 判断相等时，依然不为 nil。</li>
</ul>
<h3 id="发现-nil-类型值返回时直接返回-nil"><a href="#发现-nil-类型值返回时直接返回-nil" class="headerlink" title="发现 nil 类型值返回时直接返回 nil"></a>发现 nil 类型值返回时直接返回 nil</h3><p>为了避免这类误判的问题，可以在函数返回时，发现带有 nil 的指针时直接返回 nil，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func GetStringer() fmt.Stringer {</span><br><span class="line"></span><br><span class="line">    var s *MyImplement = nil</span><br><span class="line"></span><br><span class="line">    if s == nil {</span><br><span class="line">        return nil</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return s</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类型断言简述"><a href="#类型断言简述" class="headerlink" title="类型断言简述"></a>类型断言简述</h2><p>类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p>
<p>在Go语言中类型断言的语法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p>
<p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：</p>
<ul>
<li>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。</li>
<li>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。</li>
<li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = 10</span><br><span class="line">    value, ok := x.(int)</span><br><span class="line">    fmt.Print(value, ",", ok)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10,true</span><br></pre></td></tr></tbody></table></figure>
<p>需要注意如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var x interface{}</span><br><span class="line">    x = "Hello"</span><br><span class="line">    value := x.(int)</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface {} is string, not int</span><br></pre></td></tr></tbody></table></figure>
<p>类型断言还可以配合 switch 使用，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    var a int</span><br><span class="line">    a = 10</span><br><span class="line">    getType(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func getType(a interface{}) {</span><br><span class="line">    switch a.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println("the type of a is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println("the type of a is string")</span><br><span class="line">    case float64:</span><br><span class="line">        fmt.Println("the type of a is float")</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println("unknown type")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the type of a is int</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实现日志系统（支持多种输出方式）"><a href="#实现日志系统（支持多种输出方式）" class="headerlink" title="实现日志系统（支持多种输出方式）"></a>实现日志系统（支持多种输出方式）</h2><p>日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，如命令行、文件、网络等。</p>
<p>本例将搭建一个支持多种写入器的日志系统，可以自由扩展多种日志写入设备。</p>
<h3 id="日志对外接口"><a href="#日志对外接口" class="headerlink" title="日志对外接口"></a>日志对外接口</h3><p>本例中定义一个日志写入器接口（LogWriter），要求写入设备必须遵守这个接口协议才能被日志器（Logger）注册。日志器有一个写入器的注册方法（Logger的RegisterWriter()方法）。</p>
<p>日志器还有一个Log()方法，进行日志的输出，这个函数会将日志写入到所有已经注册的日志写入器（LogWriter）中，详细代码实现请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//声明日志写入器接口</span><br><span class="line">type LogWriter interface{</span><br><span class="line">    Write(data interface{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//日志器</span><br><span class="line">type Logger struct{</span><br><span class="line">    //这个日志器用到的日志写入器</span><br><span class="line">    writerList []LogWriter</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//注册一个日志写入器</span><br><span class="line">func(l *Logger) RegisterWriter ( writer LogWriter ) {</span><br><span class="line">    l.writerList = append(l.writerList , writer )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//将一个data类型的数据写入日志</span><br><span class="line">func(l *Logger) Log ( data interface{}){</span><br><span class="line"></span><br><span class="line">    //遍历所有注册的写入器</span><br><span class="line">    for _ , writer := range l.writerList {</span><br><span class="line"></span><br><span class="line">        //将日志输出到每一个写入器中</span><br><span class="line">        writer.Write(data)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建日志器的实例</span><br><span class="line">func NewLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    return &amp;Logger{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，声明日志写入器接口。这个接口可以被外部使用。日志的输出可以有多种设备，这个写入器就是用来实现一个日志的输出设备。</li>
<li>第9行，声明日志器结构。日志器使用writeList记录输出到哪些设备上。</li>
<li>第15行，使用日志器方法RegisterWriter()将一个日志写入器（LogWriter）注册到日志器（Logger）中。注册的意思就是将日志写入器的接口添加到writeList中。</li>
<li>第20行，日志器的Log()方法可以将interface{}类型的data写入到注册过的日志写入器中。</li>
<li>第23行，遍历日志器拥有的所有日志写入器。</li>
<li>第26行，将本次日志的内容写入日志写入器。</li>
<li>第31行，创建日志器的实例。</li>
</ul>
<p>这个例子中，为了最大程度地展示接口的用法，仅仅只是将数据直接写入日志写入器中。复杂一些的日志器还可以将日期、级别等信息合并到数据中一并写入日志。</p>
<h3 id="文件写入器"><a href="#文件写入器" class="headerlink" title="文件写入器"></a>文件写入器</h3><p>文件写入器（fileWriter）是众多日志写入器（LogWriter）中的一种。文件写入器的功能是根据一个文件名创建日志文件（fileWriter的SetFile方法）。在有日志写入时，将日志写入文件中。</p>
<p>文件写入器代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//声明文件写入器</span><br><span class="line">type fileWriter struct{</span><br><span class="line">    file *os.File</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//设置文件写入器写入的文件名</span><br><span class="line">func(f *fileWriter) SetFile ( filename string ) (err error ) {</span><br><span class="line"></span><br><span class="line">    //如果文件已经打开,关闭前一个文件</span><br><span class="line">    if f.file != nil {</span><br><span class="line">        f.file.Close()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个文件并保存文件句柄</span><br><span class="line">    f.file , err = os.Create(filename)</span><br><span class="line"></span><br><span class="line">    //如果创建的过程出现错误,则返回错误</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *fileWriter) Write ( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //日志文件可能没有创建成功</span><br><span class="line">    if f.file == nil {</span><br><span class="line"></span><br><span class="line">        //日志文件没有准备好</span><br><span class="line">        return errors.New("file not created")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入文件中</span><br><span class="line">    _ , err := f.file.Write([]byte(str))</span><br><span class="line"></span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//创建文件写入器实例</span><br><span class="line">func newFileWriter() *fileWriter {</span><br><span class="line">    return &amp;fileWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，声明文件写入器，在结构体中保存一个文件句柄，以方便每次写入时操作。</li>
<li>第15行，文件写入器通过文件名创建文件，这里通过SetFile的参数提供一个文件名，并创建文件。</li>
<li>第18行，考虑到SetFile()方法可以被多次调用（函数可重入性），假设之前已经调用过SetFile()后再次调用，此时的f.file不为空，就需要关闭之前的文件，重新创建新的文件。</li>
<li>第23行，根据文件名创建文件，如果发生错误，通过SetFile的返回值返回。</li>
<li>第30行，fileWriter的Write()方法实现了LogWriter接口的Write()方法。</li>
<li>第33行，如果文件没有准备好，文件句柄为nil，此时使用errors包的New()函数返回一个错误对象，包含一个字符串“filenotcreated”。</li>
<li>第40行，通过Write()方法传入的data参数是interface{}类型，而f.file的Write()方法需要的是[]byte类型。使用fmt.Sprintf将data转换为字符串，这里使用的格式化参数是%v，意思是将data按其本来的值转换为字符串。</li>
<li>第43行，通过f.file的Write()方法，将str字符串转换为[]byte字节数组，再写入到文件中。如果发生错误，则返回。</li>
</ul>
<p>在操作文件时，会出现文件无法创建、无法写入等错误。开发中尽量不要忽略这些底层报出的错误，应该处理可能发生的所有错误。</p>
<p>文件使用完后，要注意使用os.File的Close()方法进行及时关闭，否则文件再次访问时会因为其属性出现无法读取、无法写入等错误。</p>
<p><strong>提示:</strong></p>
<p>一个完备的文件写入器会提供多种写入文件的模式，例子中使用的模式是将日志添加到日志文件的尾部。随着文件越来越大，文件的访问效率和查看便利性也会大大降低。此时，就需要另外一种写入模式：滚动写入文件。</p>
<p>滚动写入文件模式也是将日志添加到文件的尾部，但当文件达到设定的期望大小时，会自动开启一个新的文件继续写入文件，最终将获得多个日志文件。</p>
<p>日志文件名不仅可以按照文件大小进行分割，还可以按照日期范围进行分割。在到达设定的日期范围，如每天、每小时的周期范围时，日志器会自动创建新的日志文件。这种日志文件创建方法也能方便开发者按日志查看日志。</p>
<h3 id="命令行写入器"><a href="#命令行写入器" class="headerlink" title="命令行写入器"></a>命令行写入器</h3><p>在UNIX的思想中，一切皆文件。文件包括内存、磁盘、网络和命令行等。这种抽象方法方便我们访问这些看不见摸不着的虚拟资源。命令行在Go语言中也是一种文件，os.Stdout对应标准输出，一般表示屏幕，也就是命令行，也可以被重定向为打印机或者磁盘文件；os.Stderr对应标准错误输出，一般将错误输出到日志中，不过大多数情况，os.Stdout会与os.Stderr合并输出；os.Stdin对应标准输入，一般表示键盘。os.Stdout、os.Stderr、os.Stdin都是 <code>*os.File</code> 类型，和文件一样实现了io.Writer接口的Write()方法。</p>
<p>下面的代码展示如何将命令行抽象为日志写入器：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    "fmt"</span><br><span class="line">    "os"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//命令行写入器</span><br><span class="line">type consoleWriter struct {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现LogWriter的Write()方法</span><br><span class="line">func(f *consoleWriter) Write( data interface{}) error {</span><br><span class="line"></span><br><span class="line">    //将数据序列化为字符串</span><br><span class="line">    str := fmt.Sprintf("%v\n",data)</span><br><span class="line"></span><br><span class="line">    //将数据以字节数组写入命令行中</span><br><span class="line">    _ , err := os.Stdout.Write([]byte(str))</span><br><span class="line">    return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建命令行写入器实例</span><br><span class="line">func newConsoleWriter() *consoleWriter {</span><br><span class="line">    return &amp;consoleWriter{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，声明consoleWriter结构，以实现命令行写入器。</li>
<li>第13行，consoleWriter的Write()方法实现了日志写入接口（LogWriter）的Write()方法。</li>
<li>第16行，与fileWriter类似，这里也将data通过fmt.Sprintf序列化为字符串。</li>
<li>第19行，与fileWriter类似，这里也将str字符串转换为字节数组并写入标准输出os.Stdout。写入后的内容就会显示在命令行中。</li>
<li>第25行，创建命令行写入器的实例。</li>
</ul>
<p>除了命令行写入器（consoleWriter）和文件写入器（fileWriter），读者还可以自行使用net包中的Socket封装实现网络写入器socketWriter，让日志可以写入远程的服务器中或者可以跨进程进行日志保存和分析。</p>
<h3 id="使用日志"><a href="#使用日志" class="headerlink" title="使用日志"></a>使用日志</h3><p>在程序中使用日志器一般会先通过代码创建日志器（Logger），为日志器添加输出设备（fileWriter、consoleWriter等）。这些设备中有一部分需要一些参数设定，如文件日志写入器需要提供文件名（fileWriter的SetFile()方法）。</p>
<p>下面代码中展示了使用日志器的过程：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">//创建日志器</span><br><span class="line">func createLogger() *Logger {</span><br><span class="line"></span><br><span class="line">    //创建日志器</span><br><span class="line">    l := NewLogger()</span><br><span class="line"></span><br><span class="line">    //创建命令行写入器</span><br><span class="line">    cw := newConsoleWriter()</span><br><span class="line"></span><br><span class="line">    //注册命令行写入器到日志器中</span><br><span class="line">    l.RegisterWriter(cw)</span><br><span class="line"></span><br><span class="line">    //创建文件写入器</span><br><span class="line">    fw := newFileWriter()</span><br><span class="line"></span><br><span class="line">    //设置文件名</span><br><span class="line">    if err := fw.SetFile("log.log"); err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //注册文件写入器到日志器中</span><br><span class="line">    l.RegisterWriter(fw)</span><br><span class="line"></span><br><span class="line">    return l</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line"></span><br><span class="line">    //准备日志器</span><br><span class="line">    l := createLogger()</span><br><span class="line"></span><br><span class="line">    //写一个日志</span><br><span class="line">    l.Log("hello")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行，一个创建日志的过程。这个过程一般隐藏在系统初始化中。程序启动时初始化一次。</li>
<li>第9行，创建一个日志器的实例，后面的代码会使用到它。</li>
<li>第12行，创建一个命令行写入器。如果全局有很多日志器，命令行写入器可以被共享，全局只会有一份。</li>
<li>第18行，创建一个文件写入器。一个程序的日志一般只有一个，因此不同的日志器也应该共享一个文件写入器。</li>
<li>第21行，创建好的文件写入器需要初始化写入的文件，通过文件名确定写入的文件。设置的过程可能会发生错误，发生错误时会输出错误信息。</li>
<li>第26行，将文件写入器注册到日志器中。</li>
<li>第34行，在程序一开始创建日志器。</li>
<li>第37行，往创建好的日志器中写入日志。</li>
</ul>
<p>编译整个代码并运行，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></tbody></table></figure>
<p>同时，当前目录的log.log文件中也会出现hello字符。</p>
<p><strong>提示:</strong></p>
<p>Go语言的log包实现了一个小型的日志系统。这个日志系统可以在创建日志器时选择输出设备、日志前缀及flag，函数定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func New(out io.Writer,prefix string,flag int) *Logger { return &amp;Logger{out:out,prefix:prefix,flag:flag }}</span><br></pre></td></tr></tbody></table></figure>
<p>在flag中，还可以定制日志中是否输出日期、日期精度和详细文件名等。</p>
<p>这个日志器在编写时，也最大程度地保证了输出的效率，如果读者对日志器的编写比较感兴趣，可以在log包的基础上进行扩展，形成方便自己使用的日志库。</p>
<h2 id="排序（借助sort-Interface接口）"><a href="#排序（借助sort-Interface接口）" class="headerlink" title="排序（借助sort.Interface接口）"></a>排序（借助sort.Interface接口）</h2><p>排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要 15 行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。</p>
<p>幸运的是，sort 包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。</p>
<p>相比之下，Go语言的 sort.Sort 函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型 sort.Interface 来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 的三个方法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package sort</span><br><span class="line">type Interface interface {</span><br><span class="line">    Len() int            // 获取元素数量</span><br><span class="line">    Less(i, j int) bool // i，j是序列元素的指数。</span><br><span class="line">    Swap(i, j int)        // 交换元素</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用 sort.Sort 函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型 MyStringList  和它的 Len，Less 和 Swap 方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type MyStringList  []string</span><br><span class="line">func (p MyStringList ) Len() int { return len(m) }</span><br><span class="line">func (p MyStringList ) Less(i, j int) bool { return m[i] &lt; m[j] }</span><br><span class="line">func (p MyStringList ) Swap(i, j int) { m[i], m[j] = m[j], m[i] }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用sort-Interface接口进行排序"><a href="#使用sort-Interface接口进行排序" class="headerlink" title="使用sort.Interface接口进行排序"></a>使用sort.Interface接口进行排序</h3><p>对一系列字符串进行排序时，使用字符串切片（ <code>[]string</code> ）承载多个字符串。使用 type 关键字，将字符串切片（ <code>[]string</code> ）定义为自定义类型 MyStringList。为了让 sort 包能识别 MyStringList，能够对 MyStringList 进行排序，就必须让 MyStringList 实现 sort.Interface 接口。</p>
<p>下面是对字符串排序的详细代码（代码1）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 将[]string定义为MyStringList类型</span><br><span class="line">type MyStringList []string</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的获取元素数量方法</span><br><span class="line">func (m MyStringList) Len() int {</span><br><span class="line">    return len(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的比较元素方法</span><br><span class="line">func (m MyStringList) Less(i, j int) bool {</span><br><span class="line">    return m[i] &lt; m[j]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口的交换元素方法</span><br><span class="line">func (m MyStringList) Swap(i, j int) {</span><br><span class="line">    m[i], m[j] = m[j], m[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备一个内容被打乱顺序的字符串切片</span><br><span class="line">    names := MyStringList{</span><br><span class="line">        "3. Triple Kill",</span><br><span class="line">        "5. Penta Kill",</span><br><span class="line">        "2. Double Kill",</span><br><span class="line">        "4. Quadra Kill",</span><br><span class="line">        "1. First Blood",</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(names)</span><br><span class="line"></span><br><span class="line">    // 遍历打印结果</span><br><span class="line">    for _, v := range names {</span><br><span class="line">            fmt.Printf("%s\n", v)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First Blood</span><br><span class="line">2. Double Kill</span><br><span class="line">3. Triple Kill</span><br><span class="line">4. Quadra Kill</span><br><span class="line">5. Penta Kill</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，接口实现不受限于结构体，任何类型都可以实现接口。要排序的字符串切片 <code>[]string</code> 是系统定制好的类型，无法让这个类型去实现 sort.Interface 排序接口。因此，需要将 <code>[]string</code> 定义为自定义的类型。</li>
<li>第 12 行，实现获取元素数量的 Len() 方法，返回字符串切片的元素数量。</li>
<li>第 17 行，实现比较元素的 Less() 方法，直接取 m 切片的 i 和 j 元素值进行小于比较，并返回比较结果。</li>
<li>第 22 行，实现交换元素的 Swap() 方法，这里使用Go语言的多变量赋值特性实现元素交换。</li>
<li><p>第 29 行，由于将 <code>[]string</code> 定义成 MyStringList 类型，字符串切片初始化的过程等效于下面的写法</p>
  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names := []string {</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>第 38 行，使用 sort 包的 Sort() 函数，将 names（MyStringList类型）进行排序。排序时，sort 包会通过 MyStringList 实现的 Len()、Less()、Swap() 这 3 个方法进行数据获取和修改。</p>
</li>
<li>第 41 行，遍历排序好的字符串切片，并打印结果。</li>
</ul>
<h3 id="常见类型的便捷排序"><a href="#常见类型的便捷排序" class="headerlink" title="常见类型的便捷排序"></a>常见类型的便捷排序</h3><p>通过实现 sort.Interface 接口的排序过程具有很强的可定制性，可以根据被排序对象比较复杂的特性进行定制。例如，需要多种排序逻辑的需求就适合使用 sort.Interface 接口进行排序。但大部分情况中，只需要对字符串、整型等进行快速排序。Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。</p>
<p>1)字符串切片的便捷排序</p>
<p>sort 包中有一个 StringSlice 类型，定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type StringSlice []string</span><br><span class="line"></span><br><span class="line">func (p StringSlice) Len() int           { return len(p) }</span><br><span class="line">func (p StringSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p StringSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure>
<p>sort 包中的 StringSlice 的代码与 MyStringList 的实现代码几乎一样。因此，只需要使用 sort 包的 StringSlice 就可以更简单快速地进行字符串排序。将代码1中的排序代码简化后如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names := sort.StringSlice{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Sort(names)</span><br></pre></td></tr></tbody></table></figure>
<p>简化后，只要两句代码就实现了字符串排序的功能。</p>
<p>2)对整型切片进行排序</p>
<p>除了字符串可以使用 sort 包进行便捷排序外，还可以使用 sort.IntSlice 进行整型切片的排序。sort.IntSlice 的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type IntSlice []int</span><br><span class="line"></span><br><span class="line">func (p IntSlice) Len() int           { return len(p) }</span><br><span class="line">func (p IntSlice) Less(i, j int) bool { return p[i] &lt; p[j] }</span><br><span class="line">func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }</span><br><span class="line"></span><br><span class="line">// Sort is a convenience method.</span><br><span class="line">func (p IntSlice) Sort() { Sort(p) }</span><br></pre></td></tr></tbody></table></figure>
<p>sort 包在 sort.Interface 对各类型的封装上还有更进一步的简化，下面使用 sort.Strings 继续对代码1进行简化，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">names := []string{</span><br><span class="line">    "3. Triple Kill",</span><br><span class="line">    "5. Penta Kill",</span><br><span class="line">    "2. Double Kill",</span><br><span class="line">    "4. Quadra Kill",</span><br><span class="line">    "1. First Blood",</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sort.Strings(names)</span><br><span class="line"></span><br><span class="line">// 遍历打印结果</span><br><span class="line">for _, v := range names {</span><br><span class="line">    fmt.Printf("%s\n", v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行，需要排序的字符串切片。</li>
<li>第 9 行，使用 sort.Strings 直接对字符串切片进行排序。</li>
</ul>
<p>3)sort包内建的类型排序接口一览</p>
<p>Go语言中的 sort 包中定义了一些常见类型的排序方法，如下表所示。</p>
<table>
    <thead><tr><th>类  型</th><th>实现 sort.lnterface的类型</th><th>直接排序方法</th><th>说  明</th></tr></thead>
    <tbody>
        <tr><th>字符串（String）</th><th>StringSlice</th><th>sort.Strings(a [] string)</th><th>字符 ASCII 值升序</th></tr>
        <tr><th>整型（int）</th><th>IntSlice</th><th>sort.Ints(a []int)</th><th>数值升序</th></tr>
        <tr><th>双精度浮点（float64）</th><th>Float64Slice</th><th>sort.Float64s(a []float64)</th><th>数值升序</th></tr>
    </tbody>
</table>

<p>编程中经常用到的 int32、int64、float32、bool 类型并没有由 sort 包实现，使用时依然需要开发者自己编写。</p>
<h3 id="对结构体数据进行排序"><a href="#对结构体数据进行排序" class="headerlink" title="对结构体数据进行排序"></a>对结构体数据进行排序</h3><p>除了基本类型的排序，也可以对结构体进行排序。结构体比基本类型更为复杂，排序时不能像数值和字符串一样拥有一些固定的单一原则。结构体的多个字段在排序中可能会存在多种排序的规则，例如，结构体中的名字按字母升序排列，数值按从小到大的顺序排序。一般在多种规则同时存在时，需要确定规则的优先度，如先按名字排序，再按年龄排序等。</p>
<p>1)完整实现sort.Interface进行结构体排序</p>
<p>将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程如下。</p>
<p>结构体排序代码（代码2）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明英雄的分类</span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">// 定义HeroKind常量, 类似于枚举</span><br><span class="line">const (</span><br><span class="line">    None HeroKind = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义英雄名单的结构</span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string  // 英雄的名字</span><br><span class="line">    Kind HeroKind  // 英雄的种类</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 将英雄指针的切片定义为Heros类型</span><br><span class="line">type Heros []*Hero</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口取元素数量方法</span><br><span class="line">func (s Heros) Len() int {</span><br><span class="line">    return len(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口比较元素方法</span><br><span class="line">func (s Heros) Less(i, j int) bool {</span><br><span class="line"></span><br><span class="line">    // 如果英雄的分类不一致时, 优先对分类进行排序</span><br><span class="line">    if s[i].Kind != s[j].Kind {</span><br><span class="line">        return s[i].Kind &lt; s[j].Kind</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 默认按英雄名字字符升序排列</span><br><span class="line">    return s[i].Name &lt; s[j].Name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现sort.Interface接口交换元素方法</span><br><span class="line">func (s Heros) Swap(i, j int) {</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 准备英雄列表</span><br><span class="line">    heros := Heros{</span><br><span class="line">        &amp;Hero{"吕布", Tank},</span><br><span class="line">        &amp;Hero{"李白", Assassin},</span><br><span class="line">        &amp;Hero{"妲己", Mage},</span><br><span class="line">        &amp;Hero{"貂蝉", Assassin},</span><br><span class="line">        &amp;Hero{"关羽", Tank},</span><br><span class="line">        &amp;Hero{"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 使用sort包进行排序</span><br><span class="line">    sort.Sort(heros)</span><br><span class="line"></span><br><span class="line">    // 遍历英雄列表打印排序结果</span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;{Name:关羽 Kind:1}</span><br><span class="line">&amp;{Name:吕布 Kind:1}</span><br><span class="line">&amp;{Name:李白 Kind:2}</span><br><span class="line">&amp;{Name:貂蝉 Kind:2}</span><br><span class="line">&amp;{Name:妲己 Kind:3}</span><br><span class="line">&amp;{Name:诸葛亮 Kind:3}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 9 行，将 int 声明为 HeroKind 英雄类型，后面会将这个类型当做枚举来使用。</li>
<li>第 13 行，定义一些英雄类型常量，可以理解为枚举的值。</li>
<li>第 26 行，为了方便实现 sort.Interface 接口，将 <code>[]*Hero</code> 定义为 Heros 类型。</li>
<li>第 29 行，Heros 类型实现了 sort.Interface 的 Len() 方法，返回英雄的数量。</li>
<li>第 34 行，Heros 类型实现了 sort.Interface 的 Less() 方法，根据英雄字段的比较结果决定如何排序。</li>
<li>第 37 行，当英雄的分类不一致时，优先按分类的枚举数值从小到大排序。</li>
<li>第 42 行，英雄分类相等的情况下，默认根据英雄的名字字符升序排序。</li>
<li>第 46 行，Heros 类型实现了 sort.Interface 的 Swap() 方法，交换英雄元素的位置。</li>
<li>第 53～60 行，准备一系列英雄数据。</li>
<li>第 63 行，使用 sort 包进行排序。</li>
<li>第 66 行，遍历所有排序完成的英雄数据。</li>
</ul>
<p>2)使用sort.Slice进行切片元素排序</p>
<p>从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice() 函数进行更为简便的排序方法。sort.Slice() 函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为 <code>func(i,j int) bool</code>，sort.Slice() 函数的定义如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Slice(slice interface{}, less func(i, j int) bool)</span><br></pre></td></tr></tbody></table></figure>
<p>使用 sort.Slice() 函数，对代码2重新优化的完整代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "sort"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HeroKind int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    None = iota</span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Hero struct {</span><br><span class="line">    Name string</span><br><span class="line">    Kind HeroKind</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    heros := []*Hero{</span><br><span class="line">        {"吕布", Tank},</span><br><span class="line">        {"李白", Assassin},</span><br><span class="line">        {"妲己", Mage},</span><br><span class="line">        {"貂蝉", Assassin},</span><br><span class="line">        {"关羽", Tank},</span><br><span class="line">        {"诸葛亮", Mage},</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sort.Slice(heros, func(i, j int) bool {</span><br><span class="line">        if heros[i].Kind != heros[j].Kind {</span><br><span class="line">            return heros[i].Kind &lt; heros[j].Kind</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return heros[i].Name &lt; heros[j].Name</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    for _, v := range heros {</span><br><span class="line">        fmt.Printf("%+v\n", v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第 33 行到第 39 行部分是新添加的 sort.Slice() 及回调函数部分。对比前面的代码，这里去掉了 Heros 及接口实现部分的代码。</p>
<p>使用 sort.Slice() 不仅可以完成结构体切片排序，还可以对各种切片类型进行自定义排序。</p>
<h2 id="接口的嵌套组合"><a href="#接口的嵌套组合" class="headerlink" title="接口的嵌套组合"></a>接口的嵌套组合</h2><p>在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。</p>
<p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。</p>
<h3 id="系统包中的接口嵌套组合"><a href="#系统包中的接口嵌套组合" class="headerlink" title="系统包中的接口嵌套组合"></a>系统包中的接口嵌套组合</h3><p>Go语言的 io 包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3 个接口，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface {</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Closer interface {</span><br><span class="line">    Close() error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type WriteCloser interface {</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 1 行定义了写入器（Writer），如这个接口较为常用，常用于 I/O 设备的数据写入。</li>
<li>第 5 行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。</li>
<li>第 9 行定义了写入关闭器（WriteCloser），这个接口由 Writer 和 Closer 两个接口嵌入。也就是说，WriteCloser 同时拥有了 Writer 和 Closer 的特性。</li>
</ul>
<h3 id="在代码中使用接口嵌套组合"><a href="#在代码中使用接口嵌套组合" class="headerlink" title="在代码中使用接口嵌套组合"></a>在代码中使用接口嵌套组合</h3><p>在代码中使用 io.Writer、io.Closer 和 io.WriteCloser 这 3 个接口时，只需要按照接口实现的规则实现 io.Writer 接口和 io.Closer 接口即可。而 io.WriteCloser 接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了 io.Writer 和 io.Closer 接口，详细实现代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 声明一个设备结构</span><br><span class="line">type device struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Writer的Write()方法</span><br><span class="line">func (d *device) Write(p []byte) (n int, err error) {</span><br><span class="line">    return 0, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现io.Closer的Close()方法</span><br><span class="line">func (d *device) Close() error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 声明写入关闭器, 并赋予device的实例</span><br><span class="line">    var wc io.WriteCloser = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    wc.Write(nil)</span><br><span class="line"></span><br><span class="line">    // 关闭设备</span><br><span class="line">    wc.Close()</span><br><span class="line"></span><br><span class="line">    // 声明写入器, 并赋予device的新实例</span><br><span class="line">    var writeOnly io.Writer = new(device)</span><br><span class="line"></span><br><span class="line">    // 写入数据</span><br><span class="line">    writeOnly.Write(nil)</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 8 行定义了 device 结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的 3 种接口。</li>
<li>第 12 行，实现了 io.Writer 的 Write() 方法。</li>
<li>第 17 行，实现了 io.Closer 的 Close() 方法。</li>
<li>第 24 行，对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。</li>
<li>第 27 行，调用了 wc（io.WriteCloser接口）的 Write() 方法，由于 wc 被赋值 <code>*device</code> ，因此最终会调用 device 的 Write() 方法。</li>
<li>第 30 行，与 27 行类似，最终调用 device 的 Close() 方法。</li>
<li>第 33 行，再次创建一个 device 的实例，writeOnly 是一个 io.Writer 接口，这个接口只有 Write() 方法。</li>
<li>第 36 行，writeOnly 只能调用 Write() 方法，没有 Close() 方法。</li>
</ul>
<p>为了整理思路，将上面的实现、调用关系使用图方式来展现，参见图 1 和图 2。</p>
<p>1)io.WriteCloser的实现及调用过程如图 1 所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writecloser.jpg" alt="图1：io.WriteCloser 的实现及调用过程"></p>
<p>2)io.Writer 的实现调用过程如图 2 所示。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/writer.jpg" alt="图2：io.Write 的实现及调用过程"></p>
<p>给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。</p>
<h2 id="接口和类型之间的转换"><a href="#接口和类型之间的转换" class="headerlink" title="接口和类型之间的转换"></a>接口和类型之间的转换</h2><p>Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。</p>
<h3 id="类型断言的格式"><a href="#类型断言的格式" class="headerlink" title="类型断言的格式"></a>类型断言的格式</h3><p>类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p>
<p>类型断言的基本格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量。</p>
<p>这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File) // 成功: f == os.Stdout</span><br><span class="line">c := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer</span><br></pre></td></tr></tbody></table></figure>
<p>第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 i 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。</p>
<p>在下面的第一个类型断言后，w 和 rw 都持有 os.Stdout 因此它们每个有一个动态类型 *os.File，但是变量 w 是一个 io.Writer 类型只对外公开出文件的 Write 方法，然而 rw 变量也只公开它的 Read 方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) // 成功：*os.file具有读写功能</span><br><span class="line">w = new(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) // 死机：*字节计数器没有读取方法</span><br></pre></td></tr></tbody></table></figure>
<p>如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于 nil 接口值的情况。</p>
<p>如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t,ok := i.(T)</span><br></pre></td></tr></tbody></table></figure>
<p>这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true。这里 ok 可以被认为是：i 接口是否实现 T 类型的结果。</p>
<h3 id="将接口转换为其他接口"><a href="#将接口转换为其他接口" class="headerlink" title="将接口转换为其他接口"></a>将接口转换为其他接口</h3><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p>
<p>鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的 Fly() 和 Walk() 方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。</p>
<p>将鸟和猪的实例创建后，被保存到 interface{} 类型的 map 中。interface{} 类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的 interface{} 变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回 false。例如下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj interface = new(bird)</span><br><span class="line">f, isFlyer := obj.(Flyer)</span><br></pre></td></tr></tbody></table></figure>
<p>代码中，new(bird) 产生 <code>*bird</code> 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。</p>
<p>下面是详细的代码（代码1）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 定义飞行动物接口</span><br><span class="line">type Flyer interface {</span><br><span class="line">    Fly()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义行走动物接口</span><br><span class="line">type Walker interface {</span><br><span class="line">    Walk()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义鸟类</span><br><span class="line">type bird struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 实现飞行动物接口</span><br><span class="line">func (b *bird) Fly() {</span><br><span class="line">    fmt.Println("bird: fly")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为鸟添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (b *bird) Walk() {</span><br><span class="line">    fmt.Println("bird: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义猪</span><br><span class="line">type pig struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为猪添加Walk()方法, 实现行走动物接口</span><br><span class="line">func (p *pig) Walk() {</span><br><span class="line">    fmt.Println("pig: walk")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建动物的名字到实例的映射</span><br><span class="line">    animals := map[string]interface{}{</span><br><span class="line">        "bird": new(bird),</span><br><span class="line">        "pig":  new(pig),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 遍历映射</span><br><span class="line">    for name, obj := range animals {</span><br><span class="line"></span><br><span class="line">        // 判断对象是否为飞行动物</span><br><span class="line">        f, isFlyer := obj.(Flyer)</span><br><span class="line">        // 判断对象是否为行走动物</span><br><span class="line">        w, isWalker := obj.(Walker)</span><br><span class="line"></span><br><span class="line">        fmt.Printf("name: %s isFlyer: %v isWalker: %v\n", name, isFlyer, isWalker)</span><br><span class="line">        // 如果是飞行动物则调用飞行动物接口</span><br><span class="line">        if isFlyer {</span><br><span class="line">            f.Fly()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 如果是行走动物则调用行走动物接口</span><br><span class="line">        if isWalker {</span><br><span class="line">            w.Walk()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6 行定义了飞行动物的接口。</li>
<li>第 11 行定义了行走动物的接口。</li>
<li>第 16 和 30 行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。</li>
<li>第 41 行是一个 map，映射对象名字和对象实例，实例是鸟和猪。</li>
<li>第 47 行开始遍历 map，obj 为 interface{} 接口类型。</li>
<li>第 50 行中，使用类型断言获得 f，类型为 Flyer 及 isFlyer 的断言成功的判定。</li>
<li>第 52 行中，使用类型断言获得 w，类型为 Walker 及 isWalker 的断言成功的判定。</li>
<li>第 57 和 62 行，根据飞行动物和行走动物两者是否断言成功，调用其接口。</li>
</ul>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name: pig isFlyer: false isWalker: true</span><br><span class="line">pig: walk</span><br><span class="line">name: bird isFlyer: true isWalker: true</span><br><span class="line">bird: fly</span><br><span class="line">bird: walk</span><br></pre></td></tr></tbody></table></figure>
<h3 id="将接口转换为其他类型"><a href="#将接口转换为其他类型" class="headerlink" title="将接口转换为其他类型"></a>将接口转换为其他类型</h3><p>在代码 1 中，可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 <code>*pig</code> 类型，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*pig)</span><br><span class="line"></span><br><span class="line">fmt.Printf("p1=%p p2=%p", p1, p2)</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明如下：</p>
<ul>
<li>第 3 行，由于 pig 实现了 Walker 接口，因此可以被隐式转换为 Walker 接口类型保存于 a 中。</li>
<li>第 4 行，由于 a 中保存的本来就是 <code>*pig</code> 本体，因此可以转换为 <code>*pig</code> 类型。</li>
<li>第 6 行，对比发现，p1 和 p2 指针是相同的。</li>
</ul>
<p>如果尝试将上面这段代码中的 Walker 类型的 a 转换为 <code>*bird</code> 类型，将会发出运行时错误，请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 := new(pig)</span><br><span class="line"></span><br><span class="line">var a Walker = p1</span><br><span class="line">p2 := a.(*bird)</span><br></pre></td></tr></tbody></table></figure>
<p>运行时报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: main.Walker is *main.pig, not *main.bird</span><br></pre></td></tr></tbody></table></figure>
<p>报错意思是：接口转换时，main.Walker 接口的内部保存的是 <code>*main.pig</code> ，而不是 <code>*main.bird</code> 。</p>
<p>因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p>
<p><strong>总结:</strong></p>
<p>接口和其他类型的转换可以在Go语言中自由进行，前提是已经完全实现。</p>
<p>接口断言类似于流程控制中的 if。但大量类型断言出现时，应使用更为高效的类型分支 switch 特性。</p>
<h2 id="空接口类型（interface-）"><a href="#空接口类型（interface-）" class="headerlink" title="空接口类型（interface{}）"></a>空接口类型（interface{}）</h2><p>空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。</p>
<p><strong>提示:</strong></p>
<p>空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。</p>
<p>空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。</p>
<h3 id="将值保存到空接口"><a href="#将值保存到空接口" class="headerlink" title="将值保存到空接口"></a>将值保存到空接口</h3><p>空接口的赋值如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var any interface{}</span><br><span class="line"></span><br><span class="line">any = 1</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = "hello"</span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = false</span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">hello</span><br><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>对代码的说明：</p>
<ul>
<li>第 1 行，声明 any 为 interface{} 类型的变量。</li>
<li>第 3 行，为 any 赋值一个整型 1。</li>
<li>第 4 行，打印 any 的值，提供给 fmt.Println 的类型依然是 interface{}。</li>
<li>第 6 行，为 any 赋值一个字符串 hello。此时 any 内部保存了一个字符串。但类型依然是 interface{}。</li>
<li>第 9 行，赋值布尔值。</li>
</ul>
<h3 id="从空接口获取值"><a href="#从空接口获取值" class="headerlink" title="从空接口获取值"></a>从空接口获取值</h3><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明a变量, 类型int, 初始值为1</span><br><span class="line">var a int = 1</span><br><span class="line"></span><br><span class="line">// 声明i变量, 类型为interface{}, 初始值为a, 此时i的值变为1</span><br><span class="line">var i interface{} = a</span><br><span class="line"></span><br><span class="line">// 声明b变量, 尝试赋值i</span><br><span class="line">var b int = i</span><br></pre></td></tr></tbody></table></figure>
<p>第8行代码编译报错：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use i (type interface {}) as type int in assignment: need type assertion</span><br></pre></td></tr></tbody></table></figure>
<p>编译器告诉我们，不能将i变量视为int类型赋值给b。</p>
<p>在代码第 5 行中，将 a 的值赋值给 i 时，虽然 i 在赋值完成后的内部值为 int，但 i 还是一个 interface{} 类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。</p>
<p>为了让第 8 行的操作能够完成，编译器提示我们得使用 <code>type assertion</code> ，意思就是类型断言。</p>
<p>使用类型断言修改第 8 行代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b int = i.(int)</span><br></pre></td></tr></tbody></table></figure>
<p>修改后，代码可以编译通过，并且 b 可以获得 i 变量保存的 a 变量的值：1。</p>
<h3 id="空接口的值比较"><a href="#空接口的值比较" class="headerlink" title="空接口的值比较"></a>空接口的值比较</h3><p>空接口在保存不同的值后，可以和其他变量值一样使用 <code>==</code> 进行比较操作。空接口的比较有以下几种特性。</p>
<p>1)类型不同的空接口间的比较结果不相同</p>
<p>保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a保存整型</span><br><span class="line">var a interface{} = 100</span><br><span class="line"></span><br><span class="line">// b保存字符串</span><br><span class="line">var b interface{} = "hi"</span><br><span class="line"></span><br><span class="line">// 两个空接口不相等</span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></tbody></table></figure>
<p>2)不能比较空接口中的动态值</p>
<p>当接口中保存有动态类型的值时，运行时将触发错误，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c保存包含10的整型切片</span><br><span class="line">var c interface{} = []int{10}</span><br><span class="line"></span><br><span class="line">// d保存包含20的整型切片</span><br><span class="line">var d interface{} = []int{20}</span><br><span class="line"></span><br><span class="line">// 这里会发生崩溃</span><br><span class="line">fmt.Println(c == d)</span><br></pre></td></tr></tbody></table></figure>
<p>代码运行到第8行时发生崩溃：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: comparing uncomparable type []int</span><br></pre></td></tr></tbody></table></figure>
<p>这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。</p>
<table>
    <thead><tr><th>类  型</th><th>说  明</th></tr></thead>
    <tbody>
        <tr><th>map</th><th>宕机错误，不可比较</th></tr>
        <tr><th>切片（[]T）</th><th>宕机错误，不可比较</th></tr>
        <tr><th>通道（channel）</th><th>可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false</th></tr>
        <tr><th>数组（[容量]T）</th><th>可比较，编译期知道两个数组是否一致</th></tr>
        <tr><th>结构体</th><th>可比较，可以逐个比较结构体的值</th></tr>
         <tr><th>函数</th><th>可比较</th></tr>
    </tbody>
</table>

<h2 id="使用空接口实现可以保存任意值的字典"><a href="#使用空接口实现可以保存任意值的字典" class="headerlink" title="使用空接口实现可以保存任意值的字典"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/85.html">使用空接口实现可以保存任意值的字典</a></h2><p>空接口可以保存任何类型这个特性可以方便地用于容器的设计。下面例子使用 map 和 interface{} 实现了一个字典。字典在其他语言中的功能和 map 类似，可以将任意类型的值做成键值对保存，然后进行找回、遍历操作。详细实现过程请参考下面的代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{} // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line"></span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 遍历所有的键值，如果回调返回值为false，停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型，并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出很贵</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出很便宜</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="值设置和获取"><a href="#值设置和获取" class="headerlink" title="值设置和获取"></a>值设置和获取</h3><p>字典内部拥有一个 data 字段，其类型为 map。这个 map 的键和值都是 interface{} 类型，也就是实现任意类型关联任意类型。字典的值设置和获取通过 Set() 和 Get() 两个方法来完成，参数都是 interface{}。详细实现代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 字典结构</span><br><span class="line">type Dictionary struct {</span><br><span class="line">    data map[interface{}]interface{}  // 键值都为interface{}类型</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 根据键获取值</span><br><span class="line">func (d *Dictionary) Get(key interface{}) interface{} {</span><br><span class="line">    return d.data[key]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 设置键值</span><br><span class="line">func (d *Dictionary) Set(key interface{}, value interface{}) {</span><br><span class="line">    d.data[key] = value</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，Dictionary 的内部实现是一个键值均为 interface{} 类型的 map，map 也具备与 Dictionary 一致的功能。</li>
<li>第 8 行，通过 map 直接获取值，如果键不存在，将返回 nil。</li>
<li>第 13 行，通过 map 设置键值。</li>
</ul>
<h3 id="遍历字段的所有键值关联数据"><a href="#遍历字段的所有键值关联数据" class="headerlink" title="遍历字段的所有键值关联数据"></a>遍历字段的所有键值关联数据</h3><p>每个容器都有遍历操作。遍历时，需要提供一个回调返回需要遍历的数据。为了方便在必要时终止遍历操作，可以将回调的返回值设置为 bool 类型，外部逻辑在回调中不需要遍历时直接返回 false 即可终止遍历。</p>
<p>Dictionary 的 Visit() 方法需要传入回调函数，回调函数的类型为 <code>func(k,v interface{}) bool</code>。每次遍历时获得的键值关联数据通过回调函数的 k 和 v 参数返回。Visit 的详细实现请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 遍历所有的键值, 如果回调返回值为false, 停止遍历</span><br><span class="line">func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {</span><br><span class="line"></span><br><span class="line">    if callback == nil {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for k, v := range d.data {</span><br><span class="line">        if !callback(k, v) {</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 2 行，定义回调，类型为 <code>func(k,v interface{}) bool</code>，意思是返回键值数据（k、v）。bool 表示遍历流程控制，返回 true 时继续遍历，返回 false 时终止遍历。</li>
<li>第 4 行，当 callback 为空时，退出遍历，避免后续代码访问空的 callback 而导致的崩溃。</li>
<li>第 8 行，遍历字典结构的 data 成员，也就是遍历 map 的所有元素。</li>
<li>第 9 行，根据 callback 的返回值，决定是否继续遍历。</li>
</ul>
<h3 id="初始化和清除"><a href="#初始化和清除" class="headerlink" title="初始化和清除"></a>初始化和清除</h3><p>字典结构包含有 map，需要在创建 Dictionary 实例时初始化 map。这个过程通过 Dictionary 的 Clear() 方法完成。在 NewDictionary 中调用 Clear() 方法避免了 map 初始化过程的代码重复问题。请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 清空所有的数据</span><br><span class="line">func (d *Dictionary) Clear() {</span><br><span class="line">    d.data = make(map[interface{}]interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 创建一个字典</span><br><span class="line">func NewDictionary() *Dictionary {</span><br><span class="line">    d := &amp;Dictionary{}</span><br><span class="line"></span><br><span class="line">    // 初始化map</span><br><span class="line">    d.Clear()</span><br><span class="line">    return d</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 3 行，map 没有独立的复位内部元素的操作，需要复位元素时，使用 make 创建新的实例。Go语言的垃圾回收是并行的，不用担心 map 清除的效率问题。</li>
<li>第 7 行，实例化一个 Dictionary。</li>
<li>第 11 行，在初始化时调用 Clear 进行 map 初始化操作。</li>
</ul>
<h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>字典实现完成后，需要经过一个测试过程，查看这个字典是否存在问题。</p>
<p>将一些字符串和数值组合放入到字典中，然后再从字典中根据键查询出对应的值，接着再遍历一个字典中所有的元素。详细实现过程请参考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 创建字典实例</span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    // 添加游戏数据</span><br><span class="line">    dict.Set("My Factory", 60)</span><br><span class="line">    dict.Set("Terra Craft", 36)</span><br><span class="line">    dict.Set("Don't Hungry", 24)</span><br><span class="line"></span><br><span class="line">    // 获取值及打印值</span><br><span class="line">    favorite := dict.Get("Terra Craft")</span><br><span class="line">    fmt.Println("favorite:", favorite)</span><br><span class="line"></span><br><span class="line">    // 遍历所有的字典元素</span><br><span class="line">    dict.Visit(func(key, value interface{}) bool {</span><br><span class="line"></span><br><span class="line">        // 将值转为int类型, 并判断是否大于40</span><br><span class="line">        if value.(int) &gt; 40 {</span><br><span class="line"></span><br><span class="line">            // 输出“很贵”</span><br><span class="line">            fmt.Println(key, "is expensive")</span><br><span class="line">            return true</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 默认都是输出“很便宜”</span><br><span class="line">        fmt.Println(key, "is cheap")</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 4 行创建字典的实例。</li>
<li>第 7～9 行，将 3 组键值对通过字典的 Set() 方法设置到字典中。</li>
<li>第 12 行，根据字符串键查找值，将结果保存在 favorite 中。</li>
<li>第 13 行，打印 favorite 的值。</li>
<li>第 16 行，遍历字典的所有键值对。遍历的返回数据通过回调提供，key 是键，value 是值。</li>
<li>第 19 行，遍历返回的 key 和 value 的类型都是 interface{}，这里确认 value 只有 int 类型，所以将 value 转换为 int 类型判断是否大于 40。</li>
<li>第 23 和 29 行，继续遍历，返回 true</li>
<li>第 23 行，打印键。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite: 36</span><br><span class="line">My Factory is expensive</span><br><span class="line">Terra Craft is cheap</span><br><span class="line">Don't Hungry is cheap</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类型分支（switch判断空接口中变量的类型）"><a href="#类型分支（switch判断空接口中变量的类型）" class="headerlink" title="类型分支（switch判断空接口中变量的类型）"></a>类型分支（switch判断空接口中变量的类型）</h2><p>type-switch 流程控制的语法或许是Go语言中最古怪的语法。 它可以被看作是类型断言的增强版。它和 switch-case 流程控制代码块有些相似。 一个 type-switch 流程控制代码块的语法如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch t := areaIntf.(type) {</span><br><span class="line">case *Square:</span><br><span class="line">    fmt.Printf("Type Square %T with value %v\n", t, t)</span><br><span class="line">case *Circle:</span><br><span class="line">    fmt.Printf("Type Circle %T with value %v\n", t, t)</span><br><span class="line">case nil:</span><br><span class="line">    fmt.Printf("nil value: nothing to check?\n")</span><br><span class="line">default:</span><br><span class="line">    fmt.Printf("Unexpected type %T\n", t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type Square *main.Square with value &amp;{5}</span><br></pre></td></tr></tbody></table></figure>
<p>变量 t 得到了 areaIntf 的值和类型， 所有 case 语句中列举的类型（nil 除外）都必须实现对应的接口，如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。</p>
<p>如果跟随在某个 case 关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值 x 的（接口）类型。</p>
<h3 id="类型断言的书写格式"><a href="#类型断言的书写格式" class="headerlink" title="类型断言的书写格式"></a>类型断言的书写格式</h3><p>switch 实现类型分支时的写法格式如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch 接口变量.(type) {</span><br><span class="line">    case 类型1:</span><br><span class="line">        // 变量是类型1时的处理</span><br><span class="line">    case 类型2:</span><br><span class="line">        // 变量是类型2时的处理</span><br><span class="line">    …</span><br><span class="line">    default:</span><br><span class="line">        // 变量不是所有case中列举的类型时的处理</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li>接口变量：表示需要判断的接口类型的变量。</li>
<li>类型1、类型2……：表示接口变量可能具有的类型列表，满足时，会指定 case 对应的分支进行处理。</li>
</ul>
<h3 id="使用类型分支判断基本类型"><a href="#使用类型分支判断基本类型" class="headerlink" title="使用类型分支判断基本类型"></a>使用类型分支判断基本类型</h3><p>下面的例子将一个 interface{} 类型的参数传给 printType() 函数，通过 switch 判断 v 的类型，然后：打印对应类型的提示，代码如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printType(v interface{}) {</span><br><span class="line"></span><br><span class="line">    switch v.(type) {</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(v, "is int")</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(v, "is string")</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Println(v, "is bool")</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    printType(1024)</span><br><span class="line">    printType("pig")</span><br><span class="line">    printType(true)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1024 is int</span><br><span class="line">pig is string</span><br><span class="line">true is bool</span><br></pre></td></tr></tbody></table></figure>
<p>代码第 9 行中，<code>v.(type)</code> 就是类型分支的典型写法。通过这个写法，在 switch 的每个 case 中写的将是各种类型分支。</p>
<p>代码经过 switch 时，会判断 v 这个 interface{} 的具体类型从而进行类型分支跳转。</p>
<p>switch 的 default 也是可以使用的，功能和其他的 switch 一致。</p>
<h3 id="使用类型分支判断接口类型"><a href="#使用类型分支判断接口类型" class="headerlink" title="使用类型分支判断接口类型"></a>使用类型分支判断接口类型</h3><p>多个接口进行类型断言时，可以使用类型分支简化判断过程。</p>
<p>现在电子支付逐渐成为人们普遍使用的支付方式，电子支付相比现金支付具备很多优点。例如，电子支付能够刷脸支付，而现金支付容易被偷等。使用类型分支可以方便地判断一种支付方法具备哪些特性，具体请参考下面的代码。</p>
<p>电子支付和现金支付：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "fmt"</span><br><span class="line"></span><br><span class="line">// 电子支付方式</span><br><span class="line">type Alipay struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Alipay添加CanUseFaceID()方法, 表示电子支付方式支持刷脸</span><br><span class="line">func (a *Alipay) CanUseFaceID() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 现金支付方式</span><br><span class="line">type Cash struct {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 为Cash添加Stolen()方法, 表示现金支付方式会出现偷窃情况</span><br><span class="line">func (a *Cash) Stolen() {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备刷脸特性的接口</span><br><span class="line">type CantainCanUseFaceID interface {</span><br><span class="line">    CanUseFaceID()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 具备被偷特性的接口</span><br><span class="line">type ContainStolen interface {</span><br><span class="line">    Stolen()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印支付方式具备的特点</span><br><span class="line">func print(payMethod interface{}) {</span><br><span class="line">    switch payMethod.(type) {</span><br><span class="line">    case CantainCanUseFaceID:  // 可以刷脸</span><br><span class="line">        fmt.Printf("%T can use faceid\n", payMethod)</span><br><span class="line">    case ContainStolen:  // 可能被偷</span><br><span class="line">        fmt.Printf("%T may be stolen\n", payMethod)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line"></span><br><span class="line">    // 使用电子支付判断</span><br><span class="line">    print(new(Alipay))</span><br><span class="line"></span><br><span class="line">    // 使用现金判断</span><br><span class="line">    print(new(Cash))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第 6～19 行，分别定义 Alipay 和 Cash 结构，并为它们添加具备各自特点的方法。</li>
<li>第 22～29 行，定义两种特性，即刷脸和被偷。</li>
<li>第 32 行，传入支付方式的接口。</li>
<li>第 33 行，使用类型分支进行支付方法的特性判断。</li>
<li>第 34～37 行，分别对刷脸和被偷的特性进行打印。</li>
</ul>
<p>运行代码，输出如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*main.Alipay can use faceid</span><br><span class="line">*main.Cash may be stolen</span><br></pre></td></tr></tbody></table></figure>
<h2 id="error接口：返回错误信息"><a href="#error接口：返回错误信息" class="headerlink" title="error接口：返回错误信息"></a>error接口：返回错误信息</h2><p>错误处理在每个编程语言中都是一项重要内容，通常开发中遇到的分为异常与错误两种，Go语言中也不例外。本节我们主要来学习一下Go语言中的错误处理。</p>
<p>在C语言中通过返回 -1 或者 NULL 之类的信息来表示错误，但是对于使用者来说，如果不查看相应的 API 说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如返回 0 是成功还是失败？</p>
<p>针对这样的情况，Go语言中引入 error 接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含 error。error 处理过程类似于C语言中的错误码，可逐层返回，直到被处理。</p>
<h3 id="error-基本用法"><a href="#error-基本用法" class="headerlink" title="error 基本用法"></a>error 基本用法</h3><p>Go语言中返回的 error 类型究竟是什么呢？查看Go语言的源码就会发现 error 类型是一个非常简单的接口类型，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The error built-in interface type is the conventional interface for</span><br><span class="line">// representing an error condition, with the nil value representing no error.</span><br><span class="line">type error interface {</span><br><span class="line">    Error() string</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>error 接口有一个签名为 Error() string 的方法，所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述，在使用 fmt.Println 打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。</p>
<p>一般情况下，如果函数需要返回错误，就将 error 作为多个返回值中的最后一个（但这并非是强制要求）。</p>
<p>创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error，示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "errors"</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, errors.New("math: square root of negative number")</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">math: square root of negative number</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中简单介绍了使用 errors.New 来返回一个错误信息，与其他语言的异常相比，Go语言的方法相对更加容易、直观。</p>
<h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>除了上面的 errors.New 用法之外，我们还可以使用 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "math"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type dualError struct {</span><br><span class="line">    Num     float64</span><br><span class="line">    problem string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (e dualError) Error() string {</span><br><span class="line">    return fmt.Sprintf("Wrong!!!,because \"%f\" is a negative number", e.Num)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func Sqrt(f float64) (float64, error) {</span><br><span class="line">    if f &lt; 0 {</span><br><span class="line">        return -1, dualError{Num: f}</span><br><span class="line">    }</span><br><span class="line">    return math.Sqrt(f), nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    result, err := Sqrt(-13)</span><br><span class="line">    if err != nil {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    } else {</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wrong!!!,because "-13.000000" is a negative number</span><br></pre></td></tr></tbody></table></figure>
<h2 id="接口内部实现"><a href="#接口内部实现" class="headerlink" title="接口内部实现"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5116.html">接口内部实现</a></h2><p>前几节我们介绍了接口的基本概念和用法，定义接口只需简单声明一个方法集合即可，定义新类型时不需要显式地声明要实现的接口，接口的使用也很简单。</p>
<p>那么接口的底层是如何实现的呢？如何实现动态调用的呢？接口的动态调用到底有多大的额外开销？本节我们就来深入讲解一下接口的底层实现。</p>
<p>阅读本节需要读者了解Go语言接口的基础知识和Go语言汇编基础和函数调用规约，以及对 ELF 可执行文件格式有基本了解。本节内容有点偏底层，有一定的难度，如果阅读起来有困难，可以先跳过去，有时间再慢慢读。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a></h3><p>从前面章节了解到，接口变量必须初始化才有意义，没有初始化的接口变量的默认值是 nil，没有任何意义。具体类型实例传递给接口称为接口的实例化。在接口的实例化的过程中，编译器通过特定的数据结构描述这个过程。</p>
<p>首先介绍非空接口的内部数据结构，空接口的底层更简单，放到最后介绍。非空接口的底层数据结构是 iface，代码位于Go语言安装目录的 <code>src/runtime/runtime2.go</code> 文件中。</p>
<h4 id="iface-数据结构"><a href="#iface-数据结构" class="headerlink" title="iface 数据结构"></a>iface 数据结构</h4><p>非空接口初始化的过程就是初始化一个 iface 类型的结构，示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type iface struct {</span><br><span class="line">    tab *itab                //itab 存放类型及方法指针信息</span><br><span class="line">    data unsafe.Pointer      //数据信息</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到 iface 结构很简单，有两个指针类型字段。</p>
<ul>
<li>itab：用来存放接口自身类型和绑定的实例类型及实例相关的函数指针，具体内容后面有详细介绍。</li>
<li>数据指针 data：指向接口绑定的实例的副本，接口的初始化也是一种值拷贝。</li>
</ul>
<p>data 指向具体的实例数据，如果传递给接口的是值类型，则 data 指向的是实例的副本；如果传递给接口的是指针类型，则 data 指向指针的副本。总而言之，无论接口的转换，还是函数调用，Go 遵循一样的规则——值传递。</p>
<p>接下来看一下 itab 数据结构，itab 是接口内部实现的核心和基础。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/runtime2.go</span><br><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype      //接口自身的静态类型</span><br><span class="line">    _type *_type              //_type 就是接口存放的具体实例的类型（动态类型）</span><br><span class="line">    //hash 存放具体类型的 Hash 值</span><br><span class="line">    hash uint32               // copy of _type.hash. Used for type switches.</span><br><span class="line">    _   [4]byte</span><br><span class="line">    fun [1]uintptr            // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>itab 有 5 个字段：</p>
<ul>
<li>inter：是指向接口类型元信息的指针。</li>
<li>_type：是指向接口存放的具体类型元信息的指针，iface 里的 data 指针指向的是该类型的值。一个是类型信息，另一个是类型的值。</li>
<li>hash：是具体类型的 Hash 值，_type 里面也有 hash，这里冗余存放主要是为了接口断言或类型查询时快速访问。</li>
<li>fun：是一个函数指针，可以理解为 C++ 对象模型里面的虚拟函数指针，这里虽然只有一个元素，实际上指针数组的大小是可变的，编译器负责填充，运行时使用底层指针进行访问，不会受 struct 类型越界检查的约束，这些指针指向的是具体类型的方法。</li>
</ul>
<p>itab 这个数据结构是非空接口实现动态调用的基础，itab 的信息被编译器和链接器保存了下来，存放在可执行文件的只读存储段（ <code>.rodata</code> ）中。itab 存放在静态分配的存储空间中，不受 GC 的限制，其内存不会被回收。</p>
<p>接下来介绍 <code>_type</code> 数据结构，Go语言是一种强类型的语言，编译器在编译时会做严格的类型校验。所以 Go 必然为每种类型维护一个类型的元信息，这个元信息在运行和反射时都会用到，Go语言的类型元信息的通用结构是 <code>_type</code>（代码位于 <code>src/runtime/type.go</code>）， 其他类型都是以 <code>_type</code> 为内嵌宇段封装而成的结构体。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">type type struct {</span><br><span class="line">    size uintptr     // 大小</span><br><span class="line">    ptrdata uintptr  //size of memory prefix holding all pointers</span><br><span class="line">    hash uint32      //类型Hash</span><br><span class="line">    tflag tflag      //类型的特征标记</span><br><span class="line">    align uint8      //_type 作为整体交量存放时的对齐字节数</span><br><span class="line">    fieldalign uint8 //当前结构字段的对齐字节数</span><br><span class="line">    kind uint8       //基础类型枚举值和反射中的 Kind 一致，kind 决定了如何解析该类型</span><br><span class="line">    alg *typeAlg     //指向一个函数指针表，该表有两个函数，一个是计算类型 Hash 函</span><br><span class="line">                     //数，另一个是比较两个类型是否相同的 equal 函数</span><br><span class="line">    //gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    //If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    //Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata *byte      //GC 相关信息</span><br><span class="line">    str nameOff       //str 用来表示类型名称字符串在编译后二进制文件中某个 section</span><br><span class="line">                      //的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">    ptrToThis typeOff //ptrToThis 用来表示类型元信息的指针在编译后二进制文件中某个</span><br><span class="line">                      //section 的偏移量</span><br><span class="line">                      //由链接器负责填充</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>_type</code> 包含所有类型的共同元信息，编译器和运行时可以根据该元信息解析具体类型、类型名存放位置、类型的 Hash 值等基本信息。</p>
<p>这里需要说明一下：<code>＿type</code> 里面的 nameOff 和 typeOff 最终是由链接器负责确定和填充的，它们都是一个偏移量（offset），类型的名称和类型元信息实际上存放在连接后可执行文件的某个段（section）里，这两个值是相对于段内的偏移量，运行时提供两个转换查找函数。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//src/runtime/type.go</span><br><span class="line">//获取 _type 的 name</span><br><span class="line">func resolveNameOff(ptrInModule unsafe.Pointer , off nameOff) name {}</span><br><span class="line">//获取 _type 的副本</span><br><span class="line">func resolveTypeOff(ptrInModule unsafe.Pointer , off typeOff) *_type {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：Go语言类型元信息最初由编译器负责构建，并以表的形式存放在编译后的对象文件中，再由链接器在链接时进行段合并、符号重定向（填充某些值）。这些类型信息在接口的动态调用和反射中被运行时引用。</em></strong></p>
<p>接下来看一下接口的类型元信息的数据结构。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//描述接口的类型</span><br><span class="line">type interfacetype struct {</span><br><span class="line">    typ _type       //类型通用部分</span><br><span class="line">    pkgpath name    //接口所属包的名字信息， name 内存放的不仅有名称，还有描述信息</span><br><span class="line">    mhdr []imethod  //接口的方法</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//接口方法元信息</span><br><span class="line">type imethod struct {</span><br><span class="line">    name nameOff //方法名在编译后的 section 里面的偏移量</span><br><span class="line">    ityp typeOff //方法类型在编译后的 section 里面的偏移量</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口调用过程分析"><a href="#接口调用过程分析" class="headerlink" title="接口调用过程分析"></a>接口调用过程分析</h3><p>前面讨论了接口内部的基本数据结构，下面就来通过跟踪接口实例化和动态调用过程，使用 Go 源码和反汇编代码相结合的方式进行研究。下面是一段非常简单的接口调用代码。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//iface.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Caler interface {</span><br><span class="line">    Add (a , b int) int</span><br><span class="line">    Sub (a , b int) int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Adder struct ｛id int }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int) int { return a + b }</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a , b int) int { return a - b }</span><br><span class="line"></span><br><span class="line">func main () {</span><br><span class="line">    var m Caler=Adder{id: 1234}</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>生成汇编代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags= "-S - N -l" iface.go &gt;iface.s 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>接下来分析 main 函数的汇编代码，非关键逻辑已经去掉：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"".main STEXT size=151 args=0x0 locals=0x40</span><br><span class="line">    ...</span><br><span class="line">    0x000f 00015 (src/iface.go:16) SUBQ $64, SP</span><br><span class="line">    0x0013 00019 (src/iface.go:16) MOVQ BP, 56(SP)</span><br><span class="line">    0x0018 00024 (src/iface.go:16) LEAQ 56(SP), BP</span><br></pre></td></tr></tbody></table></figure>
<p>为 main 函数堆栈开辟空间并保存原来的 BP 指针，这是函数调用前编译器的固定动作。</p>
<p>var m Caler = Adder {id: 1234} 语句汇编代码分析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00ld 00029 (src/iface.go:17) MOVQ    $0, ""..autotmp_1+32(SP)</span><br><span class="line">0x0026 00038 (src/iface.go:17) MOVQ    $1234, ""..autotmp_1+32(SP)</span><br></pre></td></tr></tbody></table></figure>
<p>在堆上初始化局部对象 Adder，先初始化为 0，后初始化为 1234。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x002f 00047 (src/iface.go:17) LEAQ    go.itab."".Adder,"".Caler(SB),AX</span><br><span class="line">0x0036 00054 (src/iface.go:17) MOVQ    AX, (SP)</span><br></pre></td></tr></tbody></table></figure>
<p>这两条语句非常关键，首先 LEAQ 指令是一个获取地址的指令，<code>go.itab."".Adder,"".Caler(SB)</code> 是一个全局符号引用，通过该符号能够获取接口初始化时 itab 数据结构的地址。</p>
<p>注意：这个标号在链接器链接的过程中会替换为具体的地址。我们知道 (SP) 里面存放的是指向 <code>itab(Caler,Adder)</code> 的元信息的地址，这里 (SP) 是函数调用第一个参数的位置。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x003a 00058 (src/iface.go:17) LEAQ ""..autotmp_1+32(SP), AX</span><br><span class="line">0x003f 00063 (src/iface.go:17) MOVQ AX, 8(SP)</span><br><span class="line">0x0044 00068 (src/iface.go:17) PCDATA $0, $0</span><br></pre></td></tr></tbody></table></figure>
<p>复制刚才的 Adder 类型对象的地址到 8(SP)，8(SP) 是函数调用的第二个参数位置。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0044 00068 (src/iface.go:17) CALL    runtime.convT2I64(SB)</span><br></pre></td></tr></tbody></table></figure>
<p>runtime.convT2I64 函数是运行时接口动态调用的核心函数。runtime 中有一类这样的函数，看一下 runtime.convT2I64 的源码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {</span><br><span class="line">    t := tab._type</span><br><span class="line">    if raceenabled {</span><br><span class="line">        raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&amp;tab)), funcPC(convT2I64))</span><br><span class="line">    }</span><br><span class="line">    if msanenabled {</span><br><span class="line">        msanread (elem, t.size)</span><br><span class="line">    }</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(uint64) (elem) == 0 {</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    } else {</span><br><span class="line">        x = mallocgc(8, t, false)</span><br><span class="line">        *(*uint64) (x) = *(*uint64) (elem)</span><br><span class="line">    }</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上述源码可以清楚地看出，<code>runtime.convT2I64</code> 的两个参数分别是 <code>*itab</code> 和 <code>unsafe.Pointer</code> 类型，这两个参数正是上文传递进去的两个参数值：<code>go.itab."".Adder, "".Caler(SB)</code> 和指向 Adder 对象复制的指针。</p>
<p><code>runtime.convT2I64</code> 的返回值是一个 iface 数据结构，其意义就是根据 itab 元信息和对象值复制的指针构建和初始化 iface 数据结构，iface 数据结构是实现接口动态调用的关键。至此己经完成了接口初始化的工作，即完成了 iface 数据结构的构建过程。下一步就是接口方法调用了。示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0049 00073 (src/iface.go:17) MOVQ 24(SP), AX</span><br><span class="line">0x004e 00078 (src/iface.go:17) MOVQ 16(SP), CX</span><br><span class="line">0x0053 00083 (src/iface.go:17 ) MOVQ CX, "".m+40(SP)</span><br><span class="line">0x0058 00088 (src/iface.go:17 ) MOVQ AX, "".m+48(SP)</span><br></pre></td></tr></tbody></table></figure>
<p>16(SP) 和 24(SP) 存放的是函数 runtime.convT2I64 的返回值，分别是指向 itab 和 data 的指针，将指向 itab 的指针复制到 40(SP)，将指向对象 data 的指针复制到 48(SP) 位置。</p>
<p>m.Add(10, 32) 对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00Sd 00093 (src/iface.go:18) MOVQ "".m+40(SP), AX</span><br><span class="line">0x0062 00098 (src/iface.go:18) MOVQ 32(AX), AX</span><br><span class="line">0x0066 00102 (src/iface.go:18) MOVQ "".m+48(SP), ex</span><br><span class="line">0x006b 00107 (src/iface.go:18) MOVQ $10, 8(SP)</span><br><span class="line">0x0074 00116 (src/iface.go:18) MOVQ $32, 16(SP)</span><br><span class="line">0x007d 00125 (src/iface.go:18) MOVQ CX, (SP)</span><br><span class="line">0x0081 00129 (src/iface.go:18) PCDATA $0, $0</span><br><span class="line">0x0081 00129 (src/iface.go:18) CALL AX</span><br></pre></td></tr></tbody></table></figure>
<p>第 1 条指令是将 itab 的指针（位于 40(SP)）复制到 AX 寄存器。第 2 条指令是 AX 将 itab 的偏移 32 字节的值复制到 AX。再来看一下 itab 的数据结构：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type itab struct {</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *type</span><br><span class="line">    link *itab</span><br><span class="line">    hash uint32 //copy of _type.hash.Used for type switches.</span><br><span class="line">    bad bool    //type does not implement interface</span><br><span class="line">    inhash bool //has this itab been added to hash?</span><br><span class="line">    unused [2]byte</span><br><span class="line">    fun [1] uintptr //variable sized</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>32(AX) 正好是函数指针的位置， 即存放 <code>Adder *Add()</code> 方法指针的地址（注意：编译器将接收者为值类型的 Add 方法转换为指针的 Add 方法，编译器的这种行为是为了方便调用和优化）。</p>
<p>第 3 条指令和第 6 条指令是将对象指针作为接下来函数调用的第 1 个参数。</p>
<p>第 4 条和第 5 条指令是准备函数的第 2、第 3 个参数。</p>
<p>第 8 条指令是调用 Adder 类型的 Add 方法。</p>
<p>此函数调用时，对象的值的副本作为第 1 个参数，调用格式可以表述为 <code>func(reciver, param1, param2)</code>。</p>
<p>至此，整个接口的动态调用完成。从中可以清楚地看到，接口的动态调用分为两个阶段：</p>
<ul>
<li>第一阶段就是构建 iface 动态数据结构，这一阶段是在接口实例化的时候完成的，映射到 Go 语句就是 <code>var m Caler = Adder{id: 1234}</code>。</li>
<li>第二阶段就是通过函数指针间接调用接口绑定的实例方法的过程，映射到 Go 语句就是 <code>m.Add(10, 32)</code> 。</li>
</ul>
<p>接下来看一下 <code>go.itab. "".Adder, "".Caler(SB)</code> 这个符号在哪里？我们使用 readelf 工具来静态地分析编译后的 ELF 格式的可执行程序。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#编译</span><br><span class="line">#go build -gcflag s= "-N -l" iface.go</span><br><span class="line">#readelf -s -W iface legrep 'itab'</span><br><span class="line">    60:000000000047b220 0 OBJECT LOCAL DEFAULT 5 runtime.itablink</span><br><span class="line">    61:000000000047b230 0 OBJECT LOCAL DEFAULT 5 runtime.eitablink</span><br><span class="line">    88:00000000004aa100 48 OBJECT GLOBAL DEFAULT 8 go.itab.main.Adder, main.Caler</span><br><span class="line">    214:00000000004aa080 40 OBJECT GLOBAL DEFAULT 8 go.itab.runtime.errorString, error</span><br><span class="line">    418:00000000004095e0 1129 FUNC GLOBAL DEFAULT 1 runtime.getitab</span><br><span class="line">    419:0000000000409a50 1665 FUNC GLOBAL DEFAULT 1 runtime.additab</span><br><span class="line">    420:000000000040a0e0 257 FUNC GLOBAL DEFAULT 1 runtime.itabsinit</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到符号表里面 <code>go.itab.main.Adder, main.Caler</code> 对应本程序里面 itab 的元信息，它被存放在第 8 个段中。我们来看一下第 8 个段是什么段？</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#readelf -S -W iface |egrep '＼[8\] | I Nr'</span><br><span class="line">[Nr] Name Type Address Off Size ES Flg Lk Inf Al</span><br><span class="line">[8]. noptrdata PROGBITS 00000000004aa000 OaaOOO 000a78 00 WA 0 0 32</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到这个接口动态转换的数据元信息存放在 .noptrdata 段中，它是由链接器负责初始化的。可以进一步使用 dd 工具读取井分析其内容，这里就不再继续深入这个细节，留给感兴趣的读者继续分析。</p>
<h3 id="接口调用代价"><a href="#接口调用代价" class="headerlink" title="接口调用代价"></a>接口调用代价</h3><p>前面讨论了接口动态调用过程，这个过程有两部分多余时耗，一个是接口实例化的过程，也就是 iface 结构建立的过程，一旦实例化后，这个接口和具体类型的 itab 数据结构是可以复用的；另一个是接口的方法调用，它是一个函数指针的间接调用。</p>
<p>同时我们应考虑到接口调用是一种动态的计算后的跳转调用，这对现代的计算机 CPU 的执行很不友好，会导致 CPU 缓存失效和分支预测失败，这也有一部分的性能损失。当然最直接的办法就是对比测试，看看接口动态调用的性能损失到底有多大。</p>
<p><strong>测试用例：</strong></p>
<p>直接选用 GitHub 上的一个测试用例，稍作改写，代码如下。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    "testing"</span><br><span class="line">)</span><br><span class="line">type identifier interface {</span><br><span class="line">    idInline() int32</span><br><span class="line">    idNoInline() int32</span><br><span class="line">}</span><br><span class="line">type id32 struct{ id int32 }</span><br><span class="line">func (id *id32) idinline() int32 { return id.id }</span><br><span class="line">//go:noinline</span><br><span class="line">func (id *id32) idNoinline() int32 { return id.id }</span><br><span class="line">var escapeMePlease *id32</span><br><span class="line">//主要作用是强制变量内存在 heap 上分配</span><br><span class="line">//go:noinline</span><br><span class="line">func escapeToHeap(id *id32) identifier {</span><br><span class="line">    escapeMePlease = id</span><br><span class="line">    return escapeMePlease</span><br><span class="line">}</span><br><span class="line">//直接调用</span><br><span class="line">func BenchmarkMethodCall_direct(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer ()</span><br><span class="line">        for i :＝ 0; i ＜ b.N; i++ {</span><br><span class="line">            //CALL "".(*id32).idNoinline(SB)</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "".&amp;myID+40(SP), CX</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    b.Run ("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754}).(*id32)</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i: ＝ 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVL (DX), SI</span><br><span class="line">            //MOVL SI, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line">//接口调用</span><br><span class="line">func BenchmarkMethodCall_interface(b *testing.B) { //</span><br><span class="line">    var myID int32</span><br><span class="line">    b.Run("single/noinline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(＆id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N ; i++ {</span><br><span class="line">            // MOVQ 32(AX), CX</span><br><span class="line">            // MOVQ "".m.data+40(SP), DX</span><br><span class="line">            // MOVQ DX, (SP)</span><br><span class="line">            // CALL CX</span><br><span class="line">            // MOVL 8(SP), AX</span><br><span class="line">            // MOVQ "".&amp;myID+48(SP), CX</span><br><span class="line">            // MOVL AX, (CX)</span><br><span class="line">            myID = m.idNoInline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    b.Run("single/inline", func(b *testing.B) {</span><br><span class="line">        m := escapeToHeap(&amp;id32{id: 6754})</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        for i := 0; i &lt; b.N; i++ {</span><br><span class="line">            //MOVQ 24(AX), CX</span><br><span class="line">            //MOVQ "".m.data+40(SP), DX</span><br><span class="line">            //MOVQ DX, (SP)</span><br><span class="line">            //CALL CX</span><br><span class="line">            //MOVL 8(SP), AX</span><br><span class="line">            //MOVQ "". &amp;myID+48(SP), ex</span><br><span class="line">            //MOVL AX, (CX)</span><br><span class="line">            myID = m.idinline()</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">} //</span><br><span class="line">func main() {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>测试过程和结果：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//直接调用</span><br><span class="line">#go test -bench= 'BenchmarkMethodCall_direct/single/noinline' -cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 2.00 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.94 ns/op</span><br><span class="line">BenchmarkMethodCall_direct/single/noinline 2000000000 1.97 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 20.682s</span><br><span class="line">//接口调用</span><br><span class="line">#go test -bench='BenchmarkMethodCall_interface/single/noinline' －cpu=1 -count=5 iface_bench_test.go</span><br><span class="line">goos:linux</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.18 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.17 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.15 ns/op</span><br><span class="line">BenchmarkMethodCall_interface/single/noinline 1000000000 2.16 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok command-line-arguments 11.930s</span><br></pre></td></tr></tbody></table></figure>
<p><strong>结果分析：</strong></p>
<p>直接调用平均时耗为 1.97ns/op，接口调用的平均时耗为 2.16ns/op, (2.16-1.97)/1.97 约等于 9.64%。可以看到测试结果符合预期，每次迭代接口要慢 0.19ns，大约有 9% 的性能损失。</p>
<p>但是要清楚这个百分比并不能真实地反映接口的效率问题，首先调用的方法是一个很简单的方法，方法的耗时占比很小，无形中放大了接口调用的耗时。如果方法里面有复杂的逻辑，则真实的性能损失远远小于9%。</p>
<p>从绝对值的角度来看更合理，那就是每次接口调用大约比直接调用慢 0.2ns ，从这个角度看，动态调用的性能损失几乎可以忽略不计。</p>
<h3 id="空接口数据结构"><a href="#空接口数据结构" class="headerlink" title="空接口数据结构"></a>空接口数据结构</h3><p>前面我们了解到空接口 interface{} 是没有任何方法集的接口，所以空接口内部不需要维护和动态内存分配相关的数据结构 itab 。空接口只关心存放的具体类型是什么，具体类型的值是什么，所以空接口的底层数据结构也很简单，具体如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//go/src/runtime/runtime2.go</span><br><span class="line">//空接口</span><br><span class="line">type eface struct {</span><br><span class="line">    _type *_type</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从 eface 的数据结构可以看出，空接口不是真的为空，其保留了具体实例的类型和值拷贝，即便存放的具体类型是空的，空接口也不是空的。</p>
<p>由于空接口自身没有方法集，所以空接口变量实例化后的真正用途不是接口方法的动态调用。空接口在Go语言中真正的意义是支持多态，有如下几种方式使用了空接口（将空接口类型还原）：</p>
<ul>
<li>通过接口类型断言</li>
<li>通过接口类型查询</li>
<li>通过反射</li>
</ul>
<p>至此，接口内部实现原理全部讲完，大家在了解和学习接口内部实现的知识的同时，更应该学习和思考分析过程中的方法和技巧，使用该方法可以继续分析接口断言、接口查询和接口赋值的内部实现机制。</p>
<h2 id="表达式求值器"><a href="#表达式求值器" class="headerlink" title="表达式求值器"></a>表达式求值器</h2><p>在本节中，我们将创建简单算术表达式的一个求值器。我们将使用一个接口 Expr 来代表这种语言中的任意一个表达式。现在，这个接口没有任何方法，但稍后我们会逐个添加。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Expr：算术表达式</span><br><span class="line">type Expr interface{}</span><br></pre></td></tr></tbody></table></figure>
<p>我们的表达式语言包括浮点数字面量，二元操作符 +、-、*、/，一元操作符 -x 和 +x，函数调用 pow(x,y)、sin(x) 和 sqrt(x)，变量（比如 x 和 pi），当然，还有圆括号和标准的操作符优先级。所有的值都是 float64 类型。下面是几个示例表达式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">(F - 32) * 5 / 9</span><br></pre></td></tr></tbody></table></figure>
<p>下面 5 种具体类型代表特定类型的表达式。Var 代表变量应用（很快我们将了解到为什么这个类型需要导岀）。literal 代表浮点数常量。unary 和 binary 类型代表有一个或者两个操作数的操作符表达式，而操作数则可以任意的 Expr。call 代表函数调用，这里限制它的 fn 字段只能是 pow、sin 和 sqrt。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Var 表示一个变量，比如 x</span><br><span class="line">type Var string</span><br><span class="line">// literal 是一个数字常量，比如 3.141</span><br><span class="line">type literal float64</span><br><span class="line">// unary 表示一元操作符表达式，比如-x</span><br><span class="line">type unary struct {</span><br><span class="line">    op rune // '+', '-' 中的一个</span><br><span class="line">    x Expr</span><br><span class="line">}</span><br><span class="line">// binary 表示二元操作符表达式，比如 x+y</span><br><span class="line">type binary struct {</span><br><span class="line">    op rune // '+', '-', '*', '/' 中的一个</span><br><span class="line">    x, y Expr</span><br><span class="line">}</span><br><span class="line">// call 表示函数调用表达式，比如 sin(x)</span><br><span class="line">type call struct {</span><br><span class="line">    fn string // one of "pow", "sin", "sqrt" 中的一个</span><br><span class="line">    args []Expr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要对包含变量的表达式进行求值，需要一个上下文 (environment) 来把变量映射到数值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Env map[Var]float64</span><br></pre></td></tr></tbody></table></figure>
<p>我们还需要为每种类型的表达式定义一个 Eval 方法来返回表达式在一个给定上下文下的值。既然每个表达式都必须提供这个方法，那么可以把它加到 Expr 接口中。这个包只导出了类型 Expr、Env 和 Var。客户端可以在不接触其他表达式类型的情况下使用这个求值器。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    // Eval 返回表达式在 env 上下文下的值</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是具体的 Eval 方法。Var 的 Eval 方法从上下文中查询结果，如果变量不存在则返回 0 literal 的 Eval 方法则直接返冋本身的值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (v Var) Eval(env Env) float64 {</span><br><span class="line">    return env[v]</span><br><span class="line">}</span><br><span class="line">func (l literal) Eval(_ Env) float64 {</span><br><span class="line">    return float64(l)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>unary 和 binary 的 Eval 方法首先对它们的操作数递归求值，然后应用 op 操作。我们不把除以 0 或者无穷大当做错误（尽管它们生成的结果显然不是有穷数）。最后，call 方法先对 pow、sin 或者 sqrt 函数的参数求值，再调用 math 包中的对应函数</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (u unary) Eval(env Env) float64 {</span><br><span class="line">    switch u.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return +u.x.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return -u.x.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported unary operator: %q", u.op))</span><br><span class="line">}</span><br><span class="line">func (b binary) Eval(env Env) float64 {</span><br><span class="line">    switch b.op {</span><br><span class="line">    case '+':</span><br><span class="line">        return b.x.Eval(env) + b.y.Eval(env)</span><br><span class="line">    case '-':</span><br><span class="line">        return b.x.Eval(env) - b.y.Eval(env)</span><br><span class="line">    case '*1:</span><br><span class="line">        return b.x.Eval(env) * b.y.Eval(env)</span><br><span class="line">    case '/':</span><br><span class="line">        return b.x.Eval(env) / b.y.Eval(env)</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported binary operator: %q", b.op))</span><br><span class="line">}</span><br><span class="line">func (c call) Eval(env Env) float64 {</span><br><span class="line">    switch c.fn {</span><br><span class="line">    case "pow":</span><br><span class="line">        return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env)</span><br><span class="line">    case "sin":</span><br><span class="line">        return math.Sin(c.args[0].Eval(erw))</span><br><span class="line">    case "sqrt":</span><br><span class="line">        return math.Sqrt(c.args[0].Eval(env))</span><br><span class="line">    }</span><br><span class="line">    panic(fmt.Sprintf("unsupported function call: %s", c.fn))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>某些方法可能会失败，比如 call 表达式可能会遇到未知的函数，或者参数数量不对。也有可能用“!”或者“&lt;”这类无效的操作符构造了一个 unary 或 binary 表达式（尽管后面的 Parse 函数不会产生这样的结果）。这些错误都会导致 Eval 崩溃。</p>
<p>其他错误（比如对一个上下文中没有定义的变量求值）仅会导致返回不正确的结果。所有这些错误都可以在求值之前做检查来发现。后面的 Check 方法就负责完成这个任务，但我们先测试 Eval。</p>
<p>下面的 TestEval 函数用于测试求值器，它使用 testing 包。我们知道调用 t.Errorf 来报告错误。这个函数遍历一个表格，表格中定义了三个表达式并为每个表达式准备了不同上下文。第一个表达式用于根据圆面积 A 求半径，第二个用于计算两个变量 x 和 y 的立方和，第三个把华氏温度 F 转为摄氏温度。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func TestEval(t *testing.T) {</span><br><span class="line">    tests := []struct {</span><br><span class="line">        expr string</span><br><span class="line">        env Env</span><br><span class="line">        want string</span><br><span class="line">    }{</span><br><span class="line">        {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},</span><br><span class="line">        {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": -40}, "-40"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 32}, "0"},</span><br><span class="line">        {"5/9 * (F - 32)", Env{"F": 212}, "100"},</span><br><span class="line">    }</span><br><span class="line">    var prevExpr string</span><br><span class="line">    for _, test := range tests {</span><br><span class="line">        // 仅在表达式变更时才输出</span><br><span class="line">        if test.expr != prevExpr {</span><br><span class="line">            fmt.Printf("\n%s\n", test.expr)</span><br><span class="line">            prevExpr = test.expr</span><br><span class="line">        }</span><br><span class="line">        expr, err := Parse(test.expr)</span><br><span class="line">        if err != nil {</span><br><span class="line">            t.Error(err) // 解析出错</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        got := fmt.Sprintf("%.6g", expr.Eval(test.env))</span><br><span class="line">        fmt.Printf("\t%v =&gt; %s\n", test.env, got)</span><br><span class="line">        if got != test.want {</span><br><span class="line">            t.Errorf("%s.Eval() in %v = %q, want %q\n", test.expr, test.env, got, test.want)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于表格中的每一行记录，该测试先解析表达式，在上下文中求值，再输出表达式。这里没有足够的空间来显示 Parse 函数，但可以通过 go get 来下载源码，自行查看。</p>
<p>go test 命令可用于运行包的测试：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go test -v gopl.io/ch7/eval</span><br></pre></td></tr></tbody></table></figure>
<p>启用 -v 选项后可以看到测试的输出，通常情况下对于结果正确的测试输出就不显示了。下面就是测试中 fmt.Printf 语句输岀的内容。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A / pi)</span><br><span class="line">    map[A:87616 pi:3.141592653589793] =&gt; 167</span><br><span class="line"></span><br><span class="line">pow(x, 3) + pow(y, 3)</span><br><span class="line">    map[x:12 y:1] =&gt; 1729</span><br><span class="line">    map[x:9 y:10] =&gt; 1729</span><br><span class="line">5 / 9 * (F - 32)</span><br><span class="line">    map[F:-40] =&gt; -40</span><br><span class="line">    map[F:32] =&gt; 0</span><br><span class="line">    map[F:212] =&gt; 100</span><br></pre></td></tr></tbody></table></figure>
<p>幸运的是，到现在为止所有的输入都是合法的，但这种幸运是不能持久的。即使在解释性语言中，通过语法检查来发现静态错误（即不用运行程序也能检测出来的错误）也是很常见的。通过分离静态检查和动态检查，我们可以更快发现错误，也可以只在运行前检查一次，而不用在表达式求值时每次都检查。</p>
<p>让我们给 Expr 方法加上另外一个方法。Check 方法用于在表达式语法树上检查静态错误。它的 vars 参数将稍后解释。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Expr interface {</span><br><span class="line">    Eval(env Env) float64</span><br><span class="line">    // Check 方法报告表达式中的错误，并把表达式中的变量加入 Vars 中</span><br><span class="line">    Check(vars map[Var]bool) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>具体的 Check 方法如下所示。literal 和 Var 的求值不可能出错，所以 Check 方法返回 nil。unary 和 binary 的方法首先检查操作符是否合法，再递归地检查操作数。类似地，call 的方法首先检查函数是否是已知的，然后检查参数个数是否正确，最后递归检查每个参数。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func (v Var) Check(vars map[Var]bool) error {</span><br><span class="line">    vars[v] = true</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (literal) Check(vars map[Var]bool) error {</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">func (u unary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-", u.op) {</span><br><span class="line">        return fmt.Errorf("unexpected unary op %q", u.op)</span><br><span class="line">    }</span><br><span class="line">    return u.x.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (b binary) Check(vars map[Var]bool) error {</span><br><span class="line">    if !strings.ContainsRune("+-*/", b.op) {</span><br><span class="line">        return fmt.Errorf("unexpected binary op %q", b.op)</span><br><span class="line">    }</span><br><span class="line">    if err := b.x.Check(vars); err != nil {</span><br><span class="line">        return err</span><br><span class="line">    }</span><br><span class="line">    return b.y.Check(vars)</span><br><span class="line">}</span><br><span class="line">func (c call) Check(vars map[Var]bool) error {</span><br><span class="line">    arity, ok := numParams[c.fn]</span><br><span class="line">    if !ok {</span><br><span class="line">        return fmt.Errorf("unknown function %q", c.fn)</span><br><span class="line">    }</span><br><span class="line">    if len(c.args) != arity {</span><br><span class="line">        return fmt.Errorf("call to %s has %d args, want %d", c.fn, len(c.args), arity)</span><br><span class="line">    }</span><br><span class="line">    for _, arg := range c.args {</span><br><span class="line">        if err := arg.Check(vars); err != nil {</span><br><span class="line">            return err</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line">var numParams = map[string]int{"pow",: 2, "sin": 1, "sqrt": 1}</span><br></pre></td></tr></tbody></table></figure>
<p>下面分两列展示了一些有错误的输入，以及它们触发的错误。Parse 函数（没有显示）报告了语法错误，Check 方法报告了语义错误。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x % 2  unexpected '%'</span><br><span class="line">math.Pi unexpected '.'</span><br><span class="line">!true  unexpected '!'</span><br><span class="line">"hello" unexpected '"'</span><br><span class="line">log(10) unknown function "log"</span><br><span class="line">sqrt(1, 2) call to sqrt has 2 args, want 1</span><br></pre></td></tr></tbody></table></figure>
<p>Check 的输入参数是一个 Ver 集合，它收集在表达中发现的变量名。要让表达式能成功求值，上下文必须包含所有的这些变量。从逻辑上来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归调用的，在这种情况下使用参数更为方便。调用方在最初调用时需要提供一个空的集合。</p>
<p>既然我们可以对字符串形式的表达式进行解析、检查和求值，那么就可以构建一个 Web 应用，在运行时从客户端接收一个表达式，并绘制函数的曲面图。可以使用 vars 集合来检查表达式是一个只有两个变量 x、y 的函数（为了简单起见，还提供了半径 r，所以实际上是 3 个变量）。使用 Check 方法来拒绝掉不规范的表达式，避免了在接下来的 40000 次求值中重复检查（4 个象限中 100 x 100 的格子）。</p>
<p>下面的 parseAndCheck 函数组合了解析和检查步骤：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import "gopl.io/ch7/eval"</span><br><span class="line">func parseAndCheck(s string) (eval.Expr, error) {</span><br><span class="line">    if s == "" {</span><br><span class="line">        return nil, fmt.Errorf("empty expression")</span><br><span class="line">    }</span><br><span class="line">    expr, err := eval.Parse(s)</span><br><span class="line">    if err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    vars := make(map[eval.Var]bool)</span><br><span class="line">    if err := expr.Check(vars); err != nil {</span><br><span class="line">        return nil, err</span><br><span class="line">    }</span><br><span class="line">    for v := range vars {</span><br><span class="line">        if v != "x" &amp;&amp; v != "y" &amp;&amp; v != "r" {</span><br><span class="line">            return nil, fmt.Errorf("undefined variable: %s", v)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return expr, nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要构造完这个 Web 应用，仅需要增加下面的 plot 函数，其函数签名与 http.HandlerFunc 类似：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func plot(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    expr, err := parseAndCheck(r.Form.Get("expr"))</span><br><span class="line">    if err != nil {</span><br><span class="line">        http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    w.Header().Set("Content-Type", "image/syg+xml")</span><br><span class="line">    surface(w, func(x, y float64) float64 {</span><br><span class="line">        r := math.Hypot(x, y)   // 与(0,0)之间的距离</span><br><span class="line">        return expr.Eval(eval.Env{"x": x, "y": y, "r" : r})</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>plot 函数解析并检查 HTTP 请求中的表达式，并用它来创建一个有两个变量的匿名函数。这个匿名函数与原始曲面图绘制程序中的f有同样的签名，且能对用户提供的表达式进行求值。上下文定义了 x、y 和半径 r。</p>
<p>最后，plot 调用了 surface 函数，surface 函数来自 gop1.io/ch3/surface 中的 main 函数，略做修改，加了参数用于接受绘制函数和输出用的 io.Writer，原始版本直接使用了函数 f 和 os.Stdout。下图显示了用这个程序绘制的三张曲面图。</p>
<p>a) <code>sin(-x)*pow(1.5, -r)</code></p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-a.gif" alt="a"></p>
<p>b) <code>pow(2, sin(y))*pow(2, sin(x))/12</code></p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-b.gif" alt="b"></p>
<p>c) <code>sin (x*y/10)/10</code></p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/plot-c.gif" alt="c"></p>
<h2 id="实现Web服务器"><a href="#实现Web服务器" class="headerlink" title="实现Web服务器"></a>实现Web服务器</h2><p>Go语言里面提供了一个完善的 net/http 包，通过 net/http 包我们可以很方便的搭建一个可以运行的 Web 服务器。同时使用 net/http 包能很简单地对 Web 的路由，静态文件，模版，cookie 等数据进行设置和操作。</p>
<h3 id="Web服务器的工作方式"><a href="#Web服务器的工作方式" class="headerlink" title="Web服务器的工作方式"></a>Web服务器的工作方式</h3><p>我们平时浏览网页的时候，会打开浏览器，然后输入网址后就可以显示出想要浏览的内容。这个看似简单的过程背后却隐藏了非常复杂的操作。</p>
<p>对于普通的上网过程，系统其实是这样做的：</p>
<ul>
<li>浏览器本身是一个客户端，当在浏览器中输入 URL （网址）的时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到对应的服务器后，要求建立 TCP 连接；</li>
<li>与服务器建立连接后，浏览器会向服务器发送 HTTP Request （请求）包；</li>
<li>服务器接收到请求包之后开始处理请求包，并调用自身服务，返回 HTTP Response（响应）包；</li>
<li>客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容后断开与该服务器之间的 TCP 连接。</li>
</ul>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/webserver.gif" alt="图：用户访问一个站点的过程"></p>
<p>通过上图可以将 Web 服务器的工作原理简单地归纳为：</p>
<ul>
<li>客户机通过 TCP/IP 协议与服务器建立 TCP 连接；</li>
<li>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档；</li>
<li>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端；</li>
<li>客户机与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</li>
</ul>
<h3 id="搭建一个简单的-Web-服务器"><a href="#搭建一个简单的-Web-服务器" class="headerlink" title="搭建一个简单的 Web 服务器"></a>搭建一个简单的 Web 服务器</h3><p>前面简单介绍了 Web 服务器的工作原理，那么如何用Go语言搭建一个 Web 服务器呢？示例代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", index) // index 为向 url发送请求时，调用的函数</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 命令运行上面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure>
<p>运行之后并没有什么提示信息，但是命令行窗口会被占用（不能再输入其它命令）。这时我们在浏览器中输入 localhost:8000 可以看到下图所示的内容，则说明我们的服务器成功运行了。</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhost.gif" alt="图：localhost:8000"></p>
<p><strong><em>提示：运行 Web 服务器会占用命令行窗口，我们可以使用 Ctrl+C 组合键来退出。</em></strong></p>
<p>上面的代码只是展示了 Web 服务器的简单应用，下面我们来完善一下，为这个服务器添加一个页面并设置访问的路由。</p>
<p>首先我们准备一个 html 文件，并命名为 index.html，代码如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;C语言中文网&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;C语言中文网&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>然后将我们上面写的 Web 服务器的代码简单修改一下，如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "io/ioutil"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    // 在/后面加上 index ，来指定访问路径</span><br><span class="line">    http.HandleFunc("/index", index)</span><br><span class="line">    log.Fatal(http.ListenAndServe("localhost:8000", nil))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func index(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    content, _ := ioutil.ReadFile("./index.html")</span><br><span class="line">    w.Write(content)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>go run</code> 命令运行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></tbody></table></figure>
<p>运行成功后，在浏览器中输入 localhost:8000/index 就可以看到我们所添加的页面了，如下图所示：</p>
<p><img src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/wssjdi/statics/imgs/localhostindex.gif" alt="图：浏览 localhost:8000/index 页面"></p>
<h2 id="部署程序到Linux服务器"><a href="#部署程序到Linux服务器" class="headerlink" title="部署程序到Linux服务器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5725.html">部署程序到Linux服务器</a></h2><p>通过前面的学习相信大家对Go语言已经有了一定的了解，平时我们都是在本地进行开发调试访问的。那要怎么打包到服务器上呢？下面通过一个简单的实例来给大家介绍一下如何把我们写好的Go语言程序发布到服务 Linux 服务器上。</p>
<p>下面所示的是我们在 Windows 系统下开发的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "log"</span><br><span class="line">    "net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func sayHello(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">    fmt.Fprintf(w, "C语言中文网")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    http.HandleFunc("/", sayHello)</span><br><span class="line">    log.Println("启动成功，可以通过 localhost:9000 访问")</span><br><span class="line">    err := http.ListenAndServe(":9000", nil)</span><br><span class="line">    if err != nil {</span><br><span class="line">        log.Fatal("List 9000")</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码已经写好了，现在需要编译了，由于是 window 环境编译到 linux 下运行，所有涉及到跨平台编译。</p>
<p>编译代码命令如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set GOARCH=amd64   //设置目标可执行程序操作系统构架，包括 386，amd64，arm</span><br><span class="line">set GOOS=linux           //设置可执行程序运行操作系统，支持 darwin，freebsd，linux，windows</span><br><span class="line">go build ./main.go       //打包</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>注意：使用 Window 10 系统的小伙伴必须用 cmd 工具执行上述命令，不能使用 powershell。</em></strong></p>
<p>OK，编译完成后会生成一个 main 可执行文件，没有后缀，这时只需要把这个文件上传到你的虚拟机，直接运行就好了。</p>
<p>运行后如果出现上图的效果，就说明已经运行起来了。这时打开你的浏览器访问服务器的 IP:9000 就能看到如下图的内容了</p>
<p>好啦！就这么简单，不需要任何语言环境，像 java 程序需要在服务器安装 java，php 需要安装 Apache，PHP 等运行环境，go 统统不需要，只需要一个 linux 系统将编译好的代码扔上去就可以了。</p>
<h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5397.html">音乐播放器</a></h2><h2 id="实现有限状态机（FSM）"><a href="#实现有限状态机（FSM）" class="headerlink" title="实现有限状态机（FSM）"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5400.html">实现有限状态机（FSM）</a></h2><h2 id="二叉树数据结构的应用"><a href="#二叉树数据结构的应用" class="headerlink" title="二叉树数据结构的应用"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/5570.html">二叉树数据结构的应用</a></h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wssjdi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wssjdi.github.io/posts/d3175357/">https://wssjdi.github.io/posts/d3175357/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wssjdi.github.io" target="_blank">Wssjdi</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3/">接口</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/">面向接口编程</a></div><div class="post_share"><div class="social-share" data-image="//goproxy.cn/assets/images/logo.svg" data-sites="qzone,douban,wechat,weibo,qq"></div><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="//cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/bd026676/"><img class="prev-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go 包</div></div></a></div><div class="next-post pull-right"><a href="/posts/e56582fa/"><img class="next-cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg" onerror="onerror=null;src='//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go结构体</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/91175219/" title="Go流程控制"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go流程控制</div></div></a></div><div><a href="/posts/fd72e7c1/" title="go mod解决依赖无法下载的问题"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">go mod解决依赖无法下载的问题</div></div></a></div><div><a href="/posts/3498a470/" title="go dubbo"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-16</div><div class="title">go dubbo</div></div></a></div><div><a href="/posts/f628ea56/" title="go 语言基础"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">go 语言基础</div></div></a></div><div><a href="/posts/30ebccd/" title="Go语言适合做什么"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">Go语言适合做什么</div></div></a></div><div><a href="/posts/5c78a85/" title="Go容器"><img class="cover" src="//cdn.jsdelivr.net/gh/wssjdi/statics/imgs/loading.gif" data-original="//goproxy.cn/assets/images/logo.svg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-20</div><div class="title">Go容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(//goproxy.cn/assets/images/logo.svg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wssjdi</div><div class="footer_custom_text">welcome to my <a href="https://wssjdi.github.io/">blog</a>!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/utils.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/main.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/tw_cn.js"></script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'd3KH3pe0YVWpajwOnn9biRFx-gzGzoHsz',
      appKey: 'qbqkhtBjXAEhixDnsmK3IMKf',
      placeholder: '来都来了总得留下点儿什么吧~~~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://leancloud.cn',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/piao.js"></script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="//cdn.jsdelivr.net/gh/wssjdi/wssjdi.github.io/js/third-party/ClickShowText.js" async="async"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>